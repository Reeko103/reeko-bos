(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fengmap"] = factory();
	else
		root["fengmap"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 255);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(256);

/***/ }),
/* 1 */
/***/ (function(module, exports) {

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

module.exports = _interopRequireDefault;

/***/ }),
/* 2 */
/***/ (function(module, exports) {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

var _Object$defineProperty = __webpack_require__(0);

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;

    _Object$defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

var _typeof = __webpack_require__(47);

var assertThisInitialized = __webpack_require__(103);

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

var _Object$getPrototypeOf = __webpack_require__(306);

var _Object$setPrototypeOf = __webpack_require__(190);

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = _Object$setPrototypeOf ? _Object$getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || _Object$getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

var _Object$create = __webpack_require__(31);

var setPrototypeOf = __webpack_require__(314);

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = _Object$create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 * FMNode 表示地图元素的基类
 * @interface
 * @memberof fengmap
 * @hideconstructor true
 */
var FMNode =
/*#__PURE__*/
function () {
  /***
   * @constructor
   * @param id
   * @param nodeType
   */
  function FMNode(id, nodeType) {
    (0, _classCallCheck2.default)(this, FMNode);
    this._eid = id;
    this._groupId = id;
    this.parent = null;
    this._nodeType = nodeType;
    this._x = 0;
    this._y = 0;
    this._z = 0;
    this._height = 0;
    this._alwaysShow = false;
    this._show = true;
    this.needAvoid = true;
    this.renderNodeInited = false;
    this.tryInit = false;
    this._visible = true; // 标记是否显示
  }

  (0, _createClass2.default)(FMNode, [{
    key: "findParent",
    value: function findParent(constructor) {
      var parent = this.parent;

      while (parent) {
        if (parent instanceof constructor) {
          return parent;
        }

        parent = parent.parent;
      }

      return false;
    }
    /**
     * 图层内或单个元素与同一图层内的其他元素在同一位置有相互遮盖时,是否自动避让。FMImageMarker FMTextMarker有效。
     * @param {bool} value 【true】: 需避让，【false】: 不避让。注意：avoid方法与show属性不能同时使用，使用avoid方法会自动更新show属性的值。
     */

  }, {
    key: "avoid",
    value: function avoid(value) {
      this.needAvoid = value;

      if (!value) {
        this.show = true;
      }
    }
    /**
     * 是否一直显示。
     */

  }, {
    key: "alwaysShow",
    value: function alwaysShow() {
      this._alwaysShow = true;
      var group;
      var parent = this.parent;

      while (parent) {
        if (parent.isGroup) {
          group = parent;
          break;
        }

        parent = parent.parent;
      }

      if (group) {
        this.renderNode && group.alwaysShowMarkers.push(this.renderNode);
      }
    }
  }, {
    key: "isAlwaysShow",
    get: function get() {
      return this._alwaysShow;
    }
    /**
     * 楼层id
     * @property {number} groupID 楼层id
     */

  }, {
    key: "groupID",
    get: function get() {
      if (this.isGroup) {
        return this._eid;
      }

      var group;
      var parent = this.parent;

      while (parent) {
        if (parent.isGroup) {
          group = parent;
          break;
        }

        parent = parent.parent;
      }

      if (group) {
        return group.eid;
      }

      return 0; // return this._groupId;
    }
    /**
     * 高度
     * @property {number} height 高度
     */

  }, {
    key: "height",
    set: function set(height) {
      this._height = height;
    },
    get: function get() {
      return this._height;
    }
    /**
     * 元素中心点坐标点
     * @property {json} mapCoord 地图坐标{x;,y:,z:}
     * @readonly
     */

  }, {
    key: "mapCoord",
    set: function set(mapCoord) {
      this._mapCoord = mapCoord;
    },
    get: function get() {
      return {
        x: this._x,
        y: this._y,
        z: this._height
      };
    }
    /**
     * 地图元素对象类型
     * @property {fengmap.FMNodeType} nodeType 地图元素对象类型
     * @readonly
     */

  }, {
    key: "nodeType",
    set: function set(nodeType) {
      this._nodeType = nodeType;
    },
    get: function get() {
      return this._nodeType;
    }
    /**
     * 地图元素的显示/隐藏
     * @property {bool} show 【true】: 显示，【false】: 隐藏
     */

  }, {
    key: "show",
    set: function set(show) {
      this._show = show;
      this._renderNode && (this._renderNode.visible = show);
    },
    get: function get() {
      return this._show;
    }
  }, {
    key: "x",
    set: function set(x) {
      this._x = x;
    },
    get: function get() {
      return this._x;
    }
  }, {
    key: "y",
    set: function set(y) {
      this._y = y;
    },
    get: function get() {
      return this._y;
    }
  }, {
    key: "z",
    set: function set(z) {
      this._z = z;
    },
    get: function get() {
      return this._z;
    }
  }, {
    key: "eid",
    get: function get() {
      return this._eid;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }]);
  return FMNode;
}();

var _default = FMNode;
exports.default = _default;

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(33).f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || __webpack_require__(23) && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});


/***/ }),
/* 9 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(14);
var core = __webpack_require__(9);
var ctx = __webpack_require__(36);
var hide = __webpack_require__(43);
var has = __webpack_require__(45);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(346);

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(373);

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(164);
var anObject = __webpack_require__(30);
var speciesConstructor = __webpack_require__(188);
var advanceStringIndex = __webpack_require__(141);
var toLength = __webpack_require__(34);
var callRegExpExec = __webpack_require__(95);
var regexpExec = __webpack_require__(131);
var fails = __webpack_require__(18);
var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });

// @@split logic
__webpack_require__(97)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = defined(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
});


/***/ }),
/* 14 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(117)('wks');
var uid = __webpack_require__(73);
var Symbol = __webpack_require__(24).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(333);

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(128)('wks');
var uid = __webpack_require__(93);
var Symbol = __webpack_require__(14).Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(68);

__webpack_require__(8);

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(13);

var _assign = _interopRequireDefault(__webpack_require__(11));

var _keys = _interopRequireDefault(__webpack_require__(54));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _isArray = _interopRequireDefault(__webpack_require__(35));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMScene = _interopRequireDefault(__webpack_require__(150));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

var _MaterialManager = _interopRequireDefault(__webpack_require__(394));

var _CompassGeometry = _interopRequireDefault(__webpack_require__(228));

var _CompassMaterial = _interopRequireDefault(__webpack_require__(398));

var _FMExternalLoader = _interopRequireDefault(__webpack_require__(400));

var _FMDynamicLoader = _interopRequireDefault(__webpack_require__(411));

var _FMUtil = _interopRequireDefault(__webpack_require__(57));

var _FMGlobal = _interopRequireDefault(__webpack_require__(110));

var _FMLanguageType = _interopRequireDefault(__webpack_require__(80));

var _vertshader = __webpack_require__(412);

var _fragshader = __webpack_require__(413);

/**
 *  NodeMaanager 是对地图元素进行数据管理 一个NodeManager对应多个FMScene
 *
 *  @class NodeMaanager
 *  @constructor
 *  @module NodeMaanager
 */
var NodeManager =
/*#__PURE__*/
function () {
  function NodeManager(options, map) {
    (0, _classCallCheck2.default)(this, NodeManager);
    this._scenes = {};
    this._materialManager = new _MaterialManager.default(options.font);
    this._raycaster = new fm.Raycaster();
    this._focusAlphaMode = options._focusAlphaMode;
    this._focusAlpha = options._focusAlpha;
    this._map = map;
    this._externalModelUrl = options.mapServerURL + "/models/";
    this._externalLoader = new _FMExternalLoader.default(this._externalModelUrl, options.mapServerURL == "fengmap", options.key);
    this._dynamicLoader = new _FMDynamicLoader.default();

    this._externalLoader.setLoadedBack(function () {
      map.dispatchEvent({
        type: "externalLoaded"
      });
      map.dispatchEvent({
        type: "gltfLoaded"
      });
      map.checkNode();
      map.setRenderList(); // console.log("allloadeed");
    });

    this.isNeedSweep = map.MapOptions.isNeedSweep;
    this.sweepMax = map.MapOptions.sweepMax;
    this.sweepMin = map.MapOptions.sweepMin;
  }
  /***
      * 指北针创建
   * @param scale {number} 缩放 默认1
   * @param url {string} 图片路径
   * @param backUrl {string} 背景图片路径
   * @param offsetx {number} x偏移
   * @param offsety {number} y偏移
   * @returns {Mesh}
      */


  (0, _createClass2.default)(NodeManager, [{
    key: "createCompassNode",
    value: function createCompassNode() {
      var scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var url = arguments.length > 1 ? arguments[1] : undefined;
      var backUrl = arguments.length > 2 ? arguments[2] : undefined;
      var offsetx = arguments.length > 3 ? arguments[3] : undefined;
      var offsety = arguments.length > 4 ? arguments[4] : undefined;
      // 默认路径
      var bg = url || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAGhUlEQVR4nOWbzW/cRBjGn7HHY7u7m8RLojIF8SFUUQECFQqnimsF/wAgEIiWKEqgH+LjAJxRDwjU0kIEpZWASvQvAM6IEy1IILUqogiEaKZVluxu1tv1ztgeDvHSELLJfno3yU/KIfaM93kfjz2ej5fMzc2hEzjnLZUTQowCeBzAgwDuBbALAAfgAcgkxaoASgDmAFwG8AuAnwF8yzkvdySwRUg/DBBC3APgOQBPEEIeZYzVKKV1SqmklErTNEPDMGJCSAwAWmsjjmMjiiIahiFL/mwppau1Pg/gawBnOee/dSR2DXpmgBDCBPA0gGnTNB9zHGfRcZwqYyzoRqCU0gmCIBMEwUgURd8DmAVwjnMedXPdBl0bkAR+GMB7juNUtm3bVrJtu9YLcSup1+vujRs3xoIgyAF4DcDxbo3oygAhxEsATrmuW85mswuUUtWNmFYJw9DyfT9fq9VGAUxyzj/t9FqdGnAfgBnLsg6MjIxcZ4zVOxXQDVJKe3FxcbtS6jSAjzjnl9q9RicGzBBCTmaz2flsNltqt3I/8H1/zPf9Ca31K5zzj9qp264BR03TfNXzPGFZ1kDuejOUUnaxWORRFL3HOX+r1XpGG79xjDF2aHx8/M9hCx4ALMuqj4+P/8kYOyyEONZqvVYNOGHb9v58Pn/VMIy4Q419xzCMOJ/PX7Vte78Q4kRLdVooc8y27Rfy+bwghOguNfYdQojO5/PCtu0XWmkJ6xlwlDE26XnetR7pSw3P864xxiaFEEfXKreWATPJC29uI9z5lRBCtOd5c6ZpviqEmGlWrpkBDxBCTnqeJ4b5mV8PwzBiz/MEIeSkEOL+Vcs0qTudy+Xmh/Ft3y6WZdVzudw8gOnVzq9mwIxlWS9mMpmh+MjpBZlMpmRZ1gEhxOTKcys/hCgAOax9fTcopexCoXAnALp8ALWyBRx2XXdxswUPLD0KruuWsTRy/ZflLYACkBMTE3+kNapLmzAMrfn5+bsAMM55CPy3BTzrOE5lswYPAJRS5TiOD+DZxrHlBkxvphdfMzKZTBHLeoSGAfdRSnd3O321EWCMBZTS3Y3vgoYBTzuOUxmgrlRJYn0KuGnAPtu2q4OTlC5JrPuAJQPGCCF7tkLzb8AYCwghe4QQYwaAvYyxvsziDjNJzHsNAA9RSjfdh896JDE/ZADYRSmVgxaUNknMuwwAO7ewATsNALebphkOWlDaJDHfbgAY2ciTHp2SxDxqAMg1Vmm3EknM2XbWBTYVWmsCQBoAKlrrLWdEEnPFALAYx/GWMyCJuWIA+CuKIjpoQWkTx7EJ4LoB4NcwDNmgBaVNEvOvBoDLW9iAywaAn8IwtActKG2SmH8yAHwnpXQHLShtkpi/MwCUtNYXpJTOoEWlhZTS0Vpf4JyXGt3f1/V6PbNmrU1EEus3wM0psbO1Wm1kcJLSJYn1C+CmAVeiKDq/Fd4FUko3iqLznPMrwH/XBWar1erogHSlRhLjbOP/5QacC4IgF4ahlb6sdAjD0Ep2mZ5rHFtuQAjgDd/386krS4kkttcb64LA/1eHj9VqtVGl1Kb7MFJK2cnW2uPLj680IAIwVS6Xt6emLCWSmKZWbq5ebRj8iVLqdLVaHUtHWv/xfX9MKXWac/7JynPN5gFmK5XKhFJqww+SlFK27/sTAFbdQ9zMgIta60PFYnHHRp4siePYKBaLO7TWU812kq8V3Mkoit5PLkD6pLFvaK1JsVjckWyePtWs3Hp3900p5alSqXRrj/X1nVKpdKuU8hTn/M21yrXSvI8EQfBZsVjkG6ElJHeeB0HwGef8yHrlW32+DwZBcGZhYeG2YX4nxHFsLCws3BYEwRnO+cFW6rQTzBEp5QeFQuGOYewdlFKsUCjcIaX8oJU736CTlJmXCSEncrnc/LBsqqpWq2OVSmVCa32Qc/5hO3U7TZq6H8C0ZVkHRkdHrw9qY6VSyi6Xy42kqVnO+cV2r9Ft2twkgI9d113M5XJ/p7XKHEURrVQqtyQTG1NrdXPr0YvESQrgDQDvOI5TyWQypX7tN5JSOtVqtZE4+TaAd5eP7Dqhl6mzDMAzAKZM09zjuu6ibds9SZ2t1+uZWq02EkXRBQAfA/iSc96TTR39TJ5+HsCThJCHGWM3LMuqJ4nTaq3k6SiKrDAMmVLKllJu01r/COArAJ8PdfJ0M4QQY1hKn38ESxmndwPYjtXT568B+B3AJQA/YCl9vq89zT/uIvNLxH1bgwAAAABJRU5ErkJggg==';
      var fg = backUrl || 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAAsTAAALEwEAmpwYAAA5nmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMwNjcgNzkuMTU3NzQ3LCAyMDE1LzAzLzMwLTIzOjQwOjQyICAgICAgICAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnhtcE1NPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvbW0vIgogICAgICAgICAgICB4bWxuczpzdFJlZj0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL3NUeXBlL1Jlc291cmNlUmVmIyIKICAgICAgICAgICAgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIKICAgICAgICAgICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICAgICAgICAgICB4bWxuczpwaG90b3Nob3A9Imh0dHA6Ly9ucy5hZG9iZS5jb20vcGhvdG9zaG9wLzEuMC8iCiAgICAgICAgICAgIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIgogICAgICAgICAgICB4bWxuczpleGlmPSJodHRwOi8vbnMuYWRvYmUuY29tL2V4aWYvMS4wLyI+CiAgICAgICAgIDx4bXA6Q3JlYXRvclRvb2w+QWRvYmUgUGhvdG9zaG9wIENDIDIwMTUgKFdpbmRvd3MpPC94bXA6Q3JlYXRvclRvb2w+CiAgICAgICAgIDx4bXA6Q3JlYXRlRGF0ZT4yMDIwLTExLTEzVDE0OjI4OjI5KzA4OjAwPC94bXA6Q3JlYXRlRGF0ZT4KICAgICAgICAgPHhtcDpNb2RpZnlEYXRlPjIwMjAtMTEtMTNUMTQ6Mjk6MjUrMDg6MDA8L3htcDpNb2RpZnlEYXRlPgogICAgICAgICA8eG1wOk1ldGFkYXRhRGF0ZT4yMDIwLTExLTEzVDE0OjI5OjI1KzA4OjAwPC94bXA6TWV0YWRhdGFEYXRlPgogICAgICAgICA8eG1wTU06SW5zdGFuY2VJRD54bXAuaWlkOjE4MjQ1YjY4LThkNDAtNzY0Ni04OTI0LTdkZDA2ZDYzZTM4MDwveG1wTU06SW5zdGFuY2VJRD4KICAgICAgICAgPHhtcE1NOkRvY3VtZW50SUQ+eG1wLmRpZDo4Nzc2QTE5MUEzRDAxMUU2QjhGOTlFMTYyOEIzMUI4MDwveG1wTU06RG9jdW1lbnRJRD4KICAgICAgICAgPHhtcE1NOkRlcml2ZWRGcm9tIHJkZjpwYXJzZVR5cGU9IlJlc291cmNlIj4KICAgICAgICAgICAgPHN0UmVmOmluc3RhbmNlSUQ+eG1wLmlpZDozRkM2NUZGNUEzQ0MxMUU2QjhGOTlFMTYyOEIzMUI4MDwvc3RSZWY6aW5zdGFuY2VJRD4KICAgICAgICAgICAgPHN0UmVmOmRvY3VtZW50SUQ+eG1wLmRpZDozRkM2NUZGNkEzQ0MxMUU2QjhGOTlFMTYyOEIzMUI4MDwvc3RSZWY6ZG9jdW1lbnRJRD4KICAgICAgICAgPC94bXBNTTpEZXJpdmVkRnJvbT4KICAgICAgICAgPHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD54bXAuZGlkOjg3NzZBMTkxQTNEMDExRTZCOEY5OUUxNjI4QjMxQjgwPC94bXBNTTpPcmlnaW5hbERvY3VtZW50SUQ+CiAgICAgICAgIDx4bXBNTTpIaXN0b3J5PgogICAgICAgICAgICA8cmRmOlNlcT4KICAgICAgICAgICAgICAgPHJkZjpsaSByZGY6cGFyc2VUeXBlPSJSZXNvdXJjZSI+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDphY3Rpb24+c2F2ZWQ8L3N0RXZ0OmFjdGlvbj4KICAgICAgICAgICAgICAgICAgPHN0RXZ0Omluc3RhbmNlSUQ+eG1wLmlpZDoxODI0NWI2OC04ZDQwLTc2NDYtODkyNC03ZGQwNmQ2M2UzODA8L3N0RXZ0Omluc3RhbmNlSUQ+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDp3aGVuPjIwMjAtMTEtMTNUMTQ6Mjk6MjUrMDg6MDA8L3N0RXZ0OndoZW4+CiAgICAgICAgICAgICAgICAgIDxzdEV2dDpzb2Z0d2FyZUFnZW50PkFkb2JlIFBob3Rvc2hvcCBDQyAyMDE1IChXaW5kb3dzKTwvc3RFdnQ6c29mdHdhcmVBZ2VudD4KICAgICAgICAgICAgICAgICAgPHN0RXZ0OmNoYW5nZWQ+Lzwvc3RFdnQ6Y2hhbmdlZD4KICAgICAgICAgICAgICAgPC9yZGY6bGk+CiAgICAgICAgICAgIDwvcmRmOlNlcT4KICAgICAgICAgPC94bXBNTTpIaXN0b3J5PgogICAgICAgICA8ZGM6Zm9ybWF0PmltYWdlL3BuZzwvZGM6Zm9ybWF0PgogICAgICAgICA8cGhvdG9zaG9wOkNvbG9yTW9kZT4zPC9waG90b3Nob3A6Q29sb3JNb2RlPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICAgICA8dGlmZjpYUmVzb2x1dGlvbj43MjAwMDAvMTAwMDA8L3RpZmY6WFJlc29sdXRpb24+CiAgICAgICAgIDx0aWZmOllSZXNvbHV0aW9uPjcyMDAwMC8xMDAwMDwvdGlmZjpZUmVzb2x1dGlvbj4KICAgICAgICAgPHRpZmY6UmVzb2x1dGlvblVuaXQ+MjwvdGlmZjpSZXNvbHV0aW9uVW5pdD4KICAgICAgICAgPGV4aWY6Q29sb3JTcGFjZT42NTUzNTwvZXhpZjpDb2xvclNwYWNlPgogICAgICAgICA8ZXhpZjpQaXhlbFhEaW1lbnNpb24+NjQ8L2V4aWY6UGl4ZWxYRGltZW5zaW9uPgogICAgICAgICA8ZXhpZjpQaXhlbFlEaW1lbnNpb24+NjQ8L2V4aWY6UGl4ZWxZRGltZW5zaW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0idyI/PtblBDkAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAAnJJREFUeNrsmz9r20AYxh8lzpGhkE6d3DRzB7fQrZ/A5A8Opl/DQ/MBWmi8t07ivZ0SJylkMPQbSM5Qg09OWpeQaCoYMpVCh8ZSB9kg26os2dYpd3oPDPLdey/H73neu5PBmuM4SHNbQMobASAABIAAEAACQAAIAAFIa8vElfhnqTQp5IVWr+uPAPzZ3HwJ4GtQ8IP9fbkA4O4ueJzzM1gWWwTAms2zv7nc4zSVwCsYRnbwhbnPxfQAaLXew/sa7jhYarUqaQFQxPl5drSTuX1F9QFwXoFtj/fbNpY4r6gOoIhGI/u/QeaObasBQNPGP5x/8FV/2AV7vnMVcEABjcbEo465MQX1SoDzvUD1R12gGIAtGMZq2GDmxm6pA8A0D0Kp73WBaR6oAmADur4adRJz52zIfwpEVX/YBVXZT4F16PratJOZrj8BsC6lAzR3569Opf7wiVCVdQ/Iz6K+xwVrAPLyAbCsNzOp73HB4s3NW/kAXF09m1eqzPV1Lq5lxveL0O3t8ljfysq4wGFyOQ6TD0C7/UsDHk68IXe7YbL9fi7hJmjd01zCAHy5p7mEAfgIoDeHPD0An2QE8APA4RzyHAHoyHoVLs/ogh6AXZnfBjsAajPMr8WpvqjX4Xdhj3ufK8Ju3IsTAaDTr+Npav+7CgAGe4EdUf2yiIWJAvAt4l5Q689RBkAUFwip/SQAXAI4DhF3LEp90QDCuEBY7ScF4ALAScD4ST9GWQBBLhBa+0kCaAM49ek/Fa1+UgD8XCC89pMGYAL4PKK+mcRCMkiuvQbwtP+8k9QiNPrPUMobASAABIAAEAACQAAIAAFIa/s3AKynv4ToD/dyAAAAAElFTkSuQmCC';
      var material = new _CompassMaterial.default();
      material.uniforms["scale"] = {
        value: scale
      };
      material.uniforms["offset"] = {
        value: new fm.Vector2(offsetx, offsety)
      };
      material.uniforms["mapfront"] = {
        value: this._materialManager.loadTexture(fg, function (texture) {
          // texture.flipY = false;
          material.needsUpdate = true;
        })
      };
      material.uniforms["mapBack"] = {
        value: this._materialManager.loadTexture(bg, function (texture) {
          // texture.flipY = false;
          material.needsUpdate = true;
        })
      };
      material.transparent = true;
      var geometry = new _CompassGeometry.default();
      var node = new fm.Mesh(geometry, material);
      node.userData.coord = {
        x: offsetx,
        y: offsety
      };
      node.userData.width = 0.5 * scale;
      node.frustumCulled = false;
      return node;
    }
    /**
     * 射线拾取模型
     * @param {*} id
     * @param {*} gids
     * @param {*} coord
     * @param {*} camera
     */

  }, {
    key: "getModel",
    value: function getModel(id, gids, coord, camera) {
      var scene = this._scenes[id];
      if (!scene) return [];
      var models = scene.getGroupsModels(gids);

      this._raycaster.setFromCamera(coord, camera);

      var intersects = this._raycaster.intersectObjects(models);

      return intersects;
    }
  }, {
    key: "getExternalModels",
    value: function getExternalModels(id, gids, coord, camera) {
      var scene = this._scenes[id];
      if (!scene) return [];
      var models = scene.getGroupsExternalModels(gids);

      this._raycaster.setFromCamera(coord, camera);

      var intersects = this._raycaster.intersectObjects(models);

      return intersects;
    }
  }, {
    key: "getModelExternal",
    value: function getModelExternal(id, gids, coord, camera) {
      var scene = this._scenes[id];
      if (!scene) return [];
      var models0 = scene.getGroupsModels(gids);
      var models1 = scene.getGroupsExternalModels(gids);
      var models = models0.concat(models1);

      this._raycaster.setFromCamera(coord, camera);

      var intersects = this._raycaster.intersectObjects(models);

      return intersects;
    }
  }, {
    key: "getMarkers",
    value: function getMarkers(id, gids, coord, camera) {
      var scene = this._scenes[id];
      if (!scene) return [];
      var markers = [];

      for (var i = 0; i < gids.length; i++) {
        var markers2 = scene.getAllImageMarker(gids[i]);

        for (var ii = 0; ii < markers2.length; ii++) {
          markers.push(markers2[ii]);
        }
      }

      this._raycaster.setFromCamera(coord, camera);

      this._raycaster.perspective = camera.type === "PerspectiveCamera";

      var intersects = this._raycaster.intersectObjects(markers);

      return intersects;
    }
    /**
     * 射线拾取地图元素
     * @param {*} id
     * @param {*} gids
     * @param {*} coord
     * @param {*} camera
     */

  }, {
    key: "getNode",
    value: function getNode(id, gids, coord, camera, filter) {
      var scene = this._scenes[id];
      if (!scene) return [];
      var nodes = scene.getNodesExceptFacility(gids, filter);
      var dynnodes = scene.getDynnodes(filter, gids);

      this._raycaster.setFromCamera(coord, camera);

      this._raycaster.perspective = camera.type === "PerspectiveCamera";

      var intersects = this._raycaster.intersectObjects(nodes);

      var dynintersects = this._raycaster.intersectObjects(dynnodes, true);

      if (dynintersects[0]) {
        var o = dynintersects[0].object;

        while (o.parent) {
          if (o.parent.mapNode) {
            dynintersects[0].object = o.parent;
            break;
          }

          o = o.parent;
        }
      }

      if (dynintersects[0] && intersects[0]) {
        if (dynintersects[0].distance > intersects.distance) {
          return intersects;
        } else {
          return dynintersects;
        }
      } else if (dynintersects[0]) {
        return dynintersects;
      } else if (intersects[0]) {
        return intersects;
      } else {
        return [];
      }
    }
  }, {
    key: "getFacility",
    value: function getFacility(id, gids, coord, camera, filter) {
      var scene = this._scenes[id];
      if (!scene) return [];
      var nodes = scene.getFacilityByFilter(gids, filter); // nodes.reverse();

      this._raycaster.setFromCamera(coord, camera);

      this._raycaster.perspective = camera.type === "PerspectiveCamera";

      var intersects = this._raycaster.intersectObjects(nodes);

      for (var i = 0; i < intersects.length; i++) {
        if (i) {
          if (intersects[i].distance - intersects[i - 1].distance < 0.000001) {
            if (typeof intersects[i].object.material.priority === "number" && typeof intersects[i - 1].object.material.priority !== "number") {
              var a = intersects[i];
              var b = intersects[i - 1];
              intersects[i - 1] = a;
              intersects[i] = b;
            } else if (typeof intersects[i].object.material.priority === "number" && typeof intersects[i - 1].object.material.priority === "number") {
              var index = 0;

              for (var o = 1; o <= i; o++) {
                if (intersects[i - index].object.material.priority > intersects[i - o].object.material.priority) {
                  var _a = intersects[i - index];
                  var _b = intersects[i - o];
                  intersects[i - o] = _a;
                  intersects[i] = _b;
                  index++;
                } else {
                  break;
                }
              }
            }
          } else {
            break;
          }
        }
      }

      var result = [];

      for (var _i = 0; _i < intersects.length; _i++) {
        var obj = intersects[_i].object.mapNode;

        if (obj.nodeType === fengmap.FMNodeType.IMAGE_MARKER || obj.nodeType === fengmap.FMNodeType.TEXT_MARKER) {
          result.push(intersects[_i]);
        }
      }

      for (var _i2 = 0; _i2 < intersects.length; _i2++) {
        var _obj = intersects[_i2].object.mapNode;

        if (_obj.nodeType === fengmap.FMNodeType.FACILITY) {
          result.push(intersects[_i2]);
        }
      } // let index = 0;
      // if (intersects.length > 1) {
      //  for (var i = 0; i < intersects.length; i++){
      //      if (i) { 
      //          if (intersects[i].distance - intersects[i - 1].distance < 0.000001) {
      //              index = i;
      //          } else { 
      //              break;
      //          }
      //      }
      //  }
      // } else { 
      //  index = 0;
      // }
      // intersects.unshift(intersects[index]);


      return result;
    }
    /**
     * 获取总楼层
     * @param {*} id
     */

  }, {
    key: "getGroupLength",
    value: function getGroupLength(id) {
      return this._scenes["" + id].groupLength;
    }
    /**
     * 获取总楼层gid数组
     * @param {*} id
     */

  }, {
    key: "getGroupIds",
    value: function getGroupIds(id) {
      return this._scenes["" + id].groupIds;
    }
    /**
     * 通过Gid获取对应group对象
     * @param {*} id
     * @param {*} gid
     */

  }, {
    key: "getGroup",
    value: function getGroup(id, gid) {
      return this._scenes["" + id].groups[gid + ""];
    }
    /**
     * 获取所有scene中的待渲染楼层
     */

  }, {
    key: "getRenderList",
    value: function getRenderList() {
      if (!this._scenes) return;
      var list = [];

      for (var s in this._scenes) {
        var rg = this._scenes[s].getRenderGroup(); //groupArray


        list.push(rg);
      }

      return list;
    }
    /**
     * 初始化scene
     * @param {*} data
     * @param {*} id
     * @param {*} theme
     */

  }, {
    key: "conformatScene",
    value: function conformatScene(data, id, theme) {
      var scene = new _FMScene.default(id, data, this);
      scene.parent = this;
      this._scenes[id + ""] = scene;
      this._scenes[id + ""].theme = theme;
    }
  }, {
    key: "checkMaterialAlpha",
    value: function checkMaterialAlpha(threeObject, gid) {
      if (!threeObject) return;

      if (this._focusAlphaMode && gid !== this._map.currentFocusGroup && this._map.otherFocus.indexOf(gid) < 0) {
        if ((0, _isArray.default)(threeObject.material)) {
          // if(threeObject.material[0].opacity !== this._focusAlpha) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = (0, _getIterator2.default)(threeObject.material), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var mat = _step.value;
              mat.opacity = this._focusAlpha;
            } // }

          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        } else {
          if (threeObject.material) {
            if (typeof threeObject.material.length === "undefined") {
              if (threeObject.material.opacity !== this._focusAlpha) {
                threeObject.material.opacity = this._focusAlpha; // threeObject.material.needsUpdate = true;
              }
            } else {
              for (var i = 0; i < threeObject.material.length; i++) {
                if (threeObject.material[i].opacity !== this._focusAlpha) {
                  threeObject.material[i].opacity = this._focusAlpha; // threeObject.material.needsUpdate = true;
                }
              }
            }
          }
        }
      } else {
        if ((0, _isArray.default)(threeObject.material)) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = (0, _getIterator2.default)(threeObject.material), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _mat = _step2.value;

              if (typeof _mat.userData.opacity === "number") {
                // if(mat.opacity !== mat.userData.opacity) {
                _mat.opacity = _mat.userData.opacity; // threeObject.material.needsUpdate = true;
                // }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } else {
          if (typeof threeObject.material !== "undefined") {
            if (typeof threeObject.material.userData.opacity === "number") {
              // if(threeObject.material.opacity !== threeObject.material.userData.opacity) {
              threeObject.material.opacity = threeObject.material.userData.opacity; // threeObject.material.needsUpdate = true;
              // }
            }
          }
        }
      }
    }
    /**
     * 通过视锥以及显示层级创建或隐藏元素
     * @param {*} data
     * @param {*} frustum
     * @param {*} visibleGroups
     * @param {*} level
     * @param {*} id
     */

  }, {
    key: "checkNodeByFrustum",
    value: function checkNodeByFrustum(data, frustum, visibleGroups, level, id) {
      // let data = this.scenes[id + ""];
      var me = this;
      if (!me._scenes[id + ""]) return;
      var themeManager = me._scenes[id + ""].theme;
      var centx = this._scenes["" + id].center.x;
      var centy = this._scenes["" + id].center.y;
      var mapcentx = this._scenes["" + id].mapcenter.x;
      var mapcenty = this._scenes["" + id].mapcenter.y;
      var labelLuage = this._map.labelLanguage;
      _FMGlobal.default[this._map.uuid].bbox = this._scenes["" + id].bboxTh;
      _FMGlobal.default[this._map.uuid].bbox.uuid = this._map.uuid; // global[this.uuid].bbox.min.x -= mapcentx; 
      // global[this.uuid].bbox.max.x -= mapcentx;
      // global[this.uuid].bbox.min.y -= mapcenty; 
      // global[this.uuid].bbox.max.y -= mapcenty;

      var groups = this._scenes["" + id].groups;
      var gkeys = (0, _keys.default)(groups);

      try {
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          var _loop = function _loop() {
            var gkey = _step3.value;
            var group = groups[gkey];

            if (visibleGroups.indexOf(group.eid) <= -1) {
              group.visible = false;
              return "continue";
            }

            group.visible = true;
            group.traverseByAlias(['extent', 'model', 'label', 'facility', 'externalModel'], function (node, alias) {
              var bdata = node.bdata;
              var isInlevel = bdata.minlevel === -1 || bdata.maxlevel === -1 || bdata.minlevel !== 0 && !bdata.minlevel || !bdata.maxlevel || bdata.minlevel <= level && bdata.maxlevel > level;

              if (!isInlevel) {
                if (node.renderNode !== null) {
                  node.visible = false;
                }

                return;
              }

              switch (alias) {
                case 'extent':
                  if (node.renderNodeInited) {
                    // node.visible && node.checkByFrustum(frustum);
                    me.checkMaterialAlpha(node.renderNode, group.eid);
                  } else {
                    me.createExtent(node, id, group.eid);
                  }

                  break;

                case 'model':
                  if (node.renderNodeInited) {
                    // node.visible && node.checkByFrustum(frustum);
                    me.checkMaterialAlpha(node.renderNode, group.eid);
                    me.checkMaterialAlpha(node.line, group.eid);
                  } else {
                    me.createModel(node, id, group.eid);
                  }

                  break;

                case 'label':
                  if (node.renderNodeInited) {
                    // node.visible && node.checkByFrustum(frustum);
                    me.checkMaterialAlpha(node._renderNode, group.eid);
                  } else {
                    if (!node.tryInit) {
                      me.createLabel(node, id, labelLuage, group.eid);
                    }
                  }

                  break;

                case 'facility':
                  if (node.renderNodeInited) {
                    // node.visible && node.checkByFrustum(frustum);
                    me.checkMaterialAlpha(node._renderNode, group.eid);
                  } else {
                    me.createFacility(node, id, group.eid);
                  }

                  break;

                case 'externalModel':
                  if (node.renderNodeInited) {
                    // node.visible && node.checkByFrustum(frustum);
                    me.checkMaterialAlpha(node._renderNode, group.eid);
                  } else {
                    var _bdata = node.bdata;
                    var gdata = node.gdata;
                    var externalTheme = themeManager.getExteralModelTheme(_bdata.fid);

                    if (!externalTheme) {
                      return;
                    }

                    if (!me._externalLoader.preLoadModels[externalTheme.normalid]) {
                      me._externalLoader.preLoadModels[externalTheme.normalid] = {
                        loaded: false,
                        isLoading: false,
                        modelUrl: externalTheme.model,
                        model: null,
                        geometry: null,
                        material: null
                      };
                    }

                    var exterdata = me._externalLoader.preLoadModels[externalTheme.normalid];

                    if (exterdata.loaded) {
                      // this._externalLoader.externalLoadingCount++;
                      // console.log("loadeed");
                      me.createExterModel(exterdata.geometry, exterdata.material, gdata, _bdata, externalTheme, node, centx, centy, group.height, mapcentx, mapcenty, exterdata.isGltf); // this._externalLoader.externalLoadingCount--;
                      // if(this._externalLoader.externalLoadingCount < 1) {
                      //  this._externalLoader.loaded && this._externalLoader.loaded();
                      // }
                    } else {
                      if (!me._externalLoader.waitingBacks[externalTheme.normalid]) {
                        me._externalLoader.addWaitingBacks(externalTheme.normalid, function (geometry, material, last) {
                          me.createExterModel(geometry, material, gdata, _bdata, externalTheme, node, centx, centy, group.height, mapcentx, mapcenty, last !== "js");
                        }, _bdata.fid);
                      } else {
                        me._externalLoader.addWaitingBacks(externalTheme.normalid, function (geometry, material, last) {
                          me.createExterModel(geometry, material, gdata, _bdata, externalTheme, node, centx, centy, group.height, mapcentx, mapcenty, last !== "js");
                        }, _bdata.fid);
                      } // else if( !me._externalLoader.waitingBacks[externalTheme.normalid][0]) {
                      //  me._externalLoader.addWaitingBacks(externalTheme.normalid,function(geometry ,material ,last){
                      //      me.createExterModel(geometry ,material  , gdata ,bdata, externalTheme, node, centx, centy ,group.height,mapcentx,mapcenty ,last !== "js");
                      //  });
                      // }


                      if (!exterdata.isLoading) {
                        me._externalLoader.load(externalTheme.normalid);
                      } // setTimeout(()=>{
                      //   me.checkNodeByFrustum(data, frustum, visibleGroups, level, id);
                      // },1000);

                    }
                  }

                  break;
              }

              node.checkByFrustum(frustum);
            });
          };

          for (var _iterator3 = (0, _getIterator2.default)(gkeys), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _ret = _loop();

            if (_ret === "continue") continue;
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      } catch (e) {
        console.log(e, 553);
      }

      return;
    }
    /**
     * 商店模型创建
     * @param {*} gdata
     * @param {*} sceneId
     * @param {*} gid
     * @param {*} frustum
     * @param {*} height
     * @param {*} theme
     */

  }, {
    key: "createModel",
    value: function createModel(node, sceneId, gid) {
      var centx = this._scenes["" + sceneId].center.x;
      var centy = this._scenes["" + sceneId].center.y;
      var mcentx = this._scenes["" + sceneId].mapcenter.x;
      var mcenty = this._scenes["" + sceneId].mapcenter.y;
      var themeManager = this._scenes["" + sceneId].theme;
      var gdata = node.gdata;
      var bdata = node.bdata; // if(bdata.eid > window.ffffff) {
      //     return;
      // }

      var theme;

      if (this._map.MapOptions.useStoreApply) {
        theme = themeManager.getStoreApplyTheme(bdata.fid);
      }

      if (!theme) {
        theme = themeManager.getModelTheme(bdata);
      }

      var model = null; //model = DataManager.convertGeo2Geometry(gdata.geo);

      if (this._map.dataManager.file_ver === 1) {
        model = _DataManager.default.convertGeo2Geometry(gdata.geo);
      } else {
        model = _DataManager.default.convertArray2Geometry(gdata.idxs, gdata.pts);
      }

      node._data = model;
      var amount = !gdata.height || gdata.height === -1 ? 2.0 : gdata.height;
      var geometry = this.createGeometry(model, amount, sceneId); //todo 判断去重后数组长度

      var material = this._materialManager.createNormalMaterial(theme); // let material = this._materialManager.createBasicMaterial(theme);


      node._geometry = geometry;
      var isNeedSweep = this.isNeedSweep;

      if (this.isNeedSweep) {
        fm.ShaderLib.physical.vertexShader = _vertshader.vertexShader;
        fm.ShaderLib.physical.fragmentShader = _fragshader.fragmentShader;
        (0, _assign.default)(fm.ShaderLib.physical.uniforms, {
          "maxPos": {
            value: this.sweepMax
          },
          "minPos": {
            value: this.sweepMin
          },
          "relativeModelMatrix": {
            value: undefined
          }
        });
      }

      node.initMesh(material, new fm.Vector3(centx, centy + amount, 0), isNeedSweep);
      node.x = mcentx;
      node.y = mcenty;
      node.height = amount;
      node.currHeight = amount;
      this.checkMaterialAlpha(node.renderNode, gid);
      node.initLine(this._materialManager.createLineMaterial(theme), gdata.height);
      this.checkMaterialAlpha(node.line, gid); // node.checkByFrustum(frustum);
      // theme.size && console.log( theme.size);

      if (theme.image && theme.sizes) {
        var s = theme.sizes.split(",");
        var c = [];

        if (theme.coords) {
          c = theme.coords.split(",");
        }

        node.addStoreImage({
          image: theme.image ? this._map.MapOptions.mapThemeURL + '/' + this._map.MapOptions.defaultThemeName + '/' + theme.image : "",
          angle: theme.angle ? theme.angle : 0,
          size: [(0, _parseFloat2.default)(s[0]), (0, _parseFloat2.default)(s[1])],
          // offset : theme.offset ? theme.offset : [0,0],
          mapCoord: theme.coords ? new fm.Vector2((0, _parseFloat2.default)(c[0]), (0, _parseFloat2.default)(c[1])) : undefined
        });
      }
    }
    /**
     * 地板模型创建
     * @param {*} gdata
     * @param {*} sceneId
     * @param {*} gid
     * @param {*} frustum
     * @param {*} height
     */

  }, {
    key: "createExtent",
    value: function createExtent(node, sceneId, gid) {
      var gdata = node.gdata;
      var themeManager = this._scenes[sceneId + ""].theme;
      var centx = this._scenes["" + sceneId].center.x;
      var centy = this._scenes["" + sceneId].center.y;
      var mcentx = this._scenes["" + sceneId].mapcenter.x;
      var mcenty = this._scenes["" + sceneId].mapcenter.y;
      var model = null; //DataManager.convertGeo2Geometry(gdata.geo);

      if (this._map.dataManager.file_ver === 1) {
        model = _DataManager.default.convertGeo2Geometry(gdata.geo);
      } else {
        model = _DataManager.default.convertArray2Geometry(gdata.idxs, gdata.pts);
      }

      var geometry = this.createGeometry(model, gdata.height ? gdata.height : 1, sceneId);
      node._geometry = geometry;
      node.x = mcentx;
      node.y = mcenty; // let material = this._materialManager.createBasicMaterial();

      var material = this._materialManager.createNormalMaterial();

      node.initMesh(material, new fm.Vector3(centx, centy, 0), themeManager.floorColor, themeManager.floorOpacity);
      this.checkMaterialAlpha(node.renderNode, gid);
    }
    /**
     * 商店label标注创建
     * @param {*} layer
     * @param {*} bdata
     * @param {*} labelPosition
     * @param {*} themeManager
     */

  }, {
    key: "createLabel",
    value: function createLabel(node, sceneId, labelLuage, gid) {
      var gdata = node.gdata;
      var bdata = node.bdata;
      var mcentx = this._scenes["" + sceneId].mapcenter.x;
      var mcenty = this._scenes["" + sceneId].mapcenter.y;
      var centx = this._scenes["" + sceneId].center.x;
      var centy = this._scenes["" + sceneId].center.y;
      var themeManager = this._scenes[sceneId + ""].theme;
      var labelgeo = null;

      if (this._map.dataManager.file_ver === 1) {
        labelgeo = _DataManager.default.convertGeo2Points(gdata.geo);
      } else {
        labelgeo = _DataManager.default.convertArrayPoints(gdata.idxs, gdata.pts);
      }

      var labelHeight = gdata.height === -1 ? 2.2 : gdata.height;
      var labelPosition = new fm.Vector3(labelgeo.vertices[0].x - mcentx, -labelgeo.vertices[0].y + mcenty, 0).applyEuler(new fm.Euler(Math.PI / 2, 0, 0, 'XYZ')).add(new fm.Vector3(centx, centy + labelHeight, 0));
      var ename = bdata.ename;
      var cname = bdata.name;
      var mname = labelLuage === _FMLanguageType.default.ZH ? cname : ename;
      node.x = labelgeo.vertices[0].x;
      node.y = labelgeo.vertices[0].y;
      node.height = labelHeight;
      node.pos = labelPosition;
      node.tryInit = true;
      var theme = themeManager.getLabelTheme(bdata);

      if (!theme) {
        return;
      }

      node.theme = theme;
      node.size = theme.fontsize * 1.4;

      if (!mname) {
        return;
      }

      var material = this._materialManager.createLabelMaterial(mname, theme);

      node.initSprite(material, new fm.Vector3().copy(labelPosition));
      this.checkMaterialAlpha(node._renderNode, gid);
      node.setSize();
    }
    /**
     * 公共设施标注创建
     * @param {*} layer
     * @param {*} bdata
     * @param {*} position
     * @param {*} themeManager
     */

  }, {
    key: "createFacility",
    value: function createFacility(node, sceneId, gid) {
      var gdata = node.gdata;
      var bdata = node.bdata;
      var centx = this._scenes["" + sceneId].center.x;
      var centy = this._scenes["" + sceneId].center.y;
      var mcentx = this._scenes["" + sceneId].mapcenter.x;
      var mcenty = this._scenes["" + sceneId].mapcenter.y;
      var themeManager = this._scenes[sceneId + ""].theme;
      var facilitygeo = null;

      if (this._map.dataManager.file_ver === 1) {
        facilitygeo = _DataManager.default.convertGeo2Points(gdata.geo);
      } else {
        facilitygeo = _DataManager.default.convertArrayPoints(gdata.idxs, gdata.pts);
      }

      var facilityHeight = gdata.height === -1 ? 2.2 : gdata.height;
      var facilityPosition = new fm.Vector3(facilitygeo.vertices[0].x - mcentx, -facilitygeo.vertices[0].y + mcenty, 0).applyEuler(new fm.Euler(Math.PI / 2, 0, 0, 'XYZ')).add(new fm.Vector3(centx, centy + facilityHeight, 0));
      var theme = themeManager.getPoiTheme(bdata);

      var material = this._materialManager.createPoiMaterial(theme);

      node.x = facilitygeo.vertices[0].x;
      node.y = facilitygeo.vertices[0].y;
      node.height = facilityHeight;
      node.pos = facilityPosition;
      theme.height && (node.size = theme.height);
      node.initSprite(material, new fm.Vector3().copy(facilityPosition));
      this.checkMaterialAlpha(node._renderNode, gid);
      node.setSize();
    }
    /**
     * 遍历group
     * @param {*} group
     * @param {*} back
     */

  }, {
    key: "everGroup",
    value: function everGroup(group, back) {
      for (var i = 0; i < group.biz.length; i++) {
        for (var j = 0; j < group.biz[i]["extentLayer"].length; j++) {
          back(group.geo[i]["extentLayer"][j], "extentLayer", group.biz[i]["extentLayer"][j]);
        }

        for (var _j = 0; _j < group.biz[i]["labelLayer"].length; _j++) {
          back(group.geo[i]["labelLayer"][_j], "labelLayer", group.biz[i]["labelLayer"][_j]);
        }

        for (var _j2 = 0; _j2 < group.biz[i]["modelLayer"].length; _j2++) {
          back(group.geo[i]["modelLayer"][_j2], "modelLayer", group.biz[i]["modelLayer"][_j2]);
        }

        for (var _j3 = 0; _j3 < group.biz[i]["poiLayer"].length; _j3++) {
          back(group.geo[i]["poiLayer"][_j3], "poiLayer", group.biz[i]["poiLayer"][_j3]);
        }

        for (var _j4 = 0; _j4 < group.biz[i]["stairLayer"].length; _j4++) {
          back(group.geo[i]["stairLayer"][_j4], "stairLayer", group.biz[i]["stairLayer"][_j4]);
        }

        for (var _j5 = 0; _j5 < group.biz[i]["externalModelLayer"].length; _j5++) {
          back(group.geo[i]["externalModelLayer"][_j5], "externalModelLayer", group.biz[i]["externalModelLayer"][_j5]);
        }
      }
    }
    /**
     * 依据二维顶点信息生成three的geometry
     * @param {*} model
     * @param {*} amount
     * @param {*} sid
     */

  }, {
    key: "createGeometry",
    value: function createGeometry(model, amount, sid) {
      var vs1 = model.vertices;

      function reversePoints(arr) {
        var tarr = [];

        for (var _i3 = 0; _i3 < arr.length; _i3 += 2) {
          var index = (arr.length - _i3) / 2;
          tarr[(index - 1) * 2] = arr[_i3];
          tarr[(index - 1) * 2 + 1] = arr[_i3 + 1];
        }

        return tarr;
      }

      var isright = _DataManager.default.checkClockwise(vs1); // console.log(isright);


      if (!isright) {
        vs1 = reversePoints(vs1);
        model.vertices = vs1;
      }

      if (vs1.length >= 6) {
        var geo;
        var shape = new fm.Shape();
        var sx = this._scenes["" + sid].mapcenter.x;
        var sz = this._scenes["" + sid].mapcenter.y;

        if (model.holes && model.holes.length > 0) {
          var rm_holes = {};

          for (var i in model.holes) {
            var hole = model.holes[i];

            var _isright = _DataManager.default.checkClockwise(hole);

            if (!_isright) {
              hole = reversePoints(hole);
              model.holes[i] = hole;
            }

            for (var j = 0; j < hole.length; j += 2) {
              var pt = '' + hole[j] + '-' + hole[j + 1];
              rm_holes[pt] = true;
            }
          }

          this.forEachVertForShape(vs1, function (first, x, y) {
            if (first) {
              shape.moveTo(x - sx, y - sz);
            } else {
              if (!rm_holes['' + x + '-' + y]) {
                shape.lineTo(x - sx, y - sz);
              }
            }
          });

          for (var i in model.holes) {
            var hole = model.holes[i];
            var holePath = new fm.Path();
            this.forEachVertForShape(hole, function (first, x, y) {
              if (first) {
                holePath.moveTo(x - sx, y - sz);
              } else {
                holePath.lineTo(x - sx, y - sz);
              }
            });
            shape.holes.push(holePath);
          }
        } else {
          this.forEachVertForShape(vs1, function (first, x, y) {
            if (first) {
              shape.moveTo(x - sx, y - sz);
            } else {
              shape.lineTo(x - sx, y - sz);
            }
          });
        }

        if (amount == 0) {
          geo = new fm.ShapeGeometry(shape);
        } else {
          geo = new fm.ExtrudeGeometry(shape, {
            depth: amount,
            bevelEnabled: false
          });
        }

        var mx = _FMGlobal.default[this._map.uuid].bbox.min.x;
        var my = _FMGlobal.default[this._map.uuid].bbox.min.y;
        var w = _FMGlobal.default[this._map.uuid].bbox.max.x - _FMGlobal.default[this._map.uuid].bbox.min.x;
        var h = _FMGlobal.default[this._map.uuid].bbox.max.y - _FMGlobal.default[this._map.uuid].bbox.min.y;
        var faces = geo.faces,
            facesLen = faces.length;

        for (var i = 0; i < facesLen; i++) {
          var va = geo.vertices[faces[i].a];
          var vb = geo.vertices[faces[i].b];
          var vc = geo.vertices[faces[i].c];
          geo.faceVertexUvs[0][i][0].x = (va.x - mx) / w;
          geo.faceVertexUvs[0][i][0].y = (va.y - my) / h;
          geo.faceVertexUvs[0][i][1].x = (vb.x - mx) / w;
          geo.faceVertexUvs[0][i][1].y = (vb.y - my) / h;
          geo.faceVertexUvs[0][i][2].x = (vc.x - mx) / w;
          geo.faceVertexUvs[0][i][2].y = (vc.y - my) / h;
        } //


        geo.computeBoundingSphere();
        return {
          geometry: geo,
          shape: shape
        };
      } else {
        return null;
      }
    }
    /**
     * 创建externalmodel
     * @param {*} geo
     * @param {*} mater
     * @param {*} gdata
     * @param {*} bdata
     * @param {*} layer
     * @param {*} gid
     */

  }, {
    key: "createExterModel",
    value: function createExterModel(geo, mater, gdata, bdata, theme, node, centx, centy, height, mcx, mcy, isgltf) {
      var _this = this;

      var point = null;

      if (this._map.dataManager.file_ver === 1) {
        point = _DataManager.default.convertGeo2Points(gdata.geo);
      } else {
        point = _DataManager.default.convertArrayPoints(gdata.idxs, gdata.pts);
      }

      var position = new fm.Vector3(point.vertices[0].x - mcx, -point.vertices[0].y + mcy, 0).applyEuler(new fm.Euler(Math.PI / 2, 0, 0, 'XYZ')).add(new fm.Vector3(centx, centy + (gdata.height === -1 ? 2.2 : gdata.height), 0));

      if (isgltf) {
        // let scene0 = geo.scene;
        // let scene = scene0.clone();
        var scene0 = geo.scene;
        var scene = null; //scene0//.clone();

        if (geo.animations.length > 0) {
          scene = scene0; //.clone();

          this._map.animaModels.push({
            model: scene0,
            animations: geo.animations
          });
        } else {
          scene = scene0.clone();
        }

        scene.traverse(function (mesh) {
          if (mesh instanceof fm.Mesh) {
            mesh.isGltf = true;

            if (typeof mesh.material.length !== "undefined") {
              for (var i = 0; i < mesh.material.length; i++) {
                mesh.material[i] = mesh.material[i].clone();
                mesh.material[i].color = new fm.Color(_FMUtil.default.toColor(theme.color));
                mesh.material[i].needsUpdate = true;
                mesh.material[i].userData.opacity = mesh.material[i].opacity; // mesh.material[i].depthWrite = false;
              }
            } else {
              mesh.material = mesh.material.clone();

              if (_this.isNeedSweep) {
                fm.ShaderLib.physical.vertexShader = _vertshader.vertexShader;
                fm.ShaderLib.physical.fragmentShader = _fragshader.fragmentShader;
                (0, _assign.default)(fm.ShaderLib.physical.uniforms, {
                  "sweepW": {
                    value: 0
                  },
                  "sweepH": {
                    value: 0
                  },
                  "se2N": {
                    value: new fm.Vector2(0, 0)
                  },
                  "se2RN": {
                    value: new fm.Vector2(0, 0)
                  },
                  "moveP": {
                    value: new fm.Vector2(0, 0)
                  },
                  "relativeModelMatrix": {
                    value: undefined
                  },
                  "isNeedSweep": {
                    value: true
                  },
                  "isRect": {
                    value: false
                  },
                  "isAnnulus": {
                    value: false
                  },
                  "circleC": {
                    value: new fm.Vector2(0, 0)
                  },
                  "maxR": {
                    value: 0
                  },
                  "minR": {
                    value: 0
                  }
                });
                mesh.name = "isNeedSweep";
                mesh.material.uniforms = {
                  "sweepW": {
                    value: 0
                  },
                  "sweepH": {
                    value: 0
                  },
                  "se2N": {
                    value: new fm.Vector2(0, 0)
                  },
                  "se2RN": {
                    value: new fm.Vector2(0, 0)
                  },
                  "moveP": {
                    value: new fm.Vector2(0, 0)
                  },
                  "relativeModelMatrix": {
                    value: mesh.matrixWorld
                  },
                  "isNeedSweep": {
                    value: false
                  },
                  "isRect": {
                    value: false
                  },
                  "isAnnulus": {
                    value: false
                  },
                  "circleC": {
                    value: new fm.Vector2(0, 0)
                  },
                  "maxR": {
                    value: 0
                  },
                  "minR": {
                    value: 0
                  }
                };
              }

              mesh.material.transparent = true;
              mesh.material.color = new fm.Color(_FMUtil.default.toColor(theme.color));
              mesh.material.needsUpdate = true;
              mesh.material.userData.opacity = mesh.material.opacity; // mesh.material.depthWrite = false;
            }

            mesh.renderOrder = bdata.eid;
          }
        });
        var scales = theme.scale.split(",");
        var rotates = theme.rotate.split(",");
        var translates = theme.translate.split(",");
        var rotate = new fm.Vector3();
        rotate.set((0, _parseFloat2.default)(rotates[0]) * fm.Math.DEG2RAD, (0, _parseFloat2.default)(rotates[2]) * fm.Math.DEG2RAD, (0, _parseFloat2.default)(rotates[1]) * fm.Math.DEG2RAD);
        scene.rotation.setFromVector3(rotate, 'YXZ');
        scene.scale.set((0, _parseFloat2.default)(scales[0]), (0, _parseFloat2.default)(scales[2]), (0, _parseFloat2.default)(scales[1]));
        position.add(new fm.Vector3((0, _parseFloat2.default)(translates[0]), (0, _parseFloat2.default)(translates[2]), (0, _parseFloat2.default)(translates[1])));
        scene.position.set(position.x, position.y, position.z);
        node.renderNode = scene;
        node.x = point.vertices[0].x + (0, _parseFloat2.default)(translates[0]);
        node.y = point.vertices[0].y + (0, _parseFloat2.default)(translates[1]);
        node.height = gdata.height === -1 ? 2.2 : gdata.height;

        if (!node._renderNode) {
          return;
        }

        node._renderNode.frustumCulled = false;
        node.renderNodeInited = true;
      } else {
        if ((0, _isArray.default)(mater)) {
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = (0, _getIterator2.default)(mater), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var mat = _step4.value;
              mat.color = new fm.Color(_FMUtil.default.toColor(theme.color));
              mat.transparent = true;

              if (mat.map) {
                mat.map.wrapS = fm.RepeatWrapping;
                mat.map.wrapT = fm.RepeatWrapping;
                mat.color.setScalar(1);
              }

              mat.userData.opacity = mat.opacity;
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }
        } else {
          mater.color = new fm.Color(_FMUtil.default.toColor(theme.color));
          mater.transparent = true;

          if (mater.map) {
            mater.map.wrapS = fm.RepeatWrapping;
            mater.map.wrapT = fm.RepeatWrapping;
            mater.color.setScalar(1);
          }

          mater.userData.opacity = mater.opacity;
        }

        var mater1 = [];

        if (typeof mater.length !== "undefined") {
          for (var i = 0; i < mater.length; i++) {
            mater1.push(mater[i].clone());
          }
        } else {
          mater1.push(mater.clone());
        }

        var mesh = new fm.Mesh(geo, mater1);

        var _scales = theme.scale.split(",");

        var _rotates = theme.rotate.split(",");

        var _translates = theme.translate.split(",");

        mesh.scale.set((0, _parseFloat2.default)(_scales[0]), (0, _parseFloat2.default)(_scales[2]), (0, _parseFloat2.default)(_scales[1]));

        var _rotate = new fm.Vector3();

        _rotate.set((0, _parseFloat2.default)(_rotates[0]) * fm.Math.DEG2RAD, (0, _parseFloat2.default)(_rotates[2]) * fm.Math.DEG2RAD, (0, _parseFloat2.default)(_rotates[1]) * fm.Math.DEG2RAD);

        mesh.rotation.setFromVector3(_rotate, 'YXZ'); // mesh.material.side = 2;

        position.add(new fm.Vector3((0, _parseFloat2.default)(_translates[0]), (0, _parseFloat2.default)(_translates[2]), (0, _parseFloat2.default)(_translates[1])));
        mesh.position.set(position.x, position.y, position.z);
        mesh.renderOrder = bdata.eid;
        node.renderNode = mesh;
        node.x = point.vertices[0].x + (0, _parseFloat2.default)(_translates[0]);
        node.y = point.vertices[0].y + (0, _parseFloat2.default)(_translates[1]);
        node.height = gdata.height === -1 ? 2.2 : gdata.height;

        if (!node._renderNode) {
          return;
        }

        node._renderNode.frustumCulled = false;
        node.renderNodeInited = true;
      }
    }
  }, {
    key: "findGltfMesh",
    value: function findGltfMesh(gltf, back) {
      if (gltf instanceof fm.Mesh) {
        back(gltf);
      } else {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = (0, _getIterator2.default)(gltf.children), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var child = _step5.value;
            this.findGltfMesh(child, back);
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }
    }
  }, {
    key: "getDynLoader",
    value: function getDynLoader() {
      return this._dynamicLoader;
    }
  }, {
    key: "getSceneCenter",
    value: function getSceneCenter(sid) {
      return new fm.Vector3().copy(this._scenes[sid + ""].center);
    }
  }, {
    key: "forEachVertForShape",
    value: function forEachVertForShape(vs1, cb) {
      var v = 0;
      cb(true, vs1[v], vs1[v + 1]);

      for (v = 2; v < vs1.length; v += 2) {
        cb(false, vs1[v], vs1[v + 1]);
      }

      v = 0; // if(global[this.uuid].bbox.min.x > vs1[v] ){
      //  global[this.uuid].bbox.min.x = vs1[v];
      // }
      // if(global[this.uuid].bbox.min.y > vs1[v + 1] ){
      //  global[this.uuid].bbox.min.y = vs1[v + 1];
      // }
      // if(global[this.uuid].bbox.max.x < vs1[v] ){
      //  global[this.uuid].bbox.max.x = vs1[v];
      // }
      // if(global[this.uuid].bbox.max.y < vs1[v + 1] ){
      //  global[this.uuid].bbox.max.y = vs1[v + 1];
      // }

      cb(false, vs1[v], vs1[v + 1]);
    }
    /**
     * 获取场景中心点
     * @param {*} gids
     * @param {*} sceneId
     */

  }, {
    key: "getCurrentNodeCenter",
    value: function getCurrentNodeCenter(gids, sceneId) {
      var scene = this._scenes[sceneId];
      var sceneCenter = scene.center;
      var z = 0;

      for (var i = 0; i < gids.length; i++) {
        z += gids[i] * scene.space;
      }

      return new fm.Vector3(sceneCenter.x, sceneCenter.y + z / gids.length, 0);
    }
  }, {
    key: "getHeight",
    value: function getHeight(sid, gid) {
      return this._scenes["" + sid].getHeight(gid);
    }
    /**
     * 获取场景
     * @param id
     * @returns {*}
     */

  }, {
    key: "getSceneById",
    value: function getSceneById(id) {
      return this._scenes["" + id];
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._materialManager.dispose();

      for (var s in this._scenes) {
        this._scenes[s].dispose();

        this._scenes[s].parent = undefined;
      }

      this._map = undefined;
      this._scenes = undefined;
      this._materialManager = undefined;
    }
  }, {
    key: "disposeById",
    value: function disposeById(id) {
      this._scenes[id].dispose();

      this._scenes[id].parent = undefined;
      this._scenes[id] = undefined;
    }
  }, {
    key: "map",
    get: function get() {
      return this._map;
    }
  }, {
    key: "materialManager",
    get: function get() {
      return this._materialManager;
    }
  }]);
  return NodeManager;
}();

var _default = NodeManager;
exports.default = _default;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

/**
 *   FMNodeType 显示对象类型枚举
 *   @class
 *   @memberof fengmap
 *   @hideconstructor true
 */
var FMNodeType = {
  /**
   * 未知类型
   * @property {number} NONE -0
   * @final
   */
  "NONE": 0,

  /**
   * 底面
   * @property {number} EXTENT -4
   * @final
   */
  "EXTENT": 4,
  "FLOOR": 4,

  /**
   * 模型
   * @property {number} MODEL -5
   * @final
   */
  "MODEL": 5,
  "DYNMODEL": 6,

  /**
   * 公共设施
   * @property {number} FACILITY -11
   * @final
   */
  "FACILITY": 11,

  /**
   * 文本标签
   * @property {number} LABEL -12
   * @final
   */
  "LABEL": 12,

  /**
   * 线标注
   * @property {number} LINE -21
   * @final
   */
  "LINE": 21,

  /**
   * 图片标注
   * @property {number} IMAGE_MARKER -31
   * @final
   */
  "IMAGE_MARKER": 31,

  /**
   * 自定义文本标注
   * @property {number} TEXT_MARKER -32
   * @final
   */
  "TEXT_MARKER": 32,

  /**
   * 定位标注
   * @property {number} LOCATION_MARKER -33
   * @final
   */
  "LOCATION_MARKER": 33,

  /*
   * 表面图片标注
   * @property {number} SURFACEIMAGE_MARKER -34
   * @final
   */
  "SURFACEIMAGE_MARKER": 34,

  /***
   * 外部模型
   * @property {number} EXTERNAL_MODEL -35
   * @deprecated
   * @see FMNodeType.EXTERNAL_MODEL
   * @final
   */
  "EXTERANL_MODEL": 35,

  /**
   * 外部模型
   * @property {number} EXTERNAL_MODEL -35
   * @final
   */
  "EXTERNAL_MODEL": 35,

  /**
   * 多边形
   * @property {number} POLYGON_MARKER -36
   * @final
   */
  "POLYGON_MARKER": 36,

  /**
   * 水波纹
   * @property {number} WATER_MARKER -37
   * @final
   */
  "WATER_MARKER": 37,

  /**
   * 多边形拉伸几何体
   * @property {number} EXTRUDE_MARKER 38
   * @final
   */
  "EXTRUDE_MARKER": 38,

  /**
   * 渐变多边形
   * @property {number} GRADIENT_POLYGON_MARKER 39
   * @final
   */
  "GRADIENT_POLYGON_MARKER": 39,

  /*
   * 边缘线
   * @property {number} EDGES_LINES_TYPE 40
   * @final
   */
  "EDGES_LINES_TYPE": 40,

  /**
   * 所有类型
   * @property {number} ALL -0xffff
   * @final
   */
  "ALL": 0xffff,

  /*
   * FM通用元素
   */
  "ELEMENT": 100
};
var _default = FMNodeType;
exports.default = _default;

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(24);
var core = __webpack_require__(82);
var hide = __webpack_require__(32);
var redefine = __webpack_require__(38);
var ctx = __webpack_require__(85);
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(18)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 24 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(44)(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(330);

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(29);
var IE8_DOM_DEFINE = __webpack_require__(156);
var toPrimitive = __webpack_require__(116);
var dP = Object.defineProperty;

exports.f = __webpack_require__(26) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(17);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(37);
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(312);

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(33);
var createDesc = __webpack_require__(83);
module.exports = __webpack_require__(23) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(30);
var IE8_DOM_DEFINE = __webpack_require__(158);
var toPrimitive = __webpack_require__(72);
var dP = Object.defineProperty;

exports.f = __webpack_require__(23) ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(46);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(338);

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(70);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 37 */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(24);
var hide = __webpack_require__(32);
var has = __webpack_require__(50);
var SRC = __webpack_require__(73)('src');
var $toString = __webpack_require__(260);
var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(82).inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(51);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

if (__webpack_require__(23)) {
  var LIBRARY = __webpack_require__(84);
  var global = __webpack_require__(24);
  var fails = __webpack_require__(18);
  var $export = __webpack_require__(22);
  var $typed = __webpack_require__(191);
  var $buffer = __webpack_require__(319);
  var ctx = __webpack_require__(85);
  var anInstance = __webpack_require__(193);
  var propertyDesc = __webpack_require__(83);
  var hide = __webpack_require__(32);
  var redefineAll = __webpack_require__(192);
  var toInteger = __webpack_require__(46);
  var toLength = __webpack_require__(34);
  var toIndex = __webpack_require__(194);
  var toAbsoluteIndex = __webpack_require__(88);
  var toPrimitive = __webpack_require__(72);
  var has = __webpack_require__(50);
  var classof = __webpack_require__(96);
  var isObject = __webpack_require__(37);
  var toObject = __webpack_require__(39);
  var isArrayIter = __webpack_require__(320);
  var create = __webpack_require__(132);
  var getPrototypeOf = __webpack_require__(177);
  var gOPN = __webpack_require__(87).f;
  var getIterFn = __webpack_require__(321);
  var uid = __webpack_require__(73);
  var wks = __webpack_require__(15);
  var createArrayMethod = __webpack_require__(322);
  var createArrayIncludes = __webpack_require__(163);
  var speciesConstructor = __webpack_require__(188);
  var ArrayIterators = __webpack_require__(62);
  var Iterators = __webpack_require__(63);
  var $iterDetect = __webpack_require__(326);
  var setSpecies = __webpack_require__(165);
  var arrayFill = __webpack_require__(142);
  var arrayCopyWithin = __webpack_require__(327);
  var $DP = __webpack_require__(33);
  var $GOPD = __webpack_require__(119);
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

var arrayWithoutHoles = __webpack_require__(367);

var iterableToArray = __webpack_require__(368);

var nonIterableSpread = __webpack_require__(372);

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

module.exports = _toConsumableArray;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(55);

__webpack_require__(56);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FileReader = _interopRequireDefault(__webpack_require__(376));

var _WKTReader = _interopRequireDefault(__webpack_require__(207));

var _ArrayReader = _interopRequireDefault(__webpack_require__(208));

/**
 *	DataManager 是对地图进行数据管理
 *  根据sceneid储存数据
 * 	@class DataManager
 *	@constructor
 * 	@module DataManager
 */
var DataManager =
/*#__PURE__*/
function () {
  function DataManager() {
    (0, _classCallCheck2.default)(this, DataManager);
    this._sceneRawData = {};
    this._sceneDecodeData = {};
    this._reader = new _FileReader.default(); //加入filever变量，1：wkt 2：数组，doublechang

    this.file_ver = 1;
  }

  (0, _createClass2.default)(DataManager, [{
    key: "putRawScene",
    value: function putRawScene(data, id) {
      this.sceneRawData[id + ""] = data;
    }
  }, {
    key: "removeRawScene",
    value: function removeRawScene(id) {
      this.sceneRawData[id + ""] = undefined;
    }
    /**
     * 二进制数据解析
     * @param {*} id 
     */

  }, {
    key: "parseScene",
    value: function parseScene(id, separate, license, obtainMapRoute) {
      var scene;

      if (separate) {
        scene = this._reader.sceneDecode(this.sceneRawData[id + ""], license, id);
        /*if(!obtainMapRoute){
        scene = this._reader.sceneDecode(this.sceneRawData[id + ""]  ,license ,id);
        } else {
        scene = this._reader.mapDecode(this.sceneRawData[id + ""]  ,license ,id);
        }*/
      } else {
        scene = this._reader.mapDecode(this.sceneRawData[id + ""], license, id);
      }

      if (!scene) {
        return;
      }

      if (separate) {
        scene = {
          scene: scene,
          floors: []
        };
      }

      var layerGroups = scene.scene['layerGroups'];

      for (var i = 0; i < layerGroups.length; i++) {
        var lg = layerGroups[i];
        lg['elevation'] = lg['height'];
      }

      return scene;
    }
  }, {
    key: "parseFloor",
    value: function parseFloor(geo, biz, navi) {
      var gdata = this._reader.floorGeoDecode(geo);

      var bdata = this._reader.floorBizDecode(biz);

      var ndata = this._reader.floorNaviDecode(navi);

      return [gdata, bdata, ndata];
    }
    /**
     * WKT数据转成Geometry
     *  */

  }, {
    key: "isSceneHasZone",

    /**
     * 获取sceneDecodeData中是否具有zone数据
     *  */
    value: function isSceneHasZone(id) {
      if (!id) {
        return false;
      }

      var decodeData = this._sceneDecodeData[id + ""];

      if (!decodeData) {
        return false;
      }

      var hasZone = false;
      decodeData.floors.forEach(function (floor) {
        if (floor.navi[0].naviZones.length > 0) {
          hasZone = true;
        }
      });
      return hasZone;
    }
  }, {
    key: "putDecodeScene",
    value: function putDecodeScene(data, id) {
      this.file_ver = data.scene.file_ver;
      this.sceneDecodeData[id + ""] = data;
    }
  }, {
    key: "removeDecodeScene",
    value: function removeDecodeScene(id) {
      this.sceneDecodeData[id + ""] = undefined;
    }
  }, {
    key: "getRawScene",
    value: function getRawScene(id) {
      return this.sceneRawData[id + ""];
    }
  }, {
    key: "getDecodeScene",
    value: function getDecodeScene(id) {
      return this.sceneDecodeData[id + ""];
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._reader.dispose();

      for (var r in this.sceneRawData) {
        this.sceneRawData[r] = undefined;
      }

      for (var d in this.sceneDecodeData) {
        this.sceneDecodeData[d] = undefined;
      }

      this.sceneRawData = undefined;
      this.sceneDecodeData = undefined;
    }
  }, {
    key: "disposeById",
    value: function disposeById(id) {
      this.sceneRawData[id] = undefined;
      this.sceneDecodeData[id] = undefined;
    }
  }, {
    key: "sceneRawData",
    get: function get() {
      return this._sceneRawData;
    },
    set: function set(v) {
      this._sceneRawData = v;
    }
  }, {
    key: "sceneDecodeData",
    get: function get() {
      return this._sceneDecodeData;
    },
    set: function set(v) {
      this._sceneDecodeData = v;
    }
  }], [{
    key: "convertGeo2Geometry",
    value: function convertGeo2Geometry(data) {
      var gd = new _WKTReader.default().parse(data);
      var d = {
        vertices: gd.toStrip(true)
        /*, indices:[]*/

      }; //holes:[[],..]

      if (gd.hasHoles()) {
        d.holes = gd.toStripHoles(true);
      }

      return d;
    }
    /**
     * WKT数据转成Geometry
     *  */

  }, {
    key: "convertArr2Geometry",
    value: function convertArr2Geometry(idxs, pts) {
      var outLen = idxs[0].idxs[0];
      var outVertexs = [];

      for (var i = 0; i < outLen - 2; i += 2) {
        outVertexs.push(pts[i]);
        outVertexs.push(pts[i + 1]);
      }

      var d = {
        vertices: outVertexs
      }; //holes:[[],..]

      if (idxs.length > 1) {
        var holes = []; // d.holes = gd.toStripHoles(true);

        for (var i_h = 1; i_h < idxs.length; i_h++) {
          var pStartIdx = idxs[i_h - 1];
          var pEndIdx = idxs[i_h];
          var hole = [];

          for (var i_p = pStartIdx; i_p < pEndIdx - 2; i_p += 2) {
            hole.push(pts[i_p]);
            hole.push(pts[i_p + 1]);
          }

          holes.push(hole);
        }

        d.holes = holes;
      }

      return d;
    }
    /**
     * 数组数据转成Geometry
     *  */

  }, {
    key: "convertArray2Geometry",
    value: function convertArray2Geometry(idxs, pts) {
      var gd = new _ArrayReader.default().parseGeometry(idxs, pts);
      var d = {
        vertices: gd.toStrip(true)
        /*, indices:[]*/

      }; //holes:[[],..]

      if (gd.hasHoles()) {
        d.holes = gd.toStripHoles(true);
      }

      return d;
    }
    /**
     * WKT数据转成position
     *  */

  }, {
    key: "convertGeo2Points",
    value: function convertGeo2Points(data) {
      var gd = new _WKTReader.default().parse(data);
      var d = {
        vertices: gd.points
        /*, indices:[]*/

      }; //holes:[[],..]

      return d;
    }
    /**
     * 数组数据转成position
     *  */

  }, {
    key: "convertArrayPoints",
    value: function convertArrayPoints(idxs, pts) {
      var gd = new _ArrayReader.default().parse(idxs, pts);
      var d = {
        vertices: gd.points
        /*, indices:[]*/

      }; //holes:[[],..]

      return d;
    }
  }, {
    key: "checkClockwise",
    value: function checkClockwise(array) {
      var minx = Number.NEGATIVE_INFINITY;
      var maxIndex = 0;
      var preIndex = 0;
      var nextIndex = 0;

      for (var i = 0; i < array.length; i += 2) {
        if (array[i] > minx) {
          minx = array[i];
          maxIndex = i;
        }
      }

      var mpoint = new fm.Vector3(array[maxIndex], array[maxIndex + 1], 0);

      if (maxIndex === 0) {
        preIndex = array.length - 2;
      } else {
        preIndex = maxIndex - 2;
      }

      if (maxIndex === array.length - 2) {
        nextIndex = 0;
      } else {
        nextIndex = maxIndex + 2;
      }

      var prePoint = new fm.Vector3(array[preIndex], array[preIndex + 1], 0);
      var nextPoint = new fm.Vector3(array[nextIndex], array[nextIndex + 1], 0);
      var leftVec = new fm.Vector3().copy(mpoint).sub(prePoint);
      var rightVec = new fm.Vector3().copy(nextPoint).sub(mpoint);
      var normal = leftVec.cross(rightVec);

      if (normal.z > 0) {
        return true;
      } else {
        return false;
      }
    }
  }]);
  return DataManager;
}();

var _default = DataManager;
exports.default = _default;

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(28);
var createDesc = __webpack_require__(71);
module.exports = __webpack_require__(26) ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),
/* 44 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};


/***/ }),
/* 45 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 46 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

var _Symbol$iterator = __webpack_require__(279);

var _Symbol = __webpack_require__(283);

function _typeof(obj) {
  if (typeof _Symbol === "function" && typeof _Symbol$iterator === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof _Symbol === "function" && obj.constructor === _Symbol && obj !== _Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(30);
var toObject = __webpack_require__(39);
var toLength = __webpack_require__(34);
var toInteger = __webpack_require__(46);
var advanceStringIndex = __webpack_require__(141);
var regExpExec = __webpack_require__(95);
var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
__webpack_require__(97)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = defined(this);
      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
      return fn !== undefined
        ? fn.call(searchValue, O, replaceValue)
        : $replace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative($replace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);
      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;
        results.push(result);
        if (!global) break;
        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }
      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];
        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

    // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * 图形计算类
 * 包含结点与路段
 */


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(53);

__webpack_require__(56);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var kRealEpsion = 0.00001;
var kSameEpsilon = 0.00001;
var kSameEpsilon1 = 1.0e-3;
var kNearlySameEpsilon = 0.01;

var Graphics =
/*#__PURE__*/
function () {
  function Graphics() {
    (0, _classCallCheck2.default)(this, Graphics);
  }

  (0, _createClass2.default)(Graphics, null, [{
    key: "epsilon",
    value: function epsilon() {
      return kSameEpsilon1;
    } //是否接近于0

  }, {
    key: "isZero",
    value: function isZero(f) {
      if (f < kRealEpsion && f > -kRealEpsion) {
        return true;
      } else {
        return false;
      }
    } //是否大于EPSILON

  }, {
    key: "gtZero",
    value: function gtZero(f) {
      if (f > kRealEpsion) {
        return true;
      } else {
        return false;
      }
    } //是否小于EPSILON

  }, {
    key: "ltZero",
    value: function ltZero(f) {
      if (f < -kRealEpsion) {
        return true;
      } else {
        return false;
      }
    }
    /*
     * 计算点到线段的最短距离和相应的垂点
     * @param point 某一点
     * @param startPoint 线段的起点
     * @param endPoint 线段的终点
     * @return 【json】 垂点
     */

  }, {
    key: "pointDistanceToLine",
    value: function pointDistanceToLine(point, startPoint, endPoint, crossPoint) {
      var dist;
      var x0 = startPoint.x,
          y0 = startPoint.y;
      var x1 = endPoint.x,
          y1 = endPoint.y;
      var xx = point.x,
          yy = point.y;
      var v1x = x1 - x0,
          v1y = y1 - y0;
      var lv1 = Math.sqrt(v1x * v1x + v1y * v1y); //终点到起点的距离

      var v2x = xx - x0,
          v2y = yy - y0;
      var lv2 = Math.sqrt(v2x * v2x + v2y * v2y); //点pt到起点的距离
      // 如果线段非常短

      if (Graphics.isZero(lv1)) {
        crossPoint.x = startPoint.x;
        crossPoint.y = startPoint.y;

        if (Graphics.isZero(lv2)) {
          dist = 0;
          return dist;
        } else {
          dist = lv2;
          return dist;
        }
      }

      var nv1x = v1x / lv1,
          nv1y = v1y / lv1;
      var dotv1v2 = nv1x * v2x + nv1y * v2y; // 计算点pt在v1v2上的投影

      if (!Graphics.gtZero(dotv1v2)) {
        // 投影点在线段外v1前
        crossPoint.x = startPoint.x;
        crossPoint.y = startPoint.y;
        dist = lv2;
        return dist;
      } else if (!Graphics.ltZero(dotv1v2 - lv1)) {
        // 投影点在线段外v2后
        var v3x = xx - x1,
            v3y = yy - y1;
        var lv3 = Math.sqrt(v3x * v3x + v3y * v3y);
        crossPoint.x = endPoint.x;
        crossPoint.y = endPoint.y;
        dist = lv3;
        return dist;
      } //投影点在中间


      var p1x = x0 + dotv1v2 * nv1x,
          p1y = y0 + dotv1v2 * nv1y;
      var vx = xx - p1x,
          vy = yy - p1y;
      var d = Math.sqrt(vx * vx + vy * vy);
      crossPoint.x = p1x;
      crossPoint.y = p1y;
      dist = d;
      return dist;
    }
    /*
    * 求 两点之间的平面距离
    * @param point1
    * @param point2
    * @return
    */

  }, {
    key: "distanceOfTwoPoints",
    value: function distanceOfTwoPoints(point1, point2) {
      if (!point1 || !point2) {
        return Number.NaN;
      }

      return Math.sqrt((point1.x - point2.x) * (point1.x - point2.x) + (point1.y - point2.y) * (point1.y - point2.y));
    }
    /*
    * 判断两个point是否为同一个 精确到小数点后五位
    * @param point1
    * @param point2
    * @return 【true】类似同一个点 【false】不是
    */

  }, {
    key: "isSamePoint",
    value: function isSamePoint(point1, point2) {
      if (Math.abs(point1.x - point2.x) <= kSameEpsilon && Math.abs(point1.y - point2.y) <= kSameEpsilon) {
        return true;
      } else {
        return false;
      }
    }
  }, {
    key: "isNearlySamePoint",
    value: function isNearlySamePoint(point1, point2) {
      if (Math.abs(point1.x - point2.x) <= kNearlySameEpsilon && Math.abs(point1.y - point2.y) <= kNearlySameEpsilon) {
        return true;
      } else {
        return false;
      }
    }
    /*
     * [getPolygonInnerPoint 随机产生一个位于多边形内部的点]
     * @param  {[array]} polygon [多边形边界点数组]
     * @return {[coord]}         [return：多边形内部的点]
     */

  }, {
    key: "getPolygonInnerPoint",
    value: function getPolygonInnerPoint(polygon) {
      if (polygon && polygon.length == 0) {
        return {
          x: 0,
          y: 0
        };
      }

      var length = polygon.length;

      if (length < 3) {
        return polygon[0];
      }

      var ptPre = polygon[0],
          ptCurr = polygon[1];
      var ptMid = {
        x: (ptPre.x + ptCurr.x) / 2,
        y: (ptPre.y + ptCurr.y) / 2
      };
      var dAlpha = Math.atan2(ptCurr.y - ptPre.y, ptCurr.x - ptPre.x);
      dAlpha -= Math.PI / 2.0;
      var dLength = 3.0;

      while (dLength > 0.5) {
        var ptTmp = {
          x: ptMid.x + dLength * Math.cos(dAlpha),
          y: ptMid.y + dLength * Math.sin(dAlpha)
        };

        if (Graphics.isInPolygon(ptTmp, polygon)) {
          return ptTmp;
        }

        dLength /= 2.0;
      }

      dAlpha += Math.PI;
      dLength = 3.0;

      while (dLength > 0.5) {
        var _ptTmp = {
          x: ptMid.x + dLength * Math.cos(dAlpha),
          y: ptMid.y + dLength * Math.sin(dAlpha)
        };

        if (Graphics.isInPolygon(_ptTmp, polygon)) {
          return _ptTmp;
        }

        dLength /= 2.0;
      }

      return {
        x: 0,
        y: 0
      };
    }
    /*
     * [isInPolygon 判断点是否在多边形中]
     * @param  {[coord]}  point      [点]
     * @param  {[array<coord>]}  polygon [多边形边界数组]
     * @return {Boolean}         [是否在多边形内部]
     */

  }, {
    key: "isInPolygon",
    value: function isInPolygon(point, polygon) {
      var bRet = false;
      var size = polygon.length;

      for (var i = 0, j = size - 1; i < size; j = i, ++i) {
        var sx = polygon[i].x;
        var sy = polygon[i].y;
        var tx = polygon[j].x;
        var ty = polygon[j].y; // 点与多边形顶点重合

        if (sx == point.x && sy == point.y || tx == point.x && ty == point.y) {
          return true;
        } // 判断线段两端点是否在射线两侧


        if (sy < point.y && ty >= point.y || sy >= point.y && ty < point.y) {
          // 线段上与射线 Y 坐标相同的点的 X 坐标
          var x = sx + (point.y - sy) * (tx - sx) / (ty - sy); // 点在多边形的边上

          if (x == point.x) {
            return true;
          } // 射线穿过多边形的边界


          if (x > point.x) {
            bRet = !bRet;
          }
        }
      } // 射线穿过多边形边界的次数为奇数时点在多边形内


      return bRet;
    }
    /*
    * [isInPolygon 判断点是否在多边形中]
    * @param  {[coord]}  point      [点]
    * @param  {[array<coord>]}  polygon [多边形边界数组]
    * @return {Boolean}         [是否在多边形内部]
    */

  }, {
    key: "isInCircle",
    value: function isInCircle(point, center, radius, bb) {
      if (point.x < bb[0] && point.x > bb[1]) {
        return false;
      }

      if (point.y < bb[2] && point.y > bb[3]) {
        return false;
      }

      var radiusSquare = radius * radius;
      var x0 = point.x,
          y0 = point.y;
      var xx = center.x,
          yy = center.y;
      var v2x = xx - x0,
          v2y = yy - y0;
      var lv2 = v2x * v2x + v2y * v2y; //点pt到起点的距离

      if (lv2 < radiusSquare) {
        return true;
      }

      return false;
    }
  }, {
    key: "isRectCross",
    value: function isRectCross(p1, p2, q1, q2) {
      if (Math.max(p1.x, p2.x) < Math.min(q1.x, q2.x)) {
        return false;
      }

      if (Math.max(p1.y, p2.y) < Math.min(q1.y, q2.y)) {
        return false;
      }

      if (Math.max(q1.x, q2.x) < Math.min(p1.x, p2.x)) {
        return false;
      }

      if (Math.max(q1.y, q2.y) < Math.min(p1.y, p2.y)) {
        return false;
      }

      return true;
    }
  }, {
    key: "pointIsInRect",
    value: function pointIsInRect(point, rectPoint, width, height) {
      return Math.abs(point.x - rectPoint.x) < width && Math.abs(point.y - rectPoint.y) < height;
    }
  }, {
    key: "pointIsInRect1",
    value: function pointIsInRect1(point, p0, p1) {
      var minX = Math.min(p0.x, p1.x);
      var maxX = Math.max(p0.x, p1.x);
      var minY = Math.min(p0.y, p1.y);
      var maxY = Math.max(p0.y, p1.y);

      if (point.x < minX || point.x > maxX || point.y < minY || point.y > maxY) {
        return false;
      }

      return true;
    }
  }, {
    key: "cross",
    value: function cross(a, b, c) {
      return (a.x - c.x) * (b.y - c.y) - (b.x - c.x) * (a.y - c.y);
    }
  }, {
    key: "isLineSegmentCross",
    value: function isLineSegmentCross(p1, p2, q1, q2) {
      if (Math.max(p1.x, p2.x) < Math.min(q1.x, q2.x)) {
        return false;
      }

      if (Math.max(p1.y, p2.y) < Math.min(q1.y, q2.y)) {
        return false;
      }

      if (Math.max(q1.x, q2.x) < Math.min(p1.x, p2.x)) {
        return false;
      }

      if (Math.max(q1.y, q2.y) < Math.min(p1.y, p2.y)) {
        return false;
      }

      if (Graphics.cross(q1, p2, p1) * Graphics.cross(p2, q2, p1) < 0) {
        return false;
      }

      if (Graphics.cross(p1, q2, q1) * Graphics.cross(q2, p2, q1) < 0) {
        return false;
      }

      return true;
    }
  }, {
    key: "rayCrossSegment",
    value: function rayCrossSegment(point, angle, q1, q2, cross) {
      var xmin = Math.min(point.x, q1.x, q2.x);
      var xmax = Math.max(point.x, q1.x, q2.x);
      var ymin = Math.min(point.y, q1.y, q2.y);
      var ymax = Math.max(point.y, q1.y, q2.y);
      var slopeLen = Math.sqrt((xmax - xmin) * (xmax - xmin) + (ymax - ymin) * (ymax - ymin));
      var radius = angle / 180.0 * Math.PI;
      var endX = slopeLen * Math.cos(radius) + point.x;
      var endY = slopeLen * Math.sin(radius) + point.y;
      return this.calcCrossPoint(point, {
        x: endX,
        y: endY
      }, q1, q2, cross) == 1 ? true : false;
    }
  }, {
    key: "calcCrossPoint",
    value: function calcCrossPoint(p1, p2, q1, q2, cross) {
      if (Graphics.isLineSegmentCross(p1, p2, q1, q2) == 1) {
        //求交点
        var tmpLeft, tmpRight;
        tmpLeft = (q2.x - q1.x) * (p1.y - p2.y) - (p2.x - p1.x) * (q1.y - q2.y);
        tmpRight = (p1.y - q1.y) * (p2.x - p1.x) * (q2.x - q1.x) + q1.x * (q2.y - q1.y) * (p2.x - p1.x) - p1.x * (p2.y - p1.y) * (q2.x - q1.x);
        cross.x = tmpRight / tmpLeft;
        tmpLeft = (p1.x - p2.x) * (q2.y - q1.y) - (p2.y - p1.y) * (q1.x - q2.x);
        tmpRight = p2.y * (p1.x - p2.x) * (q2.y - q1.y) + (q2.x - p2.x) * (q2.y - q1.y) * (p1.y - p2.y) - q2.y * (q1.x - q2.x) * (p2.y - p1.y);
        cross.y = tmpRight / tmpLeft;
        return 1;
      }

      return 0;
    }
  }, {
    key: "pointInPolygon2d",
    value: function pointInPolygon2d(polygon, point, count) {
      var oddNodes = false;
      var p1 = null;
      var p2 = null;

      for (var i = 0; i < count; i++) {
        p1 = polygon[i];
        p2 = polygon[(i + 1) % count];

        if ((p1.y < point.y && p2.y >= point.y || p2.y < point.y && p1.y >= point.y) && (p1.x <= point.x || p2.x <= point.x)) {
          if (p1.x + (point.y - p1.y) / (p2.y - p1.y) * (p2.x - p1.x) < point.x) {
            oddNodes = !oddNodes;
          }
        }
      }

      return oddNodes;
    } //2--在边上

  }, {
    key: "pointInPolygon2d1",
    value: function pointInPolygon2d1(polygon, point, count) {
      var oddNodes = 0;
      var p1 = null;
      var p2 = null;
      var x_ = null;

      for (var i = 0; i < count; i++) {
        p1 = polygon[i];
        p2 = polygon[(i + 1) % count];

        if ((p1.y < point.y && p2.y >= point.y || p2.y < point.y && p1.y >= point.y) && (p1.x <= point.x || p2.x <= point.x)) {
          x_ = p1.x + (point.y - p1.y) / (p2.y - p1.y) * (p2.x - p1.x);

          if (Math.abs(x_ - point.x) <= kSameEpsilon1) {
            return 2;
          }

          if (x_ < point.x) {
            oddNodes = !oddNodes;
          }
        }
      }

      return oddNodes;
    }
  }, {
    key: "pointInPolygonVector2d",
    value: function pointInPolygonVector2d(polygon, point, count) {
      var oddNodes = false;
      var p1 = null;
      var p2 = null;
      var index = 0;
      var length = count / 2;

      for (var i = 0; i < length; i++) {
        index = i * 2;
        p1 = {
          'x': polygon[index],
          'y': polygon[index + 1]
        };
        p2 = {
          'x': polygon[(index + 2) % count],
          'y': polygon[(index + 3) % count]
        };

        if ((p1.y < point.y && p2.y >= point.y || p2.y < point.y && p1.y >= point.y) && (p1.x <= point.x || p2.x <= point.x)) {
          if (p1.x + (point.y - p1.y) / (p2.y - p1.y) * (p2.x - p1.x) < point.x) {
            oddNodes = !oddNodes;
          }
        }
      }

      return oddNodes;
    } /// @brief 计算点到线段的距离

  }, {
    key: "pointToSegmentDistance",
    value: function pointToSegmentDistance(pt, spt, ept) {
      var x = pt.x,
          y = pt.y;
      var x1 = spt.x,
          y1 = spt.y;
      var x2 = ept.x,
          y2 = ept.y;
      var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
      if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      var d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2));
      var r = cross / d2;
      var px = x1 + (x2 - x1) * r;
      var py = y1 + (y2 - y1) * r;
      return Math.sqrt((x - px) * (x - px) + (py - y) * (py - y));
    }
  }, {
    key: "pointToPolygon2d",
    value: function pointToPolygon2d(polygon, point, count) {
      var p1 = null;
      var p2 = null;
      var minDist = Number.MAX_VALUE;

      for (var i = 0; i < count; i++) {
        p1 = polygon[i];
        p2 = polygon[(i + 1) % count];
        var pt2segdist = Graphics.pointToSegmentDistance(point, p1, p2);

        if (minDist > pt2segdist) {
          minDist = pt2segdist;
        }
      }

      return minDist;
    }
  }, {
    key: "lineInCircle2d",
    value: function lineInCircle2d(p0, p1, center, radius, bb) {
      if (p0.x < bb[0] && p1.x < bb[0]) {
        return false;
      }

      if (p0.x > bb[1] && p1.x > bb[1]) {
        return false;
      }

      if (p0.y < bb[2] && p1.y < bb[2]) {
        return false;
      }

      if (p0.y > bb[3] && p1.y > bb[3]) {
        return false;
      }

      var radiusSquare = radius * radius;
      var x0 = p0.x,
          y0 = p0.y;
      var x1 = p1.x,
          y1 = p1.y;
      var xx = center.x,
          yy = center.y;
      var v1x = x1 - x0,
          v1y = y1 - y0;
      var lv1 = v1x * v1x + v1y * v1y; //终点到起点的距离

      var v2x = xx - x0,
          v2y = yy - y0;
      var lv2 = v2x * v2x + v2y * v2y; //点pt到起点的距离
      // 如果线段非常短

      if (Graphics.isZero(lv1)) {
        if (Graphics.isZero(lv2)) {
          return true;
        } else {
          return lv2 < radiusSquare;
        }
      }

      lv1 = Math.sqrt(lv1);
      var nv1x = v1x / lv1,
          nv1y = v1y / lv1;
      var dotv1v2 = nv1x * v2x + nv1y * v2y; // 计算点pt在v1v2上的投影

      if (!Graphics.gtZero(dotv1v2)) {
        // 投影点在线段外v1前
        return lv2 < radiusSquare;
      } else if (!Graphics.ltZero(dotv1v2 - lv1)) {
        // 投影点在线段外v2后
        var v3x = xx - x1,
            v3y = yy - y1;
        var lv3 = v3x * v3x + v3y * v3y;
        return lv3 < radiusSquare;
      } //投影点在中间


      var p1x = x0 + dotv1v2 * nv1x,
          p1y = y0 + dotv1v2 * nv1y;
      var vx = xx - p1x,
          vy = yy - p1y;
      var d = vx * vx + vy * vy;
      return d < radiusSquare;
    }
  }, {
    key: "lineInPolygon2d",
    value: function lineInPolygon2d(p0, p1, points, bb) {
      if (p0.x < bb[0] && p1.x < bb[0]) {
        return false;
      }

      if (p0.x > bb[1] && p1.x > bb[1]) {
        return false;
      }

      if (p0.y < bb[2] && p1.y < bb[2]) {
        return false;
      }

      if (p0.y > bb[3] && p1.y > bb[3]) {
        return false;
      }

      var count = points.length;

      if (Graphics.pointInPolygon2d(points, p0, count)) {
        return true;
      }

      if (Graphics.pointInPolygon2d(points, p1, count)) {
        return true;
      }

      for (var i = 0; i < count; i++) {
        var idx = (i + 1) % count;

        if (Graphics.isLineSegmentCross(p0, p1, points[i], points[idx])) {
          return true;
        }
      }

      return false;
    } //计算线段与圆的交点

  }, {
    key: "calcLineCircleCrossPoints2d",
    value: function calcLineCircleCrossPoints2d(p0, p1, center, radius, bb) {
      if (p0.x < bb[0] && p1.x < bb[0]) {
        return null;
      }

      if (p0.x > bb[1] && p1.x > bb[1]) {
        return null;
      }

      if (p0.y < bb[2] && p1.y < bb[2]) {
        return null;
      }

      if (p0.y > bb[3] && p1.y > bb[3]) {
        return null;
      }

      var result = {
        isContain: false,
        crossPoints: []
      };
      var radiusSquare = radius * radius;
      var x0 = p0.x,
          y0 = p0.y;
      var x1 = p1.x,
          y1 = p1.y;
      var xx = center.x,
          yy = center.y;
      var v1x = x1 - x0,
          v1y = y1 - y0;
      var lv1 = v1x * v1x + v1y * v1y; //终点到起点的距离

      var v2x = xx - x0,
          v2y = yy - y0;
      var lv2 = v2x * v2x + v2y * v2y; //点pt到起点的距离

      var v3x = xx - x1,
          v3y = yy - y1;
      var lv3 = v3x * v3x + v3y * v3y; //点pt到起点的距离
      // 如果线段非常短

      if (Graphics.isZero(lv1)) {
        if (Graphics.isZero(lv2)) {
          result.isContain = true;
          result.crossPoints = [p0, p1];
          return result;
        } else {
          if (lv2 < radiusSquare) {
            result.isContain = true;
            result.crossPoints = [p0, p1];
          }

          return result;
        }
      } //起终点都在圆内


      if (lv2 < radiusSquare && lv3 < radiusSquare) {
        result.isContain = true;
        result.crossPoints = [p0, p1];
        return result;
      }

      var dis = Math.sqrt(lv1);
      var dx = v1x / dis;
      var dy = v1y / dis;
      var a = v2x * dx + v2y * dy;
      var a2 = a * a;
      var e2 = v2x * v2x + v2y * v2y;

      if (radiusSquare - e2 + a2 < 0) {
        return null;
      } else {
        var f = Math.sqrt(radiusSquare - e2 + a2);
        var t = a - f;

        if (t - 0.0 > -kRealEpsion && t - dis < kRealEpsion) {
          result.crossPoints.push({
            'x': x0 + t * dx,
            'y': y0 + t * dy
          });
        }

        t = a + f;

        if (t - 0.0 > -kRealEpsion && t - dis < kRealEpsion) {
          result.crossPoints.push({
            'x': x0 + t * dx,
            'y': y0 + t * dy
          });
        }

        return result;
      }
    } //计算线段与圆的交点

  }, {
    key: "calcLinePolygonCrossPoints2d",
    value: function calcLinePolygonCrossPoints2d(p0, p1, points, bb) {
      if (p0.x < bb[0] && p1.x < bb[0]) {
        return null;
      }

      if (p0.x > bb[1] && p1.x > bb[1]) {
        return null;
      }

      if (p0.y < bb[2] && p1.y < bb[2]) {
        return null;
      }

      if (p0.y > bb[3] && p1.y > bb[3]) {
        return null;
      } //0-不包含起终点 1-包含起点 2-包含终点 3-包含起终点


      var result = {
        containType: 0,
        crossPoints: []
      };
      var count = points.length;

      if (Graphics.pointInPolygon2d(points, p0, count)) {
        result.containType |= 0x1;
      }

      if (Graphics.pointInPolygon2d(points, p1, count)) {
        result.containType |= 0x1 << 1;
      }

      var crossPoints = [];

      for (var i = 0; i < count; i++) {
        var idx = (i + 1) % count;
        var crossPoint = {};

        if (Graphics.calcCrossPoint(p0, p1, points[i], points[idx], crossPoint)) {
          var vx = crossPoint.x - p0.x,
              vy = crossPoint.y - p0.y;
          crossPoints.push({
            dis2: vx * vx + vy * vy,
            point: crossPoint
          });
        }
      }

      if (crossPoints.length == 0) {
        return null;
      }

      crossPoints.sort(function (c0, c1) {
        return c1.dis2 - c0.dis2;
      });

      for (var _i = 0; _i < crossPoints.length; _i++) {
        result.crossPoints.push(crossPoints[_i].point);
      }

      return result;
    }
  }, {
    key: "calcCenterOfGravityPoint",
    value: function calcCenterOfGravityPoint(points, count) {
      var area = 0.0; //多边形面积

      var gx = 0.0,
          gy = 0.0; // 重心的x、y

      for (var i = 0; i < count; i++) {
        var p0 = points[i];
        var p1 = points[(i + 1) % count];
        var temp = (p0.x * p1.y - p0.y * p1.x) / 2.0;
        area += temp;
        gx += temp * (p0.x + p1.x) / 3.0;
        gy += temp * (p0.y + p1.y) / 3.0;
      }

      gx = gx / area;
      gy = gy / area;
      return {
        'x': gx,
        'y': gy
      };
    }
  }, {
    key: "calcPolygonArea2d",
    value: function calcPolygonArea2d(polygon) {
      var point_num = polygon.length;

      if (point_num < 3) {
        return 0.0;
      }

      var area = 0;

      for (var i = 0; i < point_num; ++i) {
        var p0 = polygon[i];
        var p1 = polygon[(i + 1) % point_num];
        area += p0.x * p1.y - p0.y * p1.x;
      }

      return Math.abs(area / 2.0);
    }
  }, {
    key: "quickRayIntersect",
    value: function quickRayIntersect(point, angle, p0, p1, cross) {
      var xmin = Math.min(p0.x, p1.x);
      var xmax = Math.max(p0.x, p1.x);
      var ymin = Math.min(p0.y, p1.y);
      var ymax = Math.max(p0.y, p1.y);
      var x0 = point.x,
          y0 = point.y,
          x1 = p0.x,
          y1 = p0.y,
          x2 = p1.x,
          y2 = p1.y; // 先处理90度

      if (90 == angle) {
        if (point.x < xmin || point.x > xmax) {
          return false;
        }

        var k = (y2 - y1) / (x2 - x1);

        var _y = k * (x0 - x1) + y1;

        cross.y = _y;
        cross.x = x0; // 如果该角度为270度

        if (_y < y0) {
          return false;
        }

        if (Graphics.pointIsInRect1(cross, p0, p1)) {
          return true;
        } else {
          return false;
        }
      } // 再处理270度


      if (270 == angle) {
        if (point.x < xmin || point.x > xmax) {
          return false;
        }

        ;

        var _k = (y2 - y1) / (x2 - x1);

        var _y2 = _k * (x0 - x1) + y1;

        cross.y = _y2;
        cross.x = x0; // 如果该角度为270度

        if (_y2 > y0) {
          return false;
        }

        if (Graphics.pointIsInRect1(cross, p0, p1)) {
          return true;
        } else {
          return false;
        }
      }

      if (270 != angle && 90 != angle) {
        if (xmax - xmin < kSameEpsilon1) {
          var _x = xmin;
          var tanAlpha = Math.tan(angle / 180 * Math.PI);

          var _y3 = tanAlpha * (_x - x0) + y0;

          cross.y = _y3;
          cross.x = _x;

          if (Graphics.pointIsInRect1(cross, p0, p1)) {
            var dx = _x - x0;
            var dy = _y3 - y0;
            var refCosTheta = dx / Math.sqrt(dx * dx + dy * dy);
            var targetCosTheta = Math.cos(angle / 180 * Math.PI); // 判断相交点的角度是否符合要求

            if (refCosTheta * targetCosTheta > 0) {
              return true;
            } else {
              return false;
            }
          }
        }
      }

      if (ymax - ymin <= 1.0e-6) {
        var _y4 = ymin;

        var _tanAlpha = Math.tan(angle / 180.0 * Math.PI);

        var _x2 = 1 / _tanAlpha * (_y4 - y0) + x0;

        cross.x = _x2;
        cross.y = _y4;

        if (Graphics.pointIsInRect1(cross, p0, p1)) {
          var _dx = _x2 - x0;

          var _dy = _y4 - y0;

          var _refCosTheta = _dx / Math.sqrt(_dx * _dx + _dy * _dy);

          var _targetCosTheta = Math.cos(angle / 180.0 * Math.PI); // 判断相交点的角度是否符合要求


          if (_refCosTheta * _targetCosTheta > 0) {
            return true;
          } else {
            return false;
          }
        } else {
          return false;
        }
      } // 其它情况


      var tanalpha = Math.tan(angle / 180 * Math.PI);
      var tanbeta = (y2 - y1) / (x2 - x1);
      var x = (y1 - y0 - (tanbeta * x1 - tanalpha * x0)) / (tanalpha - tanbeta);
      var y = y0 + tanalpha * (x - x0);
      cross.x = x;
      cross.y = y;

      if (Graphics.pointIsInRect1(cross, p0, p1)) {
        var _dx2 = x - x0;

        var _dy2 = y - y0;

        var testCosTheta = _dx2 / Math.sqrt(_dx2 * _dx2 + _dy2 * _dy2);

        var cosTheta = Math.cos(angle / 180 * Math.PI); // 判断相交点的角度是否符合要求

        if (testCosTheta * cosTheta > 0) {
          return true;
        } else {
          return false;
        }
      } else {
        return false;
      }
    }
  }, {
    key: "calcFootOfUpright",
    value: function calcFootOfUpright(point, p0, p1, cross) {
      var xmin = Math.min(p0.x, p1.x);
      var xmax = Math.max(p0.x, p1.x);
      var ymin = Math.min(p0.y, p1.y);
      var ymax = Math.max(p0.y, p1.y);
      var x0 = point.x,
          y0 = point.y,
          x1 = p0.x,
          y1 = p0.y,
          x2 = p1.x,
          y2 = p1.y;
      var k = 0.0; // 先处理90度

      if (Math.abs(x1 - x2) < kSameEpsilon) {
        cross.x = x1;
        cross.y = y0;

        if (y0 >= ymin && y0 <= ymax) {
          return true;
        }

        return false;
      }

      if (Math.abs(y1 - y2) < kSameEpsilon) {
        cross.x = x0;
        cross.y = y1;

        if (x0 >= xmin && x0 <= xmax) {
          return true;
        }

        return false;
      }

      var k2 = (y2 - y1) / (x2 - x1);
      var tanalpha = -1.0 / k2;
      var tanbeta = (y2 - y1) / (x2 - x1);
      var x = (y1 - y0 - (tanbeta * x1 - tanalpha * x0)) / (tanalpha - tanbeta);
      var y = y0 + tanalpha * (x - x0);
      cross.x = x;
      cross.y = y;

      if (Graphics.pointIsInRect1(cross, p0, p1)) {
        return true;
      }

      return false;
    }
  }, {
    key: "vectorCross",
    value: function vectorCross(v1, v2) {
      return {
        'x': v1.y * v2.z - v1.z * v2.y,
        'y': v1.z * v2.x - v1.x * v2.z,
        'z': v1.x * v2.y - v1.y * v2.x
      };
    }
  }, {
    key: "vectorDot",
    value: function vectorDot(v1, v2) {
      return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    }
  }, {
    key: "vectorLength",
    value: function vectorLength(v) {
      return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    }
  }, {
    key: "vector2DDot",
    value: function vector2DDot(v1, v2) {
      return v1.x * v2.x + v1.y * v2.y;
    }
  }, {
    key: "vector2DLength",
    value: function vector2DLength(v) {
      return Math.sqrt(v.x * v.x + v.y * v.y);
    }
  }, {
    key: "calcRotateAngle",
    value: function calcRotateAngle(v1, v2) {
      var from = {
        'x': v1.x,
        'y': v1.y,
        'z': 0.0
      };
      var to = {
        'x': v2.x,
        'y': v2.y,
        'z': 0.0
      };
      var vec_prod = Graphics.vectorCross(from, to);
      var dot_prod = Graphics.vector2DDot(v1, v2);
      var rad = Math.acos(dot_prod / (Graphics.vector2DLength(v1) * Graphics.vector2DLength(v2))); // 逆时针旋转小于 180

      if (vec_prod.z > 0) {
        return rad / Math.PI * 180.0;
      } else {
        return 360.0 - rad / Math.PI * 180.0;
      }
    }
  }, {
    key: "isPointOnSegment",
    value: function isPointOnSegment(point, p0, p1) {
      if ((point.x - p0.x) * (p1.y - p0.y) == (p1.x - p0.x) * (point.y - p0.y) //叉乘
      //保证point点坐标在p0,p1之间
      && Math.min(p0.x, p1.x) <= point.x && point.x <= Math.max(p0.x, p1.x) && Math.min(p0.y, p1.y) <= point.y && point.y <= Math.max(p0.y, p1.y)) return true;else return false;
    }
  }, {
    key: "segCrossPolygon",
    value: function segCrossPolygon(p1, p2, poly, crs) {
      for (var i = 0; i < poly.length; i++) {
        var q1 = poly[i];
        var q2 = poly[(i + 1) % poly.length];

        if (1 == this.calcCrossPoint(p1, p2, q1, q2, crs)) {
          return true;
        }
      }

      return false;
    }
  }]);
  return Graphics;
}();

var _default = Graphics;
exports.default = _default;

/***/ }),
/* 50 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),
/* 51 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(90);
module.exports = function (it) {
  return Object(defined(it));
};


/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(22);
var aFunction = __webpack_require__(118);
var toObject = __webpack_require__(39);
var fails = __webpack_require__(18);
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !__webpack_require__(315)($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(316);

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.13 String.prototype.sub()
__webpack_require__(105)('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(24);
var has = __webpack_require__(50);
var cof = __webpack_require__(74);
var inheritIfRequired = __webpack_require__(160);
var toPrimitive = __webpack_require__(72);
var fails = __webpack_require__(18);
var gOPN = __webpack_require__(87).f;
var gOPD = __webpack_require__(119).f;
var dP = __webpack_require__(33).f;
var $trim = __webpack_require__(357).trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(__webpack_require__(132)(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = __webpack_require__(23) ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  __webpack_require__(38)(global, NUMBER, $Number);
}


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

__webpack_require__(13);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 * FMUtil是工具类 存放通用的一些工具函数
 */
var FMUtil =
/*#__PURE__*/
function () {
  function FMUtil() {
    (0, _classCallCheck2.default)(this, FMUtil);
  }
  /**
   * rgb颜色转换成数值
   * @param {*} c
   */


  (0, _createClass2.default)(FMUtil, null, [{
    key: "toColor",
    value: function toColor(c) {
      if (typeof c == "number") {
        return c;
      }

      var cs = c.split(',');

      if (cs.length >= 3) {
        return (0, _parseInt2.default)(cs[0]) << 16 | (0, _parseInt2.default)(cs[1]) << 8 | (0, _parseInt2.default)(cs[2]);
      } else {
        console.error('color format error', c);
        return 0;
      }
    }
    /**
     * rgb字符串转换成rgb
     * @param {*} c
     */

  }, {
    key: "toRgba",
    value: function toRgba(c) {
      if (typeof c != 'number') {
        var cs = c.split(',');

        if (cs.length >= 3) {
          return 'rgba(' + (0, _parseInt2.default)(cs[0]) + ',' + (0, _parseInt2.default)(cs[1]) + ',' + (0, _parseInt2.default)(cs[2]) + ',1)';
        } else {
          return c;
        }
      } else {
        return 'rgba(' + (0, _parseInt2.default)(new fm.Color(c).r * 255) + ',' + (0, _parseInt2.default)(new fm.Color(c).g * 255) + ',' + (0, _parseInt2.default)(new fm.Color(c).b * 255) + ',1)';
      }
    }
    /**
     * copy from https://zhuanlan.zhihu.com/p/26536815
     * author: 桐城
     * 事件委托
     * @param {*} dom
     * @param {*} targetSelector
     * @param {*} type
     * @param {*} back
     */

  }, {
    key: "bindEvent",
    value: function bindEvent(dom, targetSelector, type, back) {
      dom.addEventListener(type, function (e) {
        // 兼容性处理
        var event = e || window.event; // 获取到目标阶段指向的元素

        var target = event.target || event.srcElement; // 获取到代理事件的函数

        var currentTarget = event.currentTarget; // 处理 matches 的兼容性

        if (!Element.prototype.matches) {
          Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function (s) {
            var matches = (this.document || this.ownerDocument).querySelectorAll(s),
                i = matches.length;

            while (--i >= 0 && matches.item(i) !== this) {}

            return i > -1;
          };
        } // 遍历外层并且匹配


        while (target !== currentTarget) {
          // 判断是否匹配到我们所需要的元素上
          if (target.matches(targetSelector)) {
            var sTarget = target; // 执行绑定的函数，注意 this

            back.call(sTarget, event);
          }

          target = target.parentNode;
        }
      });
    }
    /**
     * 地图坐标转场景坐标
     */

  }, {
    key: "toSceneCoord",
    value: function toSceneCoord(map, coord) {
      var z = 0;

      if (coord.groupID) {
        z = map.getFMGroup(coord.groupID).height;
      }

      return new fm.Vector3(coord.x - map.center.x, map.center.y + z, -coord.y + map.center.y);
    }
  }, {
    key: "removeFormArray",
    value: function removeFormArray(arr, obj) {
      var index = arr.indexOf(obj);

      if (index > -1) {
        arr.splice(index, 1);
      }
    } // static scrollEaseTime = 10;

    /**
     * 缓动函数
     * @param t 动画已消耗时间
     * @param b 原始值
     * @param c 目标值
     * @param d 持续时间
     */
    // static sineaseOut(t, b, c, d) {
    //     return c * ((t = t / d - 1) * t * t + 1) + b
    // }
    // static scrollToView(scroller, scrollTo, justify = 0) {
    //     if (!scroller || !(typeof scrollTo == 'number')) {
    //         return;
    //     }
    //     var scroll = scrollTo;
    //     var scrollStart = scroller.scrollTop;
    //     var start = null;
    //     //scroller.scrollTop = scrollStart+scroll;
    //     var step = function step(timestamp) {
    //         if (!start) {
    //             start = timestamp;
    //         }
    //         var stepScroll = FMUtil.sineaseOut(timestamp - start, 0, scroll, FMUtil.scrollEaseTime);
    //         var total = scroller.scrollTop = scrollStart + stepScroll;
    //         if ((scroll > 0 && total < scrollStart + scroll) || (scroll < 0 && total > scrollStart + scroll)) {
    //             requestAnimationFrame(step);
    //         }
    //     };
    //     requestAnimationFrame(step);
    // }
    //平滑滚动scrollTop

  }, {
    key: "scrollTopAnFun",
    value: function scrollTopAnFun() {
      var running = false,
          gapNum; // 时间切割份数变量

      return function selfFun(params) {
        var el = params.el,
            to = params.to,
            form = params.form,
            time = params.time; // ---------变量区------------

        var VDIRECTIONE = to < form ? 'up' : 'bottom',
            GAPVAL = to > form ? to - form : to == form ? 0 : form - to // 相差值
        ,
            TIMEGAP = 10 // 流畅度
        ,
            GAPNAM = GAPVAL / TIMEGAP; //(time * TIMEGAP) / gapVal // 时间切割份数

        var nextScrollTopVal = 0; // 下一个滚动值
        // ----------纯函数区-------------

        /**
         * 获取下一个滚动值
         */

        var getnextScrollTop = function getnextScrollTop(_ref) {
          var val = _ref.val,
              nbak = _ref.nbak,
              n = _ref.n,
              elTop = _ref.elTop;
          return VDIRECTIONE == 'up' ? elTop + (nbak - n) * val : elTop - (nbak - n) * val;
        }; // ----------函数区---------------
        // 动画结束又执行新的任务


        function NewEvent() {
          // console.log('scroll正在使用')
          // 暂停当前任务
          gapNum = 0; // 执行新任务

          window.setTimeout(function () {
            var p = Object(params, {
              to: el.scrollTop
            }); // 取消限制

            running = false;
            selfFun(p);
          }, TIMEGAP + 1);
        } // 滚动动画结束


        var ScrollDefer = function ScrollDefer() {
          running = false;
          gapNum = false; // 因为精确度问题， 需要手动修复

          if (form == 0) {
            el.scrollTop = 0;
          }
        }; // scroll动画


        var SetScroll = function SetScroll() {
          // 执行次数
          gapNum--;

          if (gapNum <= 0) {
            ScrollDefer();
            return;
          } // 逻辑处理


          var cors = function cors() {
            if (gapNum === false) {
              return;
            } // 获取下一个top


            nextScrollTopVal = getnextScrollTop({
              val: TIMEGAP,
              nbak: GAPNAM,
              n: gapNum,
              elTop: to,
              VDIRECTIONE: VDIRECTIONE
            }); // 防止闪屏

            nextScrollTopVal && (el.scrollTop = nextScrollTopVal);
            SetScroll();
          }; // 执行下一个


          window.setTimeout(cors, TIMEGAP);
        }; // ------------ main -------------


        function main() {
          // 动画结束又执行新的任务
          if (running) {
            NewEvent();
            return;
          }

          running = true;
          gapNum = GAPNAM; // 设置scroll （递归函数）

          SetScroll();
        }

        main();
      };
    }
    /**
     *
     * @param par
     * @returns {Vector2|oi|Ti}
     *  {
     *      x:  12 ,
     *      y:  24,
     *      z:  23
     *  }
     */

  }, {
    key: "toVector",
    value: function toVector(par) {
      if (par.hasOwnProperty('z')) {
        return new fm.Vector3(par.x, par.y, par.z);
      }

      return new fm.Vector2(par.x, par.y);
    }
  }, {
    key: "sleep",
    value: function sleep(milliseconds) {
      var start = new Date().getTime();

      for (var i = 0; i < 1e7; i++) {
        if (new Date().getTime() - start > milliseconds) {
          break;
        }
      }
    }
  }]);
  return FMUtil;
}();

var _default = FMUtil;
exports.default = _default;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(__webpack_require__(11));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

//动画执行类
var Animator =
/*#__PURE__*/
function () {
  function Animator(left, right) {
    var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
    var endBack = arguments.length > 3 ? arguments[3] : undefined;
    var runBack = arguments.length > 4 ? arguments[4] : undefined;
    (0, _classCallCheck2.default)(this, Animator);
    this._left = (0, _assign.default)({}, left);
    this._right = (0, _assign.default)({}, right);
    this._time = time;
    this._enable = false;
    this._countTime = 0;
    this._endBack = endBack;
    this._runBack = runBack;
    this.speed = 1;
    this._result = (0, _assign.default)({}, left);
  }

  (0, _createClass2.default)(Animator, [{
    key: "run",
    value: function run(deltime) {
      var dtime = deltime * this.speed;
      var deltResult = {};

      if (this._countTime + dtime > this._time) {
        for (var n in this._left) {
          var delt = (this._right[n] - this._left[n]) * (this._time - this._countTime) / this._time;
          this._result[n] += delt;
          deltResult[n] = delt;
        }

        this._enable = false;

        this._runBack(this._result, deltResult);

        this._endBack(this._result, deltResult);

        this._result = {};
        this._countTime = 0;
        return;
      }

      for (var _n in this._left) {
        var _delt = (this._right[_n] - this._left[_n]) * dtime / this._time;

        this._result[_n] += _delt;
        deltResult[_n] = _delt;
      }

      this._countTime += dtime;

      this._runBack(this._result, deltResult);
    }
  }, {
    key: "pause",
    value: function pause() {
      this._enable = false;
      return this;
    }
  }, {
    key: "resume",
    value: function resume() {
      this._enable = true;
      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      this._enable = false;
      this._countTime = 0;
      this._result = (0, _assign.default)({}, this._left);
      return this;
    }
  }, {
    key: "start",
    value: function start() {
      this._enable = true;
      return this;
    }
  }, {
    key: "enable",
    get: function get() {
      return this._enable;
    },
    set: function set(bool) {
      this._enable = bool;
    }
  }]);
  return Animator;
}();

var _default = Animator;
exports.default = _default;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(264)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(124)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 60 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(126);
var defined = __webpack_require__(90);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(175);
var step = __webpack_require__(272);
var Iterators = __webpack_require__(63);
var toIObject = __webpack_require__(86);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(176)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 63 */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

var META = __webpack_require__(93)('meta');
var isObject = __webpack_require__(17);
var has = __webpack_require__(45);
var setDesc = __webpack_require__(28).f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !__webpack_require__(44)(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(281);
var global = __webpack_require__(14);
var hide = __webpack_require__(43);
var Iterators = __webpack_require__(60);
var TO_STRING_TAG = __webpack_require__(19)('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(36);
var call = __webpack_require__(171);
var isArrayIter = __webpack_require__(172);
var anObject = __webpack_require__(29);
var toLength = __webpack_require__(92);
var getIterFn = __webpack_require__(130);
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.3.6 Object.prototype.toString()
var classof = __webpack_require__(96);
var test = {};
test[__webpack_require__(15)('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  __webpack_require__(38)(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.8 String.prototype.fontsize(size)
__webpack_require__(105)('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.mapOptionMessage = exports.tileMessage = exports.cerityMessage = void 0;
var cerityMessage = {
  //key%E5%80%BC%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%E3%80%82
  // key值未配置，请访问蜂鸟云控制台查看应用名称。
  warn_nokey: 'key%E5%80%BC%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%E3%80%82',
  // 应用名称（appname）未配置，请访问蜂鸟云控制台查看应用名称。
  //%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%EF%BC%88appname%EF%BC%89%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%E3%80%82
  warn_noappname: '%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%EF%BC%88appname%EF%BC%89%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%E3%80%82',
  // 地图ID未配置，请访问蜂鸟云控制台查看地图ID。
  //%E5%9C%B0%E5%9B%BEID%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9B%BEID%E3%80%82
  warn_nomapid: '%E5%9C%B0%E5%9B%BEID%E6%9C%AA%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%9F%A5%E7%9C%8B%E5%9C%B0%E5%9B%BEID%E3%80%82',
  // 您配置的key值不正确，请访问蜂鸟云控制台检查此应用下的key值。
  //%E6%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84key%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A3%80%E6%9F%A5%E6%AD%A4%E5%BA%94%E7%94%A8%E4%B8%8B%E7%9A%84key%E5%80%BC%E3%80%82
  warn_keynotright: '%E6%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84key%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A3%80%E6%9F%A5%E6%AD%A4%E5%BA%94%E7%94%A8%E4%B8%8B%E7%9A%84key%E5%80%BC%E3%80%82',
  // 您配置的应用名称（appname）或key值不正确，请访问蜂鸟云控制台检查您的应用。
  //%E6%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%EF%BC%88appname%EF%BC%89%E6%88%96key%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A3%80%E6%9F%A5%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%82
  warn_offline: '%E6%82%A8%E9%85%8D%E7%BD%AE%E7%9A%84%E5%BA%94%E7%94%A8%E5%90%8D%E7%A7%B0%EF%BC%88appname%EF%BC%89%E6%88%96key%E5%80%BC%E4%B8%8D%E6%AD%A3%E7%A1%AE%EF%BC%8C%E8%AF%B7%E8%AE%BF%E9%97%AE%E8%9C%82%E9%B8%9F%E4%BA%91%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%A3%80%E6%9F%A5%E6%82%A8%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%82',
  //%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5
  // 文件解析失败
  warn_openerror: '%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90%E5%A4%B1%E8%B4%A5',
  // 无法连接到蜂鸟云
  //%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%9C%82%E9%B8%9F%E4%BA%91
  warn_connecterror: '%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%9C%82%E9%B8%9F%E4%BA%91',
  // 从蜂鸟云上获得地图数据失败
  //%E4%BB%8E%E8%9C%82%E9%B8%9F%E4%BA%91%E4%B8%8A%E8%8E%B7%E5%BE%97%E5%9C%B0%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%A4%B1%E8%B4%A5
  warn_downloaderror: '%E4%BB%8E%E8%9C%82%E9%B8%9F%E4%BA%91%E4%B8%8A%E8%8E%B7%E5%BE%97%E5%9C%B0%E5%9B%BE%E6%95%B0%E6%8D%AE%E5%A4%B1%E8%B4%A5',
  // 本地验证失败
  //%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5
  warn_local: "%E6%9C%AC%E5%9C%B0%E9%AA%8C%E8%AF%81%E5%A4%B1%E8%B4%A5"
};
exports.cerityMessage = cerityMessage;
var tileMessage = {
  noGroup: "目标楼层未初始化，请检查楼层id是否越界，或者等待楼层加载！",
  noFocus: "焦点层不在可视楼层中，请检查焦点层和可视楼层的参数设置！"
};
exports.tileMessage = tileMessage;
var mapOptionMessage = {
  defaultViewCenterError: '地图初始化中心位置错误，请检查fengmap.FMMap初始化参数defaultViewCenter的正确性'
};
exports.mapOptionMessage = mapOptionMessage;

/***/ }),
/* 70 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 71 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(37);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 73 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 74 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 75 */
/***/ (function(module, exports) {

module.exports = true;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(168);
var enumBugKeys = __webpack_require__(129);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 77 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(28).f;
var has = __webpack_require__(45);
var TAG = __webpack_require__(19)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(17);
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

/**
*	FMLanguageType 语言类型枚举类
* 	@class
* 	@memberof fengmap
*   @hideconstructor true
*/
var FMLanguageType = {
  /**
   * 中文
   * @property {string} ZH -'zh'
   * @final
   */
  ZH: 'zh',

  /**
  * 英文
  * @property {string} EN -'en'
  * @final
  */
  EN: 'en',
  CHN: "zh"
};
var _default = FMLanguageType;
exports.default = _default;

/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var _interopRequireDefault=__webpack_require__(1);var _Object$defineProperty2=__webpack_require__(0);_Object$defineProperty2(exports,"__esModule",{value:true});exports.AmbientLight=AmbientLight;exports.AmbientLightProbe=AmbientLightProbe;exports.AnimationClip=AnimationClip;exports.AnimationLoader=AnimationLoader;exports.AnimationMixer=AnimationMixer;exports.AnimationObjectGroup=AnimationObjectGroup;exports.ArcCurve=ArcCurve;exports.ArrayCamera=ArrayCamera;exports.ArrowHelper=ArrowHelper;exports.Audio=Audio;exports.AudioAnalyser=AudioAnalyser;exports.AudioListener=AudioListener;exports.AudioLoader=AudioLoader;exports.AxesHelper=AxesHelper;exports.AxisHelper=AxisHelper;exports.BinaryTextureLoader=BinaryTextureLoader;exports.Bone=Bone;exports.BooleanKeyframeTrack=BooleanKeyframeTrack;exports.BoundingBoxHelper=BoundingBoxHelper;exports.Box2=Box2;exports.Box3=Box3;exports.Box3Helper=Box3Helper;exports.BoxHelper=BoxHelper;exports.BufferAttribute=BufferAttribute;exports.BufferGeometry=BufferGeometry;exports.BufferGeometryLoader=BufferGeometryLoader;exports.Camera=Camera;exports.CameraHelper=CameraHelper;exports.CanvasRenderer=CanvasRenderer;exports.CanvasTexture=CanvasTexture;exports.CatmullRomCurve3=CatmullRomCurve3;exports.CircleBufferGeometry=CircleBufferGeometry;exports.CircleGeometry=CircleGeometry;exports.Clock=Clock;exports.ClosedSplineCurve3=ClosedSplineCurve3;exports.Color=Color;exports.ColorKeyframeTrack=ColorKeyframeTrack;exports.CompressedTexture=CompressedTexture;exports.CompressedTextureLoader=CompressedTextureLoader;exports.ConeBufferGeometry=ConeBufferGeometry;exports.ConeGeometry=ConeGeometry;exports.CubeCamera=CubeCamera;exports.CubeTexture=CubeTexture;exports.CubeTextureLoader=CubeTextureLoader;exports.CubicBezierCurve=CubicBezierCurve;exports.CubicBezierCurve3=CubicBezierCurve3;exports.CubicInterpolant=CubicInterpolant;exports.Curve=Curve;exports.CurvePath=CurvePath;exports.CylinderBufferGeometry=CylinderBufferGeometry;exports.CylinderGeometry=CylinderGeometry;exports.Cylindrical=Cylindrical;exports.DataTexture=DataTexture;exports.DataTexture2DArray=DataTexture2DArray;exports.DataTexture3D=DataTexture3D;exports.DataTextureLoader=DataTextureLoader;exports.DepthTexture=DepthTexture;exports.DirectionalLight=DirectionalLight;exports.DirectionalLightHelper=DirectionalLightHelper;exports.DirectionalLightShadow=DirectionalLightShadow;exports.DiscreteInterpolant=DiscreteInterpolant;exports.DodecahedronBufferGeometry=DodecahedronBufferGeometry;exports.DodecahedronGeometry=DodecahedronGeometry;exports.DynamicBufferAttribute=DynamicBufferAttribute;exports.EdgesGeometry=EdgesGeometry;exports.EdgesHelper=EdgesHelper;exports.EllipseCurve=EllipseCurve;exports.Euler=Euler;exports.EventDispatcher=EventDispatcher;exports.ExtrudeBufferGeometry=ExtrudeBufferGeometry;exports.ExtrudeGeometry=ExtrudeGeometry;exports.Face3=Face3;exports.Face4=Face4;exports.FileLoader=FileLoader;exports.Float32Attribute=Float32Attribute;exports.Float32BufferAttribute=Float32BufferAttribute;exports.Float64Attribute=Float64Attribute;exports.Float64BufferAttribute=Float64BufferAttribute;exports.Fog=Fog;exports.FogExp2=FogExp2;exports.Font=Font;exports.FontLoader=FontLoader;exports.Frustum=Frustum;exports.Geometry=Geometry;exports.GridHelper=GridHelper;exports.Group=Group;exports.HemisphereLight=HemisphereLight;exports.HemisphereLightHelper=HemisphereLightHelper;exports.HemisphereLightProbe=HemisphereLightProbe;exports.IcosahedronBufferGeometry=IcosahedronBufferGeometry;exports.IcosahedronGeometry=IcosahedronGeometry;exports.ImageBitmapLoader=ImageBitmapLoader;exports.ImageLoader=ImageLoader;exports.ImmediateRenderObject=ImmediateRenderObject;exports.InstancedBufferAttribute=InstancedBufferAttribute;exports.InstancedBufferGeometry=InstancedBufferGeometry;exports.InstancedInterleavedBuffer=InstancedInterleavedBuffer;exports.InstancedMesh=InstancedMesh;exports.Int16Attribute=Int16Attribute;exports.Int16BufferAttribute=Int16BufferAttribute;exports.Int32Attribute=Int32Attribute;exports.Int32BufferAttribute=Int32BufferAttribute;exports.Int8Attribute=Int8Attribute;exports.Int8BufferAttribute=Int8BufferAttribute;exports.InterleavedBuffer=InterleavedBuffer;exports.InterleavedBufferAttribute=InterleavedBufferAttribute;exports.Interpolant=Interpolant;exports.JSONLoader=JSONLoader;exports.KeyframeTrack=KeyframeTrack;exports.LOD=LOD;exports.LatheBufferGeometry=LatheBufferGeometry;exports.LatheGeometry=LatheGeometry;exports.Layers=Layers;exports.LensFlare=LensFlare;exports.Light=Light;exports.LightProbe=LightProbe;exports.LightShadow=LightShadow;exports.Line=Line;exports.Line3=Line3;exports.LineBasicMaterial=LineBasicMaterial;exports.LineCurve=LineCurve;exports.LineCurve3=LineCurve3;exports.LineDashedMaterial=LineDashedMaterial;exports.LineLoop=LineLoop;exports.LineSegments=LineSegments;exports.LinearInterpolant=LinearInterpolant;exports.Loader=Loader;exports.LoadingManager=LoadingManager;exports.Material=Material;exports.MaterialLoader=MaterialLoader;exports.Matrix3=Matrix3;exports.Matrix4=Matrix4;exports.Mesh=Mesh;exports.MeshBasicMaterial=MeshBasicMaterial;exports.MeshDepthMaterial=MeshDepthMaterial;exports.MeshDistanceMaterial=MeshDistanceMaterial;exports.MeshFaceMaterial=MeshFaceMaterial;exports.MeshLambertMaterial=MeshLambertMaterial;exports.MeshMatcapMaterial=MeshMatcapMaterial;exports.MeshNormalMaterial=MeshNormalMaterial;exports.MeshPhongMaterial=MeshPhongMaterial;exports.MeshPhysicalMaterial=MeshPhysicalMaterial;exports.MeshStandardMaterial=MeshStandardMaterial;exports.MeshToonMaterial=MeshToonMaterial;exports.MultiMaterial=MultiMaterial;exports.NumberKeyframeTrack=NumberKeyframeTrack;exports.Object3D=Object3D;exports.ObjectLoader=ObjectLoader;exports.OctahedronBufferGeometry=OctahedronBufferGeometry;exports.OctahedronGeometry=OctahedronGeometry;exports.OrthographicCamera=OrthographicCamera;exports.PMREMGenerator=PMREMGenerator;exports.ParametricBufferGeometry=ParametricBufferGeometry;exports.ParametricGeometry=ParametricGeometry;exports.Particle=Particle;exports.ParticleBasicMaterial=ParticleBasicMaterial;exports.ParticleSystem=ParticleSystem;exports.ParticleSystemMaterial=ParticleSystemMaterial;exports.Path=Path;exports.PerspectiveCamera=PerspectiveCamera;exports.Plane=Plane;exports.PlaneBufferGeometry=PlaneBufferGeometry;exports.PlaneGeometry=PlaneGeometry;exports.PlaneHelper=PlaneHelper;exports.PointCloud=PointCloud;exports.PointCloudMaterial=PointCloudMaterial;exports.PointLight=PointLight;exports.PointLightHelper=PointLightHelper;exports.Points=Points;exports.PointsMaterial=PointsMaterial;exports.PolarGridHelper=PolarGridHelper;exports.PolyhedronBufferGeometry=PolyhedronBufferGeometry;exports.PolyhedronGeometry=PolyhedronGeometry;exports.PositionalAudio=PositionalAudio;exports.PropertyBinding=PropertyBinding;exports.PropertyMixer=PropertyMixer;exports.QuadraticBezierCurve=QuadraticBezierCurve;exports.QuadraticBezierCurve3=QuadraticBezierCurve3;exports.Quaternion=Quaternion;exports.QuaternionKeyframeTrack=QuaternionKeyframeTrack;exports.QuaternionLinearInterpolant=QuaternionLinearInterpolant;exports.RawShaderMaterial=RawShaderMaterial;exports.Ray=Ray;exports.Raycaster=Raycaster;exports.RectAreaLight=RectAreaLight;exports.RingBufferGeometry=RingBufferGeometry;exports.RingGeometry=RingGeometry;exports.Scene=Scene;exports.ShaderMaterial=ShaderMaterial;exports.ShadowMaterial=ShadowMaterial;exports.Shape=Shape;exports.ShapeBufferGeometry=ShapeBufferGeometry;exports.ShapeGeometry=ShapeGeometry;exports.ShapePath=ShapePath;exports.Skeleton=Skeleton;exports.SkeletonHelper=SkeletonHelper;exports.SkinnedMesh=SkinnedMesh;exports.Sphere=Sphere;exports.SphereBufferGeometry=SphereBufferGeometry;exports.SphereGeometry=SphereGeometry;exports.Spherical=Spherical;exports.SphericalHarmonics3=SphericalHarmonics3;exports.Spline=Spline;exports.SplineCurve=SplineCurve;exports.SplineCurve3=SplineCurve3;exports.SpotLight=SpotLight;exports.SpotLightHelper=SpotLightHelper;exports.SpotLightShadow=SpotLightShadow;exports.Sprite=Sprite;exports.SpriteMaterial=SpriteMaterial;exports.StereoCamera=StereoCamera;exports.StringKeyframeTrack=StringKeyframeTrack;exports.TetrahedronBufferGeometry=TetrahedronBufferGeometry;exports.TetrahedronGeometry=TetrahedronGeometry;exports.TextBufferGeometry=TextBufferGeometry;exports.TextGeometry=TextGeometry;exports.Texture=Texture;exports.TextureLoader=TextureLoader;exports.TorusBufferGeometry=TorusBufferGeometry;exports.TorusGeometry=TorusGeometry;exports.TorusKnotBufferGeometry=TorusKnotBufferGeometry;exports.TorusKnotGeometry=TorusKnotGeometry;exports.Triangle=Triangle;exports.TubeBufferGeometry=TubeBufferGeometry;exports.TubeGeometry=TubeGeometry;exports.Uint16Attribute=Uint16Attribute;exports.Uint16BufferAttribute=Uint16BufferAttribute;exports.Uint32Attribute=Uint32Attribute;exports.Uint32BufferAttribute=Uint32BufferAttribute;exports.Uint8Attribute=Uint8Attribute;exports.Uint8BufferAttribute=Uint8BufferAttribute;exports.Uint8ClampedAttribute=Uint8ClampedAttribute;exports.Uint8ClampedBufferAttribute=Uint8ClampedBufferAttribute;exports.Uniform=Uniform;exports.Vector2=Vector2;exports.Vector3=Vector3;exports.Vector4=Vector4;exports.VectorKeyframeTrack=VectorKeyframeTrack;exports.Vertex=Vertex;exports.VideoTexture=VideoTexture;exports.WebGLCubeRenderTarget=WebGLCubeRenderTarget;exports.WebGLMultisampleRenderTarget=WebGLMultisampleRenderTarget;exports.WebGLRenderTarget=WebGLRenderTarget;exports.WebGLRenderTargetCube=WebGLRenderTargetCube;exports.WebGLRenderer=WebGLRenderer;exports.WebGLUtils=WebGLUtils;exports.WireframeGeometry=WireframeGeometry;exports.WireframeHelper=WireframeHelper;exports.XHRLoader=XHRLoader;exports.NeverDepth=exports.NearestMipmapNearestFilter=exports.NearestMipmapLinearFilter=exports.NearestMipMapNearestFilter=exports.NearestMipMapLinearFilter=exports.NearestFilter=exports.MultiplyOperation=exports.MultiplyBlending=exports.MixOperation=exports.MirroredRepeatWrapping=exports.MinEquation=exports.MaxEquation=exports.MathUtils=exports.Math=exports.MOUSE=exports.LuminanceFormat=exports.LuminanceAlphaFormat=exports.LoopRepeat=exports.LoopPingPong=exports.LoopOnce=exports.LogLuvEncoding=exports.LoaderUtils=exports.LinearToneMapping=exports.LinearMipmapNearestFilter=exports.LinearMipmapLinearFilter=exports.LinearMipMapNearestFilter=exports.LinearMipMapLinearFilter=exports.LinearFilter=exports.LinearEncoding=exports.LineStrip=exports.LinePieces=exports.LessStencilFunc=exports.LessEqualStencilFunc=exports.LessEqualDepth=exports.LessDepth=exports.KeepStencilOp=exports.InvertStencilOp=exports.InterpolateSmooth=exports.InterpolateLinear=exports.InterpolateDiscrete=exports.IntType=exports.IncrementWrapStencilOp=exports.IncrementStencilOp=exports.ImageUtils=exports.HalfFloatType=exports.GreaterStencilFunc=exports.GreaterEqualStencilFunc=exports.GreaterEqualDepth=exports.GreaterDepth=exports.GeometryUtils=exports.GammaEncoding=exports.FrontSide=exports.FrontFaceDirectionCW=exports.FrontFaceDirectionCCW=exports.FloatType=exports.FlatShading=exports.FaceColors=exports.EquirectangularRefractionMapping=exports.EquirectangularReflectionMapping=exports.EqualStencilFunc=exports.EqualDepth=exports.DynamicReadUsage=exports.DynamicDrawUsage=exports.DynamicCopyUsage=exports.DstColorFactor=exports.DstAlphaFactor=exports.DoubleSide=exports.DepthStencilFormat=exports.DepthFormat=exports.DefaultLoadingManager=exports.DecrementWrapStencilOp=exports.DecrementStencilOp=exports.CustomBlending=exports.CullFaceNone=exports.CullFaceFrontBack=exports.CullFaceFront=exports.CullFaceBack=exports.CubeUVRefractionMapping=exports.CubeUVReflectionMapping=exports.CubeRefractionMapping=exports.CubeReflectionMapping=exports.ClampToEdgeWrapping=exports.CineonToneMapping=exports.Cache=exports.ByteType=exports.CubeGeometry=exports.BoxGeometry=exports.BoxBufferGeometry=exports.BasicShadowMap=exports.BasicDepthPacking=exports.BackSide=exports.AudioContext=exports.AnimationUtils=exports.AlwaysStencilFunc=exports.AlwaysDepth=exports.AlphaFormat=exports.AdditiveBlending=exports.AddOperation=exports.AddEquation=exports.ACESFilmicToneMapping=void 0;exports.UniformsLib=exports.Uncharted2ToneMapping=exports.UVMapping=exports.TrianglesDrawMode=exports.TriangleStripDrawMode=exports.TriangleFanDrawMode=exports.TangentSpaceNormalMap=exports.TOUCH=exports.SubtractiveBlending=exports.SubtractEquation=exports.StreamReadUsage=exports.StreamDrawUsage=exports.StreamCopyUsage=exports.StaticReadUsage=exports.StaticDrawUsage=exports.StaticCopyUsage=exports.SrcColorFactor=exports.SrcAlphaSaturateFactor=exports.SrcAlphaFactor=exports.SphericalReflectionMapping=exports.SmoothShading=exports.ShortType=exports.ShapeUtils=exports.ShaderLib=exports.ShaderChunk=exports.SceneUtils=exports.SRGB8_ALPHA8_ASTC_8x8_Format=exports.SRGB8_ALPHA8_ASTC_8x6_Format=exports.SRGB8_ALPHA8_ASTC_8x5_Format=exports.SRGB8_ALPHA8_ASTC_6x6_Format=exports.SRGB8_ALPHA8_ASTC_6x5_Format=exports.SRGB8_ALPHA8_ASTC_5x5_Format=exports.SRGB8_ALPHA8_ASTC_5x4_Format=exports.SRGB8_ALPHA8_ASTC_4x4_Format=exports.SRGB8_ALPHA8_ASTC_12x12_Format=exports.SRGB8_ALPHA8_ASTC_12x10_Format=exports.SRGB8_ALPHA8_ASTC_10x8_Format=exports.SRGB8_ALPHA8_ASTC_10x6_Format=exports.SRGB8_ALPHA8_ASTC_10x5_Format=exports.SRGB8_ALPHA8_ASTC_10x10_Format=exports.ReverseSubtractEquation=exports.ReplaceStencilOp=exports.RepeatWrapping=exports.ReinhardToneMapping=exports.RedIntegerFormat=exports.RedFormat=exports.RGIntegerFormat=exports.RGFormat=exports.RGB_S3TC_DXT1_Format=exports.RGB_PVRTC_4BPPV1_Format=exports.RGB_PVRTC_2BPPV1_Format=exports.RGB_ETC2_Format=exports.RGB_ETC1_Format=exports.RGBM7Encoding=exports.RGBM16Encoding=exports.RGBIntegerFormat=exports.RGBFormat=exports.RGBEFormat=exports.RGBEEncoding=exports.RGBDEncoding=exports.RGBA_S3TC_DXT5_Format=exports.RGBA_S3TC_DXT3_Format=exports.RGBA_S3TC_DXT1_Format=exports.RGBA_PVRTC_4BPPV1_Format=exports.RGBA_PVRTC_2BPPV1_Format=exports.RGBA_ETC2_EAC_Format=exports.RGBA_BPTC_Format=exports.RGBA_ASTC_8x8_Format=exports.RGBA_ASTC_8x6_Format=exports.RGBA_ASTC_8x5_Format=exports.RGBA_ASTC_6x6_Format=exports.RGBA_ASTC_6x5_Format=exports.RGBA_ASTC_5x5_Format=exports.RGBA_ASTC_5x4_Format=exports.RGBA_ASTC_4x4_Format=exports.RGBA_ASTC_12x12_Format=exports.RGBA_ASTC_12x10_Format=exports.RGBA_ASTC_10x8_Format=exports.RGBA_ASTC_10x6_Format=exports.RGBA_ASTC_10x5_Format=exports.RGBA_ASTC_10x10_Format=exports.RGBAIntegerFormat=exports.RGBAFormat=exports.RGBADepthPacking=exports.REVISION=exports.PCFSoftShadowMap=exports.PCFShadowMap=exports.OneMinusSrcColorFactor=exports.OneMinusSrcAlphaFactor=exports.OneMinusDstColorFactor=exports.OneMinusDstAlphaFactor=exports.OneFactor=exports.ObjectSpaceNormalMap=exports.NotEqualStencilFunc=exports.NotEqualDepth=exports.NormalBlending=exports.NoToneMapping=exports.NoColors=exports.NoBlending=exports.NeverStencilFunc=void 0;exports.sRGBEncoding=exports.ZeroStencilOp=exports.ZeroSlopeEnding=exports.ZeroFactor=exports.ZeroCurvatureEnding=exports.WrapAroundEnding=exports.VertexColors=exports.VSMShadowMap=exports.UnsignedShortType=exports.UnsignedShort565Type=exports.UnsignedShort5551Type=exports.UnsignedShort4444Type=exports.UnsignedIntType=exports.UnsignedInt248Type=exports.UnsignedByteType=exports.UniformsUtils=void 0;__webpack_require__(259);__webpack_require__(261);var _from=_interopRequireDefault(__webpack_require__(166));__webpack_require__(174);__webpack_require__(98);__webpack_require__(62);var _freeze=_interopRequireDefault(__webpack_require__(276));var _typeof2=_interopRequireDefault(__webpack_require__(47));var _map=_interopRequireDefault(__webpack_require__(181));var _defineProperty2=_interopRequireDefault(__webpack_require__(186));__webpack_require__(48);__webpack_require__(13);var _weakMap=_interopRequireDefault(__webpack_require__(300));var _assertThisInitialized2=_interopRequireDefault(__webpack_require__(103));var _classCallCheck2=_interopRequireDefault(__webpack_require__(2));var _possibleConstructorReturn2=_interopRequireDefault(__webpack_require__(4));var _getPrototypeOf2=_interopRequireDefault(__webpack_require__(5));var _inherits2=_interopRequireDefault(__webpack_require__(6));__webpack_require__(53);var _keys=_interopRequireDefault(__webpack_require__(54));__webpack_require__(318);__webpack_require__(25);__webpack_require__(195);__webpack_require__(328);__webpack_require__(143);__webpack_require__(196);__webpack_require__(329);__webpack_require__(144);__webpack_require__(197);var _parseInt2=_interopRequireDefault(__webpack_require__(27));var _parseFloat2=_interopRequireDefault(__webpack_require__(16));__webpack_require__(336);var _stringify=_interopRequireDefault(__webpack_require__(104));__webpack_require__(55);var _isArray=_interopRequireDefault(__webpack_require__(35));var _create=_interopRequireDefault(__webpack_require__(31));__webpack_require__(146);__webpack_require__(8);var _defineProperties=_interopRequireDefault(__webpack_require__(106));__webpack_require__(343);var _assign=_interopRequireDefault(__webpack_require__(11));__webpack_require__(107);__webpack_require__(67);__webpack_require__(199);var _defineProperty3=_interopRequireDefault(__webpack_require__(0));__webpack_require__(349);__webpack_require__(351);var _isInteger=_interopRequireDefault(__webpack_require__(353));__webpack_require__(56);__webpack_require__(359);var _epsilon=_interopRequireDefault(__webpack_require__(360));var _ENCODINGS;// Polyfills
if(_epsilon.default===undefined){Number.EPSILON=Math.pow(2,-52);}if(_isInteger.default===undefined){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
Number.isInteger=function(value){return typeof value==='number'&&isFinite(value)&&Math.floor(value)===value;};}//
if(Math.sign===undefined){// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
Math.sign=function(x){return x<0?-1:x>0?1:+x;};}if('name'in Function.prototype===false){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
(0,_defineProperty3.default)(Function.prototype,'name',{get:function get(){return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];}});}if(_assign.default===undefined){// Missing in IE
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
Object.assign=function(target){if(target===undefined||target===null){throw new TypeError('Cannot convert undefined or null to object');}var output=Object(target);for(var index=1;index<arguments.length;index++){var source=arguments[index];if(source!==undefined&&source!==null){for(var nextKey in source){if(Object.prototype.hasOwnProperty.call(source,nextKey)){output[nextKey]=source[nextKey];}}}}return output;};}var REVISION='115';exports.REVISION=REVISION;var MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2};exports.MOUSE=MOUSE;var TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3};exports.TOUCH=TOUCH;var CullFaceNone=0;exports.CullFaceNone=CullFaceNone;var CullFaceBack=1;exports.CullFaceBack=CullFaceBack;var CullFaceFront=2;exports.CullFaceFront=CullFaceFront;var CullFaceFrontBack=3;exports.CullFaceFrontBack=CullFaceFrontBack;var FrontFaceDirectionCW=0;exports.FrontFaceDirectionCW=FrontFaceDirectionCW;var FrontFaceDirectionCCW=1;exports.FrontFaceDirectionCCW=FrontFaceDirectionCCW;var BasicShadowMap=0;exports.BasicShadowMap=BasicShadowMap;var PCFShadowMap=1;exports.PCFShadowMap=PCFShadowMap;var PCFSoftShadowMap=2;exports.PCFSoftShadowMap=PCFSoftShadowMap;var VSMShadowMap=3;exports.VSMShadowMap=VSMShadowMap;var FrontSide=0;exports.FrontSide=FrontSide;var BackSide=1;exports.BackSide=BackSide;var DoubleSide=2;exports.DoubleSide=DoubleSide;var FlatShading=1;exports.FlatShading=FlatShading;var SmoothShading=2;exports.SmoothShading=SmoothShading;var NoBlending=0;exports.NoBlending=NoBlending;var NormalBlending=1;exports.NormalBlending=NormalBlending;var AdditiveBlending=2;exports.AdditiveBlending=AdditiveBlending;var SubtractiveBlending=3;exports.SubtractiveBlending=SubtractiveBlending;var MultiplyBlending=4;exports.MultiplyBlending=MultiplyBlending;var CustomBlending=5;exports.CustomBlending=CustomBlending;var AddEquation=100;exports.AddEquation=AddEquation;var SubtractEquation=101;exports.SubtractEquation=SubtractEquation;var ReverseSubtractEquation=102;exports.ReverseSubtractEquation=ReverseSubtractEquation;var MinEquation=103;exports.MinEquation=MinEquation;var MaxEquation=104;exports.MaxEquation=MaxEquation;var ZeroFactor=200;exports.ZeroFactor=ZeroFactor;var OneFactor=201;exports.OneFactor=OneFactor;var SrcColorFactor=202;exports.SrcColorFactor=SrcColorFactor;var OneMinusSrcColorFactor=203;exports.OneMinusSrcColorFactor=OneMinusSrcColorFactor;var SrcAlphaFactor=204;exports.SrcAlphaFactor=SrcAlphaFactor;var OneMinusSrcAlphaFactor=205;exports.OneMinusSrcAlphaFactor=OneMinusSrcAlphaFactor;var DstAlphaFactor=206;exports.DstAlphaFactor=DstAlphaFactor;var OneMinusDstAlphaFactor=207;exports.OneMinusDstAlphaFactor=OneMinusDstAlphaFactor;var DstColorFactor=208;exports.DstColorFactor=DstColorFactor;var OneMinusDstColorFactor=209;exports.OneMinusDstColorFactor=OneMinusDstColorFactor;var SrcAlphaSaturateFactor=210;exports.SrcAlphaSaturateFactor=SrcAlphaSaturateFactor;var NeverDepth=0;exports.NeverDepth=NeverDepth;var AlwaysDepth=1;exports.AlwaysDepth=AlwaysDepth;var LessDepth=2;exports.LessDepth=LessDepth;var LessEqualDepth=3;exports.LessEqualDepth=LessEqualDepth;var EqualDepth=4;exports.EqualDepth=EqualDepth;var GreaterEqualDepth=5;exports.GreaterEqualDepth=GreaterEqualDepth;var GreaterDepth=6;exports.GreaterDepth=GreaterDepth;var NotEqualDepth=7;exports.NotEqualDepth=NotEqualDepth;var MultiplyOperation=0;exports.MultiplyOperation=MultiplyOperation;var MixOperation=1;exports.MixOperation=MixOperation;var AddOperation=2;exports.AddOperation=AddOperation;var NoToneMapping=0;exports.NoToneMapping=NoToneMapping;var LinearToneMapping=1;exports.LinearToneMapping=LinearToneMapping;var ReinhardToneMapping=2;exports.ReinhardToneMapping=ReinhardToneMapping;var Uncharted2ToneMapping=3;exports.Uncharted2ToneMapping=Uncharted2ToneMapping;var CineonToneMapping=4;exports.CineonToneMapping=CineonToneMapping;var ACESFilmicToneMapping=5;exports.ACESFilmicToneMapping=ACESFilmicToneMapping;var UVMapping=300;exports.UVMapping=UVMapping;var CubeReflectionMapping=301;exports.CubeReflectionMapping=CubeReflectionMapping;var CubeRefractionMapping=302;exports.CubeRefractionMapping=CubeRefractionMapping;var EquirectangularReflectionMapping=303;exports.EquirectangularReflectionMapping=EquirectangularReflectionMapping;var EquirectangularRefractionMapping=304;exports.EquirectangularRefractionMapping=EquirectangularRefractionMapping;var SphericalReflectionMapping=305;exports.SphericalReflectionMapping=SphericalReflectionMapping;var CubeUVReflectionMapping=306;exports.CubeUVReflectionMapping=CubeUVReflectionMapping;var CubeUVRefractionMapping=307;exports.CubeUVRefractionMapping=CubeUVRefractionMapping;var RepeatWrapping=1000;exports.RepeatWrapping=RepeatWrapping;var ClampToEdgeWrapping=1001;exports.ClampToEdgeWrapping=ClampToEdgeWrapping;var MirroredRepeatWrapping=1002;exports.MirroredRepeatWrapping=MirroredRepeatWrapping;var NearestFilter=1003;exports.NearestFilter=NearestFilter;var NearestMipmapNearestFilter=1004;exports.NearestMipmapNearestFilter=NearestMipmapNearestFilter;var NearestMipMapNearestFilter=1004;exports.NearestMipMapNearestFilter=NearestMipMapNearestFilter;var NearestMipmapLinearFilter=1005;exports.NearestMipmapLinearFilter=NearestMipmapLinearFilter;var NearestMipMapLinearFilter=1005;exports.NearestMipMapLinearFilter=NearestMipMapLinearFilter;var LinearFilter=1006;exports.LinearFilter=LinearFilter;var LinearMipmapNearestFilter=1007;exports.LinearMipmapNearestFilter=LinearMipmapNearestFilter;var LinearMipMapNearestFilter=1007;exports.LinearMipMapNearestFilter=LinearMipMapNearestFilter;var LinearMipmapLinearFilter=1008;exports.LinearMipmapLinearFilter=LinearMipmapLinearFilter;var LinearMipMapLinearFilter=1008;exports.LinearMipMapLinearFilter=LinearMipMapLinearFilter;var UnsignedByteType=1009;exports.UnsignedByteType=UnsignedByteType;var ByteType=1010;exports.ByteType=ByteType;var ShortType=1011;exports.ShortType=ShortType;var UnsignedShortType=1012;exports.UnsignedShortType=UnsignedShortType;var IntType=1013;exports.IntType=IntType;var UnsignedIntType=1014;exports.UnsignedIntType=UnsignedIntType;var FloatType=1015;exports.FloatType=FloatType;var HalfFloatType=1016;exports.HalfFloatType=HalfFloatType;var UnsignedShort4444Type=1017;exports.UnsignedShort4444Type=UnsignedShort4444Type;var UnsignedShort5551Type=1018;exports.UnsignedShort5551Type=UnsignedShort5551Type;var UnsignedShort565Type=1019;exports.UnsignedShort565Type=UnsignedShort565Type;var UnsignedInt248Type=1020;exports.UnsignedInt248Type=UnsignedInt248Type;var AlphaFormat=1021;exports.AlphaFormat=AlphaFormat;var RGBFormat=1022;exports.RGBFormat=RGBFormat;var RGBAFormat=1023;exports.RGBAFormat=RGBAFormat;var LuminanceFormat=1024;exports.LuminanceFormat=LuminanceFormat;var LuminanceAlphaFormat=1025;exports.LuminanceAlphaFormat=LuminanceAlphaFormat;var RGBEFormat=RGBAFormat;exports.RGBEFormat=RGBEFormat;var DepthFormat=1026;exports.DepthFormat=DepthFormat;var DepthStencilFormat=1027;exports.DepthStencilFormat=DepthStencilFormat;var RedFormat=1028;exports.RedFormat=RedFormat;var RedIntegerFormat=1029;exports.RedIntegerFormat=RedIntegerFormat;var RGFormat=1030;exports.RGFormat=RGFormat;var RGIntegerFormat=1031;exports.RGIntegerFormat=RGIntegerFormat;var RGBIntegerFormat=1032;exports.RGBIntegerFormat=RGBIntegerFormat;var RGBAIntegerFormat=1033;exports.RGBAIntegerFormat=RGBAIntegerFormat;var RGB_S3TC_DXT1_Format=33776;exports.RGB_S3TC_DXT1_Format=RGB_S3TC_DXT1_Format;var RGBA_S3TC_DXT1_Format=33777;exports.RGBA_S3TC_DXT1_Format=RGBA_S3TC_DXT1_Format;var RGBA_S3TC_DXT3_Format=33778;exports.RGBA_S3TC_DXT3_Format=RGBA_S3TC_DXT3_Format;var RGBA_S3TC_DXT5_Format=33779;exports.RGBA_S3TC_DXT5_Format=RGBA_S3TC_DXT5_Format;var RGB_PVRTC_4BPPV1_Format=35840;exports.RGB_PVRTC_4BPPV1_Format=RGB_PVRTC_4BPPV1_Format;var RGB_PVRTC_2BPPV1_Format=35841;exports.RGB_PVRTC_2BPPV1_Format=RGB_PVRTC_2BPPV1_Format;var RGBA_PVRTC_4BPPV1_Format=35842;exports.RGBA_PVRTC_4BPPV1_Format=RGBA_PVRTC_4BPPV1_Format;var RGBA_PVRTC_2BPPV1_Format=35843;exports.RGBA_PVRTC_2BPPV1_Format=RGBA_PVRTC_2BPPV1_Format;var RGB_ETC1_Format=36196;exports.RGB_ETC1_Format=RGB_ETC1_Format;var RGB_ETC2_Format=37492;exports.RGB_ETC2_Format=RGB_ETC2_Format;var RGBA_ETC2_EAC_Format=37496;exports.RGBA_ETC2_EAC_Format=RGBA_ETC2_EAC_Format;var RGBA_ASTC_4x4_Format=37808;exports.RGBA_ASTC_4x4_Format=RGBA_ASTC_4x4_Format;var RGBA_ASTC_5x4_Format=37809;exports.RGBA_ASTC_5x4_Format=RGBA_ASTC_5x4_Format;var RGBA_ASTC_5x5_Format=37810;exports.RGBA_ASTC_5x5_Format=RGBA_ASTC_5x5_Format;var RGBA_ASTC_6x5_Format=37811;exports.RGBA_ASTC_6x5_Format=RGBA_ASTC_6x5_Format;var RGBA_ASTC_6x6_Format=37812;exports.RGBA_ASTC_6x6_Format=RGBA_ASTC_6x6_Format;var RGBA_ASTC_8x5_Format=37813;exports.RGBA_ASTC_8x5_Format=RGBA_ASTC_8x5_Format;var RGBA_ASTC_8x6_Format=37814;exports.RGBA_ASTC_8x6_Format=RGBA_ASTC_8x6_Format;var RGBA_ASTC_8x8_Format=37815;exports.RGBA_ASTC_8x8_Format=RGBA_ASTC_8x8_Format;var RGBA_ASTC_10x5_Format=37816;exports.RGBA_ASTC_10x5_Format=RGBA_ASTC_10x5_Format;var RGBA_ASTC_10x6_Format=37817;exports.RGBA_ASTC_10x6_Format=RGBA_ASTC_10x6_Format;var RGBA_ASTC_10x8_Format=37818;exports.RGBA_ASTC_10x8_Format=RGBA_ASTC_10x8_Format;var RGBA_ASTC_10x10_Format=37819;exports.RGBA_ASTC_10x10_Format=RGBA_ASTC_10x10_Format;var RGBA_ASTC_12x10_Format=37820;exports.RGBA_ASTC_12x10_Format=RGBA_ASTC_12x10_Format;var RGBA_ASTC_12x12_Format=37821;exports.RGBA_ASTC_12x12_Format=RGBA_ASTC_12x12_Format;var RGBA_BPTC_Format=36492;exports.RGBA_BPTC_Format=RGBA_BPTC_Format;var SRGB8_ALPHA8_ASTC_4x4_Format=37840;exports.SRGB8_ALPHA8_ASTC_4x4_Format=SRGB8_ALPHA8_ASTC_4x4_Format;var SRGB8_ALPHA8_ASTC_5x4_Format=37841;exports.SRGB8_ALPHA8_ASTC_5x4_Format=SRGB8_ALPHA8_ASTC_5x4_Format;var SRGB8_ALPHA8_ASTC_5x5_Format=37842;exports.SRGB8_ALPHA8_ASTC_5x5_Format=SRGB8_ALPHA8_ASTC_5x5_Format;var SRGB8_ALPHA8_ASTC_6x5_Format=37843;exports.SRGB8_ALPHA8_ASTC_6x5_Format=SRGB8_ALPHA8_ASTC_6x5_Format;var SRGB8_ALPHA8_ASTC_6x6_Format=37844;exports.SRGB8_ALPHA8_ASTC_6x6_Format=SRGB8_ALPHA8_ASTC_6x6_Format;var SRGB8_ALPHA8_ASTC_8x5_Format=37845;exports.SRGB8_ALPHA8_ASTC_8x5_Format=SRGB8_ALPHA8_ASTC_8x5_Format;var SRGB8_ALPHA8_ASTC_8x6_Format=37846;exports.SRGB8_ALPHA8_ASTC_8x6_Format=SRGB8_ALPHA8_ASTC_8x6_Format;var SRGB8_ALPHA8_ASTC_8x8_Format=37847;exports.SRGB8_ALPHA8_ASTC_8x8_Format=SRGB8_ALPHA8_ASTC_8x8_Format;var SRGB8_ALPHA8_ASTC_10x5_Format=37848;exports.SRGB8_ALPHA8_ASTC_10x5_Format=SRGB8_ALPHA8_ASTC_10x5_Format;var SRGB8_ALPHA8_ASTC_10x6_Format=37849;exports.SRGB8_ALPHA8_ASTC_10x6_Format=SRGB8_ALPHA8_ASTC_10x6_Format;var SRGB8_ALPHA8_ASTC_10x8_Format=37850;exports.SRGB8_ALPHA8_ASTC_10x8_Format=SRGB8_ALPHA8_ASTC_10x8_Format;var SRGB8_ALPHA8_ASTC_10x10_Format=37851;exports.SRGB8_ALPHA8_ASTC_10x10_Format=SRGB8_ALPHA8_ASTC_10x10_Format;var SRGB8_ALPHA8_ASTC_12x10_Format=37852;exports.SRGB8_ALPHA8_ASTC_12x10_Format=SRGB8_ALPHA8_ASTC_12x10_Format;var SRGB8_ALPHA8_ASTC_12x12_Format=37853;exports.SRGB8_ALPHA8_ASTC_12x12_Format=SRGB8_ALPHA8_ASTC_12x12_Format;var LoopOnce=2200;exports.LoopOnce=LoopOnce;var LoopRepeat=2201;exports.LoopRepeat=LoopRepeat;var LoopPingPong=2202;exports.LoopPingPong=LoopPingPong;var InterpolateDiscrete=2300;exports.InterpolateDiscrete=InterpolateDiscrete;var InterpolateLinear=2301;exports.InterpolateLinear=InterpolateLinear;var InterpolateSmooth=2302;exports.InterpolateSmooth=InterpolateSmooth;var ZeroCurvatureEnding=2400;exports.ZeroCurvatureEnding=ZeroCurvatureEnding;var ZeroSlopeEnding=2401;exports.ZeroSlopeEnding=ZeroSlopeEnding;var WrapAroundEnding=2402;exports.WrapAroundEnding=WrapAroundEnding;var TrianglesDrawMode=0;exports.TrianglesDrawMode=TrianglesDrawMode;var TriangleStripDrawMode=1;exports.TriangleStripDrawMode=TriangleStripDrawMode;var TriangleFanDrawMode=2;exports.TriangleFanDrawMode=TriangleFanDrawMode;var LinearEncoding=3000;exports.LinearEncoding=LinearEncoding;var sRGBEncoding=3001;exports.sRGBEncoding=sRGBEncoding;var GammaEncoding=3007;exports.GammaEncoding=GammaEncoding;var RGBEEncoding=3002;exports.RGBEEncoding=RGBEEncoding;var LogLuvEncoding=3003;exports.LogLuvEncoding=LogLuvEncoding;var RGBM7Encoding=3004;exports.RGBM7Encoding=RGBM7Encoding;var RGBM16Encoding=3005;exports.RGBM16Encoding=RGBM16Encoding;var RGBDEncoding=3006;exports.RGBDEncoding=RGBDEncoding;var BasicDepthPacking=3200;exports.BasicDepthPacking=BasicDepthPacking;var RGBADepthPacking=3201;exports.RGBADepthPacking=RGBADepthPacking;var TangentSpaceNormalMap=0;exports.TangentSpaceNormalMap=TangentSpaceNormalMap;var ObjectSpaceNormalMap=1;exports.ObjectSpaceNormalMap=ObjectSpaceNormalMap;var ZeroStencilOp=0;exports.ZeroStencilOp=ZeroStencilOp;var KeepStencilOp=7680;exports.KeepStencilOp=KeepStencilOp;var ReplaceStencilOp=7681;exports.ReplaceStencilOp=ReplaceStencilOp;var IncrementStencilOp=7682;exports.IncrementStencilOp=IncrementStencilOp;var DecrementStencilOp=7683;exports.DecrementStencilOp=DecrementStencilOp;var IncrementWrapStencilOp=34055;exports.IncrementWrapStencilOp=IncrementWrapStencilOp;var DecrementWrapStencilOp=34056;exports.DecrementWrapStencilOp=DecrementWrapStencilOp;var InvertStencilOp=5386;exports.InvertStencilOp=InvertStencilOp;var NeverStencilFunc=512;exports.NeverStencilFunc=NeverStencilFunc;var LessStencilFunc=513;exports.LessStencilFunc=LessStencilFunc;var EqualStencilFunc=514;exports.EqualStencilFunc=EqualStencilFunc;var LessEqualStencilFunc=515;exports.LessEqualStencilFunc=LessEqualStencilFunc;var GreaterStencilFunc=516;exports.GreaterStencilFunc=GreaterStencilFunc;var NotEqualStencilFunc=517;exports.NotEqualStencilFunc=NotEqualStencilFunc;var GreaterEqualStencilFunc=518;exports.GreaterEqualStencilFunc=GreaterEqualStencilFunc;var AlwaysStencilFunc=519;exports.AlwaysStencilFunc=AlwaysStencilFunc;var StaticDrawUsage=35044;exports.StaticDrawUsage=StaticDrawUsage;var DynamicDrawUsage=35048;exports.DynamicDrawUsage=DynamicDrawUsage;var StreamDrawUsage=35040;exports.StreamDrawUsage=StreamDrawUsage;var StaticReadUsage=35045;exports.StaticReadUsage=StaticReadUsage;var DynamicReadUsage=35049;exports.DynamicReadUsage=DynamicReadUsage;var StreamReadUsage=35041;exports.StreamReadUsage=StreamReadUsage;var StaticCopyUsage=35046;exports.StaticCopyUsage=StaticCopyUsage;var DynamicCopyUsage=35050;exports.DynamicCopyUsage=DynamicCopyUsage;var StreamCopyUsage=35042;/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */exports.StreamCopyUsage=StreamCopyUsage;function EventDispatcher(){}(0,_assign.default)(EventDispatcher.prototype,{addEventListener:function addEventListener(type,listener){if(this._listeners===undefined)this._listeners={};var listeners=this._listeners;if(listeners[type]===undefined){listeners[type]=[];}if(listeners[type].indexOf(listener)===-1){listeners[type].push(listener);}},hasEventListener:function hasEventListener(type,listener){if(this._listeners===undefined)return false;var listeners=this._listeners;return listeners[type]!==undefined&&listeners[type].indexOf(listener)!==-1;},removeEventListener:function removeEventListener(type,listener){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[type];if(listenerArray!==undefined){var index=listenerArray.indexOf(listener);if(index!==-1){listenerArray.splice(index,1);}}},dispatchEvent:function dispatchEvent(event){if(this._listeners===undefined)return;var listeners=this._listeners;var listenerArray=listeners[event.type];if(listenerArray!==undefined){event.target=this;// Make a copy, in case listeners are removed while iterating.
var array=listenerArray.slice(0);for(var i=0,l=array.length;i<l;i++){array[i].call(this,event);}}}});/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author thezwap
 */var _lut=[];for(var i=0;i<256;i++){_lut[i]=(i<16?'0':'')+i.toString(16);}var MathUtils={DEG2RAD:Math.PI/180,RAD2DEG:180/Math.PI,generateUUID:function generateUUID(){// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
var d0=Math.random()*0xffffffff|0;var d1=Math.random()*0xffffffff|0;var d2=Math.random()*0xffffffff|0;var d3=Math.random()*0xffffffff|0;var uuid=_lut[d0&0xff]+_lut[d0>>8&0xff]+_lut[d0>>16&0xff]+_lut[d0>>24&0xff]+'-'+_lut[d1&0xff]+_lut[d1>>8&0xff]+'-'+_lut[d1>>16&0x0f|0x40]+_lut[d1>>24&0xff]+'-'+_lut[d2&0x3f|0x80]+_lut[d2>>8&0xff]+'-'+_lut[d2>>16&0xff]+_lut[d2>>24&0xff]+_lut[d3&0xff]+_lut[d3>>8&0xff]+_lut[d3>>16&0xff]+_lut[d3>>24&0xff];// .toUpperCase() here flattens concatenated strings to save heap memory space.
return uuid.toUpperCase();},clamp:function clamp(value,min,max){return Math.max(min,Math.min(max,value));},// compute euclidian modulo of m % n
// https://en.wikipedia.org/wiki/Modulo_operation
euclideanModulo:function euclideanModulo(n,m){return(n%m+m)%m;},// Linear mapping from range <a1, a2> to range <b1, b2>
mapLinear:function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1);},// https://en.wikipedia.org/wiki/Linear_interpolation
lerp:function lerp(x,y,t){return(1-t)*x+t*y;},// http://en.wikipedia.org/wiki/Smoothstep
smoothstep:function smoothstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x);},smootherstep:function smootherstep(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(x*6-15)+10);},// Random integer from <low, high> interval
randInt:function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1));},// Random float from <low, high> interval
randFloat:function randFloat(low,high){return low+Math.random()*(high-low);},// Random float from <-range/2, range/2> interval
randFloatSpread:function randFloatSpread(range){return range*(0.5-Math.random());},degToRad:function degToRad(degrees){return degrees*MathUtils.DEG2RAD;},radToDeg:function radToDeg(radians){return radians*MathUtils.RAD2DEG;},isPowerOfTwo:function isPowerOfTwo(value){return(value&value-1)===0&&value!==0;},ceilPowerOfTwo:function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2));},floorPowerOfTwo:function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2));},setQuaternionFromProperEuler:function setQuaternionFromProperEuler(q,a,b,c,order){// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles
// rotations are applied to the axes in the order specified by 'order'
// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
// angles are in radians
var cos=Math.cos;var sin=Math.sin;var c2=cos(b/2);var s2=sin(b/2);var c13=cos((a+c)/2);var s13=sin((a+c)/2);var c1_3=cos((a-c)/2);var s1_3=sin((a-c)/2);var c3_1=cos((c-a)/2);var s3_1=sin((c-a)/2);if(order==='XYX'){q.set(c2*s13,s2*c1_3,s2*s1_3,c2*c13);}else if(order==='YZY'){q.set(s2*s1_3,c2*s13,s2*c1_3,c2*c13);}else if(order==='ZXZ'){q.set(s2*c1_3,s2*s1_3,c2*s13,c2*c13);}else if(order==='XZX'){q.set(c2*s13,s2*s3_1,s2*c3_1,c2*c13);}else if(order==='YXY'){q.set(s2*c3_1,c2*s13,s2*s3_1,c2*c13);}else if(order==='ZYZ'){q.set(s2*s3_1,s2*c3_1,c2*s13,c2*c13);}else{console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.');}}};/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */exports.MathUtils=exports.Math=MathUtils;function Vector2(x,y){this.x=x||0;this.y=y||0;}(0,_defineProperties.default)(Vector2.prototype,{"width":{get:function get(){return this.x;},set:function set(value){this.x=value;}},"height":{get:function get(){return this.y;},set:function set(value){this.y=value;}}});(0,_assign.default)(Vector2.prototype,{isVector2:true,set:function set(x,y){this.x=x;this.y=y;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y);},copy:function copy(v){this.x=v.x;this.y=v.y;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this;},multiply:function multiply(v){this.x*=v.x;this.y*=v.y;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this;},divide:function divide(v){this.x/=v.x;this.y/=v.y;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},applyMatrix3:function applyMatrix3(m){var x=this.x,y=this.y;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6];this.y=e[1]*x+e[4]*y+e[7];return this;},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this;},clamp:function clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this;},clampScalar:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));return this;},clampLength:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y;},cross:function cross(v){return this.x*v.y-this.y*v.x;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y);},manhattanLength:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y);},normalize:function normalize(){return this.divideScalar(this.length()||1);},angle:function angle(){// computes the angle in radians with respect to the positive x-axis
var angle=Math.atan2(-this.y,-this.x)+Math.PI;return angle;},distanceTo:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy;},manhattanDistanceTo:function manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y);},setLength:function setLength(length){return this.normalize().multiplyScalar(length);},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function equals(v){return v.x===this.x&&v.y===this.y;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector2: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);return this;},rotateAround:function rotateAround(center,angle){var c=Math.cos(angle),s=Math.sin(angle);var x=this.x-center.x;var y=this.y-center.y;this.x=x*c-y*s+center.x;this.y=x*s+y*c+center.y;return this;}});/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */function Matrix3(){this.elements=[1,0,0,0,1,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.');}}(0,_assign.default)(Matrix3.prototype,{isMatrix3:true,set:function set(n11,n12,n13,n21,n22,n23,n31,n32,n33){var te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this;},identity:function identity(){this.set(1,0,0,0,1,0,0,0,1);return this;},clone:function clone(){return new this.constructor().fromArray(this.elements);},copy:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];return this;},extractBasis:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrix3Column(this,0);yAxis.setFromMatrix3Column(this,1);zAxis.setFromMatrix3Column(this,2);return this;},setFromMatrix4:function setFromMatrix4(m){var me=m.elements;this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]);return this;},multiply:function multiply(m){return this.multiplyMatrices(this,m);},premultiply:function premultiply(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[3],a13=ae[6];var a21=ae[1],a22=ae[4],a23=ae[7];var a31=ae[2],a32=ae[5],a33=ae[8];var b11=be[0],b12=be[3],b13=be[6];var b21=be[1],b22=be[4],b23=be[7];var b31=be[2],b32=be[5],b33=be[8];te[0]=a11*b11+a12*b21+a13*b31;te[3]=a11*b12+a12*b22+a13*b32;te[6]=a11*b13+a12*b23+a13*b33;te[1]=a21*b11+a22*b21+a23*b31;te[4]=a21*b12+a22*b22+a23*b32;te[7]=a21*b13+a22*b23+a23*b33;te[2]=a31*b11+a32*b21+a33*b31;te[5]=a31*b12+a32*b22+a33*b32;te[8]=a31*b13+a32*b23+a33*b33;return this;},multiplyScalar:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this;},determinant:function determinant(){var te=this.elements;var a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g;},getInverse:function getInverse(matrix,throwOnDegenerate){if(throwOnDegenerate!==undefined){console.warn("THREE.Matrix3: .getInverse() can no longer be configured to throw on degenerate.");}var me=matrix.elements,te=this.elements,n11=me[0],n21=me[1],n31=me[2],n12=me[3],n22=me[4],n32=me[5],n13=me[6],n23=me[7],n33=me[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(det===0)return this.set(0,0,0,0,0,0,0,0,0);var detInv=1/det;te[0]=t11*detInv;te[1]=(n31*n23-n33*n21)*detInv;te[2]=(n32*n21-n31*n22)*detInv;te[3]=t12*detInv;te[4]=(n33*n11-n31*n13)*detInv;te[5]=(n31*n12-n32*n11)*detInv;te[6]=t13*detInv;te[7]=(n21*n13-n23*n11)*detInv;te[8]=(n22*n11-n21*n12)*detInv;return this;},transpose:function transpose(){var tmp,m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this;},getNormalMatrix:function getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).getInverse(this).transpose();},transposeIntoArray:function transposeIntoArray(r){var m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this;},setUvTransform:function setUvTransform(tx,ty,sx,sy,rotation,cx,cy){var c=Math.cos(rotation);var s=Math.sin(rotation);this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1);},scale:function scale(sx,sy){var te=this.elements;te[0]*=sx;te[3]*=sx;te[6]*=sx;te[1]*=sy;te[4]*=sy;te[7]*=sy;return this;},rotate:function rotate(theta){var c=Math.cos(theta);var s=Math.sin(theta);var te=this.elements;var a11=te[0],a12=te[3],a13=te[6];var a21=te[1],a22=te[4],a23=te[7];te[0]=c*a11+s*a21;te[3]=c*a12+s*a22;te[6]=c*a13+s*a23;te[1]=-s*a11+c*a21;te[4]=-s*a12+c*a22;te[7]=-s*a13+c*a23;return this;},translate:function translate(tx,ty){var te=this.elements;te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];return this;},equals:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<9;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;for(var i=0;i<9;i++){this.elements[i]=array[i+offset];}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */var _canvas;var ImageUtils={getDataURL:function getDataURL(image){var canvas;if(typeof HTMLCanvasElement=='undefined'){return image.src;}else if(image instanceof HTMLCanvasElement){canvas=image;}else{if(_canvas===undefined)_canvas=document.createElementNS('http://www.w3.org/1999/xhtml','canvas');_canvas.width=image.width;_canvas.height=image.height;var context=_canvas.getContext('2d');if(image instanceof ImageData){context.putImageData(image,0,0);}else{context.drawImage(image,0,0,image.width,image.height);}canvas=_canvas;}if(canvas.width>2048||canvas.height>2048){return canvas.toDataURL('image/jpeg',0.6);}else{return canvas.toDataURL('image/png');}}};/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */exports.ImageUtils=ImageUtils;var textureId=0;function Texture(image,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){(0,_defineProperty3.default)(this,'id',{value:textureId++});this.uuid=MathUtils.generateUUID();this.name='';this.image=image!==undefined?image:Texture.DEFAULT_IMAGE;this.mipmaps=[];this.mapping=mapping!==undefined?mapping:Texture.DEFAULT_MAPPING;this.wrapS=wrapS!==undefined?wrapS:ClampToEdgeWrapping;this.wrapT=wrapT!==undefined?wrapT:ClampToEdgeWrapping;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.minFilter=minFilter!==undefined?minFilter:LinearMipmapLinearFilter;this.anisotropy=anisotropy!==undefined?anisotropy:1;this.format=format!==undefined?format:RGBAFormat;this.internalFormat=null;this.type=type!==undefined?type:UnsignedByteType;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.center=new Vector2(0,0);this.rotation=0;this.matrixAutoUpdate=true;this.matrix=new Matrix3();this.generateMipmaps=true;this.premultiplyAlpha=false;this.flipY=true;this.unpackAlignment=4;// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
//
// Also changing the encoding after already used by a Material will not automatically make the Material
// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
this.encoding=encoding!==undefined?encoding:LinearEncoding;this.version=0;this.onUpdate=null;}Texture.DEFAULT_IMAGE=undefined;Texture.DEFAULT_MAPPING=UVMapping;Texture.prototype=(0,_assign.default)((0,_create.default)(EventDispatcher.prototype),{constructor:Texture,isTexture:true,updateMatrix:function updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y);},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.name=source.name;this.image=source.image;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.internalFormat=source.internalFormat;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;return this;},toJSON:function toJSON(meta){var isRootObject=meta===undefined||typeof meta==='string';if(!isRootObject&&meta.textures[this.uuid]!==undefined){return meta.textures[this.uuid];}var output={metadata:{version:4.5,type:'Texture',generator:'Texture.toJSON'},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==undefined){// TODO: Move to THREE.Image
var image=this.image;if(image.uuid===undefined){image.uuid=MathUtils.generateUUID();// UGH
}if(!isRootObject&&meta.images[image.uuid]===undefined){var url;if((0,_isArray.default)(image)){// process array of images e.g. CubeTexture
url=[];for(var i=0,l=image.length;i<l;i++){url.push(ImageUtils.getDataURL(image[i]));}}else{// process single image
url=ImageUtils.getDataURL(image);}meta.images[image.uuid]={uuid:image.uuid,url:url};}output.image=image.uuid;}if(!isRootObject){meta.textures[this.uuid]=output;}return output;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});},transformUv:function transformUv(uv){if(this.mapping!==UVMapping)return uv;uv.applyMatrix3(this.matrix);if(uv.x<0||uv.x>1){switch(this.wrapS){case RepeatWrapping:uv.x=uv.x-Math.floor(uv.x);break;case ClampToEdgeWrapping:uv.x=uv.x<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.x)%2)===1){uv.x=Math.ceil(uv.x)-uv.x;}else{uv.x=uv.x-Math.floor(uv.x);}break;}}if(uv.y<0||uv.y>1){switch(this.wrapT){case RepeatWrapping:uv.y=uv.y-Math.floor(uv.y);break;case ClampToEdgeWrapping:uv.y=uv.y<0?0:1;break;case MirroredRepeatWrapping:if(Math.abs(Math.floor(uv.y)%2)===1){uv.y=Math.ceil(uv.y)-uv.y;}else{uv.y=uv.y-Math.floor(uv.y);}break;}}if(this.flipY){uv.y=1-uv.y;}return uv;}});(0,_defineProperty3.default)(Texture.prototype,"needsUpdate",{set:function set(value){if(value===true)this.version++;}});/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */function Vector4(x,y,z,w){this.x=x||0;this.y=y||0;this.z=z||0;this.w=w!==undefined?w:1;}(0,_defineProperties.default)(Vector4.prototype,{"width":{get:function get(){return this.z;},set:function set(value){this.z=value;}},"height":{get:function get(){return this.w;},set:function set(value){this.w=value;}}});(0,_assign.default)(Vector4.prototype,{isVector4:true,set:function set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;this.w=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setZ:function setZ(z){this.z=z;return this;},setW:function setW(w){this.w=w;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y,this.z,this.w);},copy:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=v.w!==undefined?v.w:1;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this;},applyMatrix4:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z,w=this.w;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w;this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w;this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w;this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},setAxisAngleFromQuaternion:function setAxisAngleFromQuaternion(q){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
// q is assumed to be normalized
this.w=2*Math.acos(q.w);var s=Math.sqrt(1-q.w*q.w);if(s<0.0001){this.x=1;this.y=0;this.z=0;}else{this.x=q.x/s;this.y=q.y/s;this.z=q.z/s;}return this;},setAxisAngleFromRotationMatrix:function setAxisAngleFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var angle,x,y,z,// variables for result
epsilon=0.01,// margin to allow for rounding errors
epsilon2=0.1,// margin to distinguish between 0 and 180 degrees
te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<epsilon&&Math.abs(m13-m31)<epsilon&&Math.abs(m23-m32)<epsilon){// singularity found
// first check for identity matrix which must have +1 for all terms
// in leading diagonal and zero in other terms
if(Math.abs(m12+m21)<epsilon2&&Math.abs(m13+m31)<epsilon2&&Math.abs(m23+m32)<epsilon2&&Math.abs(m11+m22+m33-3)<epsilon2){// this singularity is identity matrix so angle = 0
this.set(1,0,0,0);return this;// zero angle, arbitrary axis
}// otherwise this singularity is angle = 180
angle=Math.PI;var xx=(m11+1)/2;var yy=(m22+1)/2;var zz=(m33+1)/2;var xy=(m12+m21)/4;var xz=(m13+m31)/4;var yz=(m23+m32)/4;if(xx>yy&&xx>zz){// m11 is the largest diagonal term
if(xx<epsilon){x=0;y=0.707106781;z=0.707106781;}else{x=Math.sqrt(xx);y=xy/x;z=xz/x;}}else if(yy>zz){// m22 is the largest diagonal term
if(yy<epsilon){x=0.707106781;y=0;z=0.707106781;}else{y=Math.sqrt(yy);x=xy/y;z=yz/y;}}else{// m33 is the largest diagonal term so base result on this
if(zz<epsilon){x=0.707106781;y=0.707106781;z=0;}else{z=Math.sqrt(zz);x=xz/z;y=yz/z;}}this.set(x,y,z,angle);return this;// return 180 deg rotation
}// as we have reached here there are no singularities so we can handle normally
var s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));// used to normalize
if(Math.abs(s)<0.001)s=1;// prevent divide by zero, should not happen if matrix is orthogonal and should be
// caught by singularity test above, but I've left it in just in case
this.x=(m32-m23)/s;this.y=(m13-m31)/s;this.z=(m21-m12)/s;this.w=Math.acos((m11+m22+m33-1)/2);return this;},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,v.w);return this;},clamp:function clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this;},clampScalar:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));this.w=Math.max(minVal,Math.min(maxVal,this.w));return this;},clampLength:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w;},lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);},manhattanLength:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w);},normalize:function normalize(){return this.divideScalar(this.length()||1);},setLength:function setLength(length){return this.normalize().multiplyScalar(length);},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},equals:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector4: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this;}});/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */ /*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/function WebGLRenderTarget(width,height,options){this.width=width;this.height=height;this.scissor=new Vector4(0,0,width,height);this.scissorTest=false;this.viewport=new Vector4(0,0,width,height);options=options||{};this.texture=new Texture(undefined,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.texture.image={};this.texture.image.width=width;this.texture.image.height=height;this.texture.generateMipmaps=options.generateMipmaps!==undefined?options.generateMipmaps:false;this.texture.minFilter=options.minFilter!==undefined?options.minFilter:LinearFilter;this.depthBuffer=options.depthBuffer!==undefined?options.depthBuffer:true;this.stencilBuffer=options.stencilBuffer!==undefined?options.stencilBuffer:true;this.depthTexture=options.depthTexture!==undefined?options.depthTexture:null;}WebGLRenderTarget.prototype=(0,_assign.default)((0,_create.default)(EventDispatcher.prototype),{constructor:WebGLRenderTarget,isWebGLRenderTarget:true,setSize:function setSize(width,height){if(this.width!==width||this.height!==height){this.width=width;this.height=height;this.texture.image.width=width;this.texture.image.height=height;this.dispose();}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.width=source.width;this.height=source.height;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;this.depthTexture=source.depthTexture;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
 * @author Mugen87 / https://github.com/Mugen87
 * @author Matt DesLauriers / @mattdesl
 */function WebGLMultisampleRenderTarget(width,height,options){WebGLRenderTarget.call(this,width,height,options);this.samples=4;}WebGLMultisampleRenderTarget.prototype=(0,_assign.default)((0,_create.default)(WebGLRenderTarget.prototype),{constructor:WebGLMultisampleRenderTarget,isWebGLMultisampleRenderTarget:true,copy:function copy(source){WebGLRenderTarget.prototype.copy.call(this,source);this.samples=source.samples;return this;}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */function Quaternion(x,y,z,w){this._x=x||0;this._y=y||0;this._z=z||0;this._w=w!==undefined?w:1;}(0,_assign.default)(Quaternion,{slerp:function slerp(qa,qb,qm,t){return qm.copy(qa).slerp(qb,t);},slerpFlat:function slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){// fuzz-free, array-based Quaternion SLERP operation
var x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){var s=1-t,cos=x0*x1+y0*y1+z0*z1+w0*w1,dir=cos>=0?1:-1,sqrSin=1-cos*cos;// Skip the Slerp for tiny steps to avoid numeric problems:
if(sqrSin>_epsilon.default){var sin=Math.sqrt(sqrSin),len=Math.atan2(sin,cos*dir);s=Math.sin(s*len)/sin;t=Math.sin(t*len)/sin;}var tDir=t*dir;x0=x0*s+x1*tDir;y0=y0*s+y1*tDir;z0=z0*s+z1*tDir;w0=w0*s+w1*tDir;// Normalize in case we just did a lerp:
if(s===1-t){var f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f;y0*=f;z0*=f;w0*=f;}}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=w0;}});(0,_defineProperties.default)(Quaternion.prototype,{x:{get:function get(){return this._x;},set:function set(value){this._x=value;this._onChangeCallback();}},y:{get:function get(){return this._y;},set:function set(value){this._y=value;this._onChangeCallback();}},z:{get:function get(){return this._z;},set:function set(value){this._z=value;this._onChangeCallback();}},w:{get:function get(){return this._w;},set:function set(value){this._w=value;this._onChangeCallback();}}});(0,_assign.default)(Quaternion.prototype,{isQuaternion:true,set:function set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this;},clone:function clone(){return new this.constructor(this._x,this._y,this._z,this._w);},copy:function copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this;},setFromEuler:function setFromEuler(euler,update){if(!(euler&&euler.isEuler)){throw new Error('THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.');}var x=euler._x,y=euler._y,z=euler._z,order=euler.order;// http://www.mathworks.com/matlabcentral/fileexchange/
// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
//	content/SpinCalc.m
var cos=Math.cos;var sin=Math.sin;var c1=cos(x/2);var c2=cos(y/2);var c3=cos(z/2);var s1=sin(x/2);var s2=sin(y/2);var s3=sin(z/2);if(order==='XYZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='YXZ'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='ZXY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='ZYX'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}else if(order==='YZX'){this._x=s1*c2*c3+c1*s2*s3;this._y=c1*s2*c3+s1*c2*s3;this._z=c1*c2*s3-s1*s2*c3;this._w=c1*c2*c3-s1*s2*s3;}else if(order==='XZY'){this._x=s1*c2*c3-c1*s2*s3;this._y=c1*s2*c3-s1*c2*s3;this._z=c1*c2*s3+s1*s2*c3;this._w=c1*c2*c3+s1*s2*s3;}if(update!==false)this._onChangeCallback();return this;},setFromAxisAngle:function setFromAxisAngle(axis,angle){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
// assumes axis is normalized
var halfAngle=angle/2,s=Math.sin(halfAngle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(halfAngle);this._onChangeCallback();return this;},setFromRotationMatrix:function setFromRotationMatrix(m){// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33,s;if(trace>0){s=0.5/Math.sqrt(trace+1.0);this._w=0.25/s;this._x=(m32-m23)*s;this._y=(m13-m31)*s;this._z=(m21-m12)*s;}else if(m11>m22&&m11>m33){s=2.0*Math.sqrt(1.0+m11-m22-m33);this._w=(m32-m23)/s;this._x=0.25*s;this._y=(m12+m21)/s;this._z=(m13+m31)/s;}else if(m22>m33){s=2.0*Math.sqrt(1.0+m22-m11-m33);this._w=(m13-m31)/s;this._x=(m12+m21)/s;this._y=0.25*s;this._z=(m23+m32)/s;}else{s=2.0*Math.sqrt(1.0+m33-m11-m22);this._w=(m21-m12)/s;this._x=(m13+m31)/s;this._y=(m23+m32)/s;this._z=0.25*s;}this._onChangeCallback();return this;},setFromUnitVectors:function setFromUnitVectors(vFrom,vTo){// assumes direction vectors vFrom and vTo are normalized
var EPS=0.000001;var r=vFrom.dot(vTo)+1;if(r<EPS){r=0;if(Math.abs(vFrom.x)>Math.abs(vFrom.z)){this._x=-vFrom.y;this._y=vFrom.x;this._z=0;this._w=r;}else{this._x=0;this._y=-vFrom.z;this._z=vFrom.y;this._w=r;}}else{// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3
this._x=vFrom.y*vTo.z-vFrom.z*vTo.y;this._y=vFrom.z*vTo.x-vFrom.x*vTo.z;this._z=vFrom.x*vTo.y-vFrom.y*vTo.x;this._w=r;}return this.normalize();},angleTo:function angleTo(q){return 2*Math.acos(Math.abs(MathUtils.clamp(this.dot(q),-1,1)));},rotateTowards:function rotateTowards(q,step){var angle=this.angleTo(q);if(angle===0)return this;var t=Math.min(1,step/angle);this.slerp(q,t);return this;},inverse:function inverse(){// quaternion is assumed to have unit length
return this.conjugate();},conjugate:function conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this;},dot:function dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w;},lengthSq:function lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w;},length:function length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w);},normalize:function normalize(){var l=this.length();if(l===0){this._x=0;this._y=0;this._z=0;this._w=1;}else{l=1/l;this._x=this._x*l;this._y=this._y*l;this._z=this._z*l;this._w=this._w*l;}this._onChangeCallback();return this;},multiply:function multiply(q,p){if(p!==undefined){console.warn('THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.');return this.multiplyQuaternions(q,p);}return this.multiplyQuaternions(this,q);},premultiply:function premultiply(q){return this.multiplyQuaternions(q,this);},multiplyQuaternions:function multiplyQuaternions(a,b){// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
var qax=a._x,qay=a._y,qaz=a._z,qaw=a._w;var qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby;this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz;this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx;this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this;},slerp:function slerp(qb,t){if(t===0)return this;if(t===1)return this.copy(qb);var x=this._x,y=this._y,z=this._z,w=this._w;// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;if(cosHalfTheta<0){this._w=-qb._w;this._x=-qb._x;this._y=-qb._y;this._z=-qb._z;cosHalfTheta=-cosHalfTheta;}else{this.copy(qb);}if(cosHalfTheta>=1.0){this._w=w;this._x=x;this._y=y;this._z=z;return this;}var sqrSinHalfTheta=1.0-cosHalfTheta*cosHalfTheta;if(sqrSinHalfTheta<=_epsilon.default){var s=1-t;this._w=s*w+t*this._w;this._x=s*x+t*this._x;this._y=s*y+t*this._y;this._z=s*z+t*this._z;this.normalize();this._onChangeCallback();return this;}var sinHalfTheta=Math.sqrt(sqrSinHalfTheta);var halfTheta=Math.atan2(sinHalfTheta,cosHalfTheta);var ratioA=Math.sin((1-t)*halfTheta)/sinHalfTheta,ratioB=Math.sin(t*halfTheta)/sinHalfTheta;this._w=w*ratioA+this._w*ratioB;this._x=x*ratioA+this._x*ratioB;this._y=y*ratioA+this._y*ratioB;this._z=z*ratioA+this._z*ratioB;this._onChangeCallback();return this;},equals:function equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);return this;},_onChange:function _onChange(callback){this._onChangeCallback=callback;return this;},_onChangeCallback:function _onChangeCallback(){}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */var _vector=new Vector3();var _quaternion=new Quaternion();function Vector3(x,y,z){this.x=x||0;this.y=y||0;this.z=z||0;}(0,_assign.default)(Vector3.prototype,{isVector3:true,set:function set(x,y,z){this.x=x;this.y=y;this.z=z;return this;},setScalar:function setScalar(scalar){this.x=scalar;this.y=scalar;this.z=scalar;return this;},setX:function setX(x){this.x=x;return this;},setY:function setY(y){this.y=y;return this;},setZ:function setZ(z){this.z=z;return this;},setComponent:function setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error('index is out of range: '+index);}return this;},getComponent:function getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error('index is out of range: '+index);}},clone:function clone(){return new this.constructor(this.x,this.y,this.z);},copy:function copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this;},add:function add(v,w){if(w!==undefined){console.warn('THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.');return this.addVectors(v,w);}this.x+=v.x;this.y+=v.y;this.z+=v.z;return this;},addScalar:function addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this;},addVectors:function addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this;},addScaledVector:function addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this;},sub:function sub(v,w){if(w!==undefined){console.warn('THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.');return this.subVectors(v,w);}this.x-=v.x;this.y-=v.y;this.z-=v.z;return this;},subScalar:function subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this;},subVectors:function subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this;},multiply:function multiply(v,w){if(w!==undefined){console.warn('THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.');return this.multiplyVectors(v,w);}this.x*=v.x;this.y*=v.y;this.z*=v.z;return this;},multiplyScalar:function multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this;},multiplyVectors:function multiplyVectors(a,b){this.x=a.x*b.x;this.y=a.y*b.y;this.z=a.z*b.z;return this;},applyEuler:function applyEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.');}return this.applyQuaternion(_quaternion.setFromEuler(euler));},applyAxisAngle:function applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion.setFromAxisAngle(axis,angle));},applyMatrix3:function applyMatrix3(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[3]*y+e[6]*z;this.y=e[1]*x+e[4]*y+e[7]*z;this.z=e[2]*x+e[5]*y+e[8]*z;return this;},applyNormalMatrix:function applyNormalMatrix(m){return this.applyMatrix3(m).normalize();},applyMatrix4:function applyMatrix4(m){var x=this.x,y=this.y,z=this.z;var e=m.elements;var w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w;this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w;this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w;return this;},applyQuaternion:function applyQuaternion(q){var x=this.x,y=this.y,z=this.z;var qx=q.x,qy=q.y,qz=q.z,qw=q.w;// calculate quat * vector
var ix=qw*x+qy*z-qz*y;var iy=qw*y+qz*x-qx*z;var iz=qw*z+qx*y-qy*x;var iw=-qx*x-qy*y-qz*z;// calculate result * inverse quat
this.x=ix*qw+iw*-qx+iy*-qz-iz*-qy;this.y=iy*qw+iw*-qy+iz*-qx-ix*-qz;this.z=iz*qw+iw*-qz+ix*-qy-iy*-qx;return this;},project:function project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);},unproject:function unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);},transformDirection:function transformDirection(m){// input: THREE.Matrix4 affine matrix
// vector interpreted as a direction
var x=this.x,y=this.y,z=this.z;var e=m.elements;this.x=e[0]*x+e[4]*y+e[8]*z;this.y=e[1]*x+e[5]*y+e[9]*z;this.z=e[2]*x+e[6]*y+e[10]*z;return this.normalize();},divide:function divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this;},divideScalar:function divideScalar(scalar){return this.multiplyScalar(1/scalar);},min:function min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this;},max:function max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this;},clamp:function clamp(min,max){// assumes min < max, componentwise
this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this;},clampScalar:function clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));return this;},clampLength:function clampLength(min,max){var length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)));},floor:function floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);return this;},ceil:function ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this;},round:function round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this;},roundToZero:function roundToZero(){this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x);this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y);this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z);return this;},negate:function negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this;},dot:function dot(v){return this.x*v.x+this.y*v.y+this.z*v.z;},// TODO lengthSquared?
lengthSq:function lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z;},length:function length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z);},manhattanLength:function manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z);},normalize:function normalize(){return this.divideScalar(this.length()||1);},setLength:function setLength(length){return this.normalize().multiplyScalar(length);},lerp:function lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this;},lerpVectors:function lerpVectors(v1,v2,alpha){return this.subVectors(v2,v1).multiplyScalar(alpha).add(v1);},cross:function cross(v,w){if(w!==undefined){console.warn('THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.');return this.crossVectors(v,w);}return this.crossVectors(this,v);},crossVectors:function crossVectors(a,b){var ax=a.x,ay=a.y,az=a.z;var bx=b.x,by=b.y,bz=b.z;this.x=ay*bz-az*by;this.y=az*bx-ax*bz;this.z=ax*by-ay*bx;return this;},projectOnVector:function projectOnVector(v){var denominator=v.lengthSq();if(denominator===0)return this.set(0,0,0);var scalar=v.dot(this)/denominator;return this.copy(v).multiplyScalar(scalar);},projectOnPlane:function projectOnPlane(planeNormal){_vector.copy(this).projectOnVector(planeNormal);return this.sub(_vector);},reflect:function reflect(normal){// reflect incident vector off plane orthogonal to normal
// normal is assumed to have unit length
return this.sub(_vector.copy(normal).multiplyScalar(2*this.dot(normal)));},angleTo:function angleTo(v){var denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(denominator===0)return Math.PI/2;var theta=this.dot(v)/denominator;// clamp, to handle numerical problems
return Math.acos(MathUtils.clamp(theta,-1,1));},distanceTo:function distanceTo(v){return Math.sqrt(this.distanceToSquared(v));},distanceToSquared:function distanceToSquared(v){var dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz;},manhattanDistanceTo:function manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z);},setFromSpherical:function setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta);},setFromSphericalCoords:function setFromSphericalCoords(radius,phi,theta){var sinPhiRadius=Math.sin(phi)*radius;this.x=sinPhiRadius*Math.sin(theta);this.y=Math.cos(phi)*radius;this.z=sinPhiRadius*Math.cos(theta);return this;},setFromCylindrical:function setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y);},setFromCylindricalCoords:function setFromCylindricalCoords(radius,theta,y){this.x=radius*Math.sin(theta);this.y=y;this.z=radius*Math.cos(theta);return this;},setFromMatrixPosition:function setFromMatrixPosition(m){var e=m.elements;this.x=e[12];this.y=e[13];this.z=e[14];return this;},setFromMatrixScale:function setFromMatrixScale(m){var sx=this.setFromMatrixColumn(m,0).length();var sy=this.setFromMatrixColumn(m,1).length();var sz=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=sz;return this;},setFromMatrixColumn:function setFromMatrixColumn(m,index){return this.fromArray(m.elements,index*4);},setFromMatrix3Column:function setFromMatrix3Column(m,index){return this.fromArray(m.elements,index*3);},equals:function equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array;},fromBufferAttribute:function fromBufferAttribute(attribute,index,offset){if(offset!==undefined){console.warn('THREE.Vector3: offset has been removed from .fromBufferAttribute().');}this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this;}});var _v1=new Vector3();var _m1=new Matrix4();var _zero=new Vector3(0,0,0);var _one=new Vector3(1,1,1);var _x=new Vector3();var _y=new Vector3();var _z=new Vector3();/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */function Matrix4(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];if(arguments.length>0){console.error('THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.');}}(0,_assign.default)(Matrix4.prototype,{isMatrix4:true,set:function set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){var te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this;},identity:function identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this;},clone:function clone(){return new Matrix4().fromArray(this.elements);},copy:function copy(m){var te=this.elements;var me=m.elements;te[0]=me[0];te[1]=me[1];te[2]=me[2];te[3]=me[3];te[4]=me[4];te[5]=me[5];te[6]=me[6];te[7]=me[7];te[8]=me[8];te[9]=me[9];te[10]=me[10];te[11]=me[11];te[12]=me[12];te[13]=me[13];te[14]=me[14];te[15]=me[15];return this;},copyPosition:function copyPosition(m){var te=this.elements,me=m.elements;te[12]=me[12];te[13]=me[13];te[14]=me[14];return this;},extractBasis:function extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this;},makeBasis:function makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this;},extractRotation:function extractRotation(m){// this method does not support reflection matrices
var te=this.elements;var me=m.elements;var scaleX=1/_v1.setFromMatrixColumn(m,0).length();var scaleY=1/_v1.setFromMatrixColumn(m,1).length();var scaleZ=1/_v1.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[3]=0;te[4]=me[4]*scaleY;te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[7]=0;te[8]=me[8]*scaleZ;te[9]=me[9]*scaleZ;te[10]=me[10]*scaleZ;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},makeRotationFromEuler:function makeRotationFromEuler(euler){if(!(euler&&euler.isEuler)){console.error('THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.');}var te=this.elements;var x=euler.x,y=euler.y,z=euler.z;var a=Math.cos(x),b=Math.sin(x);var c=Math.cos(y),d=Math.sin(y);var e=Math.cos(z),f=Math.sin(z);if(euler.order==='XYZ'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=-c*f;te[8]=d;te[1]=af+be*d;te[5]=ae-bf*d;te[9]=-b*c;te[2]=bf-ae*d;te[6]=be+af*d;te[10]=a*c;}else if(euler.order==='YXZ'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b;te[4]=de*b-cf;te[8]=a*d;te[1]=a*f;te[5]=a*e;te[9]=-b;te[2]=cf*b-de;te[6]=df+ce*b;te[10]=a*c;}else if(euler.order==='ZXY'){var ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b;te[4]=-a*f;te[8]=de+cf*b;te[1]=cf+de*b;te[5]=a*e;te[9]=df-ce*b;te[2]=-a*d;te[6]=b;te[10]=a*c;}else if(euler.order==='ZYX'){var ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e;te[4]=be*d-af;te[8]=ae*d+bf;te[1]=c*f;te[5]=bf*d+ae;te[9]=af*d-be;te[2]=-d;te[6]=b*c;te[10]=a*c;}else if(euler.order==='YZX'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=bd-ac*f;te[8]=bc*f+ad;te[1]=f;te[5]=a*e;te[9]=-b*e;te[2]=-d*e;te[6]=ad*f+bc;te[10]=ac-bd*f;}else if(euler.order==='XZY'){var ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e;te[4]=-f;te[8]=d*e;te[1]=ac*f+bd;te[5]=a*e;te[9]=ad*f-bc;te[2]=bc*f-ad;te[6]=b*e;te[10]=bd*f+ac;}// bottom row
te[3]=0;te[7]=0;te[11]=0;// last column
te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this;},makeRotationFromQuaternion:function makeRotationFromQuaternion(q){return this.compose(_zero,q,_one);},lookAt:function lookAt(eye,target,up){var te=this.elements;_z.subVectors(eye,target);if(_z.lengthSq()===0){// eye and target are in the same position
_z.z=1;}_z.normalize();_x.crossVectors(up,_z);if(_x.lengthSq()===0){// up and z are parallel
if(Math.abs(up.z)===1){_z.x+=0.0001;}else{_z.z+=0.0001;}_z.normalize();_x.crossVectors(up,_z);}_x.normalize();_y.crossVectors(_z,_x);te[0]=_x.x;te[4]=_y.x;te[8]=_z.x;te[1]=_x.y;te[5]=_y.y;te[9]=_z.y;te[2]=_x.z;te[6]=_y.z;te[10]=_z.z;return this;},multiply:function multiply(m,n){if(n!==undefined){console.warn('THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.');return this.multiplyMatrices(m,n);}return this.multiplyMatrices(this,m);},premultiply:function premultiply(m){return this.multiplyMatrices(m,this);},multiplyMatrices:function multiplyMatrices(a,b){var ae=a.elements;var be=b.elements;var te=this.elements;var a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12];var a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13];var a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14];var a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15];var b11=be[0],b12=be[4],b13=be[8],b14=be[12];var b21=be[1],b22=be[5],b23=be[9],b24=be[13];var b31=be[2],b32=be[6],b33=be[10],b34=be[14];var b41=be[3],b42=be[7],b43=be[11],b44=be[15];te[0]=a11*b11+a12*b21+a13*b31+a14*b41;te[4]=a11*b12+a12*b22+a13*b32+a14*b42;te[8]=a11*b13+a12*b23+a13*b33+a14*b43;te[12]=a11*b14+a12*b24+a13*b34+a14*b44;te[1]=a21*b11+a22*b21+a23*b31+a24*b41;te[5]=a21*b12+a22*b22+a23*b32+a24*b42;te[9]=a21*b13+a22*b23+a23*b33+a24*b43;te[13]=a21*b14+a22*b24+a23*b34+a24*b44;te[2]=a31*b11+a32*b21+a33*b31+a34*b41;te[6]=a31*b12+a32*b22+a33*b32+a34*b42;te[10]=a31*b13+a32*b23+a33*b33+a34*b43;te[14]=a31*b14+a32*b24+a33*b34+a34*b44;te[3]=a41*b11+a42*b21+a43*b31+a44*b41;te[7]=a41*b12+a42*b22+a43*b32+a44*b42;te[11]=a41*b13+a42*b23+a43*b33+a44*b43;te[15]=a41*b14+a42*b24+a43*b34+a44*b44;return this;},multiplyScalar:function multiplyScalar(s){var te=this.elements;te[0]*=s;te[4]*=s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this;},determinant:function determinant(){var te=this.elements;var n11=te[0],n12=te[4],n13=te[8],n14=te[12];var n21=te[1],n22=te[5],n23=te[9],n24=te[13];var n31=te[2],n32=te[6],n33=te[10],n34=te[14];var n41=te[3],n42=te[7],n43=te[11],n44=te[15];//TODO: make this more efficient
//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
return n41*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+n42*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+n43*(+n11*n24*n32-n11*n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+n44*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31);},transpose:function transpose(){var te=this.elements;var tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this;},setPosition:function setPosition(x,y,z){var te=this.elements;if(x.isVector3){te[12]=x.x;te[13]=x.y;te[14]=x.z;}else{te[12]=x;te[13]=y;te[14]=z;}return this;},getInverse:function getInverse(m,throwOnDegenerate){if(throwOnDegenerate!==undefined){console.warn("THREE.Matrix4: .getInverse() can no longer be configured to throw on degenerate.");}// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
var te=this.elements,me=m.elements,n11=me[0],n21=me[1],n31=me[2],n41=me[3],n12=me[4],n22=me[5],n32=me[6],n42=me[7],n13=me[8],n23=me[9],n33=me[10],n43=me[11],n14=me[12],n24=me[13],n34=me[14],n44=me[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(det===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);var detInv=1/det;te[0]=t11*detInv;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*detInv;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*detInv;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*detInv;te[4]=t12*detInv;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*detInv;te[6]=(n14*n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*detInv;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*detInv;te[8]=t13*detInv;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*detInv;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*detInv;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*detInv;te[12]=t14*detInv;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*n34+n11*n23*n34)*detInv;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*detInv;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*detInv;return this;},scale:function scale(v){var te=this.elements;var x=v.x,y=v.y,z=v.z;te[0]*=x;te[4]*=y;te[8]*=z;te[1]*=x;te[5]*=y;te[9]*=z;te[2]*=x;te[6]*=y;te[10]*=z;te[3]*=x;te[7]*=y;te[11]*=z;return this;},getMaxScaleOnAxis:function getMaxScaleOnAxis(){var te=this.elements;var scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2];var scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6];var scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq));},makeTranslation:function makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this;},makeRotationX:function makeRotationX(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1);return this;},makeRotationY:function makeRotationY(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1);return this;},makeRotationZ:function makeRotationZ(theta){var c=Math.cos(theta),s=Math.sin(theta);this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1);return this;},makeRotationAxis:function makeRotationAxis(axis,angle){// Based on http://www.gamedev.net/reference/articles/article1199.asp
var c=Math.cos(angle);var s=Math.sin(angle);var t=1-c;var x=axis.x,y=axis.y,z=axis.z;var tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1);return this;},makeScale:function makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this;},makeShear:function makeShear(x,y,z){this.set(1,y,z,0,x,1,z,0,x,y,1,0,0,0,0,1);return this;},compose:function compose(position,quaternion,scale){var te=this.elements;var x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w;var x2=x+x,y2=y+y,z2=z+z;var xx=x*x2,xy=x*y2,xz=x*z2;var yy=y*y2,yz=y*z2,zz=z*z2;var wx=w*x2,wy=w*y2,wz=w*z2;var sx=scale.x,sy=scale.y,sz=scale.z;te[0]=(1-(yy+zz))*sx;te[1]=(xy+wz)*sx;te[2]=(xz-wy)*sx;te[3]=0;te[4]=(xy-wz)*sy;te[5]=(1-(xx+zz))*sy;te[6]=(yz+wx)*sy;te[7]=0;te[8]=(xz+wy)*sz;te[9]=(yz-wx)*sz;te[10]=(1-(xx+yy))*sz;te[11]=0;te[12]=position.x;te[13]=position.y;te[14]=position.z;te[15]=1;return this;},decompose:function decompose(position,quaternion,scale){var te=this.elements;var sx=_v1.set(te[0],te[1],te[2]).length();var sy=_v1.set(te[4],te[5],te[6]).length();var sz=_v1.set(te[8],te[9],te[10]).length();// if determine is negative, we need to invert one scale
var det=this.determinant();if(det<0)sx=-sx;position.x=te[12];position.y=te[13];position.z=te[14];// scale the rotation part
_m1.copy(this);var invSX=1/sx;var invSY=1/sy;var invSZ=1/sz;_m1.elements[0]*=invSX;_m1.elements[1]*=invSX;_m1.elements[2]*=invSX;_m1.elements[4]*=invSY;_m1.elements[5]*=invSY;_m1.elements[6]*=invSY;_m1.elements[8]*=invSZ;_m1.elements[9]*=invSZ;_m1.elements[10]*=invSZ;quaternion.setFromRotationMatrix(_m1);scale.x=sx;scale.y=sy;scale.z=sz;return this;},makePerspective:function makePerspective(left,right,top,bottom,near,far){if(far===undefined){console.warn('THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.');}var te=this.elements;var x=2*near/(right-left);var y=2*near/(top-bottom);var a=(right+left)/(right-left);var b=(top+bottom)/(top-bottom);var c=-(far+near)/(far-near);var d=-2*far*near/(far-near);te[0]=x;te[4]=0;te[8]=a;te[12]=0;te[1]=0;te[5]=y;te[9]=b;te[13]=0;te[2]=0;te[6]=0;te[10]=c;te[14]=d;te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this;},makeOrthographic:function makeOrthographic(left,right,top,bottom,near,far){var te=this.elements;var w=1.0/(right-left);var h=1.0/(top-bottom);var p=1.0/(far-near);var x=(right+left)*w;var y=(top+bottom)*h;var z=(far+near)*p;te[0]=2*w;te[4]=0;te[8]=0;te[12]=-x;te[1]=0;te[5]=2*h;te[9]=0;te[13]=-y;te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-z;te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this;},equals:function equals(matrix){var te=this.elements;var me=matrix.elements;for(var i=0;i<16;i++){if(te[i]!==me[i])return false;}return true;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;for(var i=0;i<16;i++){this.elements[i]=array[i+offset];}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */var _matrix=new Matrix4();var _quaternion$1=new Quaternion();function Euler(x,y,z,order){this._x=x||0;this._y=y||0;this._z=z||0;this._order=order||Euler.DefaultOrder;}Euler.RotationOrders=['XYZ','YZX','ZXY','XZY','YXZ','ZYX'];Euler.DefaultOrder='XYZ';(0,_defineProperties.default)(Euler.prototype,{x:{get:function get(){return this._x;},set:function set(value){this._x=value;this._onChangeCallback();}},y:{get:function get(){return this._y;},set:function set(value){this._y=value;this._onChangeCallback();}},z:{get:function get(){return this._z;},set:function set(value){this._z=value;this._onChangeCallback();}},order:{get:function get(){return this._order;},set:function set(value){this._order=value;this._onChangeCallback();}}});(0,_assign.default)(Euler.prototype,{isEuler:true,set:function set(x,y,z,order){this._x=x;this._y=y;this._z=z;this._order=order||this._order;this._onChangeCallback();return this;},clone:function clone(){return new this.constructor(this._x,this._y,this._z,this._order);},copy:function copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this._onChangeCallback();return this;},setFromRotationMatrix:function setFromRotationMatrix(m,order,update){var clamp=MathUtils.clamp;// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
var te=m.elements;var m11=te[0],m12=te[4],m13=te[8];var m21=te[1],m22=te[5],m23=te[9];var m31=te[2],m32=te[6],m33=te[10];order=order||this._order;if(order==='XYZ'){this._y=Math.asin(clamp(m13,-1,1));if(Math.abs(m13)<0.9999999){this._x=Math.atan2(-m23,m33);this._z=Math.atan2(-m12,m11);}else{this._x=Math.atan2(m32,m22);this._z=0;}}else if(order==='YXZ'){this._x=Math.asin(-clamp(m23,-1,1));if(Math.abs(m23)<0.9999999){this._y=Math.atan2(m13,m33);this._z=Math.atan2(m21,m22);}else{this._y=Math.atan2(-m31,m11);this._z=0;}}else if(order==='ZXY'){this._x=Math.asin(clamp(m32,-1,1));if(Math.abs(m32)<0.9999999){this._y=Math.atan2(-m31,m33);this._z=Math.atan2(-m12,m22);}else{this._y=0;this._z=Math.atan2(m21,m11);}}else if(order==='ZYX'){this._y=Math.asin(-clamp(m31,-1,1));if(Math.abs(m31)<0.9999999){this._x=Math.atan2(m32,m33);this._z=Math.atan2(m21,m11);}else{this._x=0;this._z=Math.atan2(-m12,m22);}}else if(order==='YZX'){this._z=Math.asin(clamp(m21,-1,1));if(Math.abs(m21)<0.9999999){this._x=Math.atan2(-m23,m22);this._y=Math.atan2(-m31,m11);}else{this._x=0;this._y=Math.atan2(m13,m33);}}else if(order==='XZY'){this._z=Math.asin(-clamp(m12,-1,1));if(Math.abs(m12)<0.9999999){this._x=Math.atan2(m32,m22);this._y=Math.atan2(m13,m11);}else{this._x=Math.atan2(-m23,m33);this._y=0;}}else{console.warn('THREE.Euler: .setFromRotationMatrix() given unsupported order: '+order);}this._order=order;if(update!==false)this._onChangeCallback();return this;},setFromQuaternion:function setFromQuaternion(q,order,update){_matrix.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(_matrix,order,update);},setFromVector3:function setFromVector3(v,order){return this.set(v.x,v.y,v.z,order||this._order);},reorder:function reorder(newOrder){// WARNING: this discards revolution information -bhouston
_quaternion$1.setFromEuler(this);return this.setFromQuaternion(_quaternion$1,newOrder);},equals:function equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order;},fromArray:function fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];if(array[3]!==undefined)this._order=array[3];this._onChangeCallback();return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array;},toVector3:function toVector3(optionalResult){if(optionalResult){return optionalResult.set(this._x,this._y,this._z);}else{return new Vector3(this._x,this._y,this._z);}},_onChange:function _onChange(callback){this._onChangeCallback=callback;return this;},_onChangeCallback:function _onChangeCallback(){}});/**
 * @author mrdoob / http://mrdoob.com/
 */function Layers(){this.mask=1|0;}(0,_assign.default)(Layers.prototype,{set:function set(channel){this.mask=1<<channel|0;},enable:function enable(channel){this.mask|=1<<channel|0;},enableAll:function enableAll(){this.mask=0xffffffff|0;},toggle:function toggle(channel){this.mask^=1<<channel|0;},disable:function disable(channel){this.mask&=~(1<<channel|0);},disableAll:function disableAll(){this.mask=0;},test:function test(layers){return(this.mask&layers.mask)!==0;}});var _object3DId=0;var _v1$1=new Vector3();var _q1=new Quaternion();var _m1$1=new Matrix4();var _target=new Vector3();var _position=new Vector3();var _scale=new Vector3();var _quaternion$2=new Quaternion();var _xAxis=new Vector3(1,0,0);var _yAxis=new Vector3(0,1,0);var _zAxis=new Vector3(0,0,1);var _addedEvent={type:'added'};var _removedEvent={type:'removed'};/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */function Object3D(){(0,_defineProperty3.default)(this,'id',{value:_object3DId++});this.uuid=MathUtils.generateUUID();this.name='';this.type='Object3D';this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();var position=new Vector3();var rotation=new Euler();var quaternion=new Quaternion();var scale=new Vector3(1,1,1);function onRotationChange(){quaternion.setFromEuler(rotation,false);}function onQuaternionChange(){rotation.setFromQuaternion(quaternion,undefined,false);}rotation._onChange(onRotationChange);quaternion._onChange(onQuaternionChange);(0,_defineProperties.default)(this,{position:{configurable:true,enumerable:true,value:position},rotation:{configurable:true,enumerable:true,value:rotation},quaternion:{configurable:true,enumerable:true,value:quaternion},scale:{configurable:true,enumerable:true,value:scale},modelViewMatrix:{value:new Matrix4()},normalMatrix:{value:new Matrix3()}});this.matrix=new Matrix4();this.matrixWorld=new Matrix4();this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=false;this.layers=new Layers();this.visible=true;this.castShadow=false;this.receiveShadow=false;this.frustumCulled=true;this.renderOrder=0;this.userData={};}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=true;Object3D.prototype=(0,_assign.default)((0,_create.default)(EventDispatcher.prototype),{constructor:Object3D,isObject3D:true,onBeforeRender:function onBeforeRender(){},onAfterRender:function onAfterRender(){},applyMatrix4:function applyMatrix4(matrix){if(this.matrixAutoUpdate)this.updateMatrix();this.matrix.premultiply(matrix);this.matrix.decompose(this.position,this.quaternion,this.scale);},applyQuaternion:function applyQuaternion(q){this.quaternion.premultiply(q);return this;},setRotationFromAxisAngle:function setRotationFromAxisAngle(axis,angle){// assumes axis is normalized
this.quaternion.setFromAxisAngle(axis,angle);},setRotationFromEuler:function setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,true);},setRotationFromMatrix:function setRotationFromMatrix(m){// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
this.quaternion.setFromRotationMatrix(m);},setRotationFromQuaternion:function setRotationFromQuaternion(q){// assumes q is normalized
this.quaternion.copy(q);},rotateOnAxis:function rotateOnAxis(axis,angle){// rotate object on axis in object space
// axis is assumed to be normalized
_q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(_q1);return this;},rotateOnWorldAxis:function rotateOnWorldAxis(axis,angle){// rotate object on axis in world space
// axis is assumed to be normalized
// method assumes no rotated parent
_q1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(_q1);return this;},rotateX:function rotateX(angle){return this.rotateOnAxis(_xAxis,angle);},rotateY:function rotateY(angle){return this.rotateOnAxis(_yAxis,angle);},rotateZ:function rotateZ(angle){return this.rotateOnAxis(_zAxis,angle);},translateOnAxis:function translateOnAxis(axis,distance){// translate object by distance along axis in object space
// axis is assumed to be normalized
_v1$1.copy(axis).applyQuaternion(this.quaternion);this.position.add(_v1$1.multiplyScalar(distance));return this;},translateX:function translateX(distance){return this.translateOnAxis(_xAxis,distance);},translateY:function translateY(distance){return this.translateOnAxis(_yAxis,distance);},translateZ:function translateZ(distance){return this.translateOnAxis(_zAxis,distance);},localToWorld:function localToWorld(vector){return vector.applyMatrix4(this.matrixWorld);},worldToLocal:function worldToLocal(vector){return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));},lookAt:function lookAt(x,y,z){// This method does not support objects having non-uniformly-scaled parent(s)
if(x.isVector3){_target.copy(x);}else{_target.set(x,y,z);}var parent=this.parent;this.updateWorldMatrix(true,false);_position.setFromMatrixPosition(this.matrixWorld);if(this.isCamera||this.isLight){_m1$1.lookAt(_position,_target,this.up);}else{_m1$1.lookAt(_target,_position,this.up);}this.quaternion.setFromRotationMatrix(_m1$1);if(parent){_m1$1.extractRotation(parent.matrixWorld);_q1.setFromRotationMatrix(_m1$1);this.quaternion.premultiply(_q1.inverse());}},add:function add(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.add(arguments[i]);}return this;}if(object===this){console.error("THREE.Object3D.add: object can't be added as a child of itself.",object);return this;}if(object&&object.isObject3D){if(object.parent!==null){object.parent.remove(object);}object.parent=this;this.children.push(object);object.dispatchEvent(_addedEvent);}else{console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object);}return this;},remove:function remove(object){if(arguments.length>1){for(var i=0;i<arguments.length;i++){this.remove(arguments[i]);}return this;}var index=this.children.indexOf(object);if(index!==-1){object.parent=null;this.children.splice(index,1);object.dispatchEvent(_removedEvent);}return this;},attach:function attach(object){// adds object as a child of this, while maintaining the object's world transform
this.updateWorldMatrix(true,false);_m1$1.getInverse(this.matrixWorld);if(object.parent!==null){object.parent.updateWorldMatrix(true,false);_m1$1.multiply(object.parent.matrixWorld);}object.applyMatrix4(_m1$1);object.updateWorldMatrix(false,false);this.add(object);return this;},getObjectById:function getObjectById(id){return this.getObjectByProperty('id',id);},getObjectByName:function getObjectByName(name){return this.getObjectByProperty('name',name);},getObjectByProperty:function getObjectByProperty(name,value){if(this[name]===value)return this;for(var i=0,l=this.children.length;i<l;i++){var child=this.children[i];var object=child.getObjectByProperty(name,value);if(object!==undefined){return object;}}return undefined;},getWorldPosition:function getWorldPosition(target){if(target===undefined){console.warn('THREE.Object3D: .getWorldPosition() target is now required');target=new Vector3();}this.updateMatrixWorld(true);return target.setFromMatrixPosition(this.matrixWorld);},getWorldQuaternion:function getWorldQuaternion(target){if(target===undefined){console.warn('THREE.Object3D: .getWorldQuaternion() target is now required');target=new Quaternion();}this.updateMatrixWorld(true);this.matrixWorld.decompose(_position,target,_scale);return target;},getWorldScale:function getWorldScale(target){if(target===undefined){console.warn('THREE.Object3D: .getWorldScale() target is now required');target=new Vector3();}this.updateMatrixWorld(true);this.matrixWorld.decompose(_position,_quaternion$2,target);return target;},getWorldDirection:function getWorldDirection(target){if(target===undefined){console.warn('THREE.Object3D: .getWorldDirection() target is now required');target=new Vector3();}this.updateMatrixWorld(true);var e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize();},raycast:function raycast(){},traverse:function traverse(callback){callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverse(callback);}},traverseVisible:function traverseVisible(callback){if(this.visible===false)return;callback(this);var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].traverseVisible(callback);}},traverseAncestors:function traverseAncestors(callback){var parent=this.parent;if(parent!==null){callback(parent);parent.traverseAncestors(callback);}},updateMatrix:function updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=true;},updateMatrixWorld:function updateMatrixWorld(force){if(this.matrixAutoUpdate)this.updateMatrix();if(this.matrixWorldNeedsUpdate||force){if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}this.matrixWorldNeedsUpdate=false;force=true;}// update children
var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(force);}},updateWorldMatrix:function updateWorldMatrix(updateParents,updateChildren){var parent=this.parent;if(updateParents===true&&parent!==null){parent.updateWorldMatrix(true,false);}if(this.matrixAutoUpdate)this.updateMatrix();if(this.parent===null){this.matrixWorld.copy(this.matrix);}else{this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);}// update children
if(updateChildren===true){var children=this.children;for(var i=0,l=children.length;i<l;i++){children[i].updateWorldMatrix(false,true);}}},toJSON:function toJSON(meta){// meta is a string when called from JSON.stringify
var isRootObject=meta===undefined||typeof meta==='string';var output={};// meta is a hash used to collect geometries, materials.
// not providing it implies that this is the root object
// being serialized.
if(isRootObject){// initialize meta obj
meta={geometries:{},materials:{},textures:{},images:{},shapes:{}};output.metadata={version:4.5,type:'Object',generator:'Object3D.toJSON'};}// standard Object3D serialization
var object={};object.uuid=this.uuid;object.type=this.type;if(this.name!=='')object.name=this.name;if(this.castShadow===true)object.castShadow=true;if(this.receiveShadow===true)object.receiveShadow=true;if(this.visible===false)object.visible=false;if(this.frustumCulled===false)object.frustumCulled=false;if(this.renderOrder!==0)object.renderOrder=this.renderOrder;if((0,_stringify.default)(this.userData)!=='{}')object.userData=this.userData;object.layers=this.layers.mask;object.matrix=this.matrix.toArray();if(this.matrixAutoUpdate===false)object.matrixAutoUpdate=false;// object specific properties
if(this.isInstancedMesh){object.type='InstancedMesh';object.count=this.count;object.instanceMatrix=this.instanceMatrix.toJSON();}//
function serialize(library,element){if(library[element.uuid]===undefined){library[element.uuid]=element.toJSON(meta);}return element.uuid;}if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);var parameters=this.geometry.parameters;if(parameters!==undefined&&parameters.shapes!==undefined){var shapes=parameters.shapes;if((0,_isArray.default)(shapes)){for(var i=0,l=shapes.length;i<l;i++){var shape=shapes[i];serialize(meta.shapes,shape);}}else{serialize(meta.shapes,shapes);}}}if(this.material!==undefined){if((0,_isArray.default)(this.material)){var uuids=[];for(var i=0,l=this.material.length;i<l;i++){uuids.push(serialize(meta.materials,this.material[i]));}object.material=uuids;}else{object.material=serialize(meta.materials,this.material);}}//
if(this.children.length>0){object.children=[];for(var i=0;i<this.children.length;i++){object.children.push(this.children[i].toJSON(meta).object);}}if(isRootObject){var geometries=extractFromCache(meta.geometries);var materials=extractFromCache(meta.materials);var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);var shapes=extractFromCache(meta.shapes);if(geometries.length>0)output.geometries=geometries;if(materials.length>0)output.materials=materials;if(textures.length>0)output.textures=textures;if(images.length>0)output.images=images;if(shapes.length>0)output.shapes=shapes;}output.object=object;return output;// extract data from the cache hash
// remove metadata on each item
// and return as array
function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}},clone:function clone(recursive){return new this.constructor().copy(this,recursive);},copy:function copy(source,recursive){if(recursive===undefined)recursive=true;this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse((0,_stringify.default)(source.userData));if(recursive===true){for(var i=0;i<source.children.length;i++){var child=source.children[i];this.add(child.clone());}}return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function Scene(){Object3D.call(this);this.type='Scene';this.background=null;this.environment=null;this.fog=null;this.overrideMaterial=null;this.autoUpdate=true;// checked by the renderer
if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));// eslint-disable-line no-undef
}}Scene.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Scene,isScene:true,copy:function copy(source,recursive){Object3D.prototype.copy.call(this,source,recursive);if(source.background!==null)this.background=source.background.clone();if(source.environment!==null)this.environment=source.environment.clone();if(source.fog!==null)this.fog=source.fog.clone();if(source.overrideMaterial!==null)this.overrideMaterial=source.overrideMaterial.clone();this.autoUpdate=source.autoUpdate;this.matrixAutoUpdate=source.matrixAutoUpdate;return this;},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);if(this.background!==null)data.object.background=this.background.toJSON(meta);if(this.environment!==null)data.object.environment=this.environment.toJSON(meta);if(this.fog!==null)data.object.fog=this.fog.toJSON();return data;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});var _points=[new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3(),new Vector3()];var _vector$1=new Vector3();var _box=new Box3();// triangle centered vertices
var _v0=new Vector3();var _v1$2=new Vector3();var _v2=new Vector3();// triangle edge vectors
var _f0=new Vector3();var _f1=new Vector3();var _f2=new Vector3();var _center=new Vector3();var _extents=new Vector3();var _triangleNormal=new Vector3();var _testAxis=new Vector3();/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */function Box3(min,max){this.min=min!==undefined?min:new Vector3(+Infinity,+Infinity,+Infinity);this.max=max!==undefined?max:new Vector3(-Infinity,-Infinity,-Infinity);}(0,_assign.default)(Box3.prototype,{isBox3:true,set:function set(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromArray:function setFromArray(array){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=array.length;i<l;i+=3){var x=array[i];var y=array[i+1];var z=array[i+2];if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromBufferAttribute:function setFromBufferAttribute(attribute){var minX=+Infinity;var minY=+Infinity;var minZ=+Infinity;var maxX=-Infinity;var maxY=-Infinity;var maxZ=-Infinity;for(var i=0,l=attribute.count;i<l;i++){var x=attribute.getX(i);var y=attribute.getY(i);var z=attribute.getZ(i);if(x<minX)minX=x;if(y<minY)minY=y;if(z<minZ)minZ=z;if(x>maxX)maxX=x;if(y>maxY)maxY=y;if(z>maxZ)maxZ=z;}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this;},setFromPoints:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function setFromCenterAndSize(center,size){var halfSize=_vector$1.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;},setFromObject:function setFromObject(object){this.makeEmpty();return this.expandByObject(object);},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function makeEmpty(){this.min.x=this.min.y=this.min.z=+Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this;},isEmpty:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z;},getCenter:function getCenter(target){if(target===undefined){console.warn('THREE.Box3: .getCenter() target is now required');target=new Vector3();}return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function getSize(target){if(target===undefined){console.warn('THREE.Box3: .getSize() target is now required');target=new Vector3();}return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min);},expandByPoint:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},expandByObject:function expandByObject(object){// Computes the world-axis-aligned bounding box of an object (including its children),
// accounting for both the object's, and children's, world transforms
object.updateWorldMatrix(false,false);var geometry=object.geometry;if(geometry!==undefined){if(geometry.boundingBox===null){geometry.computeBoundingBox();}_box.copy(geometry.boundingBox);_box.applyMatrix4(object.matrixWorld);this.union(_box);}var children=object.children;for(var i=0,l=children.length;i<l;i++){this.expandByObject(children[i]);}return this;},containsPoint:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?false:true;},containsBox:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z;},getParameter:function getParameter(point,target){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
if(target===undefined){console.warn('THREE.Box3: .getParameter() target is now required');target=new Vector3();}return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z));},intersectsBox:function intersectsBox(box){// using 6 splitting planes to rule out intersections.
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?false:true;},intersectsSphere:function intersectsSphere(sphere){// Find the point on the AABB closest to the sphere center.
this.clampPoint(sphere.center,_vector$1);// If that point is inside the sphere, the AABB and sphere intersect.
return _vector$1.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius;},intersectsPlane:function intersectsPlane(plane){// We compute the minimum and maximum dot product values. If those values
// are on the same side (back or front) of the plane, then there is no intersection.
var min,max;if(plane.normal.x>0){min=plane.normal.x*this.min.x;max=plane.normal.x*this.max.x;}else{min=plane.normal.x*this.max.x;max=plane.normal.x*this.min.x;}if(plane.normal.y>0){min+=plane.normal.y*this.min.y;max+=plane.normal.y*this.max.y;}else{min+=plane.normal.y*this.max.y;max+=plane.normal.y*this.min.y;}if(plane.normal.z>0){min+=plane.normal.z*this.min.z;max+=plane.normal.z*this.max.z;}else{min+=plane.normal.z*this.max.z;max+=plane.normal.z*this.min.z;}return min<=-plane.constant&&max>=-plane.constant;},intersectsTriangle:function intersectsTriangle(triangle){if(this.isEmpty()){return false;}// compute box center and extents
this.getCenter(_center);_extents.subVectors(this.max,_center);// translate triangle to aabb origin
_v0.subVectors(triangle.a,_center);_v1$2.subVectors(triangle.b,_center);_v2.subVectors(triangle.c,_center);// compute edge vectors for triangle
_f0.subVectors(_v1$2,_v0);_f1.subVectors(_v2,_v1$2);_f2.subVectors(_v0,_v2);// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
var axes=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];if(!satForAxes(axes,_v0,_v1$2,_v2,_extents)){return false;}// test 3 face normals from the aabb
axes=[1,0,0,0,1,0,0,0,1];if(!satForAxes(axes,_v0,_v1$2,_v2,_extents)){return false;}// finally testing the face normal of the triangle
// use already existing triangle edge vectors here
_triangleNormal.crossVectors(_f0,_f1);axes=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z];return satForAxes(axes,_v0,_v1$2,_v2,_extents);},clampPoint:function clampPoint(point,target){if(target===undefined){console.warn('THREE.Box3: .clampPoint() target is now required');target=new Vector3();}return target.copy(point).clamp(this.min,this.max);},distanceToPoint:function distanceToPoint(point){var clampedPoint=_vector$1.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();},getBoundingSphere:function getBoundingSphere(target){if(target===undefined){console.error('THREE.Box3: .getBoundingSphere() target is now required');//target = new Sphere(); // removed to avoid cyclic dependency
}this.getCenter(target.center);target.radius=this.getSize(_vector$1).length()*0.5;return target;},intersect:function intersect(box){this.min.max(box.min);this.max.min(box.max);// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
if(this.isEmpty())this.makeEmpty();return this;},union:function union(box){this.min.min(box.min);this.max.max(box.max);return this;},applyMatrix4:function applyMatrix4(matrix){// transform of empty box is an empty box.
if(this.isEmpty())return this;// NOTE: I am using a binary pattern to specify all 2^3 combinations below
_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);// 000
_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);// 001
_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);// 010
_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);// 011
_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);// 100
_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);// 101
_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);// 110
_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);// 111
this.setFromPoints(_points);return this;},translate:function translate(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});function satForAxes(axes,v0,v1,v2,extents){var i,j;for(i=0,j=axes.length-3;i<=j;i+=3){_testAxis.fromArray(axes,i);// project the aabb onto the seperating axis
var r=extents.x*Math.abs(_testAxis.x)+extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z);// project all 3 vertices of the triangle onto the seperating axis
var p0=v0.dot(_testAxis);var p1=v1.dot(_testAxis);var p2=v2.dot(_testAxis);// actual test, basically see if either of the most extreme of the triangle points intersects r
if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r){// points of the projected triangle are outside the projected half-length of the aabb
// the axis is seperating and we can exit
return false;}}return true;}var _box$1=new Box3();/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */function Sphere(center,radius){this.center=center!==undefined?center:new Vector3();this.radius=radius!==undefined?radius:0;}(0,_assign.default)(Sphere.prototype,{set:function set(center,radius){this.center.copy(center);this.radius=radius;return this;},setFromPoints:function setFromPoints(points,optionalCenter){var center=this.center;if(optionalCenter!==undefined){center.copy(optionalCenter);}else{_box$1.setFromPoints(points).getCenter(center);}var maxRadiusSq=0;for(var i=0,il=points.length;i<il;i++){maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));}this.radius=Math.sqrt(maxRadiusSq);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this;},empty:function empty(){return this.radius<=0;},containsPoint:function containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius;},distanceToPoint:function distanceToPoint(point){return point.distanceTo(this.center)-this.radius;},intersectsSphere:function intersectsSphere(sphere){var radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum;},intersectsBox:function intersectsBox(box){return box.intersectsSphere(this);},intersectsPlane:function intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius;},clampPoint:function clampPoint(point,target){var deltaLengthSq=this.center.distanceToSquared(point);if(target===undefined){console.warn('THREE.Sphere: .clampPoint() target is now required');target=new Vector3();}target.copy(point);if(deltaLengthSq>this.radius*this.radius){target.sub(this.center).normalize();target.multiplyScalar(this.radius).add(this.center);}return target;},getBoundingBox:function getBoundingBox(target){if(target===undefined){console.warn('THREE.Sphere: .getBoundingBox() target is now required');target=new Box3();}target.set(this.center,this.center);target.expandByScalar(this.radius);return target;},applyMatrix4:function applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius=this.radius*matrix.getMaxScaleOnAxis();return this;},translate:function translate(offset){this.center.add(offset);return this;},equals:function equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius;}});var _vector$2=new Vector3();var _segCenter=new Vector3();var _segDir=new Vector3();var _diff=new Vector3();var _edge1=new Vector3();var _edge2=new Vector3();var _normal=new Vector3();/**
 * @author bhouston / http://clara.io
 */function Ray(origin,direction){this.origin=origin!==undefined?origin:new Vector3();this.direction=direction!==undefined?direction:new Vector3(0,0,-1);}(0,_assign.default)(Ray.prototype,{set:function set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this;},at:function at(t,target){if(target===undefined){console.warn('THREE.Ray: .at() target is now required');target=new Vector3();}return target.copy(this.direction).multiplyScalar(t).add(this.origin);},lookAt:function lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this;},recast:function recast(t){this.origin.copy(this.at(t,_vector$2));return this;},closestPointToPoint:function closestPointToPoint(point,target){if(target===undefined){console.warn('THREE.Ray: .closestPointToPoint() target is now required');target=new Vector3();}target.subVectors(point,this.origin);var directionDistance=target.dot(this.direction);if(directionDistance<0){return target.copy(this.origin);}return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);},distanceToPoint:function distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point));},distanceSqToPoint:function distanceSqToPoint(point){var directionDistance=_vector$2.subVectors(point,this.origin).dot(this.direction);// point behind the ray
if(directionDistance<0){return this.origin.distanceToSquared(point);}_vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return _vector$2.distanceToSquared(point);},distanceSqToSegment:function distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
// It returns the min distance between the ray and the segment
// defined by v0 and v1
// It can also set two optional targets :
// - The closest point on the ray
// - The closest point on the segment
_segCenter.copy(v0).add(v1).multiplyScalar(0.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);var segExtent=v0.distanceTo(v1)*0.5;var a01=-this.direction.dot(_segDir);var b0=_diff.dot(this.direction);var b1=-_diff.dot(_segDir);var c=_diff.lengthSq();var det=Math.abs(1-a01*a01);var s0,s1,sqrDist,extDet;if(det>0){// The ray and segment are not parallel.
s0=a01*b1-b0;s1=a01*b0-b1;extDet=segExtent*det;if(s0>=0){if(s1>=-extDet){if(s1<=extDet){// region 0
// Minimum at interior points of ray and segment.
var invDet=1/det;s0*=invDet;s1*=invDet;sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c;}else{// region 1
s1=segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{// region 5
s1=-segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}else{if(s1<=-extDet){// region 4
s0=Math.max(0,-(-a01*segExtent+b0));s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}else if(s1<=extDet){// region 3
s0=0;s1=Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=s1*(s1+2*b1)+c;}else{// region 2
s0=Math.max(0,-(a01*segExtent+b0));s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent);sqrDist=-s0*s0+s1*(s1+2*b1)+c;}}}else{// Ray and segment are parallel.
s1=a01>0?-segExtent:segExtent;s0=Math.max(0,-(a01*s1+b0));sqrDist=-s0*s0+s1*(s1+2*b1)+c;}if(optionalPointOnRay){optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);}if(optionalPointOnSegment){optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);}return sqrDist;},intersectSphere:function intersectSphere(sphere,target){_vector$2.subVectors(sphere.center,this.origin);var tca=_vector$2.dot(this.direction);var d2=_vector$2.dot(_vector$2)-tca*tca;var radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;var thc=Math.sqrt(radius2-d2);// t0 = first intersect point - entrance on front of sphere
var t0=tca-thc;// t1 = second intersect point - exit point on back of sphere
var t1=tca+thc;// test to see if both t0 and t1 are behind the ray - if so, return null
if(t0<0&&t1<0)return null;// test to see if t0 is behind the ray:
// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
// in order to always return an intersect point that is in front of the ray.
if(t0<0)return this.at(t1,target);// else t0 is in front of the ray, so return the first collision point scaled by t0
return this.at(t0,target);},intersectsSphere:function intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius;},distanceToPlane:function distanceToPlane(plane){var denominator=plane.normal.dot(this.direction);if(denominator===0){// line is coplanar, return origin
if(plane.distanceToPoint(this.origin)===0){return 0;}// Null is preferable to undefined since undefined means.... it is undefined
return null;}var t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;// Return if the ray never intersects the plane
return t>=0?t:null;},intersectPlane:function intersectPlane(plane,target){var t=this.distanceToPlane(plane);if(t===null){return null;}return this.at(t,target);},intersectsPlane:function intersectsPlane(plane){// check if the ray lies on the plane first
var distToPoint=plane.distanceToPoint(this.origin);if(distToPoint===0){return true;}var denominator=plane.normal.dot(this.direction);if(denominator*distToPoint<0){return true;}// ray origin is behind the plane (and is pointing behind it)
return false;},intersectBox:function intersectBox(box,target){var tmin,tmax,tymin,tymax,tzmin,tzmax;var invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z;var origin=this.origin;if(invdirx>=0){tmin=(box.min.x-origin.x)*invdirx;tmax=(box.max.x-origin.x)*invdirx;}else{tmin=(box.max.x-origin.x)*invdirx;tmax=(box.min.x-origin.x)*invdirx;}if(invdiry>=0){tymin=(box.min.y-origin.y)*invdiry;tymax=(box.max.y-origin.y)*invdiry;}else{tymin=(box.max.y-origin.y)*invdiry;tymax=(box.min.y-origin.y)*invdiry;}if(tmin>tymax||tymin>tmax)return null;// These lines also handle the case where tmin or tmax is NaN
// (result of 0 * Infinity). x !== x returns true if x is NaN
if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;if(invdirz>=0){tzmin=(box.min.z-origin.z)*invdirz;tzmax=(box.max.z-origin.z)*invdirz;}else{tzmin=(box.max.z-origin.z)*invdirz;tzmax=(box.min.z-origin.z)*invdirz;}if(tmin>tzmax||tzmin>tmax)return null;if(tzmin>tmin||tmin!==tmin)tmin=tzmin;if(tzmax<tmax||tmax!==tmax)tmax=tzmax;//return point closest to the ray (positive side)
if(tmax<0)return null;return this.at(tmin>=0?tmin:tmax,target);},intersectsBox:function intersectsBox(box){return this.intersectBox(box,_vector$2)!==null;},intersectTriangle:function intersectTriangle(a,b,c,backfaceCulling,target){// Compute the offset origin, edges, and normal.
// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
_edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal.crossVectors(_edge1,_edge2);// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
var DdN=this.direction.dot(_normal);var sign;if(DdN>0){if(backfaceCulling)return null;sign=1;}else if(DdN<0){sign=-1;DdN=-DdN;}else{return null;}_diff.subVectors(this.origin,a);var DdQxE2=sign*this.direction.dot(_edge2.crossVectors(_diff,_edge2));// b1 < 0, no intersection
if(DdQxE2<0){return null;}var DdE1xQ=sign*this.direction.dot(_edge1.cross(_diff));// b2 < 0, no intersection
if(DdE1xQ<0){return null;}// b1+b2 > 1, no intersection
if(DdQxE2+DdE1xQ>DdN){return null;}// Line intersects triangle, check if ray does.
var QdN=-sign*_diff.dot(_normal);// t < 0, no intersection
if(QdN<0){return null;}// Ray intersects triangle.
return this.at(QdN/DdN,target);},applyMatrix4:function applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this;},equals:function equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction);}});/**
 * @author bhouston / http://clara.io
 */var _vector1=new Vector3();var _vector2=new Vector3();var _normalMatrix=new Matrix3();function Plane(normal,constant){// normal is assumed to be normalized
this.normal=normal!==undefined?normal:new Vector3(1,0,0);this.constant=constant!==undefined?constant:0;}(0,_assign.default)(Plane.prototype,{isPlane:true,set:function set(normal,constant){this.normal.copy(normal);this.constant=constant;return this;},setComponents:function setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this;},setFromNormalAndCoplanarPoint:function setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;},setFromCoplanarPoints:function setFromCoplanarPoints(a,b,c){var normal=_vector1.subVectors(c,b).cross(_vector2.subVectors(a,b)).normalize();// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
this.setFromNormalAndCoplanarPoint(normal,a);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;},normalize:function normalize(){// Note: will lead to a divide by zero if the plane is invalid.
var inverseNormalLength=1.0/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this;},negate:function negate(){this.constant*=-1;this.normal.negate();return this;},distanceToPoint:function distanceToPoint(point){return this.normal.dot(point)+this.constant;},distanceToSphere:function distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius;},projectPoint:function projectPoint(point,target){if(target===undefined){console.warn('THREE.Plane: .projectPoint() target is now required');target=new Vector3();}return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);},intersectLine:function intersectLine(line,target){if(target===undefined){console.warn('THREE.Plane: .intersectLine() target is now required');target=new Vector3();}var direction=line.delta(_vector1);var denominator=this.normal.dot(direction);if(denominator===0){// line is coplanar, return origin
if(this.distanceToPoint(line.start)===0){return target.copy(line.start);}// Unsure if this is the correct method to handle this case.
return undefined;}var t=-(line.start.dot(this.normal)+this.constant)/denominator;if(t<0||t>1){return undefined;}return target.copy(direction).multiplyScalar(t).add(line.start);},intersectsLine:function intersectsLine(line){// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
var startSign=this.distanceToPoint(line.start);var endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0;},intersectsBox:function intersectsBox(box){return box.intersectsPlane(this);},intersectsSphere:function intersectsSphere(sphere){return sphere.intersectsPlane(this);},coplanarPoint:function coplanarPoint(target){if(target===undefined){console.warn('THREE.Plane: .coplanarPoint() target is now required');target=new Vector3();}return target.copy(this.normal).multiplyScalar(-this.constant);},applyMatrix4:function applyMatrix4(matrix,optionalNormalMatrix){var normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);var referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix);var normal=this.normal.applyMatrix3(normalMatrix).normalize();this.constant=-referencePoint.dot(normal);return this;},translate:function translate(offset){this.constant-=offset.dot(this.normal);return this;},equals:function equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant;}});/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */var _v0$1=new Vector3();var _v1$3=new Vector3();var _v2$1=new Vector3();var _v3=new Vector3();var _vab=new Vector3();var _vac=new Vector3();var _vbc=new Vector3();var _vap=new Vector3();var _vbp=new Vector3();var _vcp=new Vector3();function Triangle(a,b,c){this.a=a!==undefined?a:new Vector3();this.b=b!==undefined?b:new Vector3();this.c=c!==undefined?c:new Vector3();}(0,_assign.default)(Triangle,{getNormal:function getNormal(a,b,c,target){if(target===undefined){console.warn('THREE.Triangle: .getNormal() target is now required');target=new Vector3();}target.subVectors(c,b);_v0$1.subVectors(a,b);target.cross(_v0$1);var targetLengthSq=target.lengthSq();if(targetLengthSq>0){return target.multiplyScalar(1/Math.sqrt(targetLengthSq));}return target.set(0,0,0);},// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
getBarycoord:function getBarycoord(point,a,b,c,target){_v0$1.subVectors(c,a);_v1$3.subVectors(b,a);_v2$1.subVectors(point,a);var dot00=_v0$1.dot(_v0$1);var dot01=_v0$1.dot(_v1$3);var dot02=_v0$1.dot(_v2$1);var dot11=_v1$3.dot(_v1$3);var dot12=_v1$3.dot(_v2$1);var denom=dot00*dot11-dot01*dot01;if(target===undefined){console.warn('THREE.Triangle: .getBarycoord() target is now required');target=new Vector3();}// collinear or singular triangle
if(denom===0){// arbitrary location outside of triangle?
// not sure if this is the best idea, maybe should be returning undefined
return target.set(-2,-1,-1);}var invDenom=1/denom;var u=(dot11*dot02-dot01*dot12)*invDenom;var v=(dot00*dot12-dot01*dot02)*invDenom;// barycentric coordinates must always sum to 1
return target.set(1-u-v,v,u);},containsPoint:function containsPoint(point,a,b,c){Triangle.getBarycoord(point,a,b,c,_v3);return _v3.x>=0&&_v3.y>=0&&_v3.x+_v3.y<=1;},getUV:function getUV(point,p1,p2,p3,uv1,uv2,uv3,target){this.getBarycoord(point,p1,p2,p3,_v3);target.set(0,0);target.addScaledVector(uv1,_v3.x);target.addScaledVector(uv2,_v3.y);target.addScaledVector(uv3,_v3.z);return target;},isFrontFacing:function isFrontFacing(a,b,c,direction){_v0$1.subVectors(c,b);_v1$3.subVectors(a,b);// strictly front facing
return _v0$1.cross(_v1$3).dot(direction)<0?true:false;}});(0,_assign.default)(Triangle.prototype,{set:function set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this;},setFromPointsAndIndices:function setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this;},getArea:function getArea(){_v0$1.subVectors(this.c,this.b);_v1$3.subVectors(this.a,this.b);return _v0$1.cross(_v1$3).length()*0.5;},getMidpoint:function getMidpoint(target){if(target===undefined){console.warn('THREE.Triangle: .getMidpoint() target is now required');target=new Vector3();}return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3);},getNormal:function getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target);},getPlane:function getPlane(target){if(target===undefined){console.warn('THREE.Triangle: .getPlane() target is now required');target=new Plane();}return target.setFromCoplanarPoints(this.a,this.b,this.c);},getBarycoord:function getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target);},getUV:function getUV(point,uv1,uv2,uv3,target){return Triangle.getUV(point,this.a,this.b,this.c,uv1,uv2,uv3,target);},containsPoint:function containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c);},isFrontFacing:function isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction);},intersectsBox:function intersectsBox(box){return box.intersectsTriangle(this);},closestPointToPoint:function closestPointToPoint(p,target){if(target===undefined){console.warn('THREE.Triangle: .closestPointToPoint() target is now required');target=new Vector3();}var a=this.a,b=this.b,c=this.c;var v,w;// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
// under the accompanying license; see chapter 5.1.5 for detailed explanation.
// basically, we're distinguishing which of the voronoi regions of the triangle
// the point lies in with the minimum amount of redundant computation.
_vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);var d1=_vab.dot(_vap);var d2=_vac.dot(_vap);if(d1<=0&&d2<=0){// vertex region of A; barycentric coords (1, 0, 0)
return target.copy(a);}_vbp.subVectors(p,b);var d3=_vab.dot(_vbp);var d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3){// vertex region of B; barycentric coords (0, 1, 0)
return target.copy(b);}var vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0){v=d1/(d1-d3);// edge region of AB; barycentric coords (1-v, v, 0)
return target.copy(a).addScaledVector(_vab,v);}_vcp.subVectors(p,c);var d5=_vab.dot(_vcp);var d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6){// vertex region of C; barycentric coords (0, 0, 1)
return target.copy(c);}var vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0){w=d2/(d2-d6);// edge region of AC; barycentric coords (1-w, 0, w)
return target.copy(a).addScaledVector(_vac,w);}var va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0){_vbc.subVectors(c,b);w=(d4-d3)/(d4-d3+(d5-d6));// edge region of BC; barycentric coords (0, 1-w, w)
return target.copy(b).addScaledVector(_vbc,w);// edge region of BC
}// face region
var denom=1/(va+vb+vc);// u = va * denom
v=vb*denom;w=vc*denom;return target.copy(a).addScaledVector(_vab,v).addScaledVector(_vac,w);},equals:function equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c);}});/**
 * @author mrdoob / http://mrdoob.com/
 */var _colorKeywords={'aliceblue':0xF0F8FF,'antiquewhite':0xFAEBD7,'aqua':0x00FFFF,'aquamarine':0x7FFFD4,'azure':0xF0FFFF,'beige':0xF5F5DC,'bisque':0xFFE4C4,'black':0x000000,'blanchedalmond':0xFFEBCD,'blue':0x0000FF,'blueviolet':0x8A2BE2,'brown':0xA52A2A,'burlywood':0xDEB887,'cadetblue':0x5F9EA0,'chartreuse':0x7FFF00,'chocolate':0xD2691E,'coral':0xFF7F50,'cornflowerblue':0x6495ED,'cornsilk':0xFFF8DC,'crimson':0xDC143C,'cyan':0x00FFFF,'darkblue':0x00008B,'darkcyan':0x008B8B,'darkgoldenrod':0xB8860B,'darkgray':0xA9A9A9,'darkgreen':0x006400,'darkgrey':0xA9A9A9,'darkkhaki':0xBDB76B,'darkmagenta':0x8B008B,'darkolivegreen':0x556B2F,'darkorange':0xFF8C00,'darkorchid':0x9932CC,'darkred':0x8B0000,'darksalmon':0xE9967A,'darkseagreen':0x8FBC8F,'darkslateblue':0x483D8B,'darkslategray':0x2F4F4F,'darkslategrey':0x2F4F4F,'darkturquoise':0x00CED1,'darkviolet':0x9400D3,'deeppink':0xFF1493,'deepskyblue':0x00BFFF,'dimgray':0x696969,'dimgrey':0x696969,'dodgerblue':0x1E90FF,'firebrick':0xB22222,'floralwhite':0xFFFAF0,'forestgreen':0x228B22,'fuchsia':0xFF00FF,'gainsboro':0xDCDCDC,'ghostwhite':0xF8F8FF,'gold':0xFFD700,'goldenrod':0xDAA520,'gray':0x808080,'green':0x008000,'greenyellow':0xADFF2F,'grey':0x808080,'honeydew':0xF0FFF0,'hotpink':0xFF69B4,'indianred':0xCD5C5C,'indigo':0x4B0082,'ivory':0xFFFFF0,'khaki':0xF0E68C,'lavender':0xE6E6FA,'lavenderblush':0xFFF0F5,'lawngreen':0x7CFC00,'lemonchiffon':0xFFFACD,'lightblue':0xADD8E6,'lightcoral':0xF08080,'lightcyan':0xE0FFFF,'lightgoldenrodyellow':0xFAFAD2,'lightgray':0xD3D3D3,'lightgreen':0x90EE90,'lightgrey':0xD3D3D3,'lightpink':0xFFB6C1,'lightsalmon':0xFFA07A,'lightseagreen':0x20B2AA,'lightskyblue':0x87CEFA,'lightslategray':0x778899,'lightslategrey':0x778899,'lightsteelblue':0xB0C4DE,'lightyellow':0xFFFFE0,'lime':0x00FF00,'limegreen':0x32CD32,'linen':0xFAF0E6,'magenta':0xFF00FF,'maroon':0x800000,'mediumaquamarine':0x66CDAA,'mediumblue':0x0000CD,'mediumorchid':0xBA55D3,'mediumpurple':0x9370DB,'mediumseagreen':0x3CB371,'mediumslateblue':0x7B68EE,'mediumspringgreen':0x00FA9A,'mediumturquoise':0x48D1CC,'mediumvioletred':0xC71585,'midnightblue':0x191970,'mintcream':0xF5FFFA,'mistyrose':0xFFE4E1,'moccasin':0xFFE4B5,'navajowhite':0xFFDEAD,'navy':0x000080,'oldlace':0xFDF5E6,'olive':0x808000,'olivedrab':0x6B8E23,'orange':0xFFA500,'orangered':0xFF4500,'orchid':0xDA70D6,'palegoldenrod':0xEEE8AA,'palegreen':0x98FB98,'paleturquoise':0xAFEEEE,'palevioletred':0xDB7093,'papayawhip':0xFFEFD5,'peachpuff':0xFFDAB9,'peru':0xCD853F,'pink':0xFFC0CB,'plum':0xDDA0DD,'powderblue':0xB0E0E6,'purple':0x800080,'rebeccapurple':0x663399,'red':0xFF0000,'rosybrown':0xBC8F8F,'royalblue':0x4169E1,'saddlebrown':0x8B4513,'salmon':0xFA8072,'sandybrown':0xF4A460,'seagreen':0x2E8B57,'seashell':0xFFF5EE,'sienna':0xA0522D,'silver':0xC0C0C0,'skyblue':0x87CEEB,'slateblue':0x6A5ACD,'slategray':0x708090,'slategrey':0x708090,'snow':0xFFFAFA,'springgreen':0x00FF7F,'steelblue':0x4682B4,'tan':0xD2B48C,'teal':0x008080,'thistle':0xD8BFD8,'tomato':0xFF6347,'turquoise':0x40E0D0,'violet':0xEE82EE,'wheat':0xF5DEB3,'white':0xFFFFFF,'whitesmoke':0xF5F5F5,'yellow':0xFFFF00,'yellowgreen':0x9ACD32};var _hslA={h:0,s:0,l:0};var _hslB={h:0,s:0,l:0};function Color(r,g,b){if(g===undefined&&b===undefined){// r is THREE.Color, hex or string
return this.set(r);}return this.setRGB(r,g,b);}function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*6*(2/3-t);return p;}function SRGBToLinear(c){return c<0.04045?c*0.0773993808:Math.pow(c*0.9478672986+0.0521327014,2.4);}function LinearToSRGB(c){return c<0.0031308?c*12.92:1.055*Math.pow(c,0.41666)-0.055;}(0,_assign.default)(Color.prototype,{isColor:true,r:1,g:1,b:1,set:function set(value){if(value&&value.isColor){this.copy(value);}else if(typeof value==='number'){this.setHex(value);}else if(typeof value==='string'){this.setStyle(value);}return this;},setScalar:function setScalar(scalar){this.r=scalar;this.g=scalar;this.b=scalar;return this;},setHex:function setHex(hex){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;return this;},setRGB:function setRGB(r,g,b){this.r=r;this.g=g;this.b=b;return this;},setHSL:function setHSL(h,s,l){// h,s,l ranges are in 0.0 - 1.0
h=MathUtils.euclideanModulo(h,1);s=MathUtils.clamp(s,0,1);l=MathUtils.clamp(l,0,1);if(s===0){this.r=this.g=this.b=l;}else{var p=l<=0.5?l*(1+s):l+s-l*s;var q=2*l-p;this.r=hue2rgb(q,p,h+1/3);this.g=hue2rgb(q,p,h);this.b=hue2rgb(q,p,h-1/3);}return this;},setStyle:function setStyle(style){function handleAlpha(string){if(string===undefined)return;if((0,_parseFloat2.default)(string)<1){console.warn('THREE.Color: Alpha component of '+style+' will be ignored.');}}var m;if(m=/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(style)){// rgb / hsl
var color;var name=m[1];var components=m[2];switch(name){case'rgb':case'rgba':if(color=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(255,0,0) rgba(255,0,0,0.5)
this.r=Math.min(255,(0,_parseInt2.default)(color[1],10))/255;this.g=Math.min(255,(0,_parseInt2.default)(color[2],10))/255;this.b=Math.min(255,(0,_parseInt2.default)(color[3],10))/255;handleAlpha(color[5]);return this;}if(color=/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
this.r=Math.min(100,(0,_parseInt2.default)(color[1],10))/100;this.g=Math.min(100,(0,_parseInt2.default)(color[2],10))/100;this.b=Math.min(100,(0,_parseInt2.default)(color[3],10))/100;handleAlpha(color[5]);return this;}break;case'hsl':case'hsla':if(color=/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(components)){// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
var h=(0,_parseFloat2.default)(color[1])/360;var s=(0,_parseInt2.default)(color[2],10)/100;var l=(0,_parseInt2.default)(color[3],10)/100;handleAlpha(color[5]);return this.setHSL(h,s,l);}break;}}else if(m=/^\#([A-Fa-f0-9]+)$/.exec(style)){// hex color
var hex=m[1];var size=hex.length;if(size===3){// #ff0
this.r=(0,_parseInt2.default)(hex.charAt(0)+hex.charAt(0),16)/255;this.g=(0,_parseInt2.default)(hex.charAt(1)+hex.charAt(1),16)/255;this.b=(0,_parseInt2.default)(hex.charAt(2)+hex.charAt(2),16)/255;return this;}else if(size===6){// #ff0000
this.r=(0,_parseInt2.default)(hex.charAt(0)+hex.charAt(1),16)/255;this.g=(0,_parseInt2.default)(hex.charAt(2)+hex.charAt(3),16)/255;this.b=(0,_parseInt2.default)(hex.charAt(4)+hex.charAt(5),16)/255;return this;}}if(style&&style.length>0){return this.setColorName(style);}return this;},setColorName:function setColorName(style){// color keywords
var hex=_colorKeywords[style];if(hex!==undefined){// red
this.setHex(hex);}else{// unknown color
console.warn('THREE.Color: Unknown color '+style);}return this;},clone:function clone(){return new this.constructor(this.r,this.g,this.b);},copy:function copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this;},copyGammaToLinear:function copyGammaToLinear(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;this.r=Math.pow(color.r,gammaFactor);this.g=Math.pow(color.g,gammaFactor);this.b=Math.pow(color.b,gammaFactor);return this;},copyLinearToGamma:function copyLinearToGamma(color,gammaFactor){if(gammaFactor===undefined)gammaFactor=2.0;var safeInverse=gammaFactor>0?1.0/gammaFactor:1.0;this.r=Math.pow(color.r,safeInverse);this.g=Math.pow(color.g,safeInverse);this.b=Math.pow(color.b,safeInverse);return this;},convertGammaToLinear:function convertGammaToLinear(gammaFactor){this.copyGammaToLinear(this,gammaFactor);return this;},convertLinearToGamma:function convertLinearToGamma(gammaFactor){this.copyLinearToGamma(this,gammaFactor);return this;},copySRGBToLinear:function copySRGBToLinear(color){this.r=SRGBToLinear(color.r);this.g=SRGBToLinear(color.g);this.b=SRGBToLinear(color.b);return this;},copyLinearToSRGB:function copyLinearToSRGB(color){this.r=LinearToSRGB(color.r);this.g=LinearToSRGB(color.g);this.b=LinearToSRGB(color.b);return this;},convertSRGBToLinear:function convertSRGBToLinear(){this.copySRGBToLinear(this);return this;},convertLinearToSRGB:function convertLinearToSRGB(){this.copyLinearToSRGB(this);return this;},getHex:function getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0;},getHexString:function getHexString(){return('000000'+this.getHex().toString(16)).slice(-6);},getHSL:function getHSL(target){// h,s,l ranges are in 0.0 - 1.0
if(target===undefined){console.warn('THREE.Color: .getHSL() target is now required');target={h:0,s:0,l:0};}var r=this.r,g=this.g,b=this.b;var max=Math.max(r,g,b);var min=Math.min(r,g,b);var hue,saturation;var lightness=(min+max)/2.0;if(min===max){hue=0;saturation=0;}else{var delta=max-min;saturation=lightness<=0.5?delta/(max+min):delta/(2-max-min);switch(max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4;break;}hue/=6;}target.h=hue;target.s=saturation;target.l=lightness;return target;},getStyle:function getStyle(){return'rgb('+(this.r*255|0)+','+(this.g*255|0)+','+(this.b*255|0)+')';},offsetHSL:function offsetHSL(h,s,l){this.getHSL(_hslA);_hslA.h+=h;_hslA.s+=s;_hslA.l+=l;this.setHSL(_hslA.h,_hslA.s,_hslA.l);return this;},add:function add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this;},addColors:function addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this;},addScalar:function addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this;},sub:function sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this;},multiply:function multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this;},multiplyScalar:function multiplyScalar(s){this.r*=s;this.g*=s;this.b*=s;return this;},lerp:function lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this;},lerpHSL:function lerpHSL(color,alpha){this.getHSL(_hslA);color.getHSL(_hslB);var h=MathUtils.lerp(_hslA.h,_hslB.h,alpha);var s=MathUtils.lerp(_hslA.s,_hslB.s,alpha);var l=MathUtils.lerp(_hslA.l,_hslB.l,alpha);this.setHSL(h,s,l);return this;},equals:function equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b;},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array;},toJSON:function toJSON(){return this.getHex();}});Color.NAMES=_colorKeywords;/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function Face3(a,b,c,normal,color,materialIndex){this.a=a;this.b=b;this.c=c;this.normal=normal&&normal.isVector3?normal:new Vector3();this.vertexNormals=(0,_isArray.default)(normal)?normal:[];this.color=color&&color.isColor?color:new Color();this.vertexColors=(0,_isArray.default)(color)?color:[];this.materialIndex=materialIndex!==undefined?materialIndex:0;}(0,_assign.default)(Face3.prototype,{clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.a=source.a;this.b=source.b;this.c=source.c;this.normal.copy(source.normal);this.color.copy(source.color);this.materialIndex=source.materialIndex;for(var i=0,il=source.vertexNormals.length;i<il;i++){this.vertexNormals[i]=source.vertexNormals[i].clone();}for(var i=0,il=source.vertexColors.length;i<il;i++){this.vertexColors[i]=source.vertexColors[i].clone();}return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */var materialId=0;function Material(){(0,_defineProperty3.default)(this,'id',{value:materialId++});this.uuid=MathUtils.generateUUID();this.name='';this.type='Material';this.fog=true;this.blending=NormalBlending;this.side=FrontSide;this.flatShading=false;this.vertexColors=false;this.opacity=1;this.transparent=false;this.blendSrc=SrcAlphaFactor;this.blendDst=OneMinusSrcAlphaFactor;this.blendEquation=AddEquation;this.blendSrcAlpha=null;this.blendDstAlpha=null;this.blendEquationAlpha=null;this.depthFunc=LessEqualDepth;this.depthTest=true;this.depthWrite=true;this.stencilWriteMask=0xff;this.stencilFunc=AlwaysStencilFunc;this.stencilRef=0;this.stencilFuncMask=0xff;this.stencilFail=KeepStencilOp;this.stencilZFail=KeepStencilOp;this.stencilZPass=KeepStencilOp;this.stencilWrite=false;this.clippingPlanes=null;this.clipIntersection=false;this.clipShadows=false;this.shadowSide=null;this.colorWrite=true;this.precision=null;// override the renderer's default precision for this material
this.polygonOffset=false;this.polygonOffsetFactor=0;this.polygonOffsetUnits=0;this.dithering=false;this.alphaTest=0;this.premultipliedAlpha=false;this.visible=true;this.toneMapped=true;this.userData={};this.version=0;}Material.prototype=(0,_assign.default)((0,_create.default)(EventDispatcher.prototype),{constructor:Material,isMaterial:true,onBeforeCompile:function onBeforeCompile(){},setValues:function setValues(values){if(values===undefined)return;for(var key in values){var newValue=values[key];if(newValue===undefined){//console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
continue;}// for backward compatability if shading is set in the constructor
if(key==='shading'){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=newValue===FlatShading?true:false;continue;}var currentValue=this[key];if(currentValue===undefined){console.warn("THREE."+this.type+": '"+key+"' is not a property of this material.");continue;}if(currentValue&&currentValue.isColor){currentValue.set(newValue);}else if(currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3){currentValue.copy(newValue);}else{this[key]=newValue;}}},toJSON:function toJSON(meta){var isRoot=meta===undefined||typeof meta==='string';if(isRoot){meta={textures:{},images:{}};}var data={metadata:{version:4.5,type:'Material',generator:'Material.toJSON'}};// standard Material serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.color&&this.color.isColor)data.color=this.color.getHex();if(this.roughness!==undefined)data.roughness=this.roughness;if(this.metalness!==undefined)data.metalness=this.metalness;if(this.sheen&&this.sheen.isColor)data.sheen=this.sheen.getHex();if(this.emissive&&this.emissive.isColor)data.emissive=this.emissive.getHex();if(this.emissiveIntensity&&this.emissiveIntensity!==1)data.emissiveIntensity=this.emissiveIntensity;if(this.specular&&this.specular.isColor)data.specular=this.specular.getHex();if(this.shininess!==undefined)data.shininess=this.shininess;if(this.clearcoat!==undefined)data.clearcoat=this.clearcoat;if(this.clearcoatRoughness!==undefined)data.clearcoatRoughness=this.clearcoatRoughness;if(this.clearcoatMap&&this.clearcoatMap.isTexture){data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid;}if(this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture){data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid;}if(this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture){data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid;data.clearcoatNormalScale=this.clearcoatNormalScale.toArray();}if(this.map&&this.map.isTexture)data.map=this.map.toJSON(meta).uuid;if(this.matcap&&this.matcap.isTexture)data.matcap=this.matcap.toJSON(meta).uuid;if(this.alphaMap&&this.alphaMap.isTexture)data.alphaMap=this.alphaMap.toJSON(meta).uuid;if(this.lightMap&&this.lightMap.isTexture)data.lightMap=this.lightMap.toJSON(meta).uuid;if(this.aoMap&&this.aoMap.isTexture){data.aoMap=this.aoMap.toJSON(meta).uuid;data.aoMapIntensity=this.aoMapIntensity;}if(this.bumpMap&&this.bumpMap.isTexture){data.bumpMap=this.bumpMap.toJSON(meta).uuid;data.bumpScale=this.bumpScale;}if(this.normalMap&&this.normalMap.isTexture){data.normalMap=this.normalMap.toJSON(meta).uuid;data.normalMapType=this.normalMapType;data.normalScale=this.normalScale.toArray();}if(this.displacementMap&&this.displacementMap.isTexture){data.displacementMap=this.displacementMap.toJSON(meta).uuid;data.displacementScale=this.displacementScale;data.displacementBias=this.displacementBias;}if(this.roughnessMap&&this.roughnessMap.isTexture)data.roughnessMap=this.roughnessMap.toJSON(meta).uuid;if(this.metalnessMap&&this.metalnessMap.isTexture)data.metalnessMap=this.metalnessMap.toJSON(meta).uuid;if(this.emissiveMap&&this.emissiveMap.isTexture)data.emissiveMap=this.emissiveMap.toJSON(meta).uuid;if(this.specularMap&&this.specularMap.isTexture)data.specularMap=this.specularMap.toJSON(meta).uuid;if(this.envMap&&this.envMap.isTexture){data.envMap=this.envMap.toJSON(meta).uuid;data.reflectivity=this.reflectivity;// Scale behind envMap
data.refractionRatio=this.refractionRatio;if(this.combine!==undefined)data.combine=this.combine;if(this.envMapIntensity!==undefined)data.envMapIntensity=this.envMapIntensity;}if(this.gradientMap&&this.gradientMap.isTexture){data.gradientMap=this.gradientMap.toJSON(meta).uuid;}if(this.size!==undefined)data.size=this.size;if(this.sizeAttenuation!==undefined)data.sizeAttenuation=this.sizeAttenuation;if(this.blending!==NormalBlending)data.blending=this.blending;if(this.flatShading===true)data.flatShading=this.flatShading;if(this.side!==FrontSide)data.side=this.side;if(this.vertexColors)data.vertexColors=true;if(this.opacity<1)data.opacity=this.opacity;if(this.transparent===true)data.transparent=this.transparent;data.depthFunc=this.depthFunc;data.depthTest=this.depthTest;data.depthWrite=this.depthWrite;data.stencilWrite=this.stencilWrite;data.stencilWriteMask=this.stencilWriteMask;data.stencilFunc=this.stencilFunc;data.stencilRef=this.stencilRef;data.stencilFuncMask=this.stencilFuncMask;data.stencilFail=this.stencilFail;data.stencilZFail=this.stencilZFail;data.stencilZPass=this.stencilZPass;// rotation (SpriteMaterial)
if(this.rotation&&this.rotation!==0)data.rotation=this.rotation;if(this.polygonOffset===true)data.polygonOffset=true;if(this.polygonOffsetFactor!==0)data.polygonOffsetFactor=this.polygonOffsetFactor;if(this.polygonOffsetUnits!==0)data.polygonOffsetUnits=this.polygonOffsetUnits;if(this.linewidth&&this.linewidth!==1)data.linewidth=this.linewidth;if(this.dashSize!==undefined)data.dashSize=this.dashSize;if(this.gapSize!==undefined)data.gapSize=this.gapSize;if(this.scale!==undefined)data.scale=this.scale;if(this.dithering===true)data.dithering=true;if(this.alphaTest>0)data.alphaTest=this.alphaTest;if(this.premultipliedAlpha===true)data.premultipliedAlpha=this.premultipliedAlpha;if(this.wireframe===true)data.wireframe=this.wireframe;if(this.wireframeLinewidth>1)data.wireframeLinewidth=this.wireframeLinewidth;if(this.wireframeLinecap!=='round')data.wireframeLinecap=this.wireframeLinecap;if(this.wireframeLinejoin!=='round')data.wireframeLinejoin=this.wireframeLinejoin;if(this.morphTargets===true)data.morphTargets=true;if(this.morphNormals===true)data.morphNormals=true;if(this.skinning===true)data.skinning=true;if(this.visible===false)data.visible=false;if(this.toneMapped===false)data.toneMapped=false;if((0,_stringify.default)(this.userData)!=='{}')data.userData=this.userData;// TODO: Copied from Object3D.toJSON
function extractFromCache(cache){var values=[];for(var key in cache){var data=cache[key];delete data.metadata;values.push(data);}return values;}if(isRoot){var textures=extractFromCache(meta.textures);var images=extractFromCache(meta.images);if(textures.length>0)data.textures=textures;if(images.length>0)data.images=images;}return data;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.name=source.name;this.fog=source.fog;this.blending=source.blending;this.side=source.side;this.flatShading=source.flatShading;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.stencilWriteMask=source.stencilWriteMask;this.stencilFunc=source.stencilFunc;this.stencilRef=source.stencilRef;this.stencilFuncMask=source.stencilFuncMask;this.stencilFail=source.stencilFail;this.stencilZFail=source.stencilZFail;this.stencilZPass=source.stencilZPass;this.stencilWrite=source.stencilWrite;var srcPlanes=source.clippingPlanes,dstPlanes=null;if(srcPlanes!==null){var n=srcPlanes.length;dstPlanes=new Array(n);for(var i=0;i!==n;++i){dstPlanes[i]=srcPlanes[i].clone();}}this.clippingPlanes=dstPlanes;this.clipIntersection=source.clipIntersection;this.clipShadows=source.clipShadows;this.shadowSide=source.shadowSide;this.colorWrite=source.colorWrite;this.precision=source.precision;this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.premultipliedAlpha=source.premultipliedAlpha;this.visible=source.visible;this.toneMapped=source.toneMapped;this.userData=JSON.parse((0,_stringify.default)(source.userData));return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});(0,_defineProperty3.default)(Material.prototype,'needsUpdate',{set:function set(value){if(value===true)this.version++;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */function MeshBasicMaterial(parameters){Material.call(this);this.type='MeshBasicMaterial';this.color=new Color(0xffffff);// emissive
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.setValues(parameters);}MeshBasicMaterial.prototype=(0,_create.default)(Material.prototype);MeshBasicMaterial.prototype.constructor=MeshBasicMaterial;MeshBasicMaterial.prototype.isMeshBasicMaterial=true;MeshBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 */var _vector$3=new Vector3();function BufferAttribute(array,itemSize,normalized){if((0,_isArray.default)(array)){throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');}this.name='';this.array=array;this.itemSize=itemSize;this.count=array!==undefined?array.length/itemSize:0;this.normalized=normalized===true;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;}(0,_defineProperty3.default)(BufferAttribute.prototype,'needsUpdate',{set:function set(value){if(value===true)this.version++;}});(0,_assign.default)(BufferAttribute.prototype,{isBufferAttribute:true,onUploadCallback:function onUploadCallback(){},setUsage:function setUsage(value){this.usage=value;return this;},copy:function copy(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.usage=source.usage;return this;},copyAt:function copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(var i=0,l=this.itemSize;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},copyArray:function copyArray(array){this.array.set(array);return this;},copyColorsArray:function copyColorsArray(colors){var array=this.array,offset=0;for(var i=0,l=colors.length;i<l;i++){var color=colors[i];if(color===undefined){console.warn('THREE.BufferAttribute.copyColorsArray(): color is undefined',i);color=new Color();}array[offset++]=color.r;array[offset++]=color.g;array[offset++]=color.b;}return this;},copyVector2sArray:function copyVector2sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector2sArray(): vector is undefined',i);vector=new Vector2();}array[offset++]=vector.x;array[offset++]=vector.y;}return this;},copyVector3sArray:function copyVector3sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector3sArray(): vector is undefined',i);vector=new Vector3();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;}return this;},copyVector4sArray:function copyVector4sArray(vectors){var array=this.array,offset=0;for(var i=0,l=vectors.length;i<l;i++){var vector=vectors[i];if(vector===undefined){console.warn('THREE.BufferAttribute.copyVector4sArray(): vector is undefined',i);vector=new Vector4();}array[offset++]=vector.x;array[offset++]=vector.y;array[offset++]=vector.z;array[offset++]=vector.w;}return this;},applyMatrix3:function applyMatrix3(m){for(var i=0,l=this.count;i<l;i++){_vector$3.x=this.getX(i);_vector$3.y=this.getY(i);_vector$3.z=this.getZ(i);_vector$3.applyMatrix3(m);this.setXYZ(i,_vector$3.x,_vector$3.y,_vector$3.z);}return this;},applyMatrix4:function applyMatrix4(m){for(var i=0,l=this.count;i<l;i++){_vector$3.x=this.getX(i);_vector$3.y=this.getY(i);_vector$3.z=this.getZ(i);_vector$3.applyMatrix4(m);this.setXYZ(i,_vector$3.x,_vector$3.y,_vector$3.z);}return this;},applyNormalMatrix:function applyNormalMatrix(m){for(var i=0,l=this.count;i<l;i++){_vector$3.x=this.getX(i);_vector$3.y=this.getY(i);_vector$3.z=this.getZ(i);_vector$3.applyNormalMatrix(m);this.setXYZ(i,_vector$3.x,_vector$3.y,_vector$3.z);}return this;},transformDirection:function transformDirection(m){for(var i=0,l=this.count;i<l;i++){_vector$3.x=this.getX(i);_vector$3.y=this.getY(i);_vector$3.z=this.getZ(i);_vector$3.transformDirection(m);this.setXYZ(i,_vector$3.x,_vector$3.y,_vector$3.z);}return this;},set:function set(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},getX:function getX(index){return this.array[index*this.itemSize];},setX:function setX(index,x){this.array[index*this.itemSize]=x;return this;},getY:function getY(index){return this.array[index*this.itemSize+1];},setY:function setY(index,y){this.array[index*this.itemSize+1]=y;return this;},getZ:function getZ(index){return this.array[index*this.itemSize+2];},setZ:function setZ(index,z){this.array[index*this.itemSize+2]=z;return this;},getW:function getW(index){return this.array[index*this.itemSize+3];},setW:function setW(index,w){this.array[index*this.itemSize+3]=w;return this;},setXY:function setXY(index,x,y){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;return this;},setXYZ:function setXYZ(index,x,y,z){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this;},setXYZW:function setXYZW(index,x,y,z,w){index*=this.itemSize;this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;this.array[index+3]=w;return this;},onUpload:function onUpload(callback){this.onUploadCallback=callback;return this;},clone:function clone(){return new this.constructor(this.array,this.itemSize).copy(this);},toJSON:function toJSON(){return{itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};}});//
function Int8BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int8Array(array),itemSize,normalized);}Int8BufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Int8BufferAttribute.prototype.constructor=Int8BufferAttribute;function Uint8BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint8Array(array),itemSize,normalized);}Uint8BufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Uint8BufferAttribute.prototype.constructor=Uint8BufferAttribute;function Uint8ClampedBufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint8ClampedArray(array),itemSize,normalized);}Uint8ClampedBufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Uint8ClampedBufferAttribute.prototype.constructor=Uint8ClampedBufferAttribute;function Int16BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int16Array(array),itemSize,normalized);}Int16BufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Int16BufferAttribute.prototype.constructor=Int16BufferAttribute;function Uint16BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint16Array(array),itemSize,normalized);}Uint16BufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Uint16BufferAttribute.prototype.constructor=Uint16BufferAttribute;function Int32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Int32Array(array),itemSize,normalized);}Int32BufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Int32BufferAttribute.prototype.constructor=Int32BufferAttribute;function Uint32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Uint32Array(array),itemSize,normalized);}Uint32BufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Uint32BufferAttribute.prototype.constructor=Uint32BufferAttribute;function Float32BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Float32Array(array),itemSize,normalized);}Float32BufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Float32BufferAttribute.prototype.constructor=Float32BufferAttribute;function Float64BufferAttribute(array,itemSize,normalized){BufferAttribute.call(this,new Float64Array(array),itemSize,normalized);}Float64BufferAttribute.prototype=(0,_create.default)(BufferAttribute.prototype);Float64BufferAttribute.prototype.constructor=Float64BufferAttribute;/**
 * @author mrdoob / http://mrdoob.com/
 */function DirectGeometry(){this.vertices=[];this.normals=[];this.colors=[];this.uvs=[];this.uvs2=[];this.groups=[];this.morphTargets={};this.skinWeights=[];this.skinIndices=[];// this.lineDistances = [];
this.boundingBox=null;this.boundingSphere=null;// update flags
this.verticesNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.uvsNeedUpdate=false;this.groupsNeedUpdate=false;}(0,_assign.default)(DirectGeometry.prototype,{computeGroups:function computeGroups(geometry){var group;var groups=[];var materialIndex=undefined;var faces=geometry.faces;for(var i=0;i<faces.length;i++){var face=faces[i];// materials
if(face.materialIndex!==materialIndex){materialIndex=face.materialIndex;if(group!==undefined){group.count=i*3-group.start;groups.push(group);}group={start:i*3,materialIndex:materialIndex};}}if(group!==undefined){group.count=i*3-group.start;groups.push(group);}this.groups=groups;},fromGeometry:function fromGeometry(geometry){var faces=geometry.faces;var vertices=geometry.vertices;var faceVertexUvs=geometry.faceVertexUvs;var hasFaceVertexUv=faceVertexUvs[0]&&faceVertexUvs[0].length>0;var hasFaceVertexUv2=faceVertexUvs[1]&&faceVertexUvs[1].length>0;// morphs
var morphTargets=geometry.morphTargets;var morphTargetsLength=morphTargets.length;var morphTargetsPosition;if(morphTargetsLength>0){morphTargetsPosition=[];for(var i=0;i<morphTargetsLength;i++){morphTargetsPosition[i]={name:morphTargets[i].name,data:[]};}this.morphTargets.position=morphTargetsPosition;}var morphNormals=geometry.morphNormals;var morphNormalsLength=morphNormals.length;var morphTargetsNormal;if(morphNormalsLength>0){morphTargetsNormal=[];for(var i=0;i<morphNormalsLength;i++){morphTargetsNormal[i]={name:morphNormals[i].name,data:[]};}this.morphTargets.normal=morphTargetsNormal;}// skins
var skinIndices=geometry.skinIndices;var skinWeights=geometry.skinWeights;var hasSkinIndices=skinIndices.length===vertices.length;var hasSkinWeights=skinWeights.length===vertices.length;//
if(vertices.length>0&&faces.length===0){console.error('THREE.DirectGeometry: Faceless geometries are not supported.');}for(var i=0;i<faces.length;i++){var face=faces[i];this.vertices.push(vertices[face.a],vertices[face.b],vertices[face.c]);var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){this.normals.push(vertexNormals[0],vertexNormals[1],vertexNormals[2]);}else{var normal=face.normal;this.normals.push(normal,normal,normal);}var vertexColors=face.vertexColors;if(vertexColors.length===3){this.colors.push(vertexColors[0],vertexColors[1],vertexColors[2]);}else{var color=face.color;this.colors.push(color,color,color);}if(hasFaceVertexUv===true){var vertexUvs=faceVertexUvs[0][i];if(vertexUvs!==undefined){this.uvs.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ',i);this.uvs.push(new Vector2(),new Vector2(),new Vector2());}}if(hasFaceVertexUv2===true){var vertexUvs=faceVertexUvs[1][i];if(vertexUvs!==undefined){this.uvs2.push(vertexUvs[0],vertexUvs[1],vertexUvs[2]);}else{console.warn('THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ',i);this.uvs2.push(new Vector2(),new Vector2(),new Vector2());}}// morphs
for(var j=0;j<morphTargetsLength;j++){var morphTarget=morphTargets[j].vertices;morphTargetsPosition[j].data.push(morphTarget[face.a],morphTarget[face.b],morphTarget[face.c]);}for(var j=0;j<morphNormalsLength;j++){var morphNormal=morphNormals[j].vertexNormals[i];morphTargetsNormal[j].data.push(morphNormal.a,morphNormal.b,morphNormal.c);}// skins
if(hasSkinIndices){this.skinIndices.push(skinIndices[face.a],skinIndices[face.b],skinIndices[face.c]);}if(hasSkinWeights){this.skinWeights.push(skinWeights[face.a],skinWeights[face.b],skinWeights[face.c]);}}this.computeGroups(geometry);this.verticesNeedUpdate=geometry.verticesNeedUpdate;this.normalsNeedUpdate=geometry.normalsNeedUpdate;this.colorsNeedUpdate=geometry.colorsNeedUpdate;this.uvsNeedUpdate=geometry.uvsNeedUpdate;this.groupsNeedUpdate=geometry.groupsNeedUpdate;if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function arrayMax(array){if(array.length===0)return-Infinity;var max=array[0];for(var i=1,l=array.length;i<l;++i){if(array[i]>max)max=array[i];}return max;}/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */var _bufferGeometryId=1;// BufferGeometry uses odd numbers as Id
var _m1$2=new Matrix4();var _obj=new Object3D();var _offset=new Vector3();var _box$2=new Box3();var _boxMorphTargets=new Box3();var _vector$4=new Vector3();function BufferGeometry(){(0,_defineProperty3.default)(this,'id',{value:_bufferGeometryId+=2});this.uuid=MathUtils.generateUUID();this.name='';this.type='BufferGeometry';this.index=null;this.attributes={};this.morphAttributes={};this.morphTargetsRelative=false;this.groups=[];this.boundingBox=null;this.boundingSphere=null;this.drawRange={start:0,count:Infinity};this.userData={};}BufferGeometry.prototype=(0,_assign.default)((0,_create.default)(EventDispatcher.prototype),{constructor:BufferGeometry,isBufferGeometry:true,getIndex:function getIndex(){return this.index;},setIndex:function setIndex(index){if((0,_isArray.default)(index)){this.index=new(arrayMax(index)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(index,1);}else{this.index=index;}},getAttribute:function getAttribute(name){return this.attributes[name];},setAttribute:function setAttribute(name,attribute){this.attributes[name]=attribute;return this;},deleteAttribute:function deleteAttribute(name){delete this.attributes[name];return this;},addGroup:function addGroup(start,count,materialIndex){this.groups.push({start:start,count:count,materialIndex:materialIndex!==undefined?materialIndex:0});},clearGroups:function clearGroups(){this.groups=[];},setDrawRange:function setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count;},applyMatrix4:function applyMatrix4(matrix){var position=this.attributes.position;if(position!==undefined){position.applyMatrix4(matrix);position.needsUpdate=true;}var normal=this.attributes.normal;if(normal!==undefined){var normalMatrix=new Matrix3().getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix);normal.needsUpdate=true;}var tangent=this.attributes.tangent;if(tangent!==undefined){tangent.transformDirection(matrix);tangent.needsUpdate=true;}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}return this;},rotateX:function rotateX(angle){// rotate geometry around world x-axis
_m1$2.makeRotationX(angle);this.applyMatrix4(_m1$2);return this;},rotateY:function rotateY(angle){// rotate geometry around world y-axis
_m1$2.makeRotationY(angle);this.applyMatrix4(_m1$2);return this;},rotateZ:function rotateZ(angle){// rotate geometry around world z-axis
_m1$2.makeRotationZ(angle);this.applyMatrix4(_m1$2);return this;},translate:function translate(x,y,z){// translate geometry
_m1$2.makeTranslation(x,y,z);this.applyMatrix4(_m1$2);return this;},scale:function scale(x,y,z){// scale geometry
_m1$2.makeScale(x,y,z);this.applyMatrix4(_m1$2);return this;},lookAt:function lookAt(vector){_obj.lookAt(vector);_obj.updateMatrix();this.applyMatrix4(_obj.matrix);return this;},center:function center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset).negate();this.translate(_offset.x,_offset.y,_offset.z);return this;},setFromObject:function setFromObject(object){// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
var geometry=object.geometry;if(object.isPoints||object.isLine){var positions=new Float32BufferAttribute(geometry.vertices.length*3,3);var colors=new Float32BufferAttribute(geometry.colors.length*3,3);this.setAttribute('position',positions.copyVector3sArray(geometry.vertices));this.setAttribute('color',colors.copyColorsArray(geometry.colors));if(geometry.lineDistances&&geometry.lineDistances.length===geometry.vertices.length){var lineDistances=new Float32BufferAttribute(geometry.lineDistances.length,1);this.setAttribute('lineDistance',lineDistances.copyArray(geometry.lineDistances));}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}}else if(object.isMesh){if(geometry&&geometry.isGeometry){this.fromGeometry(geometry);}}return this;},setFromPoints:function setFromPoints(points){var position=[];for(var i=0,l=points.length;i<l;i++){var point=points[i];position.push(point.x,point.y,point.z||0);}this.setAttribute('position',new Float32BufferAttribute(position,3));return this;},updateFromObject:function updateFromObject(object){var geometry=object.geometry;if(object.isMesh){var direct=geometry.__directGeometry;if(geometry.elementsNeedUpdate===true){direct=undefined;geometry.elementsNeedUpdate=false;}if(direct===undefined){return this.fromGeometry(geometry);}direct.verticesNeedUpdate=geometry.verticesNeedUpdate;direct.normalsNeedUpdate=geometry.normalsNeedUpdate;direct.colorsNeedUpdate=geometry.colorsNeedUpdate;direct.uvsNeedUpdate=geometry.uvsNeedUpdate;direct.groupsNeedUpdate=geometry.groupsNeedUpdate;geometry.verticesNeedUpdate=false;geometry.normalsNeedUpdate=false;geometry.colorsNeedUpdate=false;geometry.uvsNeedUpdate=false;geometry.groupsNeedUpdate=false;geometry=direct;}var attribute;if(geometry.verticesNeedUpdate===true){attribute=this.attributes.position;if(attribute!==undefined){attribute.copyVector3sArray(geometry.vertices);attribute.needsUpdate=true;}geometry.verticesNeedUpdate=false;}if(geometry.normalsNeedUpdate===true){attribute=this.attributes.normal;if(attribute!==undefined){attribute.copyVector3sArray(geometry.normals);attribute.needsUpdate=true;}geometry.normalsNeedUpdate=false;}if(geometry.colorsNeedUpdate===true){attribute=this.attributes.color;if(attribute!==undefined){attribute.copyColorsArray(geometry.colors);attribute.needsUpdate=true;}geometry.colorsNeedUpdate=false;}if(geometry.uvsNeedUpdate){attribute=this.attributes.uv;if(attribute!==undefined){attribute.copyVector2sArray(geometry.uvs);attribute.needsUpdate=true;}geometry.uvsNeedUpdate=false;}if(geometry.lineDistancesNeedUpdate){attribute=this.attributes.lineDistance;if(attribute!==undefined){attribute.copyArray(geometry.lineDistances);attribute.needsUpdate=true;}geometry.lineDistancesNeedUpdate=false;}if(geometry.groupsNeedUpdate){geometry.computeGroups(object.geometry);this.groups=geometry.groups;geometry.groupsNeedUpdate=false;}return this;},fromGeometry:function fromGeometry(geometry){geometry.__directGeometry=new DirectGeometry().fromGeometry(geometry);return this.fromDirectGeometry(geometry.__directGeometry);},fromDirectGeometry:function fromDirectGeometry(geometry){var positions=new Float32Array(geometry.vertices.length*3);this.setAttribute('position',new BufferAttribute(positions,3).copyVector3sArray(geometry.vertices));if(geometry.normals.length>0){var normals=new Float32Array(geometry.normals.length*3);this.setAttribute('normal',new BufferAttribute(normals,3).copyVector3sArray(geometry.normals));}if(geometry.colors.length>0){var colors=new Float32Array(geometry.colors.length*3);this.setAttribute('color',new BufferAttribute(colors,3).copyColorsArray(geometry.colors));}if(geometry.uvs.length>0){var uvs=new Float32Array(geometry.uvs.length*2);this.setAttribute('uv',new BufferAttribute(uvs,2).copyVector2sArray(geometry.uvs));}if(geometry.uvs2.length>0){var uvs2=new Float32Array(geometry.uvs2.length*2);this.setAttribute('uv2',new BufferAttribute(uvs2,2).copyVector2sArray(geometry.uvs2));}// groups
this.groups=geometry.groups;// morphs
for(var name in geometry.morphTargets){var array=[];var morphTargets=geometry.morphTargets[name];for(var i=0,l=morphTargets.length;i<l;i++){var morphTarget=morphTargets[i];var attribute=new Float32BufferAttribute(morphTarget.data.length*3,3);attribute.name=morphTarget.name;array.push(attribute.copyVector3sArray(morphTarget.data));}this.morphAttributes[name]=array;}// skinning
if(geometry.skinIndices.length>0){var skinIndices=new Float32BufferAttribute(geometry.skinIndices.length*4,4);this.setAttribute('skinIndex',skinIndices.copyVector4sArray(geometry.skinIndices));}if(geometry.skinWeights.length>0){var skinWeights=new Float32BufferAttribute(geometry.skinWeights.length*4,4);this.setAttribute('skinWeight',skinWeights.copyVector4sArray(geometry.skinWeights));}//
if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}return this;},computeBoundingBox:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}var position=this.attributes.position;var morphAttributesPosition=this.morphAttributes.position;if(position!==undefined){this.boundingBox.setFromBufferAttribute(position);// process morph attributes if present
if(morphAttributesPosition){for(var i=0,il=morphAttributesPosition.length;i<il;i++){var morphAttribute=morphAttributesPosition[i];_box$2.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$4.addVectors(this.boundingBox.min,_box$2.min);this.boundingBox.expandByPoint(_vector$4);_vector$4.addVectors(this.boundingBox.max,_box$2.max);this.boundingBox.expandByPoint(_vector$4);}else{this.boundingBox.expandByPoint(_box$2.min);this.boundingBox.expandByPoint(_box$2.max);}}}}else{this.boundingBox.makeEmpty();}if(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z)){console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this);}},computeBoundingSphere:function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}var position=this.attributes.position;var morphAttributesPosition=this.morphAttributes.position;if(position){// first, find the center of the bounding sphere
var center=this.boundingSphere.center;_box$2.setFromBufferAttribute(position);// process morph attributes if present
if(morphAttributesPosition){for(var i=0,il=morphAttributesPosition.length;i<il;i++){var morphAttribute=morphAttributesPosition[i];_boxMorphTargets.setFromBufferAttribute(morphAttribute);if(this.morphTargetsRelative){_vector$4.addVectors(_box$2.min,_boxMorphTargets.min);_box$2.expandByPoint(_vector$4);_vector$4.addVectors(_box$2.max,_boxMorphTargets.max);_box$2.expandByPoint(_vector$4);}else{_box$2.expandByPoint(_boxMorphTargets.min);_box$2.expandByPoint(_boxMorphTargets.max);}}}_box$2.getCenter(center);// second, try to find a boundingSphere with a radius smaller than the
// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
var maxRadiusSq=0;for(var i=0,il=position.count;i<il;i++){_vector$4.fromBufferAttribute(position,i);maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$4));}// process morph attributes if present
if(morphAttributesPosition){for(var i=0,il=morphAttributesPosition.length;i<il;i++){var morphAttribute=morphAttributesPosition[i];var morphTargetsRelative=this.morphTargetsRelative;for(var j=0,jl=morphAttribute.count;j<jl;j++){_vector$4.fromBufferAttribute(morphAttribute,j);if(morphTargetsRelative){_offset.fromBufferAttribute(position,j);_vector$4.add(_offset);}maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$4));}}}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);if(isNaN(this.boundingSphere.radius)){console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this);}}},computeFaceNormals:function computeFaceNormals(){// backwards compatibility
},computeVertexNormals:function computeVertexNormals(){var index=this.index;var attributes=this.attributes;if(attributes.position){var positions=attributes.position.array;if(attributes.normal===undefined){this.setAttribute('normal',new BufferAttribute(new Float32Array(positions.length),3));}else{// reset existing normals to zero
var array=attributes.normal.array;for(var i=0,il=array.length;i<il;i++){array[i]=0;}}var normals=attributes.normal.array;var vA,vB,vC;var pA=new Vector3(),pB=new Vector3(),pC=new Vector3();var cb=new Vector3(),ab=new Vector3();// indexed elements
if(index){var indices=index.array;for(var i=0,il=index.count;i<il;i+=3){vA=indices[i+0]*3;vB=indices[i+1]*3;vC=indices[i+2]*3;pA.fromArray(positions,vA);pB.fromArray(positions,vB);pC.fromArray(positions,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[vA]+=cb.x;normals[vA+1]+=cb.y;normals[vA+2]+=cb.z;normals[vB]+=cb.x;normals[vB+1]+=cb.y;normals[vB+2]+=cb.z;normals[vC]+=cb.x;normals[vC+1]+=cb.y;normals[vC+2]+=cb.z;}}else{// non-indexed elements (unconnected triangle soup)
for(var i=0,il=positions.length;i<il;i+=9){pA.fromArray(positions,i);pB.fromArray(positions,i+3);pC.fromArray(positions,i+6);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);normals[i]=cb.x;normals[i+1]=cb.y;normals[i+2]=cb.z;normals[i+3]=cb.x;normals[i+4]=cb.y;normals[i+5]=cb.z;normals[i+6]=cb.x;normals[i+7]=cb.y;normals[i+8]=cb.z;}}this.normalizeNormals();attributes.normal.needsUpdate=true;}},merge:function merge(geometry,offset){if(!(geometry&&geometry.isBufferGeometry)){console.error('THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',geometry);return;}if(offset===undefined){offset=0;console.warn('THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '+'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.');}var attributes=this.attributes;for(var key in attributes){if(geometry.attributes[key]===undefined)continue;var attribute1=attributes[key];var attributeArray1=attribute1.array;var attribute2=geometry.attributes[key];var attributeArray2=attribute2.array;var attributeOffset=attribute2.itemSize*offset;var length=Math.min(attributeArray2.length,attributeArray1.length-attributeOffset);for(var i=0,j=attributeOffset;i<length;i++,j++){attributeArray1[j]=attributeArray2[i];}}return this;},normalizeNormals:function normalizeNormals(){var normals=this.attributes.normal;for(var i=0,il=normals.count;i<il;i++){_vector$4.x=normals.getX(i);_vector$4.y=normals.getY(i);_vector$4.z=normals.getZ(i);_vector$4.normalize();normals.setXYZ(i,_vector$4.x,_vector$4.y,_vector$4.z);}},toNonIndexed:function toNonIndexed(){function convertBufferAttribute(attribute,indices){var array=attribute.array;var itemSize=attribute.itemSize;var array2=new array.constructor(indices.length*itemSize);var index=0,index2=0;for(var i=0,l=indices.length;i<l;i++){index=indices[i]*itemSize;for(var j=0;j<itemSize;j++){array2[index2++]=array[index++];}}return new BufferAttribute(array2,itemSize);}//
if(this.index===null){console.warn('THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.');return this;}var geometry2=new BufferGeometry();var indices=this.index.array;var attributes=this.attributes;// attributes
for(var name in attributes){var attribute=attributes[name];var newAttribute=convertBufferAttribute(attribute,indices);geometry2.setAttribute(name,newAttribute);}// morph attributes
var morphAttributes=this.morphAttributes;for(name in morphAttributes){var morphArray=[];var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
for(var i=0,il=morphAttribute.length;i<il;i++){var attribute=morphAttribute[i];var newAttribute=convertBufferAttribute(attribute,indices);morphArray.push(newAttribute);}geometry2.morphAttributes[name]=morphArray;}geometry2.morphTargetsRelative=this.morphTargetsRelative;// groups
var groups=this.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];geometry2.addGroup(group.start,group.count,group.materialIndex);}return geometry2;},toJSON:function toJSON(){var data={metadata:{version:4.5,type:'BufferGeometry',generator:'BufferGeometry.toJSON'}};// standard BufferGeometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if((0,_keys.default)(this.userData).length>0)data.userData=this.userData;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}data.data={attributes:{}};var index=this.index;if(index!==null){data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)};}var attributes=this.attributes;for(var key in attributes){var attribute=attributes[key];var attributeData=attribute.toJSON();if(attribute.name!=='')attributeData.name=attribute.name;data.data.attributes[key]=attributeData;}var morphAttributes={};var hasMorphAttributes=false;for(var key in this.morphAttributes){var attributeArray=this.morphAttributes[key];var array=[];for(var i=0,il=attributeArray.length;i<il;i++){var attribute=attributeArray[i];var attributeData=attribute.toJSON();if(attribute.name!=='')attributeData.name=attribute.name;array.push(attributeData);}if(array.length>0){morphAttributes[key]=array;hasMorphAttributes=true;}}if(hasMorphAttributes){data.data.morphAttributes=morphAttributes;data.data.morphTargetsRelative=this.morphTargetsRelative;}var groups=this.groups;if(groups.length>0){data.data.groups=JSON.parse((0,_stringify.default)(groups));}var boundingSphere=this.boundingSphere;if(boundingSphere!==null){data.data.boundingSphere={center:boundingSphere.center.toArray(),radius:boundingSphere.radius};}return data;},clone:function clone(){/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */return new BufferGeometry().copy(this);},copy:function copy(source){var name,i,l;// reset
this.index=null;this.attributes={};this.morphAttributes={};this.groups=[];this.boundingBox=null;this.boundingSphere=null;// name
this.name=source.name;// index
var index=source.index;if(index!==null){this.setIndex(index.clone());}// attributes
var attributes=source.attributes;for(name in attributes){var attribute=attributes[name];this.setAttribute(name,attribute.clone());}// morph attributes
var morphAttributes=source.morphAttributes;for(name in morphAttributes){var array=[];var morphAttribute=morphAttributes[name];// morphAttribute: array of Float32BufferAttributes
for(i=0,l=morphAttribute.length;i<l;i++){array.push(morphAttribute[i].clone());}this.morphAttributes[name]=array;}this.morphTargetsRelative=source.morphTargetsRelative;// groups
var groups=source.groups;for(i=0,l=groups.length;i<l;i++){var group=groups[i];this.addGroup(group.start,group.count,group.materialIndex);}// bounding box
var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// draw range
this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;// user data
this.userData=source.userData;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */var _inverseMatrix=new Matrix4();var _ray=new Ray();var _sphere=new Sphere();var _vA=new Vector3();var _vB=new Vector3();var _vC=new Vector3();var _tempA=new Vector3();var _tempB=new Vector3();var _tempC=new Vector3();var _morphA=new Vector3();var _morphB=new Vector3();var _morphC=new Vector3();var _uvA=new Vector2();var _uvB=new Vector2();var _uvC=new Vector2();var _intersectionPoint=new Vector3();var _intersectionPointWorld=new Vector3();function Mesh(geometry,material){Object3D.call(this);this.type='Mesh';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new MeshBasicMaterial();this.updateMorphTargets();}Mesh.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Mesh,isMesh:true,copy:function copy(source){Object3D.prototype.copy.call(this,source);if(source.morphTargetInfluences!==undefined){this.morphTargetInfluences=source.morphTargetInfluences.slice();}if(source.morphTargetDictionary!==undefined){this.morphTargetDictionary=(0,_assign.default)({},source.morphTargetDictionary);}return this;},updateMorphTargets:function updateMorphTargets(){var geometry=this.geometry;var m,ml,name;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=(0,_keys.default)(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(m=0,ml=morphAttribute.length;m<ml;m++){name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else{var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}}},raycast:function raycast(raycaster,intersects){var geometry=this.geometry;var material=this.material;var matrixWorld=this.matrixWorld;if(material===undefined)return;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere.copy(geometry.boundingSphere);_sphere.applyMatrix4(matrixWorld);if(raycaster.ray.intersectsSphere(_sphere)===false)return;//
_inverseMatrix.getInverse(matrixWorld);_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);// Check boundingBox before continuing
if(geometry.boundingBox!==null){if(_ray.intersectsBox(geometry.boundingBox)===false)return;}var intersection;if(geometry.isBufferGeometry){var a,b,c;var index=geometry.index;var position=geometry.attributes.position;var morphPosition=geometry.morphAttributes.position;var morphTargetsRelative=geometry.morphTargetsRelative;var uv=geometry.attributes.uv;var uv2=geometry.attributes.uv2;var groups=geometry.groups;var drawRange=geometry.drawRange;var i,j,il,jl;var group,groupMaterial;var start,end;if(index!==null){// indexed buffer geometry
if((0,_isArray.default)(material)){for(i=0,il=groups.length;i<il;i++){group=groups[i];groupMaterial=material[group.materialIndex];start=Math.max(group.start,drawRange.start);end=Math.min(group.start+group.count,drawRange.start+drawRange.count);for(j=start,jl=end;j<jl;j+=3){a=index.getX(j);b=index.getX(j+1);c=index.getX(j+2);intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in indexed buffer semantics
intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else{start=Math.max(0,drawRange.start);end=Math.min(index.count,drawRange.start+drawRange.count);for(i=start,il=end;i<il;i+=3){a=index.getX(i);b=index.getX(i+1);c=index.getX(i+2);intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in indexed buffer semantics
intersects.push(intersection);}}}}else if(position!==undefined){// non-indexed buffer geometry
if((0,_isArray.default)(material)){for(i=0,il=groups.length;i<il;i++){group=groups[i];groupMaterial=material[group.materialIndex];start=Math.max(group.start,drawRange.start);end=Math.min(group.start+group.count,drawRange.start+drawRange.count);for(j=start,jl=end;j<jl;j+=3){a=j;b=j+1;c=j+2;intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(j/3);// triangle number in non-indexed buffer semantics
intersection.face.materialIndex=group.materialIndex;intersects.push(intersection);}}}}else{start=Math.max(0,drawRange.start);end=Math.min(position.count,drawRange.start+drawRange.count);for(i=start,il=end;i<il;i+=3){a=i;b=i+1;c=i+2;intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c);if(intersection){intersection.faceIndex=Math.floor(i/3);// triangle number in non-indexed buffer semantics
intersects.push(intersection);}}}}}else if(geometry.isGeometry){var fvA,fvB,fvC;var isMultiMaterial=(0,_isArray.default)(material);var vertices=geometry.vertices;var faces=geometry.faces;var uvs;var faceVertexUvs=geometry.faceVertexUvs[0];if(faceVertexUvs.length>0)uvs=faceVertexUvs;for(var f=0,fl=faces.length;f<fl;f++){var face=faces[f];var faceMaterial=isMultiMaterial?material[face.materialIndex]:material;if(faceMaterial===undefined)continue;fvA=vertices[face.a];fvB=vertices[face.b];fvC=vertices[face.c];intersection=checkIntersection(this,faceMaterial,raycaster,_ray,fvA,fvB,fvC,_intersectionPoint);if(intersection){if(uvs&&uvs[f]){var uvs_f=uvs[f];_uvA.copy(uvs_f[0]);_uvB.copy(uvs_f[1]);_uvC.copy(uvs_f[2]);intersection.uv=Triangle.getUV(_intersectionPoint,fvA,fvB,fvC,_uvA,_uvB,_uvC,new Vector2());}intersection.face=face;intersection.faceIndex=f;intersects.push(intersection);}}}},clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});function checkIntersection(object,material,raycaster,ray,pA,pB,pC,point){var intersect;if(material.side===BackSide){intersect=ray.intersectTriangle(pC,pB,pA,true,point);}else{intersect=ray.intersectTriangle(pA,pB,pC,material.side!==DoubleSide,point);}if(intersect===null)return null;_intersectionPointWorld.copy(point);_intersectionPointWorld.applyMatrix4(object.matrixWorld);var distance=raycaster.ray.origin.distanceTo(_intersectionPointWorld);if(distance<raycaster.near||distance>raycaster.far)return null;return{distance:distance,point:_intersectionPointWorld.clone(),object:object};}function checkBufferGeometryIntersection(object,material,raycaster,ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c){_vA.fromBufferAttribute(position,a);_vB.fromBufferAttribute(position,b);_vC.fromBufferAttribute(position,c);var morphInfluences=object.morphTargetInfluences;if(material.morphTargets&&morphPosition&&morphInfluences){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(var i=0,il=morphPosition.length;i<il;i++){var influence=morphInfluences[i];var morphAttribute=morphPosition[i];if(influence===0)continue;_tempA.fromBufferAttribute(morphAttribute,a);_tempB.fromBufferAttribute(morphAttribute,b);_tempC.fromBufferAttribute(morphAttribute,c);if(morphTargetsRelative){_morphA.addScaledVector(_tempA,influence);_morphB.addScaledVector(_tempB,influence);_morphC.addScaledVector(_tempC,influence);}else{_morphA.addScaledVector(_tempA.sub(_vA),influence);_morphB.addScaledVector(_tempB.sub(_vB),influence);_morphC.addScaledVector(_tempC.sub(_vC),influence);}}_vA.add(_morphA);_vB.add(_morphB);_vC.add(_morphC);}var intersection=checkIntersection(object,material,raycaster,ray,_vA,_vB,_vC,_intersectionPoint);if(intersection){if(uv){_uvA.fromBufferAttribute(uv,a);_uvB.fromBufferAttribute(uv,b);_uvC.fromBufferAttribute(uv,c);intersection.uv=Triangle.getUV(_intersectionPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2());}if(uv2){_uvA.fromBufferAttribute(uv2,a);_uvB.fromBufferAttribute(uv2,b);_uvC.fromBufferAttribute(uv2,c);intersection.uv2=Triangle.getUV(_intersectionPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2());}var face=new Face3(a,b,c);Triangle.getNormal(_vA,_vB,_vC,face.normal);intersection.face=face;}return intersection;}/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */var _geometryId=0;// Geometry uses even numbers as Id
var _m1$3=new Matrix4();var _obj$1=new Object3D();var _offset$1=new Vector3();function Geometry(){(0,_defineProperty3.default)(this,'id',{value:_geometryId+=2});this.uuid=MathUtils.generateUUID();this.name='';this.type='Geometry';this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// update flags
this.elementsNeedUpdate=false;this.verticesNeedUpdate=false;this.uvsNeedUpdate=false;this.normalsNeedUpdate=false;this.colorsNeedUpdate=false;this.lineDistancesNeedUpdate=false;this.groupsNeedUpdate=false;}Geometry.prototype=(0,_assign.default)((0,_create.default)(EventDispatcher.prototype),{constructor:Geometry,isGeometry:true,applyMatrix4:function applyMatrix4(matrix){var normalMatrix=new Matrix3().getNormalMatrix(matrix);for(var i=0,il=this.vertices.length;i<il;i++){var vertex=this.vertices[i];vertex.applyMatrix4(matrix);}for(var i=0,il=this.faces.length;i<il;i++){var face=this.faces[i];face.normal.applyMatrix3(normalMatrix).normalize();for(var j=0,jl=face.vertexNormals.length;j<jl;j++){face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();}}if(this.boundingBox!==null){this.computeBoundingBox();}if(this.boundingSphere!==null){this.computeBoundingSphere();}this.verticesNeedUpdate=true;this.normalsNeedUpdate=true;return this;},rotateX:function rotateX(angle){// rotate geometry around world x-axis
_m1$3.makeRotationX(angle);this.applyMatrix4(_m1$3);return this;},rotateY:function rotateY(angle){// rotate geometry around world y-axis
_m1$3.makeRotationY(angle);this.applyMatrix4(_m1$3);return this;},rotateZ:function rotateZ(angle){// rotate geometry around world z-axis
_m1$3.makeRotationZ(angle);this.applyMatrix4(_m1$3);return this;},translate:function translate(x,y,z){// translate geometry
_m1$3.makeTranslation(x,y,z);this.applyMatrix4(_m1$3);return this;},scale:function scale(x,y,z){// scale geometry
_m1$3.makeScale(x,y,z);this.applyMatrix4(_m1$3);return this;},lookAt:function lookAt(vector){_obj$1.lookAt(vector);_obj$1.updateMatrix();this.applyMatrix4(_obj$1.matrix);return this;},fromBufferGeometry:function fromBufferGeometry(geometry){var scope=this;var indices=geometry.index!==null?geometry.index.array:undefined;var attributes=geometry.attributes;if(attributes.position===undefined){console.error('THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.');return this;}var positions=attributes.position.array;var normals=attributes.normal!==undefined?attributes.normal.array:undefined;var colors=attributes.color!==undefined?attributes.color.array:undefined;var uvs=attributes.uv!==undefined?attributes.uv.array:undefined;var uvs2=attributes.uv2!==undefined?attributes.uv2.array:undefined;if(uvs2!==undefined)this.faceVertexUvs[1]=[];for(var i=0;i<positions.length;i+=3){scope.vertices.push(new Vector3().fromArray(positions,i));if(colors!==undefined){scope.colors.push(new Color().fromArray(colors,i));}}function addFace(a,b,c,materialIndex){var vertexColors=colors===undefined?[]:[scope.colors[a].clone(),scope.colors[b].clone(),scope.colors[c].clone()];var vertexNormals=normals===undefined?[]:[new Vector3().fromArray(normals,a*3),new Vector3().fromArray(normals,b*3),new Vector3().fromArray(normals,c*3)];var face=new Face3(a,b,c,vertexNormals,vertexColors,materialIndex);scope.faces.push(face);if(uvs!==undefined){scope.faceVertexUvs[0].push([new Vector2().fromArray(uvs,a*2),new Vector2().fromArray(uvs,b*2),new Vector2().fromArray(uvs,c*2)]);}if(uvs2!==undefined){scope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2,a*2),new Vector2().fromArray(uvs2,b*2),new Vector2().fromArray(uvs2,c*2)]);}}var groups=geometry.groups;if(groups.length>0){for(var i=0;i<groups.length;i++){var group=groups[i];var start=group.start;var count=group.count;for(var j=start,jl=start+count;j<jl;j+=3){if(indices!==undefined){addFace(indices[j],indices[j+1],indices[j+2],group.materialIndex);}else{addFace(j,j+1,j+2,group.materialIndex);}}}}else{if(indices!==undefined){for(var i=0;i<indices.length;i+=3){addFace(indices[i],indices[i+1],indices[i+2]);}}else{for(var i=0;i<positions.length/3;i+=3){addFace(i,i+1,i+2);}}}this.computeFaceNormals();if(geometry.boundingBox!==null){this.boundingBox=geometry.boundingBox.clone();}if(geometry.boundingSphere!==null){this.boundingSphere=geometry.boundingSphere.clone();}return this;},center:function center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset$1).negate();this.translate(_offset$1.x,_offset$1.y,_offset$1.z);return this;},normalize:function normalize(){this.computeBoundingSphere();var center=this.boundingSphere.center;var radius=this.boundingSphere.radius;var s=radius===0?1:1.0/radius;var matrix=new Matrix4();matrix.set(s,0,0,-s*center.x,0,s,0,-s*center.y,0,0,s,-s*center.z,0,0,0,1);this.applyMatrix4(matrix);return this;},computeFaceNormals:function computeFaceNormals(){var cb=new Vector3(),ab=new Vector3();for(var f=0,fl=this.faces.length;f<fl;f++){var face=this.faces[f];var vA=this.vertices[face.a];var vB=this.vertices[face.b];var vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);cb.normalize();face.normal.copy(cb);}},computeVertexNormals:function computeVertexNormals(areaWeighted){if(areaWeighted===undefined)areaWeighted=true;var v,vl,f,fl,face,vertices;vertices=new Array(this.vertices.length);for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v]=new Vector3();}if(areaWeighted){// vertex normals weighted by triangle areas
// http://www.iquilezles.org/www/articles/normals/normals.htm
var vA,vB,vC;var cb=new Vector3(),ab=new Vector3();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vA=this.vertices[face.a];vB=this.vertices[face.b];vC=this.vertices[face.c];cb.subVectors(vC,vB);ab.subVectors(vA,vB);cb.cross(ab);vertices[face.a].add(cb);vertices[face.b].add(cb);vertices[face.c].add(cb);}}else{this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];vertices[face.a].add(face.normal);vertices[face.b].add(face.normal);vertices[face.c].add(face.normal);}}for(v=0,vl=this.vertices.length;v<vl;v++){vertices[v].normalize();}for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(vertices[face.a]);vertexNormals[1].copy(vertices[face.b]);vertexNormals[2].copy(vertices[face.c]);}else{vertexNormals[0]=vertices[face.a].clone();vertexNormals[1]=vertices[face.b].clone();vertexNormals[2]=vertices[face.c].clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeFlatVertexNormals:function computeFlatVertexNormals(){var f,fl,face;this.computeFaceNormals();for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];var vertexNormals=face.vertexNormals;if(vertexNormals.length===3){vertexNormals[0].copy(face.normal);vertexNormals[1].copy(face.normal);vertexNormals[2].copy(face.normal);}else{vertexNormals[0]=face.normal.clone();vertexNormals[1]=face.normal.clone();vertexNormals[2]=face.normal.clone();}}if(this.faces.length>0){this.normalsNeedUpdate=true;}},computeMorphNormals:function computeMorphNormals(){var i,il,f,fl,face;// save original normals
// - create temp variables on first access
//   otherwise just copy (for faster repeated calls)
for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];if(!face.__originalFaceNormal){face.__originalFaceNormal=face.normal.clone();}else{face.__originalFaceNormal.copy(face.normal);}if(!face.__originalVertexNormals)face.__originalVertexNormals=[];for(i=0,il=face.vertexNormals.length;i<il;i++){if(!face.__originalVertexNormals[i]){face.__originalVertexNormals[i]=face.vertexNormals[i].clone();}else{face.__originalVertexNormals[i].copy(face.vertexNormals[i]);}}}// use temp geometry to compute face and vertex normals for each morph
var tmpGeo=new Geometry();tmpGeo.faces=this.faces;for(i=0,il=this.morphTargets.length;i<il;i++){// create on first access
if(!this.morphNormals[i]){this.morphNormals[i]={};this.morphNormals[i].faceNormals=[];this.morphNormals[i].vertexNormals=[];var dstNormalsFace=this.morphNormals[i].faceNormals;var dstNormalsVertex=this.morphNormals[i].vertexNormals;var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){faceNormal=new Vector3();vertexNormals={a:new Vector3(),b:new Vector3(),c:new Vector3()};dstNormalsFace.push(faceNormal);dstNormalsVertex.push(vertexNormals);}}var morphNormals=this.morphNormals[i];// set vertices to morph target
tmpGeo.vertices=this.morphTargets[i].vertices;// compute morph normals
tmpGeo.computeFaceNormals();tmpGeo.computeVertexNormals();// store morph normals
var faceNormal,vertexNormals;for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];faceNormal=morphNormals.faceNormals[f];vertexNormals=morphNormals.vertexNormals[f];faceNormal.copy(face.normal);vertexNormals.a.copy(face.vertexNormals[0]);vertexNormals.b.copy(face.vertexNormals[1]);vertexNormals.c.copy(face.vertexNormals[2]);}}// restore original normals
for(f=0,fl=this.faces.length;f<fl;f++){face=this.faces[f];face.normal=face.__originalFaceNormal;face.vertexNormals=face.__originalVertexNormals;}},computeBoundingBox:function computeBoundingBox(){if(this.boundingBox===null){this.boundingBox=new Box3();}this.boundingBox.setFromPoints(this.vertices);},computeBoundingSphere:function computeBoundingSphere(){if(this.boundingSphere===null){this.boundingSphere=new Sphere();}this.boundingSphere.setFromPoints(this.vertices);},merge:function merge(geometry,matrix,materialIndexOffset){if(!(geometry&&geometry.isGeometry)){console.error('THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.',geometry);return;}var normalMatrix,vertexOffset=this.vertices.length,vertices1=this.vertices,vertices2=geometry.vertices,faces1=this.faces,faces2=geometry.faces,colors1=this.colors,colors2=geometry.colors;if(materialIndexOffset===undefined)materialIndexOffset=0;if(matrix!==undefined){normalMatrix=new Matrix3().getNormalMatrix(matrix);}// vertices
for(var i=0,il=vertices2.length;i<il;i++){var vertex=vertices2[i];var vertexCopy=vertex.clone();if(matrix!==undefined)vertexCopy.applyMatrix4(matrix);vertices1.push(vertexCopy);}// colors
for(var i=0,il=colors2.length;i<il;i++){colors1.push(colors2[i].clone());}// faces
for(i=0,il=faces2.length;i<il;i++){var face=faces2[i],faceCopy,normal,color,faceVertexNormals=face.vertexNormals,faceVertexColors=face.vertexColors;faceCopy=new Face3(face.a+vertexOffset,face.b+vertexOffset,face.c+vertexOffset);faceCopy.normal.copy(face.normal);if(normalMatrix!==undefined){faceCopy.normal.applyMatrix3(normalMatrix).normalize();}for(var j=0,jl=faceVertexNormals.length;j<jl;j++){normal=faceVertexNormals[j].clone();if(normalMatrix!==undefined){normal.applyMatrix3(normalMatrix).normalize();}faceCopy.vertexNormals.push(normal);}faceCopy.color.copy(face.color);for(var j=0,jl=faceVertexColors.length;j<jl;j++){color=faceVertexColors[j];faceCopy.vertexColors.push(color.clone());}faceCopy.materialIndex=face.materialIndex+materialIndexOffset;faces1.push(faceCopy);}// uvs
for(var i=0,il=geometry.faceVertexUvs.length;i<il;i++){var faceVertexUvs2=geometry.faceVertexUvs[i];if(this.faceVertexUvs[i]===undefined)this.faceVertexUvs[i]=[];for(var j=0,jl=faceVertexUvs2.length;j<jl;j++){var uvs2=faceVertexUvs2[j],uvsCopy=[];for(var k=0,kl=uvs2.length;k<kl;k++){uvsCopy.push(uvs2[k].clone());}this.faceVertexUvs[i].push(uvsCopy);}}},mergeMesh:function mergeMesh(mesh){if(!(mesh&&mesh.isMesh)){console.error('THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.',mesh);return;}if(mesh.matrixAutoUpdate)mesh.updateMatrix();this.merge(mesh.geometry,mesh.matrix);},/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */mergeVertices:function mergeVertices(){var verticesMap={};// Hashmap for looking up vertices by position coordinates (and making sure they are unique)
var unique=[],changes=[];var v,key;var precisionPoints=4;// number of decimal points, e.g. 4 for epsilon of 0.0001
var precision=Math.pow(10,precisionPoints);var i,il,face;var indices,j,jl;for(i=0,il=this.vertices.length;i<il;i++){v=this.vertices[i];key=Math.round(v.x*precision)+'_'+Math.round(v.y*precision)+'_'+Math.round(v.z*precision);if(verticesMap[key]===undefined){verticesMap[key]=i;unique.push(this.vertices[i]);changes[i]=unique.length-1;}else{//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
changes[i]=changes[verticesMap[key]];}}// if faces are completely degenerate after merging vertices, we
// have to remove them from the geometry.
var faceIndicesToRemove=[];for(i=0,il=this.faces.length;i<il;i++){face=this.faces[i];face.a=changes[face.a];face.b=changes[face.b];face.c=changes[face.c];indices=[face.a,face.b,face.c];// if any duplicate vertices are found in a Face3
// we have to remove the face as nothing can be saved
for(var n=0;n<3;n++){if(indices[n]===indices[(n+1)%3]){faceIndicesToRemove.push(i);break;}}}for(i=faceIndicesToRemove.length-1;i>=0;i--){var idx=faceIndicesToRemove[i];this.faces.splice(idx,1);for(j=0,jl=this.faceVertexUvs.length;j<jl;j++){this.faceVertexUvs[j].splice(idx,1);}}// Use unique set of vertices
var diff=this.vertices.length-unique.length;this.vertices=unique;return diff;},setFromPoints:function setFromPoints(points){this.vertices=[];for(var i=0,l=points.length;i<l;i++){var point=points[i];this.vertices.push(new Vector3(point.x,point.y,point.z||0));}return this;},sortFacesByMaterialIndex:function sortFacesByMaterialIndex(){var faces=this.faces;var length=faces.length;// tag faces
for(var i=0;i<length;i++){faces[i]._id=i;}// sort faces
function materialIndexSort(a,b){return a.materialIndex-b.materialIndex;}faces.sort(materialIndexSort);// sort uvs
var uvs1=this.faceVertexUvs[0];var uvs2=this.faceVertexUvs[1];var newUvs1,newUvs2;if(uvs1&&uvs1.length===length)newUvs1=[];if(uvs2&&uvs2.length===length)newUvs2=[];for(var i=0;i<length;i++){var id=faces[i]._id;if(newUvs1)newUvs1.push(uvs1[id]);if(newUvs2)newUvs2.push(uvs2[id]);}if(newUvs1)this.faceVertexUvs[0]=newUvs1;if(newUvs2)this.faceVertexUvs[1]=newUvs2;},toJSON:function toJSON(){var data={metadata:{version:4.5,type:'Geometry',generator:'Geometry.toJSON'}};// standard Geometry serialization
data.uuid=this.uuid;data.type=this.type;if(this.name!=='')data.name=this.name;if(this.parameters!==undefined){var parameters=this.parameters;for(var key in parameters){if(parameters[key]!==undefined)data[key]=parameters[key];}return data;}var vertices=[];for(var i=0;i<this.vertices.length;i++){var vertex=this.vertices[i];vertices.push(vertex.x,vertex.y,vertex.z);}var faces=[];var normals=[];var normalsHash={};var colors=[];var colorsHash={};var uvs=[];var uvsHash={};for(var i=0;i<this.faces.length;i++){var face=this.faces[i];var hasMaterial=true;var hasFaceUv=false;// deprecated
var hasFaceVertexUv=this.faceVertexUvs[0][i]!==undefined;var hasFaceNormal=face.normal.length()>0;var hasFaceVertexNormal=face.vertexNormals.length>0;var hasFaceColor=face.color.r!==1||face.color.g!==1||face.color.b!==1;var hasFaceVertexColor=face.vertexColors.length>0;var faceType=0;faceType=setBit(faceType,0,0);// isQuad
faceType=setBit(faceType,1,hasMaterial);faceType=setBit(faceType,2,hasFaceUv);faceType=setBit(faceType,3,hasFaceVertexUv);faceType=setBit(faceType,4,hasFaceNormal);faceType=setBit(faceType,5,hasFaceVertexNormal);faceType=setBit(faceType,6,hasFaceColor);faceType=setBit(faceType,7,hasFaceVertexColor);faces.push(faceType);faces.push(face.a,face.b,face.c);faces.push(face.materialIndex);if(hasFaceVertexUv){var faceVertexUvs=this.faceVertexUvs[0][i];faces.push(getUvIndex(faceVertexUvs[0]),getUvIndex(faceVertexUvs[1]),getUvIndex(faceVertexUvs[2]));}if(hasFaceNormal){faces.push(getNormalIndex(face.normal));}if(hasFaceVertexNormal){var vertexNormals=face.vertexNormals;faces.push(getNormalIndex(vertexNormals[0]),getNormalIndex(vertexNormals[1]),getNormalIndex(vertexNormals[2]));}if(hasFaceColor){faces.push(getColorIndex(face.color));}if(hasFaceVertexColor){var vertexColors=face.vertexColors;faces.push(getColorIndex(vertexColors[0]),getColorIndex(vertexColors[1]),getColorIndex(vertexColors[2]));}}function setBit(value,position,enabled){return enabled?value|1<<position:value&~(1<<position);}function getNormalIndex(normal){var hash=normal.x.toString()+normal.y.toString()+normal.z.toString();if(normalsHash[hash]!==undefined){return normalsHash[hash];}normalsHash[hash]=normals.length/3;normals.push(normal.x,normal.y,normal.z);return normalsHash[hash];}function getColorIndex(color){var hash=color.r.toString()+color.g.toString()+color.b.toString();if(colorsHash[hash]!==undefined){return colorsHash[hash];}colorsHash[hash]=colors.length;colors.push(color.getHex());return colorsHash[hash];}function getUvIndex(uv){var hash=uv.x.toString()+uv.y.toString();if(uvsHash[hash]!==undefined){return uvsHash[hash];}uvsHash[hash]=uvs.length/2;uvs.push(uv.x,uv.y);return uvsHash[hash];}data.data={};data.data.vertices=vertices;data.data.normals=normals;if(colors.length>0)data.data.colors=colors;if(uvs.length>0)data.data.uvs=[uvs];// temporal backward compatibility
data.data.faces=faces;return data;},clone:function clone(){/*
		 // Handle primitives

		 var parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 var values = [];

		 for ( var key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 var geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */return new Geometry().copy(this);},copy:function copy(source){var i,il,j,jl,k,kl;// reset
this.vertices=[];this.colors=[];this.faces=[];this.faceVertexUvs=[[]];this.morphTargets=[];this.morphNormals=[];this.skinWeights=[];this.skinIndices=[];this.lineDistances=[];this.boundingBox=null;this.boundingSphere=null;// name
this.name=source.name;// vertices
var vertices=source.vertices;for(i=0,il=vertices.length;i<il;i++){this.vertices.push(vertices[i].clone());}// colors
var colors=source.colors;for(i=0,il=colors.length;i<il;i++){this.colors.push(colors[i].clone());}// faces
var faces=source.faces;for(i=0,il=faces.length;i<il;i++){this.faces.push(faces[i].clone());}// face vertex uvs
for(i=0,il=source.faceVertexUvs.length;i<il;i++){var faceVertexUvs=source.faceVertexUvs[i];if(this.faceVertexUvs[i]===undefined){this.faceVertexUvs[i]=[];}for(j=0,jl=faceVertexUvs.length;j<jl;j++){var uvs=faceVertexUvs[j],uvsCopy=[];for(k=0,kl=uvs.length;k<kl;k++){var uv=uvs[k];uvsCopy.push(uv.clone());}this.faceVertexUvs[i].push(uvsCopy);}}// morph targets
var morphTargets=source.morphTargets;for(i=0,il=morphTargets.length;i<il;i++){var morphTarget={};morphTarget.name=morphTargets[i].name;// vertices
if(morphTargets[i].vertices!==undefined){morphTarget.vertices=[];for(j=0,jl=morphTargets[i].vertices.length;j<jl;j++){morphTarget.vertices.push(morphTargets[i].vertices[j].clone());}}// normals
if(morphTargets[i].normals!==undefined){morphTarget.normals=[];for(j=0,jl=morphTargets[i].normals.length;j<jl;j++){morphTarget.normals.push(morphTargets[i].normals[j].clone());}}this.morphTargets.push(morphTarget);}// morph normals
var morphNormals=source.morphNormals;for(i=0,il=morphNormals.length;i<il;i++){var morphNormal={};// vertex normals
if(morphNormals[i].vertexNormals!==undefined){morphNormal.vertexNormals=[];for(j=0,jl=morphNormals[i].vertexNormals.length;j<jl;j++){var srcVertexNormal=morphNormals[i].vertexNormals[j];var destVertexNormal={};destVertexNormal.a=srcVertexNormal.a.clone();destVertexNormal.b=srcVertexNormal.b.clone();destVertexNormal.c=srcVertexNormal.c.clone();morphNormal.vertexNormals.push(destVertexNormal);}}// face normals
if(morphNormals[i].faceNormals!==undefined){morphNormal.faceNormals=[];for(j=0,jl=morphNormals[i].faceNormals.length;j<jl;j++){morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());}}this.morphNormals.push(morphNormal);}// skin weights
var skinWeights=source.skinWeights;for(i=0,il=skinWeights.length;i<il;i++){this.skinWeights.push(skinWeights[i].clone());}// skin indices
var skinIndices=source.skinIndices;for(i=0,il=skinIndices.length;i<il;i++){this.skinIndices.push(skinIndices[i].clone());}// line distances
var lineDistances=source.lineDistances;for(i=0,il=lineDistances.length;i<il;i++){this.lineDistances.push(lineDistances[i]);}// bounding box
var boundingBox=source.boundingBox;if(boundingBox!==null){this.boundingBox=boundingBox.clone();}// bounding sphere
var boundingSphere=source.boundingSphere;if(boundingSphere!==null){this.boundingSphere=boundingSphere.clone();}// update flags
this.elementsNeedUpdate=source.elementsNeedUpdate;this.verticesNeedUpdate=source.verticesNeedUpdate;this.uvsNeedUpdate=source.uvsNeedUpdate;this.normalsNeedUpdate=source.normalsNeedUpdate;this.colorsNeedUpdate=source.colorsNeedUpdate;this.lineDistancesNeedUpdate=source.lineDistancesNeedUpdate;this.groupsNeedUpdate=source.groupsNeedUpdate;return this;},dispose:function dispose(){this.dispatchEvent({type:'dispose'});}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // BoxGeometry
var BoxGeometry=/*#__PURE__*/function(_Geometry){(0,_inherits2.default)(BoxGeometry,_Geometry);function BoxGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){var _this2;(0,_classCallCheck2.default)(this,BoxGeometry);_this2=(0,_possibleConstructorReturn2.default)(this,(0,_getPrototypeOf2.default)(BoxGeometry).call(this));_this2.type='BoxGeometry';_this2.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};_this2.fromBufferGeometry(new BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments));_this2.mergeVertices();return _this2;}return BoxGeometry;}(Geometry);// BoxBufferGeometry
exports.CubeGeometry=exports.BoxGeometry=BoxGeometry;var BoxBufferGeometry=/*#__PURE__*/function(_BufferGeometry){(0,_inherits2.default)(BoxBufferGeometry,_BufferGeometry);function BoxBufferGeometry(width,height,depth,widthSegments,heightSegments,depthSegments){var _this3;(0,_classCallCheck2.default)(this,BoxBufferGeometry);_this3=(0,_possibleConstructorReturn2.default)(this,(0,_getPrototypeOf2.default)(BoxBufferGeometry).call(this));_this3.type='BoxBufferGeometry';_this3.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};var scope=(0,_assertThisInitialized2.default)(_this3);width=width||1;height=height||1;depth=depth||1;// segments
widthSegments=Math.floor(widthSegments)||1;heightSegments=Math.floor(heightSegments)||1;depthSegments=Math.floor(depthSegments)||1;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var numberOfVertices=0;var groupStart=0;// build each side of the box geometry
buildPlane('z','y','x',-1,-1,depth,height,width,depthSegments,heightSegments,0);// px
buildPlane('z','y','x',1,-1,depth,height,-width,depthSegments,heightSegments,1);// nx
buildPlane('x','z','y',1,1,width,depth,height,widthSegments,depthSegments,2);// py
buildPlane('x','z','y',1,-1,width,depth,-height,widthSegments,depthSegments,3);// ny
buildPlane('x','y','z',1,-1,width,height,depth,widthSegments,heightSegments,4);// pz
buildPlane('x','y','z',-1,-1,width,height,-depth,widthSegments,heightSegments,5);// nz
// build geometry
_this3.setIndex(indices);_this3.setAttribute('position',new Float32BufferAttribute(vertices,3));_this3.setAttribute('normal',new Float32BufferAttribute(normals,3));_this3.setAttribute('uv',new Float32BufferAttribute(uvs,2));function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){var segmentWidth=width/gridX;var segmentHeight=height/gridY;var widthHalf=width/2;var heightHalf=height/2;var depthHalf=depth/2;var gridX1=gridX+1;var gridY1=gridY+1;var vertexCounter=0;var groupCount=0;var ix,iy;var vector=new Vector3();// generate vertices, normals and uvs
for(iy=0;iy<gridY1;iy++){var y=iy*segmentHeight-heightHalf;for(ix=0;ix<gridX1;ix++){var x=ix*segmentWidth-widthHalf;// set values to correct vector component
vector[u]=x*udir;vector[v]=y*vdir;vector[w]=depthHalf;// now apply vector to vertex buffer
vertices.push(vector.x,vector.y,vector.z);// set values to correct vector component
vector[u]=0;vector[v]=0;vector[w]=depth>0?1:-1;// now apply vector to normal buffer
normals.push(vector.x,vector.y,vector.z);// uvs
uvs.push(ix/gridX);uvs.push(1-iy/gridY);// counters
vertexCounter+=1;}}// indices
// 1. you need three indices to draw a single face
// 2. a single segment consists of two faces
// 3. so we need to generate six (2*3) indices per segment
for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=numberOfVertices+ix+gridX1*iy;var b=numberOfVertices+ix+gridX1*(iy+1);var c=numberOfVertices+(ix+1)+gridX1*(iy+1);var d=numberOfVertices+(ix+1)+gridX1*iy;// faces
indices.push(a,b,d);indices.push(b,c,d);// increase counter
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,materialIndex);// calculate new start value for groups
groupStart+=groupCount;// update total number of vertices
numberOfVertices+=vertexCounter;}return _this3;}return BoxBufferGeometry;}(BufferGeometry);/**
 * Uniform Utilities
 */exports.BoxBufferGeometry=BoxBufferGeometry;function cloneUniforms(src){var dst={};for(var u in src){dst[u]={};for(var p in src[u]){var property=src[u][p];if(property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture)){dst[u][p]=property.clone();}else if((0,_isArray.default)(property)){dst[u][p]=property.slice();}else{dst[u][p]=property;}}}return dst;}function mergeUniforms(uniforms){var merged={};for(var u=0;u<uniforms.length;u++){var tmp=cloneUniforms(uniforms[u]);for(var p in tmp){merged[p]=tmp[p];}}return merged;}// Legacy
var UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};exports.UniformsUtils=UniformsUtils;var default_vertex="void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";var default_fragment="void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function ShaderMaterial(parameters){Material.call(this);this.type='ShaderMaterial';this.defines={};this.uniforms={};this.vertexShader=default_vertex;this.fragmentShader=default_fragment;this.linewidth=1;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;// set to use scene fog
this.lights=false;// set to use scene lights
this.clipping=false;// set to use user-defined clipping planes
this.skinning=false;// set to use skinning attribute streams
this.morphTargets=false;// set to use morph targets
this.morphNormals=false;// set to use morph normals
this.extensions={derivatives:false,// set to use derivatives
fragDepth:false,// set to use fragment depth values
drawBuffers:false,// set to use draw buffers
shaderTextureLOD:false// set to use shader texture LOD
};// When rendered geometry doesn't include these attributes but the material does,
// use these default values in WebGL. This avoids errors when buffer data is missing.
this.defaultAttributeValues={'color':[1,1,1],'uv':[0,0],'uv2':[0,0]};this.index0AttributeName=undefined;this.uniformsNeedUpdate=false;if(parameters!==undefined){if(parameters.attributes!==undefined){console.error('THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.');}this.setValues(parameters);}}ShaderMaterial.prototype=(0,_create.default)(Material.prototype);ShaderMaterial.prototype.constructor=ShaderMaterial;ShaderMaterial.prototype.isShaderMaterial=true;ShaderMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.fragmentShader=source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=cloneUniforms(source.uniforms);this.defines=(0,_assign.default)({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.lights=source.lights;this.clipping=source.clipping;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;this.extensions=source.extensions;return this;};ShaderMaterial.prototype.toJSON=function(meta){var data=Material.prototype.toJSON.call(this,meta);data.uniforms={};for(var name in this.uniforms){var uniform=this.uniforms[name];var value=uniform.value;if(value&&value.isTexture){data.uniforms[name]={type:'t',value:value.toJSON(meta).uuid};}else if(value&&value.isColor){data.uniforms[name]={type:'c',value:value.getHex()};}else if(value&&value.isVector2){data.uniforms[name]={type:'v2',value:value.toArray()};}else if(value&&value.isVector3){data.uniforms[name]={type:'v3',value:value.toArray()};}else if(value&&value.isVector4){data.uniforms[name]={type:'v4',value:value.toArray()};}else if(value&&value.isMatrix3){data.uniforms[name]={type:'m3',value:value.toArray()};}else if(value&&value.isMatrix4){data.uniforms[name]={type:'m4',value:value.toArray()};}else{data.uniforms[name]={value:value};// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
}}if((0,_keys.default)(this.defines).length>0)data.defines=this.defines;data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;var extensions={};for(var key in this.extensions){if(this.extensions[key]===true)extensions[key]=true;}if((0,_keys.default)(extensions).length>0)data.extensions=extensions;return data;};/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/function Camera(){Object3D.call(this);this.type='Camera';this.matrixWorldInverse=new Matrix4();this.projectionMatrix=new Matrix4();this.projectionMatrixInverse=new Matrix4();}Camera.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Camera,isCamera:true,copy:function copy(source,recursive){Object3D.prototype.copy.call(this,source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);this.projectionMatrixInverse.copy(source.projectionMatrixInverse);return this;},getWorldDirection:function getWorldDirection(target){if(target===undefined){console.warn('THREE.Camera: .getWorldDirection() target is now required');target=new Vector3();}this.updateMatrixWorld(true);var e=this.matrixWorld.elements;return target.set(-e[8],-e[9],-e[10]).normalize();},updateMatrixWorld:function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);this.matrixWorldInverse.getInverse(this.matrixWorld);},updateWorldMatrix:function updateWorldMatrix(updateParents,updateChildren){Object3D.prototype.updateWorldMatrix.call(this,updateParents,updateChildren);this.matrixWorldInverse.getInverse(this.matrixWorld);},clone:function clone(){return new this.constructor().copy(this);}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */function PerspectiveCamera(fov,aspect,near,far){Camera.call(this);this.type='PerspectiveCamera';this.fov=fov!==undefined?fov:50;this.zoom=1;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.focus=10;this.aspect=aspect!==undefined?aspect:1;this.view=null;this.filmGauge=35;// width of the film (default in millimeters)
this.filmOffset=0;// horizontal film offset (same unit as gauge)
this.updateProjectionMatrix();}PerspectiveCamera.prototype=(0,_assign.default)((0,_create.default)(Camera.prototype),{constructor:PerspectiveCamera,isPerspectiveCamera:true,copy:function copy(source,recursive){Camera.prototype.copy.call(this,source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=source.view===null?null:(0,_assign.default)({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this;},/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */setFocalLength:function setFocalLength(focalLength){// see http://www.bobatkins.com/photography/technical/field_of_view.html
var vExtentSlope=0.5*this.getFilmHeight()/focalLength;this.fov=MathUtils.RAD2DEG*2*Math.atan(vExtentSlope);this.updateProjectionMatrix();},/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */getFocalLength:function getFocalLength(){var vExtentSlope=Math.tan(MathUtils.DEG2RAD*0.5*this.fov);return 0.5*this.getFilmHeight()/vExtentSlope;},getEffectiveFOV:function getEffectiveFOV(){return MathUtils.RAD2DEG*2*Math.atan(Math.tan(MathUtils.DEG2RAD*0.5*this.fov)/this.zoom);},getFilmWidth:function getFilmWidth(){// film not completely covered in portrait format (aspect < 1)
return this.filmGauge*Math.min(this.aspect,1);},getFilmHeight:function getFilmHeight(){// film not completely covered in landscape format (aspect > 1)
return this.filmGauge/Math.max(this.aspect,1);},/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();},clearViewOffset:function clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();},updateProjectionMatrix:function updateProjectionMatrix(){var near=this.near,top=near*Math.tan(MathUtils.DEG2RAD*0.5*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-0.5*width,view=this.view;if(this.view!==null&&this.view.enabled){var fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight;}var skew=this.filmOffset;if(skew!==0)left+=near*skew/this.getFilmWidth();this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);this.projectionMatrixInverse.getInverse(this.projectionMatrix);},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.fov=this.fov;data.object.zoom=this.zoom;data.object.near=this.near;data.object.far=this.far;data.object.focus=this.focus;data.object.aspect=this.aspect;if(this.view!==null)data.object.view=(0,_assign.default)({},this.view);data.object.filmGauge=this.filmGauge;data.object.filmOffset=this.filmOffset;return data;}});/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */var fov=90,aspect=1;function CubeCamera(near,far,cubeResolution,options){Object3D.call(this);this.type='CubeCamera';var cameraPX=new PerspectiveCamera(fov,aspect,near,far);cameraPX.up.set(0,-1,0);cameraPX.lookAt(new Vector3(1,0,0));this.add(cameraPX);var cameraNX=new PerspectiveCamera(fov,aspect,near,far);cameraNX.up.set(0,-1,0);cameraNX.lookAt(new Vector3(-1,0,0));this.add(cameraNX);var cameraPY=new PerspectiveCamera(fov,aspect,near,far);cameraPY.up.set(0,0,1);cameraPY.lookAt(new Vector3(0,1,0));this.add(cameraPY);var cameraNY=new PerspectiveCamera(fov,aspect,near,far);cameraNY.up.set(0,0,-1);cameraNY.lookAt(new Vector3(0,-1,0));this.add(cameraNY);var cameraPZ=new PerspectiveCamera(fov,aspect,near,far);cameraPZ.up.set(0,-1,0);cameraPZ.lookAt(new Vector3(0,0,1));this.add(cameraPZ);var cameraNZ=new PerspectiveCamera(fov,aspect,near,far);cameraNZ.up.set(0,-1,0);cameraNZ.lookAt(new Vector3(0,0,-1));this.add(cameraNZ);options=options||{format:RGBFormat,magFilter:LinearFilter,minFilter:LinearFilter};this.renderTarget=new WebGLCubeRenderTarget(cubeResolution,options);this.renderTarget.texture.name="CubeCamera";this.update=function(renderer,scene){if(this.parent===null)this.updateMatrixWorld();var currentRenderTarget=renderer.getRenderTarget();var renderTarget=this.renderTarget;var generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=false;renderer.setRenderTarget(renderTarget,0);renderer.render(scene,cameraPX);renderer.setRenderTarget(renderTarget,1);renderer.render(scene,cameraNX);renderer.setRenderTarget(renderTarget,2);renderer.render(scene,cameraPY);renderer.setRenderTarget(renderTarget,3);renderer.render(scene,cameraNY);renderer.setRenderTarget(renderTarget,4);renderer.render(scene,cameraPZ);renderTarget.texture.generateMipmaps=generateMipmaps;renderer.setRenderTarget(renderTarget,5);renderer.render(scene,cameraNZ);renderer.setRenderTarget(currentRenderTarget);};this.clear=function(renderer,color,depth,stencil){var currentRenderTarget=renderer.getRenderTarget();var renderTarget=this.renderTarget;for(var i=0;i<6;i++){renderer.setRenderTarget(renderTarget,i);renderer.clear(color,depth,stencil);}renderer.setRenderTarget(currentRenderTarget);};}CubeCamera.prototype=(0,_create.default)(Object3D.prototype);CubeCamera.prototype.constructor=CubeCamera;/**
 * @author alteredq / http://alteredqualia.com
 * @author WestLangley / http://github.com/WestLangley
 */function WebGLCubeRenderTarget(size,options,dummy){if((0,_isInteger.default)(options)){console.warn('THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )');options=dummy;}WebGLRenderTarget.call(this,size,size,options);}WebGLCubeRenderTarget.prototype=(0,_create.default)(WebGLRenderTarget.prototype);WebGLCubeRenderTarget.prototype.constructor=WebGLCubeRenderTarget;WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget=true;WebGLCubeRenderTarget.prototype.fromEquirectangularTexture=function(renderer,texture){this.texture.type=texture.type;this.texture.format=texture.format;this.texture.encoding=texture.encoding;var scene=new Scene();var shader={uniforms:{tEquirect:{value:null}},vertexShader:["varying vec3 vWorldDirection;","vec3 transformDirection( in vec3 dir, in mat4 matrix ) {","	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );","}","void main() {","	vWorldDirection = transformDirection( position, modelMatrix );","	#include <begin_vertex>","	#include <project_vertex>","}"].join('\n'),fragmentShader:["uniform sampler2D tEquirect;","varying vec3 vWorldDirection;","#define RECIPROCAL_PI 0.31830988618","#define RECIPROCAL_PI2 0.15915494","void main() {","	vec3 direction = normalize( vWorldDirection );","	vec2 sampleUV;","	sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;","	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;","	gl_FragColor = texture2D( tEquirect, sampleUV );","}"].join('\n')};var material=new ShaderMaterial({type:'CubemapFromEquirect',uniforms:cloneUniforms(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader,side:BackSide,blending:NoBlending});material.uniforms.tEquirect.value=texture;var mesh=new Mesh(new BoxBufferGeometry(5,5,5),material);scene.add(mesh);var camera=new CubeCamera(1,10,1);camera.renderTarget=this;camera.renderTarget.texture.name='CubeCameraTexture';camera.update(renderer,scene);mesh.geometry.dispose();mesh.material.dispose();return this;};/**
 * @author alteredq / http://alteredqualia.com/
 */function DataTexture(data,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={data:data||null,width:width||1,height:height||1};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.generateMipmaps=false;this.flipY=false;this.unpackAlignment=1;this.needsUpdate=true;}DataTexture.prototype=(0,_create.default)(Texture.prototype);DataTexture.prototype.constructor=DataTexture;DataTexture.prototype.isDataTexture=true;/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */var _sphere$1=new Sphere();var _vector$5=new Vector3();function Frustum(p0,p1,p2,p3,p4,p5){this.planes=[p0!==undefined?p0:new Plane(),p1!==undefined?p1:new Plane(),p2!==undefined?p2:new Plane(),p3!==undefined?p3:new Plane(),p4!==undefined?p4:new Plane(),p5!==undefined?p5:new Plane()];}(0,_assign.default)(Frustum.prototype,{set:function set(p0,p1,p2,p3,p4,p5){var planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(frustum){var planes=this.planes;for(var i=0;i<6;i++){planes[i].copy(frustum.planes[i]);}return this;},setFromProjectionMatrix:function setFromProjectionMatrix(m){var planes=this.planes;var me=m.elements;var me0=me[0],me1=me[1],me2=me[2],me3=me[3];var me4=me[4],me5=me[5],me6=me[6],me7=me[7];var me8=me[8],me9=me[9],me10=me[10],me11=me[11];var me12=me[12],me13=me[13],me14=me[14],me15=me[15];planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize();planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();return this;},intersectsObject:function intersectsObject(object){var geometry=object.geometry;if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(_sphere$1);},intersectsSprite:function intersectsSprite(sprite){_sphere$1.center.set(0,0,0);_sphere$1.radius=0.7071067811865476;_sphere$1.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere$1);},intersectsSphere:function intersectsSphere(sphere){var planes=this.planes;var center=sphere.center;var negRadius=-sphere.radius;for(var i=0;i<6;i++){var distance=planes[i].distanceToPoint(center);if(distance<negRadius){return false;}}return true;},intersectsBox:function intersectsBox(box){var planes=this.planes;for(var i=0;i<6;i++){var plane=planes[i];// corner at max distance
_vector$5.x=plane.normal.x>0?box.max.x:box.min.x;_vector$5.y=plane.normal.y>0?box.max.y:box.min.y;_vector$5.z=plane.normal.z>0?box.max.z:box.min.z;if(plane.distanceToPoint(_vector$5)<0){return false;}}return true;},containsPoint:function containsPoint(point){var planes=this.planes;for(var i=0;i<6;i++){if(planes[i].distanceToPoint(point)<0){return false;}}return true;}});/**
 * Uniforms library for shared webgl shaders
 */var UniformsLib={common:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},map:{value:null},uvTransform:{value:new Matrix3()},uv2Transform:{value:new Matrix3()},alphaMap:{value:null}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1.0},refractionRatio:{value:0.98},maxMipLevel:{value:0}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:0.00025},fogNear:{value:1},fogFar:{value:2000},fogColor:{value:new Color(0xffffff)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}}},points:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},size:{value:1.0},scale:{value:1.0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Matrix3()}},sprite:{diffuse:{value:new Color(0xeeeeee)},opacity:{value:1.0},center:{value:new Vector2(0.5,0.5)},rotation:{value:0.0},map:{value:null},alphaMap:{value:null},uvTransform:{value:new Matrix3()}}};/**
 * @author mrdoob / http://mrdoob.com/
 */exports.UniformsLib=UniformsLib;function WebGLAnimation(){var context=null;var isAnimating=false;var animationLoop=null;function onAnimationFrame(time,frame){if(isAnimating===false)return;animationLoop(time,frame);context.requestAnimationFrame(onAnimationFrame);}return{start:function start(){if(isAnimating===true)return;if(animationLoop===null)return;context.requestAnimationFrame(onAnimationFrame);isAnimating=true;},stop:function stop(){isAnimating=false;},setAnimationLoop:function setAnimationLoop(callback){animationLoop=callback;},setContext:function setContext(value){context=value;}};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLAttributes(gl,capabilities){var isWebGL2=capabilities.isWebGL2;var buffers=new _weakMap.default();function createBuffer(attribute,bufferType){var array=attribute.array;var usage=attribute.usage;var buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();var type=5126;if(array instanceof Float32Array){type=5126;}else if(array instanceof Float64Array){console.warn('THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.');}else if(array instanceof Uint16Array){type=5123;}else if(array instanceof Int16Array){type=5122;}else if(array instanceof Uint32Array){type=5125;}else if(array instanceof Int32Array){type=5124;}else if(array instanceof Int8Array){type=5120;}else if(array instanceof Uint8Array){type=5121;}return{buffer:buffer,type:type,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version};}function updateBuffer(buffer,attribute,bufferType){var array=attribute.array;var updateRange=attribute.updateRange;gl.bindBuffer(bufferType,buffer);if(updateRange.count===-1){// Not using update ranges
gl.bufferSubData(bufferType,0,array);}else{if(isWebGL2){gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array,updateRange.offset,updateRange.count);}else{gl.bufferSubData(bufferType,updateRange.offset*array.BYTES_PER_ELEMENT,array.subarray(updateRange.offset,updateRange.offset+updateRange.count));}updateRange.count=-1;// reset range
}}//
function get(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;return buffers.get(attribute);}function remove(attribute){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data){gl.deleteBuffer(data.buffer);buffers.delete(attribute);}}function update(attribute,bufferType){if(attribute.isInterleavedBufferAttribute)attribute=attribute.data;var data=buffers.get(attribute);if(data===undefined){buffers.set(attribute,createBuffer(attribute,bufferType));}else if(data.version<attribute.version){updateBuffer(data.buffer,attribute,bufferType);data.version=attribute.version;}}return{get:get,remove:remove,update:update};}/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // PlaneGeometry
function PlaneGeometry(width,height,widthSegments,heightSegments){Geometry.call(this);this.type='PlaneGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};this.fromBufferGeometry(new PlaneBufferGeometry(width,height,widthSegments,heightSegments));this.mergeVertices();}PlaneGeometry.prototype=(0,_create.default)(Geometry.prototype);PlaneGeometry.prototype.constructor=PlaneGeometry;// PlaneBufferGeometry
function PlaneBufferGeometry(width,height,widthSegments,heightSegments){BufferGeometry.call(this);this.type='PlaneBufferGeometry';this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};width=width||1;height=height||1;var width_half=width/2;var height_half=height/2;var gridX=Math.floor(widthSegments)||1;var gridY=Math.floor(heightSegments)||1;var gridX1=gridX+1;var gridY1=gridY+1;var segment_width=width/gridX;var segment_height=height/gridY;var ix,iy;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
for(iy=0;iy<gridY1;iy++){var y=iy*segment_height-height_half;for(ix=0;ix<gridX1;ix++){var x=ix*segment_width-width_half;vertices.push(x,-y,0);normals.push(0,0,1);uvs.push(ix/gridX);uvs.push(1-iy/gridY);}}// indices
for(iy=0;iy<gridY;iy++){for(ix=0;ix<gridX;ix++){var a=ix+gridX1*iy;var b=ix+gridX1*(iy+1);var c=ix+1+gridX1*(iy+1);var d=ix+1+gridX1*iy;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}PlaneBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);PlaneBufferGeometry.prototype.constructor=PlaneBufferGeometry;var alphamap_fragment="#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";var alphamap_pars_fragment="#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var alphatest_fragment="#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";var aomap_fragment="#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";var aomap_pars_fragment="#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";var begin_vertex="vec3 transformed = vec3( position );";var beginnormal_vertex="vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";var bsdfs="vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";var bumpmap_pars_fragment="#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";var clipping_planes_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";var clipping_planes_pars_fragment="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";var clipping_planes_pars_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";var clipping_planes_vertex="#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";var color_fragment="#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";var color_pars_fragment="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";var color_pars_vertex="#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";var color_vertex="#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";var common="#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";var cube_uv_reflection_fragment="#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";var defaultnormal_vertex="vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";var displacementmap_pars_vertex="#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";var displacementmap_vertex="#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";var emissivemap_fragment="#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";var emissivemap_pars_fragment="#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";var encodings_fragment="gl_FragColor = linearToOutputTexel( gl_FragColor );";var encodings_pars_fragment="\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";var envmap_fragment="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";var envmap_common_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";var envmap_pars_fragment="#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";var envmap_pars_vertex="#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";var envmap_vertex="#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";var fog_vertex="#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";var fog_pars_vertex="#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";var fog_fragment="#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";var fog_pars_fragment="#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";var gradientmap_pars_fragment="#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";var lightmap_fragment="#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";var lightmap_pars_fragment="#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";var lights_lambert_vertex="vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";var lights_pars_begin="uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";var envmap_physical_pars_fragment="#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";var lights_toon_fragment="ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var lights_toon_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";var lights_phong_fragment="BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";var lights_phong_pars_fragment="varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";var lights_physical_fragment="PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";var lights_physical_pars_fragment="struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";var lights_fragment_begin="\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";var lights_fragment_maps="#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";var lights_fragment_end="#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";var logdepthbuf_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";var logdepthbuf_pars_fragment="#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";var logdepthbuf_pars_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";var logdepthbuf_vertex="#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";var map_fragment="#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	#ifdef USE_MAP_MIXCOLOR\n diffuseColor = texelColor*texelColor.a + diffuseColor*(1.0-texelColor.a);\n #else\n diffuseColor *= texelColor;\n #endif\n #endif\n";var map_pars_fragment="#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";var map_particle_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";var map_particle_pars_fragment="#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";var metalnessmap_fragment="float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";var metalnessmap_pars_fragment="#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";var morphnormal_vertex="#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";var morphtarget_pars_vertex="#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";var morphtarget_vertex="#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";var normal_fragment_begin="#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";var normal_fragment_maps="#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";var normalmap_pars_fragment="#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";var clearcoat_normal_fragment_begin="#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";var clearcoat_normal_fragment_maps="#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";var clearcoat_pars_fragment="#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";var packing="vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";var premultiplied_alpha_fragment="#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";var project_vertex="vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";var dithering_fragment="#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";var dithering_pars_fragment="#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";var roughnessmap_fragment="float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";var roughnessmap_pars_fragment="#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";var shadowmap_pars_fragment="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";var shadowmap_pars_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";var shadowmap_vertex="#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";var shadowmask_pars_fragment="float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";var skinbase_vertex="#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";var skinning_pars_vertex="#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";var skinning_vertex="#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";var skinnormal_vertex="#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";var specularmap_fragment="float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";var specularmap_pars_fragment="#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";var tonemapping_fragment="#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";var tonemapping_pars_fragment="#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";var uv_pars_fragment="#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";var uv_pars_vertex="#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";var uv_vertex="#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";var uv2_pars_fragment="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";var uv2_pars_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";var uv2_vertex="#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";var worldpos_vertex="#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";var background_frag="uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var background_vert="varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";var cube_frag="#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var cube_vert="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";var depth_frag="#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";var depth_vert="#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";var distanceRGBA_frag="#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";var distanceRGBA_vert="#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";var equirect_frag="uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";var equirect_vert="varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";var linedashed_frag="uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var linedashed_vert="uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var meshbasic_frag="uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var meshbasic_vert="#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";var meshlambert_frag="uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshlambert_vert="#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var meshmatcap_frag="#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var meshmatcap_vert="#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";var meshtoon_frag="#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshtoon_vert="#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var meshphong_frag="#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\tgl_FragColor =vec4(1.0,0.2,0.3,1.0);\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshphong_vert="#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var meshphysical_frag="#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform float test;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\tif(test == 1.0){\n\tgl_FragColor = vec4( 1.0,1.0,0.2,1.0 );\n\t}\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";var meshphysical_vert="#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var normal_frag="#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";var normal_vert="#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";var points_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";var points_vert="uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";var shadow_frag="uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var shadow_vert="#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";var sprite_frag="uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";var sprite_vert="uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";var ShaderChunk={alphamap_fragment:alphamap_fragment,alphamap_pars_fragment:alphamap_pars_fragment,alphatest_fragment:alphatest_fragment,aomap_fragment:aomap_fragment,aomap_pars_fragment:aomap_pars_fragment,begin_vertex:begin_vertex,beginnormal_vertex:beginnormal_vertex,bsdfs:bsdfs,bumpmap_pars_fragment:bumpmap_pars_fragment,clipping_planes_fragment:clipping_planes_fragment,clipping_planes_pars_fragment:clipping_planes_pars_fragment,clipping_planes_pars_vertex:clipping_planes_pars_vertex,clipping_planes_vertex:clipping_planes_vertex,color_fragment:color_fragment,color_pars_fragment:color_pars_fragment,color_pars_vertex:color_pars_vertex,color_vertex:color_vertex,common:common,cube_uv_reflection_fragment:cube_uv_reflection_fragment,defaultnormal_vertex:defaultnormal_vertex,displacementmap_pars_vertex:displacementmap_pars_vertex,displacementmap_vertex:displacementmap_vertex,emissivemap_fragment:emissivemap_fragment,emissivemap_pars_fragment:emissivemap_pars_fragment,encodings_fragment:encodings_fragment,encodings_pars_fragment:encodings_pars_fragment,envmap_fragment:envmap_fragment,envmap_common_pars_fragment:envmap_common_pars_fragment,envmap_pars_fragment:envmap_pars_fragment,envmap_pars_vertex:envmap_pars_vertex,envmap_physical_pars_fragment:envmap_physical_pars_fragment,envmap_vertex:envmap_vertex,fog_vertex:fog_vertex,fog_pars_vertex:fog_pars_vertex,fog_fragment:fog_fragment,fog_pars_fragment:fog_pars_fragment,gradientmap_pars_fragment:gradientmap_pars_fragment,lightmap_fragment:lightmap_fragment,lightmap_pars_fragment:lightmap_pars_fragment,lights_lambert_vertex:lights_lambert_vertex,lights_pars_begin:lights_pars_begin,lights_toon_fragment:lights_toon_fragment,lights_toon_pars_fragment:lights_toon_pars_fragment,lights_phong_fragment:lights_phong_fragment,lights_phong_pars_fragment:lights_phong_pars_fragment,lights_physical_fragment:lights_physical_fragment,lights_physical_pars_fragment:lights_physical_pars_fragment,lights_fragment_begin:lights_fragment_begin,lights_fragment_maps:lights_fragment_maps,lights_fragment_end:lights_fragment_end,logdepthbuf_fragment:logdepthbuf_fragment,logdepthbuf_pars_fragment:logdepthbuf_pars_fragment,logdepthbuf_pars_vertex:logdepthbuf_pars_vertex,logdepthbuf_vertex:logdepthbuf_vertex,map_fragment:map_fragment,map_pars_fragment:map_pars_fragment,map_particle_fragment:map_particle_fragment,map_particle_pars_fragment:map_particle_pars_fragment,metalnessmap_fragment:metalnessmap_fragment,metalnessmap_pars_fragment:metalnessmap_pars_fragment,morphnormal_vertex:morphnormal_vertex,morphtarget_pars_vertex:morphtarget_pars_vertex,morphtarget_vertex:morphtarget_vertex,normal_fragment_begin:normal_fragment_begin,normal_fragment_maps:normal_fragment_maps,normalmap_pars_fragment:normalmap_pars_fragment,clearcoat_normal_fragment_begin:clearcoat_normal_fragment_begin,clearcoat_normal_fragment_maps:clearcoat_normal_fragment_maps,clearcoat_pars_fragment:clearcoat_pars_fragment,packing:packing,premultiplied_alpha_fragment:premultiplied_alpha_fragment,project_vertex:project_vertex,dithering_fragment:dithering_fragment,dithering_pars_fragment:dithering_pars_fragment,roughnessmap_fragment:roughnessmap_fragment,roughnessmap_pars_fragment:roughnessmap_pars_fragment,shadowmap_pars_fragment:shadowmap_pars_fragment,shadowmap_pars_vertex:shadowmap_pars_vertex,shadowmap_vertex:shadowmap_vertex,shadowmask_pars_fragment:shadowmask_pars_fragment,skinbase_vertex:skinbase_vertex,skinning_pars_vertex:skinning_pars_vertex,skinning_vertex:skinning_vertex,skinnormal_vertex:skinnormal_vertex,specularmap_fragment:specularmap_fragment,specularmap_pars_fragment:specularmap_pars_fragment,tonemapping_fragment:tonemapping_fragment,tonemapping_pars_fragment:tonemapping_pars_fragment,uv_pars_fragment:uv_pars_fragment,uv_pars_vertex:uv_pars_vertex,uv_vertex:uv_vertex,uv2_pars_fragment:uv2_pars_fragment,uv2_pars_vertex:uv2_pars_vertex,uv2_vertex:uv2_vertex,worldpos_vertex:worldpos_vertex,background_frag:background_frag,background_vert:background_vert,cube_frag:cube_frag,cube_vert:cube_vert,depth_frag:depth_frag,depth_vert:depth_vert,distanceRGBA_frag:distanceRGBA_frag,distanceRGBA_vert:distanceRGBA_vert,equirect_frag:equirect_frag,equirect_vert:equirect_vert,linedashed_frag:linedashed_frag,linedashed_vert:linedashed_vert,meshbasic_frag:meshbasic_frag,meshbasic_vert:meshbasic_vert,meshlambert_frag:meshlambert_frag,meshlambert_vert:meshlambert_vert,meshmatcap_frag:meshmatcap_frag,meshmatcap_vert:meshmatcap_vert,meshtoon_frag:meshtoon_frag,meshtoon_vert:meshtoon_vert,meshphong_frag:meshphong_frag,meshphong_vert:meshphong_vert,meshphysical_frag:meshphysical_frag,meshphysical_vert:meshphysical_vert,normal_frag:normal_frag,normal_vert:normal_vert,points_frag:points_frag,points_vert:points_vert,shadow_frag:shadow_frag,shadow_vert:shadow_vert,sprite_frag:sprite_frag,sprite_vert:sprite_vert};/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */exports.ShaderChunk=ShaderChunk;var ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},roughness:{value:0.5},metalness:{value:0.5},envMapIntensity:{value:1}// temporary
}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0x000000)},specular:{value:new Color(0x111111)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.normal_vert,fragmentShader:ShaderChunk.normal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3()},t2D:{value:null}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */cube:{uniforms:mergeUniforms([UniformsLib.envmap,{opacity:{value:1.0}}]),vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,{referencePosition:{value:new Vector3()},nearDistance:{value:1},farDistance:{value:1000}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0x00000)},opacity:{value:1.0}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};exports.ShaderLib=ShaderLib;ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},sheen:{value:new Color(0x000000)},transparency:{value:0}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLBackground(renderer,state,objects,premultipliedAlpha){var clearColor=new Color(0x000000);var clearAlpha=0;var planeMesh;var boxMesh;var currentBackground=null;var currentBackgroundVersion=0;var currentTonemapping=null;function render(renderList,scene,camera,forceClear){var background=scene.background;// Ignore background in AR
// TODO: Reconsider this.
var xr=renderer.xr;var session=xr.getSession&&xr.getSession();if(session&&session.environmentBlendMode==='additive'){background=null;}if(background===null){setClear(clearColor,clearAlpha);}else if(background&&background.isColor){setClear(background,1);forceClear=true;}if(renderer.autoClear||forceClear){renderer.clear(renderer.autoClearColor,renderer.autoClearDepth,renderer.autoClearStencil);}if(background&&(background.isCubeTexture||background.isWebGLCubeRenderTarget||background.mapping===CubeUVReflectionMapping)){if(boxMesh===undefined){boxMesh=new Mesh(new BoxBufferGeometry(1,1,1),new ShaderMaterial({type:'BackgroundCubeMaterial',uniforms:cloneUniforms(ShaderLib.cube.uniforms),vertexShader:ShaderLib.cube.vertexShader,fragmentShader:ShaderLib.cube.fragmentShader,side:BackSide,depthTest:false,depthWrite:false,fog:false}));boxMesh.geometry.deleteAttribute('normal');boxMesh.geometry.deleteAttribute('uv');boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld);};// enable code injection for non-built-in material
(0,_defineProperty3.default)(boxMesh.material,'envMap',{get:function get(){return this.uniforms.envMap.value;}});objects.update(boxMesh);}var texture=background.isWebGLCubeRenderTarget?background.texture:background;boxMesh.material.uniforms.envMap.value=texture;boxMesh.material.uniforms.flipEnvMap.value=texture.isCubeTexture?-1:1;if(currentBackground!==background||currentBackgroundVersion!==texture.version||currentTonemapping!==renderer.toneMapping){boxMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=texture.version;currentTonemapping=renderer.toneMapping;}// push to the pre-sorted opaque render list
renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null);}else if(background&&background.isTexture){if(planeMesh===undefined){planeMesh=new Mesh(new PlaneBufferGeometry(2,2),new ShaderMaterial({type:'BackgroundMaterial',uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:FrontSide,depthTest:false,depthWrite:false,fog:false}));planeMesh.geometry.deleteAttribute('normal');// enable code injection for non-built-in material
(0,_defineProperty3.default)(planeMesh.material,'map',{get:function get(){return this.uniforms.t2D.value;}});objects.update(planeMesh);}planeMesh.material.uniforms.t2D.value=background;if(background.matrixAutoUpdate===true){background.updateMatrix();}planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer.toneMapping){planeMesh.material.needsUpdate=true;currentBackground=background;currentBackgroundVersion=background.version;currentTonemapping=renderer.toneMapping;}// push to the pre-sorted opaque render list
renderList.unshift(planeMesh,planeMesh.geometry,planeMesh.material,0,0,null);}}function setClear(color,alpha){state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha);}return{getClearColor:function getClearColor(){return clearColor;},setClearColor:function setClearColor(color,alpha){clearColor.set(color);clearAlpha=alpha!==undefined?alpha:1;setClear(clearColor,clearAlpha);},getClearAlpha:function getClearAlpha(){return clearAlpha;},setClearAlpha:function setClearAlpha(alpha){clearAlpha=alpha;setClear(clearColor,clearAlpha);},render:render};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLBufferRenderer(gl,extensions,info,capabilities){var isWebGL2=capabilities.isWebGL2;var mode;function setMode(value){mode=value;}function render(start,count){gl.drawArrays(mode,start,count);info.update(count,mode);}function renderInstances(geometry,start,count,primcount){if(primcount===0)return;var extension,methodName;if(isWebGL2){extension=gl;methodName='drawArraysInstanced';}else{extension=extensions.get('ANGLE_instanced_arrays');methodName='drawArraysInstancedANGLE';if(extension===null){console.error('THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,start,count,primcount);info.update(count,mode,primcount);}//
this.setMode=setMode;this.render=render;this.renderInstances=renderInstances;}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLCapabilities(gl,extensions,parameters){var maxAnisotropy;function getMaxAnisotropy(){if(maxAnisotropy!==undefined)return maxAnisotropy;var extension=extensions.get('EXT_texture_filter_anisotropic');if(extension!==null){maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);}else{maxAnisotropy=0;}return maxAnisotropy;}function getMaxPrecision(precision){if(precision==='highp'){if(gl.getShaderPrecisionFormat(35633,36338).precision>0&&gl.getShaderPrecisionFormat(35632,36338).precision>0){return'highp';}precision='mediump';}if(precision==='mediump'){if(gl.getShaderPrecisionFormat(35633,36337).precision>0&&gl.getShaderPrecisionFormat(35632,36337).precision>0){return'mediump';}}return'lowp';}/* eslint-disable no-undef */var isWebGL2=typeof WebGL2RenderingContext!=='undefined'&&gl instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!=='undefined'&&gl instanceof WebGL2ComputeRenderingContext;/* eslint-enable no-undef */var precision=parameters.precision!==undefined?parameters.precision:'highp';var maxPrecision=getMaxPrecision(precision);if(maxPrecision!==precision){//console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
precision=maxPrecision;}var logarithmicDepthBuffer=parameters.logarithmicDepthBuffer===true;var maxTextures=gl.getParameter(34930);var maxVertexTextures=gl.getParameter(35660);var maxTextureSize=gl.getParameter(3379);var maxCubemapSize=gl.getParameter(34076);var maxAttributes=gl.getParameter(34921);var maxVertexUniforms=gl.getParameter(36347);var maxVaryings=gl.getParameter(36348);var maxFragmentUniforms=gl.getParameter(36349);var vertexTextures=maxVertexTextures>0;var floatFragmentTextures=isWebGL2||!!extensions.get('OES_texture_float');var floatVertexTextures=vertexTextures&&floatFragmentTextures;var maxSamples=isWebGL2?gl.getParameter(36183):0;return{isWebGL2:isWebGL2,getMaxAnisotropy:getMaxAnisotropy,getMaxPrecision:getMaxPrecision,precision:precision,logarithmicDepthBuffer:logarithmicDepthBuffer,maxTextures:maxTextures,maxVertexTextures:maxVertexTextures,maxTextureSize:maxTextureSize,maxCubemapSize:maxCubemapSize,maxAttributes:maxAttributes,maxVertexUniforms:maxVertexUniforms,maxVaryings:maxVaryings,maxFragmentUniforms:maxFragmentUniforms,vertexTextures:vertexTextures,floatFragmentTextures:floatFragmentTextures,floatVertexTextures:floatVertexTextures,maxSamples:maxSamples};}/**
 * @author tschw
 */function WebGLClipping(){var scope=this,globalState=null,numGlobalPlanes=0,localClippingEnabled=false,renderingShadows=false,plane=new Plane(),viewNormalMatrix=new Matrix3(),uniform={value:null,needsUpdate:false};this.uniform=uniform;this.numPlanes=0;this.numIntersection=0;this.init=function(planes,enableLocalClipping,camera){var enabled=planes.length!==0||enableLocalClipping||// enable state of previous frame - the clipping code has to
// run another frame in order to reset the state:
numGlobalPlanes!==0||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled;};this.beginShadows=function(){renderingShadows=true;projectPlanes(null);};this.endShadows=function(){renderingShadows=false;resetGlobalState();};this.setState=function(planes,clipIntersection,clipShadows,camera,cache,fromCache){if(!localClippingEnabled||planes===null||planes.length===0||renderingShadows&&!clipShadows){// there's no local clipping
if(renderingShadows){// there's no global clipping
projectPlanes(null);}else{resetGlobalState();}}else{var nGlobal=renderingShadows?0:numGlobalPlanes,lGlobal=nGlobal*4,dstArray=cache.clippingState||null;uniform.value=dstArray;// ensure unique state
dstArray=projectPlanes(planes,camera,lGlobal,fromCache);for(var i=0;i!==lGlobal;++i){dstArray[i]=globalState[i];}cache.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=nGlobal;}};function resetGlobalState(){if(uniform.value!==globalState){uniform.value=globalState;uniform.needsUpdate=numGlobalPlanes>0;}scope.numPlanes=numGlobalPlanes;scope.numIntersection=0;}function projectPlanes(planes,camera,dstOffset,skipTransform){var nPlanes=planes!==null?planes.length:0,dstArray=null;if(nPlanes!==0){dstArray=uniform.value;if(skipTransform!==true||dstArray===null){var flatSize=dstOffset+nPlanes*4,viewMatrix=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(viewMatrix);if(dstArray===null||dstArray.length<flatSize){dstArray=new Float32Array(flatSize);}for(var i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4){plane.copy(planes[i]).applyMatrix4(viewMatrix,viewNormalMatrix);plane.normal.toArray(dstArray,i4);dstArray[i4+3]=plane.constant;}}uniform.value=dstArray;uniform.needsUpdate=true;}scope.numPlanes=nPlanes;scope.numIntersection=0;return dstArray;}}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLExtensions(gl){var extensions={};return{get:function get(name){if(extensions[name]!==undefined){return extensions[name];}var extension;switch(name){case'WEBGL_depth_texture':extension=gl.getExtension('WEBGL_depth_texture')||gl.getExtension('MOZ_WEBGL_depth_texture')||gl.getExtension('WEBKIT_WEBGL_depth_texture');break;case'EXT_texture_filter_anisotropic':extension=gl.getExtension('EXT_texture_filter_anisotropic')||gl.getExtension('MOZ_EXT_texture_filter_anisotropic')||gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic');break;case'WEBGL_compressed_texture_s3tc':extension=gl.getExtension('WEBGL_compressed_texture_s3tc')||gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc');break;case'WEBGL_compressed_texture_pvrtc':extension=gl.getExtension('WEBGL_compressed_texture_pvrtc')||gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');break;default:extension=gl.getExtension(name);}if(extension===null){//console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
}extensions[name]=extension;return extension;}};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLGeometries(gl,attributes,info){var geometries=new _weakMap.default();var wireframeAttributes=new _weakMap.default();function onGeometryDispose(event){var geometry=event.target;var buffergeometry=geometries.get(geometry);if(buffergeometry.index!==null){attributes.remove(buffergeometry.index);}for(var name in buffergeometry.attributes){attributes.remove(buffergeometry.attributes[name]);}geometry.removeEventListener('dispose',onGeometryDispose);geometries.delete(geometry);var attribute=wireframeAttributes.get(buffergeometry);if(attribute){attributes.remove(attribute);wireframeAttributes.delete(buffergeometry);}//
info.memory.geometries--;}function get(object,geometry){var buffergeometry=geometries.get(geometry);if(buffergeometry)return buffergeometry;geometry.addEventListener('dispose',onGeometryDispose);if(geometry.isBufferGeometry){buffergeometry=geometry;}else if(geometry.isGeometry){if(geometry._bufferGeometry===undefined){geometry._bufferGeometry=new BufferGeometry().setFromObject(object);}buffergeometry=geometry._bufferGeometry;}geometries.set(geometry,buffergeometry);info.memory.geometries++;return buffergeometry;}function update(geometry){var index=geometry.index;var geometryAttributes=geometry.attributes;if(index!==null){attributes.update(index,34963);}for(var name in geometryAttributes){attributes.update(geometryAttributes[name],34962);}// morph targets
var morphAttributes=geometry.morphAttributes;for(var name in morphAttributes){var array=morphAttributes[name];for(var i=0,l=array.length;i<l;i++){attributes.update(array[i],34962);}}}function updateWireframeAttribute(geometry){var indices=[];var geometryIndex=geometry.index;var geometryPosition=geometry.attributes.position;var version=0;if(geometryIndex!==null){var array=geometryIndex.array;version=geometryIndex.version;for(var i=0,l=array.length;i<l;i+=3){var a=array[i+0];var b=array[i+1];var c=array[i+2];indices.push(a,b,b,c,c,a);}}else{var array=geometryPosition.array;version=geometryPosition.version;for(var i=0,l=array.length/3-1;i<l;i+=3){var a=i+0;var b=i+1;var c=i+2;indices.push(a,b,b,c,c,a);}}var attribute=new(arrayMax(indices)>65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);attribute.version=version;attributes.update(attribute,34963);//
var previousAttribute=wireframeAttributes.get(geometry);if(previousAttribute)attributes.remove(previousAttribute);//
wireframeAttributes.set(geometry,attribute);}function getWireframeAttribute(geometry){var currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){var geometryIndex=geometry.index;if(geometryIndex!==null){// if the attribute is obsolete, create a new one
if(currentAttribute.version<geometryIndex.version){updateWireframeAttribute(geometry);}}}else{updateWireframeAttribute(geometry);}return wireframeAttributes.get(geometry);}return{get:get,update:update,getWireframeAttribute:getWireframeAttribute};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLIndexedBufferRenderer(gl,extensions,info,capabilities){var isWebGL2=capabilities.isWebGL2;var mode;function setMode(value){mode=value;}var type,bytesPerElement;function setIndex(value){type=value.type;bytesPerElement=value.bytesPerElement;}function render(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,mode);}function renderInstances(geometry,start,count,primcount){if(primcount===0)return;var extension,methodName;if(isWebGL2){extension=gl;methodName='drawElementsInstanced';}else{extension=extensions.get('ANGLE_instanced_arrays');methodName='drawElementsInstancedANGLE';if(extension===null){console.error('THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.');return;}}extension[methodName](mode,count,type,start*bytesPerElement,primcount);info.update(count,mode,primcount);}//
this.setMode=setMode;this.setIndex=setIndex;this.render=render;this.renderInstances=renderInstances;}/**
 * @author Mugen87 / https://github.com/Mugen87
 */function WebGLInfo(gl){var memory={geometries:0,textures:0};var render={frame:0,calls:0,triangles:0,points:0,lines:0};function update(count,mode,instanceCount){instanceCount=instanceCount||1;render.calls++;switch(mode){case 4:render.triangles+=instanceCount*(count/3);break;case 1:render.lines+=instanceCount*(count/2);break;case 3:render.lines+=instanceCount*(count-1);break;case 2:render.lines+=instanceCount*count;break;case 0:render.points+=instanceCount*count;break;default:console.error('THREE.WebGLInfo: Unknown draw mode:',mode);break;}}function reset(){render.frame++;render.calls=0;render.triangles=0;render.points=0;render.lines=0;}return{memory:memory,render:render,programs:null,autoReset:true,reset:reset,update:update};}/**
 * @author mrdoob / http://mrdoob.com/
 */function absNumericalSort(a,b){return Math.abs(b[1])-Math.abs(a[1]);}function WebGLMorphtargets(gl){var influencesList={};var morphInfluences=new Float32Array(8);function update(object,geometry,material,program){var objectInfluences=object.morphTargetInfluences;// When object doesn't have morph target influences defined, we treat it as a 0-length array
// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences
var length=objectInfluences===undefined?0:objectInfluences.length;var influences=influencesList[geometry.id];if(influences===undefined){// initialise list
influences=[];for(var i=0;i<length;i++){influences[i]=[i,0];}influencesList[geometry.id]=influences;}var morphTargets=material.morphTargets&&geometry.morphAttributes.position;var morphNormals=material.morphNormals&&geometry.morphAttributes.normal;// Remove current morphAttributes
for(var i=0;i<length;i++){var influence=influences[i];if(influence[1]!==0){if(morphTargets)geometry.deleteAttribute('morphTarget'+i);if(morphNormals)geometry.deleteAttribute('morphNormal'+i);}}// Collect influences
for(var i=0;i<length;i++){var influence=influences[i];influence[0]=i;influence[1]=objectInfluences[i];}influences.sort(absNumericalSort);// Add morphAttributes
var morphInfluencesSum=0;for(var i=0;i<8;i++){var influence=influences[i];if(influence){var index=influence[0];var value=influence[1];if(value){if(morphTargets)geometry.setAttribute('morphTarget'+i,morphTargets[index]);if(morphNormals)geometry.setAttribute('morphNormal'+i,morphNormals[index]);morphInfluences[i]=value;morphInfluencesSum+=value;continue;}}morphInfluences[i]=0;}// GLSL shader uses formula baseinfluence * base + sum(target * influence)
// This allows us to switch between absolute morphs and relative morphs without changing shader code
// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
var morphBaseInfluence=geometry.morphTargetsRelative?1:1-morphInfluencesSum;program.getUniforms().setValue(gl,'morphTargetBaseInfluence',morphBaseInfluence);program.getUniforms().setValue(gl,'morphTargetInfluences',morphInfluences);}return{update:update};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLObjects(gl,geometries,attributes,info){var updateMap=new _weakMap.default();function update(object){var frame=info.render.frame;var geometry=object.geometry;var buffergeometry=geometries.get(object,geometry);// Update once per frame
if(updateMap.get(buffergeometry)!==frame){if(geometry.isGeometry){buffergeometry.updateFromObject(object);}geometries.update(buffergeometry);updateMap.set(buffergeometry,frame);}if(object.isInstancedMesh){attributes.update(object.instanceMatrix,34962);}return buffergeometry;}function dispose(){updateMap=new _weakMap.default();}return{update:update,dispose:dispose};}/**
 * @author mrdoob / http://mrdoob.com/
 */function CubeTexture(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=images!==undefined?images:[];mapping=mapping!==undefined?mapping:CubeReflectionMapping;format=format!==undefined?format:RGBFormat;Texture.call(this,images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.flipY=false;}CubeTexture.prototype=(0,_create.default)(Texture.prototype);CubeTexture.prototype.constructor=CubeTexture;CubeTexture.prototype.isCubeTexture=true;(0,_defineProperty3.default)(CubeTexture.prototype,'images',{get:function get(){return this.image;},set:function set(value){this.image=value;}});/**
 * @author Takahiro https://github.com/takahirox
 */function DataTexture2DArray(data,width,height,depth){Texture.call(this,null);this.image={data:data||null,width:width||1,height:height||1,depth:depth||1};this.magFilter=NearestFilter;this.minFilter=NearestFilter;this.wrapR=ClampToEdgeWrapping;this.generateMipmaps=false;this.flipY=false;this.needsUpdate=true;}DataTexture2DArray.prototype=(0,_create.default)(Texture.prototype);DataTexture2DArray.prototype.constructor=DataTexture2DArray;DataTexture2DArray.prototype.isDataTexture2DArray=true;/**
 * @author Artur Trzesiok
 */function DataTexture3D(data,width,height,depth){// We're going to add .setXXX() methods for setting properties later.
// Users can still set in DataTexture3D directly.
//
//	var texture = new THREE.DataTexture3D( data, width, height, depth );
// 	texture.anisotropy = 16;
//
// See #14839
Texture.call(this,null);this.image={data:data||null,width:width||1,height:height||1,depth:depth||1};this.magFilter=NearestFilter;this.minFilter=NearestFilter;this.wrapR=ClampToEdgeWrapping;this.generateMipmaps=false;this.flipY=false;this.needsUpdate=true;}DataTexture3D.prototype=(0,_create.default)(Texture.prototype);DataTexture3D.prototype.constructor=DataTexture3D;DataTexture3D.prototype.isDataTexture3D=true;/**
 * @author tschw
 * @author Mugen87 / https://github.com/Mugen87
 * @author mrdoob / http://mrdoob.com/
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */var emptyTexture=new Texture();var emptyTexture2dArray=new DataTexture2DArray();var emptyTexture3d=new DataTexture3D();var emptyCubeTexture=new CubeTexture();// --- Utilities ---
// Array Caches (provide typed arrays for temporary by size)
var arrayCacheF32=[];var arrayCacheI32=[];// Float32Array caches used for uploading Matrix uniforms
var mat4array=new Float32Array(16);var mat3array=new Float32Array(9);var mat2array=new Float32Array(4);// Flattening for arrays of vectors and matrices
function flatten(array,nBlocks,blockSize){var firstElem=array[0];if(firstElem<=0||firstElem>0)return array;// unoptimized: ! isNaN( firstElem )
// see http://jacksondunstan.com/articles/983
var n=nBlocks*blockSize,r=arrayCacheF32[n];if(r===undefined){r=new Float32Array(n);arrayCacheF32[n]=r;}if(nBlocks!==0){firstElem.toArray(r,0);for(var i=1,offset=0;i!==nBlocks;++i){offset+=blockSize;array[i].toArray(r,offset);}}return r;}function arraysEqual(a,b){if(a.length!==b.length)return false;for(var i=0,l=a.length;i<l;i++){if(a[i]!==b[i])return false;}return true;}function copyArray(a,b){for(var i=0,l=b.length;i<l;i++){a[i]=b[i];}}// Texture unit allocation
function allocTexUnits(textures,n){var r=arrayCacheI32[n];if(r===undefined){r=new Int32Array(n);arrayCacheI32[n]=r;}for(var i=0;i!==n;++i){r[i]=textures.allocateTextureUnit();}return r;}// --- Setters ---
// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.
// Single scalar
function setValueV1f(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1f(this.addr,v);cache[0]=v;}// Single float vector (from flat array or THREE.VectorN)
function setValueV2f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y){gl.uniform2f(this.addr,v.x,v.y);cache[0]=v.x;cache[1]=v.y;}}else{if(arraysEqual(cache,v))return;gl.uniform2fv(this.addr,v);copyArray(cache,v);}}function setValueV3f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z){gl.uniform3f(this.addr,v.x,v.y,v.z);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;}}else if(v.r!==undefined){if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b){gl.uniform3f(this.addr,v.r,v.g,v.b);cache[0]=v.r;cache[1]=v.g;cache[2]=v.b;}}else{if(arraysEqual(cache,v))return;gl.uniform3fv(this.addr,v);copyArray(cache,v);}}function setValueV4f(gl,v){var cache=this.cache;if(v.x!==undefined){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w){gl.uniform4f(this.addr,v.x,v.y,v.z,v.w);cache[0]=v.x;cache[1]=v.y;cache[2]=v.z;cache[3]=v.w;}}else{if(arraysEqual(cache,v))return;gl.uniform4fv(this.addr,v);copyArray(cache,v);}}// Single matrix (from flat array or MatrixN)
function setValueM2(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix2fv(this.addr,false,v);copyArray(cache,v);}else{if(arraysEqual(cache,elements))return;mat2array.set(elements);gl.uniformMatrix2fv(this.addr,false,mat2array);copyArray(cache,elements);}}function setValueM3(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix3fv(this.addr,false,v);copyArray(cache,v);}else{if(arraysEqual(cache,elements))return;mat3array.set(elements);gl.uniformMatrix3fv(this.addr,false,mat3array);copyArray(cache,elements);}}function setValueM4(gl,v){var cache=this.cache;var elements=v.elements;if(elements===undefined){if(arraysEqual(cache,v))return;gl.uniformMatrix4fv(this.addr,false,v);copyArray(cache,v);}else{if(arraysEqual(cache,elements))return;mat4array.set(elements);gl.uniformMatrix4fv(this.addr,false,mat4array);copyArray(cache,elements);}}// Single texture (2D / Cube)
function setValueT1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.safeSetTexture2D(v||emptyTexture,unit);}function setValueT2DArray1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture2DArray(v||emptyTexture2dArray,unit);}function setValueT3D1(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.setTexture3D(v||emptyTexture3d,unit);}function setValueT6(gl,v,textures){var cache=this.cache;var unit=textures.allocateTextureUnit();if(cache[0]!==unit){gl.uniform1i(this.addr,unit);cache[0]=unit;}textures.safeSetTextureCube(v||emptyCubeTexture,unit);}// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1i(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1i(this.addr,v);cache[0]=v;}function setValueV2i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform2iv(this.addr,v);copyArray(cache,v);}function setValueV3i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform3iv(this.addr,v);copyArray(cache,v);}function setValueV4i(gl,v){var cache=this.cache;if(arraysEqual(cache,v))return;gl.uniform4iv(this.addr,v);copyArray(cache,v);}// uint
function setValueV1ui(gl,v){var cache=this.cache;if(cache[0]===v)return;gl.uniform1ui(this.addr,v);cache[0]=v;}// Helper to pick the right setter for the singular case
function getSingularSetter(type){switch(type){case 0x1406:return setValueV1f;// FLOAT
case 0x8b50:return setValueV2f;// _VEC2
case 0x8b51:return setValueV3f;// _VEC3
case 0x8b52:return setValueV4f;// _VEC4
case 0x8b5a:return setValueM2;// _MAT2
case 0x8b5b:return setValueM3;// _MAT3
case 0x8b5c:return setValueM4;// _MAT4
case 0x1404:case 0x8b56:return setValueV1i;// INT, BOOL
case 0x8b53:case 0x8b57:return setValueV2i;// _VEC2
case 0x8b54:case 0x8b58:return setValueV3i;// _VEC3
case 0x8b55:case 0x8b59:return setValueV4i;// _VEC4
case 0x1405:return setValueV1ui;// UINT
case 0x8b5e:// SAMPLER_2D
case 0x8d66:// SAMPLER_EXTERNAL_OES
case 0x8dca:// INT_SAMPLER_2D
case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
case 0x8b62:// SAMPLER_2D_SHADOW
return setValueT1;case 0x8b5f:// SAMPLER_3D
case 0x8dcb:// INT_SAMPLER_3D
case 0x8dd3:// UNSIGNED_INT_SAMPLER_3D
return setValueT3D1;case 0x8b60:// SAMPLER_CUBE
case 0x8dcc:// INT_SAMPLER_CUBE
case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
case 0x8dc5:// SAMPLER_CUBE_SHADOW
return setValueT6;case 0x8dc1:// SAMPLER_2D_ARRAY
case 0x8dcf:// INT_SAMPLER_2D_ARRAY
case 0x8dd7:// UNSIGNED_INT_SAMPLER_2D_ARRAY
case 0x8dc4:// SAMPLER_2D_ARRAY_SHADOW
return setValueT2DArray1;}}// Array of scalars
function setValueV1fArray(gl,v){gl.uniform1fv(this.addr,v);}// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray(gl,v){gl.uniform1iv(this.addr,v);}function setValueV2iArray(gl,v){gl.uniform2iv(this.addr,v);}function setValueV3iArray(gl,v){gl.uniform3iv(this.addr,v);}function setValueV4iArray(gl,v){gl.uniform4iv(this.addr,v);}// Array of vectors (flat or from THREE classes)
function setValueV2fArray(gl,v){var data=flatten(v,this.size,2);gl.uniform2fv(this.addr,data);}function setValueV3fArray(gl,v){var data=flatten(v,this.size,3);gl.uniform3fv(this.addr,data);}function setValueV4fArray(gl,v){var data=flatten(v,this.size,4);gl.uniform4fv(this.addr,data);}// Array of matrices (flat or from THREE clases)
function setValueM2Array(gl,v){var data=flatten(v,this.size,4);gl.uniformMatrix2fv(this.addr,false,data);}function setValueM3Array(gl,v){var data=flatten(v,this.size,9);gl.uniformMatrix3fv(this.addr,false,data);}function setValueM4Array(gl,v){var data=flatten(v,this.size,16);gl.uniformMatrix4fv(this.addr,false,data);}// Array of textures (2D / Cube)
function setValueT1Array(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){textures.safeSetTexture2D(v[i]||emptyTexture,units[i]);}}function setValueT6Array(gl,v,textures){var n=v.length;var units=allocTexUnits(textures,n);gl.uniform1iv(this.addr,units);for(var i=0;i!==n;++i){textures.safeSetTextureCube(v[i]||emptyCubeTexture,units[i]);}}// Helper to pick the right setter for a pure (bottom-level) array
function getPureArraySetter(type){switch(type){case 0x1406:return setValueV1fArray;// FLOAT
case 0x8b50:return setValueV2fArray;// _VEC2
case 0x8b51:return setValueV3fArray;// _VEC3
case 0x8b52:return setValueV4fArray;// _VEC4
case 0x8b5a:return setValueM2Array;// _MAT2
case 0x8b5b:return setValueM3Array;// _MAT3
case 0x8b5c:return setValueM4Array;// _MAT4
case 0x1404:case 0x8b56:return setValueV1iArray;// INT, BOOL
case 0x8b53:case 0x8b57:return setValueV2iArray;// _VEC2
case 0x8b54:case 0x8b58:return setValueV3iArray;// _VEC3
case 0x8b55:case 0x8b59:return setValueV4iArray;// _VEC4
case 0x8b5e:// SAMPLER_2D
case 0x8d66:// SAMPLER_EXTERNAL_OES
case 0x8dca:// INT_SAMPLER_2D
case 0x8dd2:// UNSIGNED_INT_SAMPLER_2D
case 0x8b62:// SAMPLER_2D_SHADOW
return setValueT1Array;case 0x8b60:// SAMPLER_CUBE
case 0x8dcc:// INT_SAMPLER_CUBE
case 0x8dd4:// UNSIGNED_INT_SAMPLER_CUBE
case 0x8dc5:// SAMPLER_CUBE_SHADOW
return setValueT6Array;}}// --- Uniform Classes ---
function SingleUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.setValue=getSingularSetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}function PureArrayUniform(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type);// this.path = activeInfo.name; // DEBUG
}PureArrayUniform.prototype.updateCache=function(data){var cache=this.cache;if(data instanceof Float32Array&&cache.length!==data.length){this.cache=new Float32Array(data.length);}copyArray(cache,data);};function StructuredUniform(id){this.id=id;this.seq=[];this.map={};}StructuredUniform.prototype.setValue=function(gl,value,textures){var seq=this.seq;for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];u.setValue(gl,value[u.id],textures);}};// --- Top-level ---
// Parser - builds up the property tree from the path strings
var RePathPart=/([\w\d_]+)(\])?(\[|\.)?/g;// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.
function addUniform(container,uniformObject){container.seq.push(uniformObject);container.map[uniformObject.id]=uniformObject;}function parseUniform(activeInfo,addr,container){var path=activeInfo.name,pathLength=path.length;// reset RegExp object, because of the early exit of a previous run
RePathPart.lastIndex=0;while(true){var match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex,id=match[1],idIsIndex=match[2]===']',subscript=match[3];if(idIsIndex)id=id|0;// convert to integer
if(subscript===undefined||subscript==='['&&matchEnd+2===pathLength){// bare name or "pure" bottom-level array "[0]" suffix
addUniform(container,subscript===undefined?new SingleUniform(id,activeInfo,addr):new PureArrayUniform(id,activeInfo,addr));break;}else{// step into inner node / create it in case it doesn't exist
var map=container.map,next=map[id];if(next===undefined){next=new StructuredUniform(id);addUniform(container,next);}container=next;}}}// Root Container
function WebGLUniforms(gl,program){this.seq=[];this.map={};var n=gl.getProgramParameter(program,35718);for(var i=0;i<n;++i){var info=gl.getActiveUniform(program,i),addr=gl.getUniformLocation(program,info.name);parseUniform(info,addr,this);}}WebGLUniforms.prototype.setValue=function(gl,name,value,textures){var u=this.map[name];if(u!==undefined)u.setValue(gl,value,textures);};WebGLUniforms.prototype.setOptional=function(gl,object,name){var v=object[name];if(v!==undefined)this.setValue(gl,name,v);};// Static interface
WebGLUniforms.upload=function(gl,seq,values,textures){for(var i=0,n=seq.length;i!==n;++i){var u=seq[i],v=values[u.id];if(v.needsUpdate!==false){// note: always updating when .needsUpdate is undefined
u.setValue(gl,v.value,textures);}}};WebGLUniforms.seqWithValue=function(seq,values){var r=[];for(var i=0,n=seq.length;i!==n;++i){var u=seq[i];if(u.id in values)r.push(u);}return r;};/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLShader(gl,type,string){var shader=gl.createShader(type);gl.shaderSource(shader,string);gl.compileShader(shader);return shader;}/**
 * @author mrdoob / http://mrdoob.com/
 */var programIdCount=0;function addLineNumbers(string){var lines=string.split('\n');for(var i=0;i<lines.length;i++){lines[i]=i+1+': '+lines[i];}return lines.join('\n');}function getEncodingComponents(encoding){switch(encoding){case LinearEncoding:return['Linear','( value )'];case sRGBEncoding:return['sRGB','( value )'];case RGBEEncoding:return['RGBE','( value )'];case RGBM7Encoding:return['RGBM','( value, 7.0 )'];case RGBM16Encoding:return['RGBM','( value, 16.0 )'];case RGBDEncoding:return['RGBD','( value, 256.0 )'];case GammaEncoding:return['Gamma','( value, float( GAMMA_FACTOR ) )'];case LogLuvEncoding:return['LogLuv','( value )'];default:throw new Error('unsupported encoding: '+encoding);}}function getShaderErrors(gl,shader,type){var status=gl.getShaderParameter(shader,35713);var log=gl.getShaderInfoLog(shader).trim();if(status&&log==='')return'';// --enable-privileged-webgl-extension
// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
var source=gl.getShaderSource(shader);return'THREE.WebGLShader: gl.getShaderInfoLog() '+type+'\n'+log+addLineNumbers(source);}function getTexelDecodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return'vec4 '+functionName+'( vec4 value ) { return '+components[0]+'ToLinear'+components[1]+'; }';}function getTexelEncodingFunction(functionName,encoding){var components=getEncodingComponents(encoding);return'vec4 '+functionName+'( vec4 value ) { return LinearTo'+components[0]+components[1]+'; }';}function getToneMappingFunction(functionName,toneMapping){var toneMappingName;switch(toneMapping){case LinearToneMapping:toneMappingName='Linear';break;case ReinhardToneMapping:toneMappingName='Reinhard';break;case Uncharted2ToneMapping:toneMappingName='Uncharted2';break;case CineonToneMapping:toneMappingName='OptimizedCineon';break;case ACESFilmicToneMapping:toneMappingName='ACESFilmic';break;default:throw new Error('unsupported toneMapping: '+toneMapping);}return'vec3 '+functionName+'( vec3 color ) { return '+toneMappingName+'ToneMapping( color ); }';}function generateExtensions(parameters){var chunks=[parameters.extensionDerivatives||parameters.envMapCubeUV||parameters.bumpMap||parameters.tangentSpaceNormalMap||parameters.clearcoatNormalMap||parameters.flatShading||parameters.shaderID==='physical'?'#extension GL_OES_standard_derivatives : enable':'',(parameters.extensionFragDepth||parameters.logarithmicDepthBuffer)&&parameters.rendererExtensionFragDepth?'#extension GL_EXT_frag_depth : enable':'',parameters.extensionDrawBuffers&&parameters.rendererExtensionDrawBuffers?'#extension GL_EXT_draw_buffers : require':'',(parameters.extensionShaderTextureLOD||parameters.envMap)&&parameters.rendererExtensionShaderTextureLod?'#extension GL_EXT_shader_texture_lod : enable':''];return chunks.filter(filterEmptyLine).join('\n');}function generateDefines(defines){var chunks=[];for(var name in defines){var value=defines[name];if(value===false)continue;chunks.push('#define '+name+' '+value);}return chunks.join('\n');}function fetchAttributeLocations(gl,program){var attributes={};var n=gl.getProgramParameter(program,35721);for(var i=0;i<n;i++){var info=gl.getActiveAttrib(program,i);var name=info.name;// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
attributes[name]=gl.getAttribLocation(program,name);}return attributes;}function filterEmptyLine(string){return string!=='';}function replaceLightNums(string,parameters){return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows);}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection);}// Resolve Includes
var includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm;function resolveIncludes(string){return string.replace(includePattern,includeReplacer);}function includeReplacer(match,include){var string=ShaderChunk[include];if(string===undefined){throw new Error('Can not resolve #include <'+include+'>');}return resolveIncludes(string);}// Unroll Loops
var deprecatedUnrollLoopPattern=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;var unrollLoopPattern=/#pragma unroll_loop_start[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}[\s]+?#pragma unroll_loop_end/g;function unrollLoops(string){return string.replace(unrollLoopPattern,loopReplacer).replace(deprecatedUnrollLoopPattern,deprecatedLoopReplacer);}function deprecatedLoopReplacer(match,start,end,snippet){console.warn('WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.');return loopReplacer(match,start,end,snippet);}function loopReplacer(match,start,end,snippet){var string='';for(var i=(0,_parseInt2.default)(start);i<(0,_parseInt2.default)(end);i++){string+=snippet.replace(/\[ i \]/g,'[ '+i+' ]').replace(/UNROLLED_LOOP_INDEX/g,i);}return string;}//
function generatePrecision(parameters){var precisionstring="precision "+parameters.precision+" float;\nprecision "+parameters.precision+" int;";if(parameters.precision==="highp"){precisionstring+="\n#define HIGH_PRECISION";}else if(parameters.precision==="mediump"){precisionstring+="\n#define MEDIUM_PRECISION";}else if(parameters.precision==="lowp"){precisionstring+="\n#define LOW_PRECISION";}return precisionstring;}function generateShadowMapTypeDefine(parameters){var shadowMapTypeDefine='SHADOWMAP_TYPE_BASIC';if(parameters.shadowMapType===PCFShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF';}else if(parameters.shadowMapType===PCFSoftShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_PCF_SOFT';}else if(parameters.shadowMapType===VSMShadowMap){shadowMapTypeDefine='SHADOWMAP_TYPE_VSM';}return shadowMapTypeDefine;}function generateEnvMapTypeDefine(parameters){var envMapTypeDefine='ENVMAP_TYPE_CUBE';if(parameters.envMap){switch(parameters.envMapMode){case CubeReflectionMapping:case CubeRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE';break;case CubeUVReflectionMapping:case CubeUVRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_CUBE_UV';break;case EquirectangularReflectionMapping:case EquirectangularRefractionMapping:envMapTypeDefine='ENVMAP_TYPE_EQUIREC';break;case SphericalReflectionMapping:envMapTypeDefine='ENVMAP_TYPE_SPHERE';break;}}return envMapTypeDefine;}function generateEnvMapModeDefine(parameters){var envMapModeDefine='ENVMAP_MODE_REFLECTION';if(parameters.envMap){switch(parameters.envMapMode){case CubeRefractionMapping:case EquirectangularRefractionMapping:envMapModeDefine='ENVMAP_MODE_REFRACTION';break;}}return envMapModeDefine;}function generateEnvMapBlendingDefine(parameters){var envMapBlendingDefine='ENVMAP_BLENDING_NONE';if(parameters.envMap){switch(parameters.combine){case MultiplyOperation:envMapBlendingDefine='ENVMAP_BLENDING_MULTIPLY';break;case MixOperation:envMapBlendingDefine='ENVMAP_BLENDING_MIX';break;case AddOperation:envMapBlendingDefine='ENVMAP_BLENDING_ADD';break;}}return envMapBlendingDefine;}function WebGLProgram(renderer,cacheKey,parameters){var gl=renderer.getContext();var defines=parameters.defines;var vertexShader=parameters.vertexShader;var fragmentShader=parameters.fragmentShader;var shadowMapTypeDefine=generateShadowMapTypeDefine(parameters);var envMapTypeDefine=generateEnvMapTypeDefine(parameters);var envMapModeDefine=generateEnvMapModeDefine(parameters);var envMapBlendingDefine=generateEnvMapBlendingDefine(parameters);var gammaFactorDefine=renderer.gammaFactor>0?renderer.gammaFactor:1.0;var customExtensions=parameters.isWebGL2?'':generateExtensions(parameters);var customDefines=generateDefines(defines);var program=gl.createProgram();var prefixVertex,prefixFragment;if(parameters.isRawShaderMaterial){prefixVertex=[customDefines].filter(filterEmptyLine).join('\n');if(prefixVertex.length>0){prefixVertex+='\n';}prefixFragment=[customExtensions,customDefines].filter(filterEmptyLine).join('\n');if(prefixFragment.length>0){prefixFragment+='\n';}}else{prefixVertex=[generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.instancing?'#define USE_INSTANCING':'',parameters.supportsVertexTextures?'#define VERTEX_TEXTURES':'','#define GAMMA_FACTOR '+gammaFactorDefine,'#define MAX_BONES '+parameters.maxBones,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.mapMixColor?'#define USE_MAP_MIXCOLOR':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.displacementMap&&parameters.supportsVertexTextures?'#define USE_DISPLACEMENTMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.skinning?'#define USE_SKINNING':'',parameters.useVertexTexture?'#define BONE_TEXTURE':'',parameters.morphTargets?'#define USE_MORPHTARGETS':'',parameters.morphNormals&&parameters.flatShading===false?'#define USE_MORPHNORMALS':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.sizeAttenuation?'#define USE_SIZEATTENUATION':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'','uniform mat4 modelMatrix;','uniform mat4 modelViewMatrix;','uniform mat4 projectionMatrix;','uniform mat4 viewMatrix;','uniform mat3 normalMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;','#ifdef USE_INSTANCING',' attribute mat4 instanceMatrix;','#endif','attribute vec3 position;','attribute vec3 normal;','attribute vec2 uv;','#ifdef USE_TANGENT','	attribute vec4 tangent;','#endif','#ifdef USE_COLOR','	attribute vec3 color;','#endif','#ifdef USE_MORPHTARGETS','	attribute vec3 morphTarget0;','	attribute vec3 morphTarget1;','	attribute vec3 morphTarget2;','	attribute vec3 morphTarget3;','	#ifdef USE_MORPHNORMALS','		attribute vec3 morphNormal0;','		attribute vec3 morphNormal1;','		attribute vec3 morphNormal2;','		attribute vec3 morphNormal3;','	#else','		attribute vec3 morphTarget4;','		attribute vec3 morphTarget5;','		attribute vec3 morphTarget6;','		attribute vec3 morphTarget7;','	#endif','#endif','#ifdef USE_SKINNING','	attribute vec4 skinIndex;','	attribute vec4 skinWeight;','#endif','\n'].filter(filterEmptyLine).join('\n');prefixFragment=[customExtensions,generatePrecision(parameters),'#define SHADER_NAME '+parameters.shaderName,customDefines,parameters.alphaTest?'#define ALPHATEST '+parameters.alphaTest+(parameters.alphaTest%1?'':'.0'):'',// add '.0' if integer
'#define GAMMA_FACTOR '+gammaFactorDefine,parameters.useFog&&parameters.fog?'#define USE_FOG':'',parameters.useFog&&parameters.fogExp2?'#define FOG_EXP2':'',parameters.map?'#define USE_MAP':'',parameters.mapMixColor?'#define USE_MAP_MIXCOLOR':'',parameters.matcap?'#define USE_MATCAP':'',parameters.envMap?'#define USE_ENVMAP':'',parameters.envMap?'#define '+envMapTypeDefine:'',parameters.envMap?'#define '+envMapModeDefine:'',parameters.envMap?'#define '+envMapBlendingDefine:'',parameters.lightMap?'#define USE_LIGHTMAP':'',parameters.aoMap?'#define USE_AOMAP':'',parameters.emissiveMap?'#define USE_EMISSIVEMAP':'',parameters.bumpMap?'#define USE_BUMPMAP':'',parameters.normalMap?'#define USE_NORMALMAP':'',parameters.normalMap&&parameters.objectSpaceNormalMap?'#define OBJECTSPACE_NORMALMAP':'',parameters.normalMap&&parameters.tangentSpaceNormalMap?'#define TANGENTSPACE_NORMALMAP':'',parameters.clearcoatMap?'#define USE_CLEARCOATMAP':'',parameters.clearcoatRoughnessMap?'#define USE_CLEARCOAT_ROUGHNESSMAP':'',parameters.clearcoatNormalMap?'#define USE_CLEARCOAT_NORMALMAP':'',parameters.specularMap?'#define USE_SPECULARMAP':'',parameters.roughnessMap?'#define USE_ROUGHNESSMAP':'',parameters.metalnessMap?'#define USE_METALNESSMAP':'',parameters.alphaMap?'#define USE_ALPHAMAP':'',parameters.sheen?'#define USE_SHEEN':'',parameters.vertexTangents?'#define USE_TANGENT':'',parameters.vertexColors?'#define USE_COLOR':'',parameters.vertexUvs?'#define USE_UV':'',parameters.uvsVertexOnly?'#define UVS_VERTEX_ONLY':'',parameters.gradientMap?'#define USE_GRADIENTMAP':'',parameters.flatShading?'#define FLAT_SHADED':'',parameters.doubleSided?'#define DOUBLE_SIDED':'',parameters.flipSided?'#define FLIP_SIDED':'',parameters.shadowMapEnabled?'#define USE_SHADOWMAP':'',parameters.shadowMapEnabled?'#define '+shadowMapTypeDefine:'',parameters.premultipliedAlpha?'#define PREMULTIPLIED_ALPHA':'',parameters.physicallyCorrectLights?'#define PHYSICALLY_CORRECT_LIGHTS':'',parameters.logarithmicDepthBuffer?'#define USE_LOGDEPTHBUF':'',parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?'#define USE_LOGDEPTHBUF_EXT':'',(parameters.extensionShaderTextureLOD||parameters.envMap)&&parameters.rendererExtensionShaderTextureLod?'#define TEXTURE_LOD_EXT':'','uniform mat4 viewMatrix;','uniform vec3 cameraPosition;','uniform bool isOrthographic;',parameters.toneMapping!==NoToneMapping?'#define TONE_MAPPING':'',parameters.toneMapping!==NoToneMapping?ShaderChunk['tonemapping_pars_fragment']:'',// this code is required here because it is used by the toneMapping() function defined below
parameters.toneMapping!==NoToneMapping?getToneMappingFunction('toneMapping',parameters.toneMapping):'',parameters.dithering?'#define DITHERING':'',parameters.outputEncoding||parameters.mapEncoding||parameters.matcapEncoding||parameters.envMapEncoding||parameters.emissiveMapEncoding||parameters.lightMapEncoding?ShaderChunk['encodings_pars_fragment']:'',// this code is required here because it is used by the various encoding/decoding function defined below
parameters.mapEncoding?getTexelDecodingFunction('mapTexelToLinear',parameters.mapEncoding):'',parameters.matcapEncoding?getTexelDecodingFunction('matcapTexelToLinear',parameters.matcapEncoding):'',parameters.envMapEncoding?getTexelDecodingFunction('envMapTexelToLinear',parameters.envMapEncoding):'',parameters.emissiveMapEncoding?getTexelDecodingFunction('emissiveMapTexelToLinear',parameters.emissiveMapEncoding):'',parameters.lightMapEncoding?getTexelDecodingFunction('lightMapTexelToLinear',parameters.lightMapEncoding):'',parameters.outputEncoding?getTexelEncodingFunction('linearToOutputTexel',parameters.outputEncoding):'',parameters.depthPacking?'#define DEPTH_PACKING '+parameters.depthPacking:'','\n'].filter(filterEmptyLine).join('\n');}vertexShader=resolveIncludes(vertexShader);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=resolveIncludes(fragmentShader);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=unrollLoops(vertexShader);fragmentShader=unrollLoops(fragmentShader);if(parameters.isWebGL2&&!parameters.isRawShaderMaterial){var isGLSL3ShaderMaterial=false;var versionRegex=/^\s*#version\s+300\s+es\s*\n/;if(parameters.isShaderMaterial&&vertexShader.match(versionRegex)!==null&&fragmentShader.match(versionRegex)!==null){isGLSL3ShaderMaterial=true;vertexShader=vertexShader.replace(versionRegex,'');fragmentShader=fragmentShader.replace(versionRegex,'');}// GLSL 3.0 conversion
prefixVertex=['#version 300 es\n','#define attribute in','#define varying out','#define texture2D texture'].join('\n')+'\n'+prefixVertex;prefixFragment=['#version 300 es\n','#define varying in',isGLSL3ShaderMaterial?'':'out highp vec4 pc_fragColor;',isGLSL3ShaderMaterial?'':'#define gl_FragColor pc_fragColor','#define gl_FragDepthEXT gl_FragDepth','#define texture2D texture','#define textureCube texture','#define texture2DProj textureProj','#define texture2DLodEXT textureLod','#define texture2DProjLodEXT textureProjLod','#define textureCubeLodEXT textureLod','#define texture2DGradEXT textureGrad','#define texture2DProjGradEXT textureProjGrad','#define textureCubeGradEXT textureGrad'].join('\n')+'\n'+prefixFragment;}var vertexGlsl=prefixVertex+vertexShader;var fragmentGlsl=prefixFragment+fragmentShader;// console.log( '*VERTEX*', vertexGlsl );
// console.log( '*FRAGMENT*', fragmentGlsl );
var glVertexShader=WebGLShader(gl,35633,vertexGlsl);var glFragmentShader=WebGLShader(gl,35632,fragmentGlsl);gl.attachShader(program,glVertexShader);gl.attachShader(program,glFragmentShader);// Force a particular attribute to index 0.
if(parameters.index0AttributeName!==undefined){gl.bindAttribLocation(program,0,parameters.index0AttributeName);}else if(parameters.morphTargets===true){// programs with morphTargets displace position out of attribute 0
gl.bindAttribLocation(program,0,'position');}gl.linkProgram(program);// check for link errors
if(renderer.debug.checkShaderErrors){var programLog=gl.getProgramInfoLog(program).trim();var vertexLog=gl.getShaderInfoLog(glVertexShader).trim();var fragmentLog=gl.getShaderInfoLog(glFragmentShader).trim();var runnable=true;var haveDiagnostics=true;if(gl.getProgramParameter(program,35714)===false){runnable=false;var vertexErrors=getShaderErrors(gl,glVertexShader,'vertex');var fragmentErrors=getShaderErrors(gl,glFragmentShader,'fragment');console.error('THREE.WebGLProgram: shader error: ',gl.getError(),'35715',gl.getProgramParameter(program,35715),'gl.getProgramInfoLog',programLog,vertexErrors,fragmentErrors);}else if(programLog!==''){console.warn('THREE.WebGLProgram: gl.getProgramInfoLog()',programLog);}else if(vertexLog===''||fragmentLog===''){haveDiagnostics=false;}if(haveDiagnostics){this.diagnostics={runnable:runnable,programLog:programLog,vertexShader:{log:vertexLog,prefix:prefixVertex},fragmentShader:{log:fragmentLog,prefix:prefixFragment}};}}// clean up
gl.detachShader(program,glVertexShader);gl.detachShader(program,glFragmentShader);gl.deleteShader(glVertexShader);gl.deleteShader(glFragmentShader);// set up caching for uniform locations
var cachedUniforms;this.getUniforms=function(){if(cachedUniforms===undefined){cachedUniforms=new WebGLUniforms(gl,program);}return cachedUniforms;};// set up caching for attribute locations
var cachedAttributes;this.getAttributes=function(){if(cachedAttributes===undefined){cachedAttributes=fetchAttributeLocations(gl,program);}return cachedAttributes;};// free resource
this.destroy=function(){gl.deleteProgram(program);this.program=undefined;};//
this.name=parameters.shaderName;this.id=programIdCount++;this.cacheKey=cacheKey;this.usedTimes=1;this.program=program;this.vertexShader=glVertexShader;this.fragmentShader=glFragmentShader;return this;}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLPrograms(renderer,extensions,capabilities){var programs=[];var isWebGL2=capabilities.isWebGL2;var logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer;var floatVertexTextures=capabilities.floatVertexTextures;var precision=capabilities.precision;var maxVertexUniforms=capabilities.maxVertexUniforms;var vertexTextures=capabilities.vertexTextures;var shaderIDs={MeshDepthMaterial:'depth',MeshDistanceMaterial:'distanceRGBA',MeshNormalMaterial:'normal',MeshBasicMaterial:'basic',MeshLambertMaterial:'lambert',MeshPhongMaterial:'phong',MeshToonMaterial:'toon',MeshStandardMaterial:'physical',MeshPhysicalMaterial:'physical',MeshMatcapMaterial:'matcap',LineBasicMaterial:'basic',LineDashedMaterial:'dashed',PointsMaterial:'points',ShadowMaterial:'shadow',SpriteMaterial:'sprite'};var parameterNames=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","map","mapMixColor","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap","roughnessMap","metalnessMap","gradientMap","alphaMap","combine","vertexColors","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","maxMorphTargets","maxMorphNormals","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping",'physicallyCorrectLights',"alphaTest","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","sheen"];function getShaderObject(material,shaderID){var shaderobject;if(shaderID){var shader=ShaderLib[shaderID];shaderobject={name:material.type,uniforms:UniformsUtils.clone(shader.uniforms),vertexShader:shader.vertexShader,fragmentShader:shader.fragmentShader};}else{shaderobject={name:material.type,uniforms:material.uniforms,vertexShader:material.vertexShader,fragmentShader:material.fragmentShader};}return shaderobject;}function allocateBones(object){var skeleton=object.skeleton;var bones=skeleton.bones;if(floatVertexTextures){return 1024;}else{// default for when object is not specified
// ( for example when prebuilding shader to be used with multiple objects )
//
//  - leave some extra space for other uniforms
//  - limit here is ANGLE's 254 max uniform vectors
//    (up to 54 should be safe)
var nVertexUniforms=maxVertexUniforms;var nVertexMatrices=Math.floor((nVertexUniforms-20)/4);var maxBones=Math.min(nVertexMatrices,bones.length);if(maxBones<bones.length){//console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
return 0;}return maxBones;}}function getTextureEncodingFromMap(map){var encoding;if(!map){encoding=LinearEncoding;}else if(map.isTexture){encoding=map.encoding;}else if(map.isWebGLRenderTarget){console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");encoding=map.texture.encoding;}return encoding;}this.getParameters=function(material,lights,shadows,scene,nClipPlanes,nClipIntersection,object){var fog=scene.fog;var environment=material.isMeshStandardMaterial?scene.environment:null;var envMap=material.envMap||environment;var shaderID=shaderIDs[material.type];// heuristics to create shader parameters according to lights in the scene
// (not to blow over maxLights budget)
var maxBones=object.isSkinnedMesh?allocateBones(object):0;if(material.precision!==null){precision=capabilities.getMaxPrecision(material.precision);if(precision!==material.precision){console.warn('THREE.WebGLProgram.getParameters:',material.precision,'not supported, using',precision,'instead.');}}var shaderobject=getShaderObject(material,shaderID);material.onBeforeCompile(shaderobject,renderer);var currentRenderTarget=renderer.getRenderTarget();var parameters={isWebGL2:isWebGL2,shaderID:shaderID,shaderName:shaderobject.name,uniforms:shaderobject.uniforms,vertexShader:shaderobject.vertexShader,fragmentShader:shaderobject.fragmentShader,defines:material.defines,isRawShaderMaterial:material.isRawShaderMaterial,isShaderMaterial:material.isShaderMaterial,precision:precision,instancing:object.isInstancedMesh===true,supportsVertexTextures:vertexTextures,outputEncoding:currentRenderTarget!==null?getTextureEncodingFromMap(currentRenderTarget.texture):renderer.outputEncoding,map:!!material.map,mapMixColor:!!material.mapMixColor,mapEncoding:getTextureEncodingFromMap(material.map),matcap:!!material.matcap,matcapEncoding:getTextureEncodingFromMap(material.matcap),envMap:!!envMap,envMapMode:envMap&&envMap.mapping,envMapEncoding:getTextureEncodingFromMap(envMap),envMapCubeUV:!!envMap&&(envMap.mapping===CubeUVReflectionMapping||envMap.mapping===CubeUVRefractionMapping),lightMap:!!material.lightMap,lightMapEncoding:getTextureEncodingFromMap(material.lightMap),aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,emissiveMapEncoding:getTextureEncodingFromMap(material.emissiveMap),bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,objectSpaceNormalMap:material.normalMapType===ObjectSpaceNormalMap,tangentSpaceNormalMap:material.normalMapType===TangentSpaceNormalMap,clearcoatMap:!!material.clearcoatMap,clearcoatRoughnessMap:!!material.clearcoatRoughnessMap,clearcoatNormalMap:!!material.clearcoatNormalMap,displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,alphaMap:!!material.alphaMap,gradientMap:!!material.gradientMap,sheen:!!material.sheen,combine:material.combine,vertexTangents:material.normalMap&&material.vertexTangents,vertexColors:material.vertexColors,vertexUvs:!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatMap||!!material.clearcoatRoughnessMap||!!material.clearcoatNormalMap||!!material.displacementMap,uvsVertexOnly:!(!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||!!material.metalnessMap||!!material.clearcoatNormalMap)&&!!material.displacementMap,fog:!!fog,useFog:material.fog,fogExp2:fog&&fog.isFogExp2,flatShading:material.flatShading,sizeAttenuation:material.sizeAttenuation,logarithmicDepthBuffer:logarithmicDepthBuffer,skinning:material.skinning&&maxBones>0,maxBones:maxBones,useVertexTexture:floatVertexTextures,morphTargets:material.morphTargets,morphNormals:material.morphNormals,maxMorphTargets:renderer.maxMorphTargets,maxMorphNormals:renderer.maxMorphNormals,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numClippingPlanes:nClipPlanes,numClipIntersection:nClipIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&shadows.length>0,shadowMapType:renderer.shadowMap.type,toneMapping:material.toneMapped?renderer.toneMapping:NoToneMapping,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,alphaTest:material.alphaTest,doubleSided:material.side===DoubleSide,flipSided:material.side===BackSide,depthPacking:material.depthPacking!==undefined?material.depthPacking:false,index0AttributeName:material.index0AttributeName,extensionDerivatives:material.extensions&&material.extensions.derivatives,extensionFragDepth:material.extensions&&material.extensions.fragDepth,extensionDrawBuffers:material.extensions&&material.extensions.drawBuffers,extensionShaderTextureLOD:material.extensions&&material.extensions.shaderTextureLOD,rendererExtensionFragDepth:isWebGL2||extensions.get('EXT_frag_depth')!==null,rendererExtensionDrawBuffers:isWebGL2||extensions.get('WEBGL_draw_buffers')!==null,rendererExtensionShaderTextureLod:isWebGL2||extensions.get('EXT_shader_texture_lod')!==null,onBeforeCompile:material.onBeforeCompile};return parameters;};this.getProgramCacheKey=function(parameters){var array=[];if(parameters.shaderID){array.push(parameters.shaderID);}else{array.push(parameters.fragmentShader);array.push(parameters.vertexShader);}if(parameters.defines!==undefined){for(var name in parameters.defines){array.push(name);array.push(parameters.defines[name]);}}if(parameters.isRawShaderMaterial===undefined){for(var i=0;i<parameterNames.length;i++){array.push(parameters[parameterNames[i]]);}array.push(renderer.outputEncoding);array.push(renderer.gammaFactor);}array.push(parameters.onBeforeCompile.toString());return array.join();};this.acquireProgram=function(parameters,cacheKey){var program;// Check if code has been already compiled
for(var p=0,pl=programs.length;p<pl;p++){var preexistingProgram=programs[p];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram;++program.usedTimes;break;}}if(program===undefined){program=new WebGLProgram(renderer,cacheKey,parameters);programs.push(program);}return program;};this.releaseProgram=function(program){if(--program.usedTimes===0){// Remove from unordered set
var i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();// Free WebGL resources
program.destroy();}};// Exposed for resource monitoring & error feedback via renderer.info:
this.programs=programs;}/**
 * @author fordacious / fordacious.github.io
 */function WebGLProperties(){var properties=new _weakMap.default();function get(object){var map=properties.get(object);if(map===undefined){map={};properties.set(object,map);}return map;}function remove(object){properties.delete(object);}function update(object,key,value){properties.get(object)[key]=value;}function dispose(){properties=new _weakMap.default();}return{get:get,remove:remove,update:update,dispose:dispose};}/**
 * @author mrdoob / http://mrdoob.com/
 */function painterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.program!==b.program){return a.program.id-b.program.id;}else if(a.material.id!==b.material.id){return a.material.id-b.material.id;}else if(a.z!==b.z){return a.z-b.z;}else{return a.id-b.id;}}function reversePainterSortStable(a,b){if(a.groupOrder!==b.groupOrder){return a.groupOrder-b.groupOrder;}else if(a.renderOrder!==b.renderOrder){return a.renderOrder-b.renderOrder;}else if(a.z!==b.z){return b.z-a.z;}else{return a.id-b.id;}}function WebGLRenderList(){var renderItems=[];var renderItemsIndex=0;var opaque=[];var transparent=[];var defaultProgram={id:-1};function init(){renderItemsIndex=0;opaque.length=0;transparent.length=0;}function getNextRenderItem(object,geometry,material,groupOrder,z,group){var renderItem=renderItems[renderItemsIndex];if(renderItem===undefined){renderItem={id:object.id,object:object,geometry:geometry,material:material,program:material.program||defaultProgram,groupOrder:groupOrder,renderOrder:object.renderOrder,z:z,group:group};renderItems[renderItemsIndex]=renderItem;}else{renderItem.id=object.id;renderItem.object=object;renderItem.geometry=geometry;renderItem.material=material;renderItem.program=material.program||defaultProgram;renderItem.groupOrder=groupOrder;renderItem.renderOrder=object.renderOrder;renderItem.z=z;renderItem.group=group;}renderItemsIndex++;return renderItem;}function push(object,geometry,material,groupOrder,z,group){var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);(material.transparent===true?transparent:opaque).push(renderItem);}function unshift(object,geometry,material,groupOrder,z,group){var renderItem=getNextRenderItem(object,geometry,material,groupOrder,z,group);(material.transparent===true?transparent:opaque).unshift(renderItem);}function sort(customOpaqueSort,customTransparentSort){if(opaque.length>1)opaque.sort(customOpaqueSort||painterSortStable);if(transparent.length>1)transparent.sort(customTransparentSort||reversePainterSortStable);}function finish(){// Clear references from inactive renderItems in the list
for(var i=renderItemsIndex,il=renderItems.length;i<il;i++){var renderItem=renderItems[i];if(renderItem.id===null)break;renderItem.id=null;renderItem.object=null;renderItem.geometry=null;renderItem.material=null;renderItem.program=null;renderItem.group=null;}}return{opaque:opaque,transparent:transparent,init:init,push:push,unshift:unshift,finish:finish,sort:sort};}function WebGLRenderLists(){var lists=new _weakMap.default();function onSceneDispose(event){var scene=event.target;scene.removeEventListener('dispose',onSceneDispose);lists.delete(scene);}function get(scene,camera){var cameras=lists.get(scene);var list;if(cameras===undefined){list=new WebGLRenderList();lists.set(scene,new _weakMap.default());lists.get(scene).set(camera,list);scene.addEventListener('dispose',onSceneDispose);}else{list=cameras.get(camera);if(list===undefined){list=new WebGLRenderList();cameras.set(camera,list);}}return list;}function dispose(){lists=new _weakMap.default();}return{get:get,dispose:dispose};}/**
 * @author mrdoob / http://mrdoob.com/
 */function UniformsCache(){var lights={};return{get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={direction:new Vector3(),color:new Color()};break;case'SpotLight':uniforms={position:new Vector3(),direction:new Vector3(),color:new Color(),distance:0,coneCos:0,penumbraCos:0,decay:0};break;case'PointLight':uniforms={position:new Vector3(),color:new Color(),distance:0,decay:0};break;case'HemisphereLight':uniforms={direction:new Vector3(),skyColor:new Color(),groundColor:new Color()};break;case'RectAreaLight':uniforms={color:new Color(),position:new Vector3(),halfWidth:new Vector3(),halfHeight:new Vector3()};break;}lights[light.id]=uniforms;return uniforms;}};}function ShadowUniformsCache(){var lights={};return{get:function get(light){if(lights[light.id]!==undefined){return lights[light.id];}var uniforms;switch(light.type){case'DirectionalLight':uniforms={shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'SpotLight':uniforms={shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2()};break;case'PointLight':uniforms={shadowBias:0,shadowRadius:1,shadowMapSize:new Vector2(),shadowCameraNear:1,shadowCameraFar:1000};break;// TODO (abelnation): set RectAreaLight shadow uniforms
}lights[light.id]=uniforms;return uniforms;}};}var nextVersion=0;function shadowCastingLightsFirst(lightA,lightB){return(lightB.castShadow?1:0)-(lightA.castShadow?1:0);}function WebGLLights(){var cache=new UniformsCache();var shadowCache=ShadowUniformsCache();var state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(var i=0;i<9;i++){state.probe.push(new Vector3());}var vector3=new Vector3();var matrix4=new Matrix4();var matrix42=new Matrix4();function setup(lights,shadows,camera){var r=0,g=0,b=0;for(var i=0;i<9;i++){state.probe[i].set(0,0,0);}var directionalLength=0;var pointLength=0;var spotLength=0;var rectAreaLength=0;var hemiLength=0;var numDirectionalShadows=0;var numPointShadows=0;var numSpotShadows=0;var viewMatrix=camera.matrixWorldInverse;lights.sort(shadowCastingLightsFirst);for(var i=0,l=lights.length;i<l;i++){var light=lights[i];var color=light.color;var intensity=light.intensity;var distance=light.distance;var shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight){r+=color.r*intensity;g+=color.g*intensity;b+=color.b*intensity;}else if(light.isLightProbe){for(var j=0;j<9;j++){state.probe[j].addScaledVector(light.sh.coefficients[j],intensity);}}else if(light.isDirectionalLight){var uniforms=cache.get(light);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);if(light.castShadow){var shadow=light.shadow;var shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.directionalShadow[directionalLength]=shadowUniforms;state.directionalShadowMap[directionalLength]=shadowMap;state.directionalShadowMatrix[directionalLength]=light.shadow.matrix;numDirectionalShadows++;}state.directional[directionalLength]=uniforms;directionalLength++;}else if(light.isSpotLight){var uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(color).multiplyScalar(intensity);uniforms.distance=distance;uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(viewMatrix);uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.decay;if(light.castShadow){var shadow=light.shadow;var shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;state.spotShadow[spotLength]=shadowUniforms;state.spotShadowMap[spotLength]=shadowMap;state.spotShadowMatrix[spotLength]=light.shadow.matrix;numSpotShadows++;}state.spot[spotLength]=uniforms;spotLength++;}else if(light.isRectAreaLight){var uniforms=cache.get(light);// (a) intensity is the total visible light emitted
//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
// (b) intensity is the brightness of the light
uniforms.color.copy(color).multiplyScalar(intensity);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);// extract local rotation of light to derive width/height half vectors
matrix42.identity();matrix4.copy(light.matrixWorld);matrix4.premultiply(viewMatrix);matrix42.extractRotation(matrix4);uniforms.halfWidth.set(light.width*0.5,0.0,0.0);uniforms.halfHeight.set(0.0,light.height*0.5,0.0);uniforms.halfWidth.applyMatrix4(matrix42);uniforms.halfHeight.applyMatrix4(matrix42);// TODO (abelnation): RectAreaLight distance?
// uniforms.distance = distance;
state.rectArea[rectAreaLength]=uniforms;rectAreaLength++;}else if(light.isPointLight){var uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.position.applyMatrix4(viewMatrix);uniforms.color.copy(light.color).multiplyScalar(light.intensity);uniforms.distance=light.distance;uniforms.decay=light.decay;if(light.castShadow){var shadow=light.shadow;var shadowUniforms=shadowCache.get(light);shadowUniforms.shadowBias=shadow.bias;shadowUniforms.shadowRadius=shadow.radius;shadowUniforms.shadowMapSize=shadow.mapSize;shadowUniforms.shadowCameraNear=shadow.camera.near;shadowUniforms.shadowCameraFar=shadow.camera.far;state.pointShadow[pointLength]=shadowUniforms;state.pointShadowMap[pointLength]=shadowMap;state.pointShadowMatrix[pointLength]=light.shadow.matrix;numPointShadows++;}state.point[pointLength]=uniforms;pointLength++;}else if(light.isHemisphereLight){var uniforms=cache.get(light);uniforms.direction.setFromMatrixPosition(light.matrixWorld);uniforms.direction.transformDirection(viewMatrix);uniforms.direction.normalize();uniforms.skyColor.copy(light.color).multiplyScalar(intensity);uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);state.hemi[hemiLength]=uniforms;hemiLength++;}}state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;var hash=state.hash;if(hash.directionalLength!==directionalLength||hash.pointLength!==pointLength||hash.spotLength!==spotLength||hash.rectAreaLength!==rectAreaLength||hash.hemiLength!==hemiLength||hash.numDirectionalShadows!==numDirectionalShadows||hash.numPointShadows!==numPointShadows||hash.numSpotShadows!==numSpotShadows){state.directional.length=directionalLength;state.spot.length=spotLength;state.rectArea.length=rectAreaLength;state.point.length=pointLength;state.hemi.length=hemiLength;state.directionalShadow.length=numDirectionalShadows;state.directionalShadowMap.length=numDirectionalShadows;state.pointShadow.length=numPointShadows;state.pointShadowMap.length=numPointShadows;state.spotShadow.length=numSpotShadows;state.spotShadowMap.length=numSpotShadows;state.directionalShadowMatrix.length=numDirectionalShadows;state.pointShadowMatrix.length=numPointShadows;state.spotShadowMatrix.length=numSpotShadows;hash.directionalLength=directionalLength;hash.pointLength=pointLength;hash.spotLength=spotLength;hash.rectAreaLength=rectAreaLength;hash.hemiLength=hemiLength;hash.numDirectionalShadows=numDirectionalShadows;hash.numPointShadows=numPointShadows;hash.numSpotShadows=numSpotShadows;state.version=nextVersion++;}}return{setup:setup,state:state};}/**
 * @author Mugen87 / https://github.com/Mugen87
 */function WebGLRenderState(){var lights=new WebGLLights();var lightsArray=[];var shadowsArray=[];function init(){lightsArray.length=0;shadowsArray.length=0;}function pushLight(light){lightsArray.push(light);}function pushShadow(shadowLight){shadowsArray.push(shadowLight);}function setupLights(camera){lights.setup(lightsArray,shadowsArray,camera);}var state={lightsArray:lightsArray,shadowsArray:shadowsArray,lights:lights};return{init:init,state:state,setupLights:setupLights,pushLight:pushLight,pushShadow:pushShadow};}function WebGLRenderStates(){var renderStates=new _weakMap.default();function onSceneDispose(event){var scene=event.target;scene.removeEventListener('dispose',onSceneDispose);renderStates.delete(scene);}function get(scene,camera){var renderState;if(renderStates.has(scene)===false){renderState=new WebGLRenderState();renderStates.set(scene,new _weakMap.default());renderStates.get(scene).set(camera,renderState);scene.addEventListener('dispose',onSceneDispose);}else{if(renderStates.get(scene).has(camera)===false){renderState=new WebGLRenderState();renderStates.get(scene).set(camera,renderState);}else{renderState=renderStates.get(scene).get(camera);}}return renderState;}function dispose(){renderStates=new _weakMap.default();}return{get:get,dispose:dispose};}/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */function MeshDepthMaterial(parameters){Material.call(this);this.type='MeshDepthMaterial';this.depthPacking=BasicDepthPacking;this.skinning=false;this.morphTargets=false;this.map=null;this.mapMixColor=false;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.setValues(parameters);}MeshDepthMaterial.prototype=(0,_create.default)(Material.prototype);MeshDepthMaterial.prototype.constructor=MeshDepthMaterial;MeshDepthMaterial.prototype.isMeshDepthMaterial=true;MeshDepthMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.depthPacking=source.depthPacking;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this;};/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */function MeshDistanceMaterial(parameters){Material.call(this);this.type='MeshDistanceMaterial';this.referencePosition=new Vector3();this.nearDistance=1;this.farDistance=1000;this.skinning=false;this.morphTargets=false;this.map=null;this.alphaMap=null;this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.fog=false;this.setValues(parameters);}MeshDistanceMaterial.prototype=(0,_create.default)(Material.prototype);MeshDistanceMaterial.prototype.constructor=MeshDistanceMaterial;MeshDistanceMaterial.prototype.isMeshDistanceMaterial=true;MeshDistanceMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.referencePosition.copy(source.referencePosition);this.nearDistance=source.nearDistance;this.farDistance=source.farDistance;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;return this;};var vsm_frag="uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";var vsm_vert="void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */function WebGLShadowMap(_renderer,_objects,maxTextureSize){var _frustum=new Frustum(),_shadowMapSize=new Vector2(),_viewportSize=new Vector2(),_viewport=new Vector4(),_depthMaterials=[],_distanceMaterials=[],_materialCache={};var shadowSide={0:BackSide,1:FrontSide,2:DoubleSide};var shadowMaterialVertical=new ShaderMaterial({defines:{SAMPLE_RATE:2.0/8.0,HALF_SAMPLE_RATE:1.0/8.0},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2()},radius:{value:4.0}},vertexShader:vsm_vert,fragmentShader:vsm_frag});var shadowMaterialHorizonal=shadowMaterialVertical.clone();shadowMaterialHorizonal.defines.HORIZONAL_PASS=1;var fullScreenTri=new BufferGeometry();fullScreenTri.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,0.5,3,-1,0.5,-1,3,0.5]),3));var fullScreenMesh=new Mesh(fullScreenTri,shadowMaterialVertical);var scope=this;this.enabled=false;this.autoUpdate=true;this.needsUpdate=false;this.type=PCFShadowMap;this.render=function(lights,scene,camera){if(scope.enabled===false)return;if(scope.autoUpdate===false&&scope.needsUpdate===false)return;if(lights.length===0)return;var currentRenderTarget=_renderer.getRenderTarget();var activeCubeFace=_renderer.getActiveCubeFace();var activeMipmapLevel=_renderer.getActiveMipmapLevel();var _state=_renderer.state;// Set GL state for depth map.
_state.setBlending(NoBlending);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(true);_state.setScissorTest(false);// render depth map
for(var i=0,il=lights.length;i<il;i++){var light=lights[i];var shadow=light.shadow;if(shadow===undefined){console.warn('THREE.WebGLShadowMap:',light,'has no shadow.');continue;}_shadowMapSize.copy(shadow.mapSize);var shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>maxTextureSize||_shadowMapSize.y>maxTextureSize){console.warn('THREE.WebGLShadowMap:',light,'has shadow exceeding max texture size, reducing');if(_shadowMapSize.x>maxTextureSize){_viewportSize.x=Math.floor(maxTextureSize/shadowFrameExtents.x);_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x;shadow.mapSize.x=_viewportSize.x;}if(_shadowMapSize.y>maxTextureSize){_viewportSize.y=Math.floor(maxTextureSize/shadowFrameExtents.y);_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y;shadow.mapSize.y=_viewportSize.y;}}if(shadow.map===null&&!shadow.isPointLightShadow&&this.type===VSMShadowMap){var pars={minFilter:LinearFilter,magFilter:LinearFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+".shadowMap";shadow.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.camera.updateProjectionMatrix();}if(shadow.map===null){var pars={minFilter:NearestFilter,magFilter:NearestFilter,format:RGBAFormat};shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,pars);shadow.map.texture.name=light.name+".shadowMap";shadow.camera.updateProjectionMatrix();}_renderer.setRenderTarget(shadow.map);_renderer.clear();var viewportCount=shadow.getViewportCount();for(var vp=0;vp<viewportCount;vp++){var viewport=shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type);}// do blur pass for VSM
if(!shadow.isPointLightShadow&&this.type===VSMShadowMap){VSMPass(shadow,camera);}}scope.needsUpdate=false;_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel);};function VSMPass(shadow,camera){var geometry=_objects.update(fullScreenMesh);// vertical pass
shadowMaterialVertical.uniforms.shadow_pass.value=shadow.map.texture;shadowMaterialVertical.uniforms.resolution.value=shadow.mapSize;shadowMaterialVertical.uniforms.radius.value=shadow.radius;_renderer.setRenderTarget(shadow.mapPass);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialVertical,fullScreenMesh,null);// horizonal pass
shadowMaterialHorizonal.uniforms.shadow_pass.value=shadow.mapPass.texture;shadowMaterialHorizonal.uniforms.resolution.value=shadow.mapSize;shadowMaterialHorizonal.uniforms.radius.value=shadow.radius;_renderer.setRenderTarget(shadow.map);_renderer.clear();_renderer.renderBufferDirect(camera,null,geometry,shadowMaterialHorizonal,fullScreenMesh,null);}function getDepthMaterialVariant(useMorphing,useSkinning,useInstancing){var index=useMorphing<<0|useSkinning<<1|useInstancing<<2;var material=_depthMaterials[index];if(material===undefined){material=new MeshDepthMaterial({depthPacking:RGBADepthPacking,morphTargets:useMorphing,skinning:useSkinning});_depthMaterials[index]=material;}return material;}function getDistanceMaterialVariant(useMorphing,useSkinning,useInstancing){var index=useMorphing<<0|useSkinning<<1|useInstancing<<2;var material=_distanceMaterials[index];if(material===undefined){material=new MeshDistanceMaterial({morphTargets:useMorphing,skinning:useSkinning});_distanceMaterials[index]=material;}return material;}function getDepthMaterial(object,material,light,shadowCameraNear,shadowCameraFar,type){var geometry=object.geometry;var result=null;var getMaterialVariant=getDepthMaterialVariant;var customMaterial=object.customDepthMaterial;if(light.isPointLight===true){getMaterialVariant=getDistanceMaterialVariant;customMaterial=object.customDistanceMaterial;}if(customMaterial===undefined){var useMorphing=false;if(material.morphTargets===true){if(geometry.isBufferGeometry===true){useMorphing=geometry.morphAttributes&&geometry.morphAttributes.position&&geometry.morphAttributes.position.length>0;}else if(geometry.isGeometry===true){useMorphing=geometry.morphTargets&&geometry.morphTargets.length>0;}}var useSkinning=false;if(object.isSkinnedMesh===true){if(material.skinning===true){useSkinning=true;}else{console.warn('THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:',object);}}var useInstancing=object.isInstancedMesh===true;result=getMaterialVariant(useMorphing,useSkinning,useInstancing);}else{result=customMaterial;}if(_renderer.localClippingEnabled&&material.clipShadows===true&&material.clippingPlanes.length!==0){// in this case we need a unique material instance reflecting the
// appropriate state
var keyA=result.uuid,keyB=material.uuid;var materialsForVariant=_materialCache[keyA];if(materialsForVariant===undefined){materialsForVariant={};_materialCache[keyA]=materialsForVariant;}var cachedMaterial=materialsForVariant[keyB];if(cachedMaterial===undefined){cachedMaterial=result.clone();materialsForVariant[keyB]=cachedMaterial;}result=cachedMaterial;}result.visible=material.visible;result.wireframe=material.wireframe;if(type===VSMShadowMap){result.side=material.shadowSide!==null?material.shadowSide:material.side;}else{result.side=material.shadowSide!==null?material.shadowSide:shadowSide[material.side];}result.clipShadows=material.clipShadows;result.clippingPlanes=material.clippingPlanes;result.clipIntersection=material.clipIntersection;result.wireframeLinewidth=material.wireframeLinewidth;result.linewidth=material.linewidth;if(light.isPointLight===true&&result.isMeshDistanceMaterial===true){result.referencePosition.setFromMatrixPosition(light.matrixWorld);result.nearDistance=shadowCameraNear;result.farDistance=shadowCameraFar;}return result;}function renderObject(object,camera,shadowCamera,light,type){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible&&(object.isMesh||object.isLine||object.isPoints)){if((object.castShadow||object.receiveShadow&&type===VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,object.matrixWorld);var geometry=_objects.update(object);var material=object.material;if((0,_isArray.default)(material)){var groups=geometry.groups;for(var k=0,kl=groups.length;k<kl;k++){var group=groups[k];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){var depthMaterial=getDepthMaterial(object,groupMaterial,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,group);}}}else if(material.visible){var depthMaterial=getDepthMaterial(object,material,light,shadowCamera.near,shadowCamera.far,type);_renderer.renderBufferDirect(shadowCamera,null,geometry,depthMaterial,object,null);}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){renderObject(children[i],camera,shadowCamera,light,type);}}}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLState(gl,extensions,capabilities){var _equationToGL,_factorToGL;var isWebGL2=capabilities.isWebGL2;function ColorBuffer(){var locked=false;var color=new Vector4();var currentColorMask=null;var currentColorClear=new Vector4(0,0,0,0);return{setMask:function setMask(colorMask){if(currentColorMask!==colorMask&&!locked){gl.colorMask(colorMask,colorMask,colorMask,colorMask);currentColorMask=colorMask;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(r,g,b,a,premultipliedAlpha){if(premultipliedAlpha===true){r*=a;g*=a;b*=a;}color.set(r,g,b,a);if(currentColorClear.equals(color)===false){gl.clearColor(r,g,b,a);currentColorClear.copy(color);}},reset:function reset(){locked=false;currentColorMask=null;currentColorClear.set(-1,0,0,0);// set to invalid state
}};}function DepthBuffer(){var locked=false;var currentDepthMask=null;var currentDepthFunc=null;var currentDepthClear=null;return{setTest:function setTest(depthTest){if(depthTest){enable(2929);}else{disable(2929);}},setMask:function setMask(depthMask){if(currentDepthMask!==depthMask&&!locked){gl.depthMask(depthMask);currentDepthMask=depthMask;}},setFunc:function setFunc(depthFunc){if(currentDepthFunc!==depthFunc){if(depthFunc){switch(depthFunc){case NeverDepth:gl.depthFunc(512);break;case AlwaysDepth:gl.depthFunc(519);break;case LessDepth:gl.depthFunc(513);break;case LessEqualDepth:gl.depthFunc(515);break;case EqualDepth:gl.depthFunc(514);break;case GreaterEqualDepth:gl.depthFunc(518);break;case GreaterDepth:gl.depthFunc(516);break;case NotEqualDepth:gl.depthFunc(517);break;default:gl.depthFunc(515);}}else{gl.depthFunc(515);}currentDepthFunc=depthFunc;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(depth){if(currentDepthClear!==depth){gl.clearDepth(depth);currentDepthClear=depth;}},reset:function reset(){locked=false;currentDepthMask=null;currentDepthFunc=null;currentDepthClear=null;}};}function StencilBuffer(){var locked=false;var currentStencilMask=null;var currentStencilFunc=null;var currentStencilRef=null;var currentStencilFuncMask=null;var currentStencilFail=null;var currentStencilZFail=null;var currentStencilZPass=null;var currentStencilClear=null;return{setTest:function setTest(stencilTest){if(!locked){if(stencilTest){enable(2960);}else{disable(2960);}}},setMask:function setMask(stencilMask){if(currentStencilMask!==stencilMask&&!locked){gl.stencilMask(stencilMask);currentStencilMask=stencilMask;}},setFunc:function setFunc(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask){gl.stencilFunc(stencilFunc,stencilRef,stencilMask);currentStencilFunc=stencilFunc;currentStencilRef=stencilRef;currentStencilFuncMask=stencilMask;}},setOp:function setOp(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||currentStencilZPass!==stencilZPass){gl.stencilOp(stencilFail,stencilZFail,stencilZPass);currentStencilFail=stencilFail;currentStencilZFail=stencilZFail;currentStencilZPass=stencilZPass;}},setLocked:function setLocked(lock){locked=lock;},setClear:function setClear(stencil){if(currentStencilClear!==stencil){gl.clearStencil(stencil);currentStencilClear=stencil;}},reset:function reset(){locked=false;currentStencilMask=null;currentStencilFunc=null;currentStencilRef=null;currentStencilFuncMask=null;currentStencilFail=null;currentStencilZFail=null;currentStencilZPass=null;currentStencilClear=null;}};}//
var colorBuffer=new ColorBuffer();var depthBuffer=new DepthBuffer();var stencilBuffer=new StencilBuffer();var maxVertexAttributes=gl.getParameter(34921);var newAttributes=new Uint8Array(maxVertexAttributes);var enabledAttributes=new Uint8Array(maxVertexAttributes);var attributeDivisors=new Uint8Array(maxVertexAttributes);var enabledCapabilities={};var currentProgram=null;var currentBlendingEnabled=null;var currentBlending=null;var currentBlendEquation=null;var currentBlendSrc=null;var currentBlendDst=null;var currentBlendEquationAlpha=null;var currentBlendSrcAlpha=null;var currentBlendDstAlpha=null;var currentPremultipledAlpha=false;var currentFlipSided=null;var currentCullFace=null;var currentLineWidth=null;var currentPolygonOffsetFactor=null;var currentPolygonOffsetUnits=null;var maxTextures=gl.getParameter(35661);var lineWidthAvailable=false;var version=0;var glVersion=gl.getParameter(7938);if(glVersion.indexOf('WebGL')!==-1){version=(0,_parseFloat2.default)(/^WebGL\ ([0-9])/.exec(glVersion)[1]);lineWidthAvailable=version>=1.0;}else if(glVersion.indexOf('OpenGL ES')!==-1){version=(0,_parseFloat2.default)(/^OpenGL\ ES\ ([0-9])/.exec(glVersion)[1]);lineWidthAvailable=version>=2.0;}var currentTextureSlot=null;var currentBoundTextures={};var currentScissor=new Vector4();var currentViewport=new Vector4();function createTexture(type,target,count){var data=new Uint8Array(4);// 4 is required to match default unpack alignment of 4.
var texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,10241,9728);gl.texParameteri(type,10240,9728);for(var i=0;i<count;i++){gl.texImage2D(target+i,0,6408,1,1,0,6408,5121,data);}return texture;}var emptyTextures={};emptyTextures[3553]=createTexture(3553,3553,1);emptyTextures[34067]=createTexture(34067,34069,6);// init
colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(2929);depthBuffer.setFunc(LessEqualDepth);setFlipSided(false);setCullFace(CullFaceBack);enable(2884);setBlending(NoBlending);//
function initAttributes(){for(var i=0,l=newAttributes.length;i<l;i++){newAttributes[i]=0;}}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0);}function enableAttributeAndDivisor(attribute,meshPerAttribute){newAttributes[attribute]=1;if(enabledAttributes[attribute]===0){gl.enableVertexAttribArray(attribute);enabledAttributes[attribute]=1;}if(attributeDivisors[attribute]!==meshPerAttribute){var extension=isWebGL2?gl:extensions.get('ANGLE_instanced_arrays');extension[isWebGL2?'vertexAttribDivisor':'vertexAttribDivisorANGLE'](attribute,meshPerAttribute);attributeDivisors[attribute]=meshPerAttribute;}}function disableUnusedAttributes(){for(var i=0,l=enabledAttributes.length;i!==l;++i){if(enabledAttributes[i]!==newAttributes[i]){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}}function enable(id){if(enabledCapabilities[id]!==true){gl.enable(id);enabledCapabilities[id]=true;}}function disable(id){if(enabledCapabilities[id]!==false){gl.disable(id);enabledCapabilities[id]=false;}}function useProgram(program){if(currentProgram!==program){gl.useProgram(program);currentProgram=program;return true;}return false;}var equationToGL=(_equationToGL={},(0,_defineProperty2.default)(_equationToGL,AddEquation,32774),(0,_defineProperty2.default)(_equationToGL,SubtractEquation,32778),(0,_defineProperty2.default)(_equationToGL,ReverseSubtractEquation,32779),_equationToGL);if(isWebGL2){equationToGL[MinEquation]=32775;equationToGL[MaxEquation]=32776;}else{var extension=extensions.get('EXT_blend_minmax');if(extension!==null){equationToGL[MinEquation]=extension.MIN_EXT;equationToGL[MaxEquation]=extension.MAX_EXT;}}var factorToGL=(_factorToGL={},(0,_defineProperty2.default)(_factorToGL,ZeroFactor,0),(0,_defineProperty2.default)(_factorToGL,OneFactor,1),(0,_defineProperty2.default)(_factorToGL,SrcColorFactor,768),(0,_defineProperty2.default)(_factorToGL,SrcAlphaFactor,770),(0,_defineProperty2.default)(_factorToGL,SrcAlphaSaturateFactor,776),(0,_defineProperty2.default)(_factorToGL,DstColorFactor,774),(0,_defineProperty2.default)(_factorToGL,DstAlphaFactor,772),(0,_defineProperty2.default)(_factorToGL,OneMinusSrcColorFactor,769),(0,_defineProperty2.default)(_factorToGL,OneMinusSrcAlphaFactor,771),(0,_defineProperty2.default)(_factorToGL,OneMinusDstColorFactor,775),(0,_defineProperty2.default)(_factorToGL,OneMinusDstAlphaFactor,773),_factorToGL);function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(blending===NoBlending){if(currentBlendingEnabled){disable(3042);currentBlendingEnabled=false;}return;}if(!currentBlendingEnabled){enable(3042);currentBlendingEnabled=true;}if(blending!==CustomBlending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(currentBlendEquation!==AddEquation||currentBlendEquationAlpha!==AddEquation){gl.blendEquation(32774);currentBlendEquation=AddEquation;currentBlendEquationAlpha=AddEquation;}if(premultipliedAlpha){switch(blending){case NormalBlending:gl.blendFuncSeparate(1,771,1,771);break;case AdditiveBlending:gl.blendFunc(1,1);break;case SubtractiveBlending:gl.blendFuncSeparate(0,0,769,771);break;case MultiplyBlending:gl.blendFuncSeparate(0,768,0,770);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}else{switch(blending){case NormalBlending:gl.blendFuncSeparate(770,771,1,771);break;case AdditiveBlending:gl.blendFunc(770,1);break;case SubtractiveBlending:gl.blendFunc(0,769);break;case MultiplyBlending:gl.blendFunc(0,768);break;default:console.error('THREE.WebGLState: Invalid blending: ',blending);break;}}currentBlendSrc=null;currentBlendDst=null;currentBlendSrcAlpha=null;currentBlendDstAlpha=null;currentBlending=blending;currentPremultipledAlpha=premultipliedAlpha;}return;}// custom blending
blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha){gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]);currentBlendEquation=blendEquation;currentBlendEquationAlpha=blendEquationAlpha;}if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||blendDstAlpha!==currentBlendDstAlpha){gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]);currentBlendSrc=blendSrc;currentBlendDst=blendDst;currentBlendSrcAlpha=blendSrcAlpha;currentBlendDstAlpha=blendDstAlpha;}currentBlending=blending;currentPremultipledAlpha=null;}function setMaterial(material,frontFaceCW){material.side===DoubleSide?disable(2884):enable(2884);var flipSided=material.side===BackSide;if(frontFaceCW)flipSided=!flipSided;setFlipSided(flipSided);material.blending===NormalBlending&&material.transparent===false?setBlending(NoBlending):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);var stencilWrite=material.stencilWrite;stencilBuffer.setTest(stencilWrite);if(stencilWrite){stencilBuffer.setMask(material.stencilWriteMask);stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask);stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass);}setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);}//
function setFlipSided(flipSided){if(currentFlipSided!==flipSided){if(flipSided){gl.frontFace(2304);}else{gl.frontFace(2305);}currentFlipSided=flipSided;}}function setCullFace(cullFace){if(cullFace!==CullFaceNone){enable(2884);if(cullFace!==currentCullFace){if(cullFace===CullFaceBack){gl.cullFace(1029);}else if(cullFace===CullFaceFront){gl.cullFace(1028);}else{gl.cullFace(1032);}}}else{disable(2884);}currentCullFace=cullFace;}function setLineWidth(width){if(width!==currentLineWidth){if(lineWidthAvailable)gl.lineWidth(width);currentLineWidth=width;}}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){enable(32823);if(currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units){gl.polygonOffset(factor,units);currentPolygonOffsetFactor=factor;currentPolygonOffsetUnits=units;}}else{disable(32823);}}function setScissorTest(scissorTest){if(scissorTest){enable(3089);}else{disable(3089);}}// texture
function activeTexture(webglSlot){if(webglSlot===undefined)webglSlot=33984+maxTextures-1;if(currentTextureSlot!==webglSlot){gl.activeTexture(webglSlot);currentTextureSlot=webglSlot;}}function bindTexture(webglType,webglTexture){if(currentTextureSlot===null){activeTexture();}var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture===undefined){boundTexture={type:undefined,texture:undefined};currentBoundTextures[currentTextureSlot]=boundTexture;}if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture){gl.bindTexture(webglType,webglTexture||emptyTextures[webglType]);boundTexture.type=webglType;boundTexture.texture=webglTexture;}}function unbindTexture(){var boundTexture=currentBoundTextures[currentTextureSlot];if(boundTexture!==undefined&&boundTexture.type!==undefined){gl.bindTexture(boundTexture.type,null);boundTexture.type=undefined;boundTexture.texture=undefined;}}function compressedTexImage2D(){try{gl.compressedTexImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage2D(){try{gl.texImage2D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}function texImage3D(){try{gl.texImage3D.apply(gl,arguments);}catch(error){console.error('THREE.WebGLState:',error);}}//
function scissor(scissor){if(currentScissor.equals(scissor)===false){gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w);currentScissor.copy(scissor);}}function viewport(viewport){if(currentViewport.equals(viewport)===false){gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w);currentViewport.copy(viewport);}}//
function reset(){for(var i=0;i<enabledAttributes.length;i++){if(enabledAttributes[i]===1){gl.disableVertexAttribArray(i);enabledAttributes[i]=0;}}enabledCapabilities={};currentTextureSlot=null;currentBoundTextures={};currentProgram=null;currentBlending=null;currentFlipSided=null;currentCullFace=null;colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset();}return{buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},initAttributes:initAttributes,enableAttribute:enableAttribute,enableAttributeAndDivisor:enableAttributeAndDivisor,disableUnusedAttributes:disableUnusedAttributes,enable:enable,disable:disable,useProgram:useProgram,setBlending:setBlending,setMaterial:setMaterial,setFlipSided:setFlipSided,setCullFace:setCullFace,setLineWidth:setLineWidth,setPolygonOffset:setPolygonOffset,setScissorTest:setScissorTest,activeTexture:activeTexture,bindTexture:bindTexture,unbindTexture:unbindTexture,compressedTexImage2D:compressedTexImage2D,texImage2D:texImage2D,texImage3D:texImage3D,scissor:scissor,viewport:viewport,reset:reset};}/**
 * @author mrdoob / http://mrdoob.com/
 */function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){var _wrappingToGL,_filterToGL;var isWebGL2=capabilities.isWebGL2;var maxTextures=capabilities.maxTextures;var maxCubemapSize=capabilities.maxCubemapSize;var maxTextureSize=capabilities.maxTextureSize;var maxSamples=capabilities.maxSamples;var _videoTextures=new _weakMap.default();var _canvas;// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).
var useOffscreenCanvas=false;try{useOffscreenCanvas=typeof OffscreenCanvas!=='undefined'&&new OffscreenCanvas(1,1).getContext("2d")!==null;}catch(err){// Ignore any errors
}function createCanvas(width,height){// Use OffscreenCanvas when available. Specially needed in web workers
return useOffscreenCanvas?new OffscreenCanvas(width,height):document.createElementNS('http://www.w3.org/1999/xhtml','canvas');}function resizeImage(image,needsPowerOfTwo,needsNewCanvas,maxSize){var scale=1;// handle case if texture exceeds max size
if(image.width>maxSize||image.height>maxSize){scale=maxSize/Math.max(image.width,image.height);}// only perform resize if necessary
if(scale<1||needsPowerOfTwo===true){// only perform resize for certain image types
if(typeof HTMLImageElement!=='undefined'&&image instanceof HTMLImageElement||typeof HTMLCanvasElement!=='undefined'&&image instanceof HTMLCanvasElement||typeof ImageBitmap!=='undefined'&&image instanceof ImageBitmap){var floor=needsPowerOfTwo?MathUtils.floorPowerOfTwo:Math.floor;var width=floor(scale*image.width);var height=floor(scale*image.height);if(_canvas===undefined)_canvas=createCanvas(width,height);// cube textures can't reuse the same canvas
var canvas=needsNewCanvas?createCanvas(width,height):_canvas;canvas.width=width;canvas.height=height;var context=canvas.getContext('2d');context.drawImage(image,0,0,width,height);//console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );
return canvas;}else{if('data'in image){//console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );
}return image;}}return image;}function isPowerOfTwo(image){return MathUtils.isPowerOfTwo(image.width)&&MathUtils.isPowerOfTwo(image.height);}function textureNeedsPowerOfTwo(texture){if(isWebGL2)return false;return texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping||texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function textureNeedsGenerateMipmaps(texture,supportsMips){return texture.generateMipmaps&&supportsMips&&texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter;}function generateMipmap(target,texture,width,height){_gl.generateMipmap(target);var textureProperties=properties.get(texture);// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
textureProperties.__maxMipLevel=Math.log(Math.max(width,height))*Math.LOG2E;}function getInternalFormat(internalFormatName,glFormat,glType){if(isWebGL2===false)return glFormat;if(internalFormatName!==null){if(_gl[internalFormatName]!==undefined)return _gl[internalFormatName];//console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );
}var internalFormat=glFormat;if(glFormat===6403){if(glType===5126)internalFormat=33326;if(glType===5131)internalFormat=33325;if(glType===5121)internalFormat=33321;}if(glFormat===6407){if(glType===5126)internalFormat=34837;if(glType===5131)internalFormat=34843;if(glType===5121)internalFormat=32849;}if(glFormat===6408){if(glType===5126)internalFormat=34836;if(glType===5131)internalFormat=34842;if(glType===5121)internalFormat=32856;}if(internalFormat===33325||internalFormat===33326||internalFormat===34842||internalFormat===34836){extensions.get('EXT_color_buffer_float');}return internalFormat;}// Fallback filters for non-power-of-2 textures
function filterFallback(f){if(f===NearestFilter||f===NearestMipmapNearestFilter||f===NearestMipmapLinearFilter){return 9728;}return 9729;}//
function onTextureDispose(event){var texture=event.target;texture.removeEventListener('dispose',onTextureDispose);deallocateTexture(texture);if(texture.isVideoTexture){_videoTextures.delete(texture);}info.memory.textures--;}function onRenderTargetDispose(event){var renderTarget=event.target;renderTarget.removeEventListener('dispose',onRenderTargetDispose);deallocateRenderTarget(renderTarget);info.memory.textures--;}//
function deallocateTexture(texture){var textureProperties=properties.get(texture);if(textureProperties.__webglInit===undefined)return;_gl.deleteTexture(textureProperties.__webglTexture);properties.remove(texture);}function deallocateRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);if(!renderTarget)return;if(textureProperties.__webglTexture!==undefined){_gl.deleteTexture(textureProperties.__webglTexture);}if(renderTarget.depthTexture){renderTarget.depthTexture.dispose();}if(renderTarget.isWebGLCubeRenderTarget){for(var i=0;i<6;i++){_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);}}else{_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);if(renderTargetProperties.__webglDepthbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);if(renderTargetProperties.__webglMultisampledFramebuffer)_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);if(renderTargetProperties.__webglColorRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);if(renderTargetProperties.__webglDepthRenderbuffer)_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);}properties.remove(renderTarget.texture);properties.remove(renderTarget);}//
var textureUnits=0;function resetTextureUnits(){textureUnits=0;}function allocateTextureUnit(){var textureUnit=textureUnits;if(textureUnit>=maxTextures){console.warn('THREE.WebGLTextures: Trying to use '+textureUnit+' texture units while this GPU supports only '+maxTextures);}textureUnits+=1;return textureUnit;}//
function setTexture2D(texture,slot){var textureProperties=properties.get(texture);if(texture.isVideoTexture)updateVideoTexture(texture);if(texture.version>0&&textureProperties.__version!==texture.version){var image=texture.image;if(image===undefined){//console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );
}else if(image.complete===false){//console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );
}else{uploadTexture(textureProperties,texture,slot);return;}}state.activeTexture(33984+slot);state.bindTexture(3553,textureProperties.__webglTexture);}function setTexture2DArray(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(35866,textureProperties.__webglTexture);}function setTexture3D(texture,slot){var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){uploadTexture(textureProperties,texture,slot);return;}state.activeTexture(33984+slot);state.bindTexture(32879,textureProperties.__webglTexture);}function setTextureCube(texture,slot){if(texture.image.length!==6)return;var textureProperties=properties.get(texture);if(texture.version>0&&textureProperties.__version!==texture.version){initTexture(textureProperties,texture);state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);_gl.pixelStorei(37440,texture.flipY);var isCompressed=texture&&(texture.isCompressedTexture||texture.image[0].isCompressedTexture);var isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;var cubeImage=[];for(var i=0;i<6;i++){if(!isCompressed&&!isDataTexture){cubeImage[i]=resizeImage(texture.image[i],false,true,maxCubemapSize);}else{cubeImage[i]=isDataTexture?texture.image[i].image:texture.image[i];}}var image=cubeImage[0],supportsMips=isPowerOfTwo(image)||isWebGL2,glFormat=utils.convert(texture.format),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType);setTextureParameters(34067,texture,supportsMips);var mipmaps;if(isCompressed){for(var i=0;i<6;i++){mipmaps=cubeImage[i].mipmaps;for(var j=0;j<mipmaps.length;j++){var mipmap=mipmaps[j];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(glFormat!==null){state.compressedTexImage2D(34069+i,j,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{//console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );
}}else{state.texImage2D(34069+i,j,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}}textureProperties.__maxMipLevel=mipmaps.length-1;}else{mipmaps=texture.mipmaps;for(var i=0;i<6;i++){if(isDataTexture){state.texImage2D(34069+i,0,glInternalFormat,cubeImage[i].width,cubeImage[i].height,0,glFormat,glType,cubeImage[i].data);for(var j=0;j<mipmaps.length;j++){var mipmap=mipmaps[j];var mipmapImage=mipmap.image[i].image;state.texImage2D(34069+i,j+1,glInternalFormat,mipmapImage.width,mipmapImage.height,0,glFormat,glType,mipmapImage.data);}}else{state.texImage2D(34069+i,0,glInternalFormat,glFormat,glType,cubeImage[i]);for(var j=0;j<mipmaps.length;j++){var mipmap=mipmaps[j];state.texImage2D(34069+i,j+1,glInternalFormat,glFormat,glType,mipmap.image[i]);}}}textureProperties.__maxMipLevel=mipmaps.length;}if(textureNeedsGenerateMipmaps(texture,supportsMips)){// We assume images for cube map have the same size.
generateMipmap(34067,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}else{state.activeTexture(33984+slot);state.bindTexture(34067,textureProperties.__webglTexture);}}function setTextureCubeDynamic(texture,slot){state.activeTexture(33984+slot);state.bindTexture(34067,properties.get(texture).__webglTexture);}var wrappingToGL=(_wrappingToGL={},(0,_defineProperty2.default)(_wrappingToGL,RepeatWrapping,10497),(0,_defineProperty2.default)(_wrappingToGL,ClampToEdgeWrapping,33071),(0,_defineProperty2.default)(_wrappingToGL,MirroredRepeatWrapping,33648),_wrappingToGL);var filterToGL=(_filterToGL={},(0,_defineProperty2.default)(_filterToGL,NearestFilter,9728),(0,_defineProperty2.default)(_filterToGL,NearestMipmapNearestFilter,9984),(0,_defineProperty2.default)(_filterToGL,NearestMipmapLinearFilter,9986),(0,_defineProperty2.default)(_filterToGL,LinearFilter,9729),(0,_defineProperty2.default)(_filterToGL,LinearMipmapNearestFilter,9985),(0,_defineProperty2.default)(_filterToGL,LinearMipmapLinearFilter,9987),_filterToGL);function setTextureParameters(textureType,texture,supportsMips){if(supportsMips){_gl.texParameteri(textureType,10242,wrappingToGL[texture.wrapS]);_gl.texParameteri(textureType,10243,wrappingToGL[texture.wrapT]);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,wrappingToGL[texture.wrapR]);}_gl.texParameteri(textureType,10240,filterToGL[texture.magFilter]);_gl.texParameteri(textureType,10241,filterToGL[texture.minFilter]);}else{_gl.texParameteri(textureType,10242,33071);_gl.texParameteri(textureType,10243,33071);if(textureType===32879||textureType===35866){_gl.texParameteri(textureType,32882,33071);}if(texture.wrapS!==ClampToEdgeWrapping||texture.wrapT!==ClampToEdgeWrapping){//console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );
}_gl.texParameteri(textureType,10240,filterFallback(texture.magFilter));_gl.texParameteri(textureType,10241,filterFallback(texture.minFilter));if(texture.minFilter!==NearestFilter&&texture.minFilter!==LinearFilter){//console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );
}}var extension=extensions.get('EXT_texture_filter_anisotropic');if(extension){if(texture.type===FloatType&&extensions.get('OES_texture_float_linear')===null)return;if(texture.type===HalfFloatType&&(isWebGL2||extensions.get('OES_texture_half_float_linear'))===null)return;if(texture.anisotropy>1||properties.get(texture).__currentAnisotropy){_gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy()));properties.get(texture).__currentAnisotropy=texture.anisotropy;}}}function initTexture(textureProperties,texture){if(textureProperties.__webglInit===undefined){textureProperties.__webglInit=true;texture.addEventListener('dispose',onTextureDispose);textureProperties.__webglTexture=_gl.createTexture();info.memory.textures++;}}function uploadTexture(textureProperties,texture,slot){var textureType=3553;if(texture.isDataTexture2DArray)textureType=35866;if(texture.isDataTexture3D)textureType=32879;initTexture(textureProperties,texture);state.activeTexture(33984+slot);state.bindTexture(textureType,textureProperties.__webglTexture);_gl.pixelStorei(37440,texture.flipY);_gl.pixelStorei(37441,texture.premultiplyAlpha);_gl.pixelStorei(3317,texture.unpackAlignment);var needsPowerOfTwo=textureNeedsPowerOfTwo(texture)&&isPowerOfTwo(texture.image)===false;var image=resizeImage(texture.image,needsPowerOfTwo,false,maxTextureSize);var supportsMips=isPowerOfTwo(image)||isWebGL2,glFormat=utils.convert(texture.format),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType);setTextureParameters(textureType,texture,supportsMips);var mipmap,mipmaps=texture.mipmaps;if(texture.isDepthTexture){// populate depth texture with dummy data
glInternalFormat=6402;if(isWebGL2){if(texture.type===FloatType){glInternalFormat=36012;}else if(texture.type===UnsignedIntType){glInternalFormat=33190;}else if(texture.type===UnsignedInt248Type){glInternalFormat=35056;}else{glInternalFormat=33189;// WebGL2 requires sized internalformat for glTexImage2D
}}else{if(texture.type===FloatType){console.error('WebGLRenderer: Floating point depth texture requires WebGL2.');}}// validation checks for WebGL 1
if(texture.format===DepthFormat&&glInternalFormat===6402){// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedShortType&&texture.type!==UnsignedIntType){//console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
texture.type=UnsignedShortType;glType=utils.convert(texture.type);}}if(texture.format===DepthStencilFormat&&glInternalFormat===6402){// Depth stencil textures need the DEPTH_STENCIL internal format
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
glInternalFormat=34041;// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
if(texture.type!==UnsignedInt248Type){//console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
texture.type=UnsignedInt248Type;glType=utils.convert(texture.type);}}//
state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null);}else if(texture.isDataTexture){// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&supportsMips){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else{state.texImage2D(3553,0,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}}else if(texture.isCompressedTexture){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];if(texture.format!==RGBAFormat&&texture.format!==RGBFormat){if(glFormat!==null){state.compressedTexImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,mipmap.data);}else{//console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );
}}else{state.texImage2D(3553,i,glInternalFormat,mipmap.width,mipmap.height,0,glFormat,glType,mipmap.data);}}textureProperties.__maxMipLevel=mipmaps.length-1;}else if(texture.isDataTexture2DArray){state.texImage3D(35866,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}else if(texture.isDataTexture3D){state.texImage3D(32879,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);textureProperties.__maxMipLevel=0;}else{// regular Texture (image, video, canvas)
// use manually created mipmaps if available
// if there are no manual mipmaps
// set 0 level mipmap and then use GL to generate other mipmap levels
if(mipmaps.length>0&&supportsMips){for(var i=0,il=mipmaps.length;i<il;i++){mipmap=mipmaps[i];state.texImage2D(3553,i,glInternalFormat,glFormat,glType,mipmap);}texture.generateMipmaps=false;textureProperties.__maxMipLevel=mipmaps.length-1;}else{state.texImage2D(3553,0,glInternalFormat,glFormat,glType,image);textureProperties.__maxMipLevel=0;}}if(textureNeedsGenerateMipmaps(texture,supportsMips)){generateMipmap(textureType,texture,image.width,image.height);}textureProperties.__version=texture.version;if(texture.onUpdate)texture.onUpdate(texture);}// Render targets
// Setup storage for target texture and bind it to correct framebuffer
function setupFrameBufferTexture(framebuffer,renderTarget,attachment,textureTarget){var glFormat=utils.convert(renderTarget.texture.format);var glType=utils.convert(renderTarget.texture.type);var glInternalFormat=getInternalFormat(renderTarget.texture.internalFormat,glFormat,glType);state.texImage2D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,0,glFormat,glType,null);_gl.bindFramebuffer(36160,framebuffer);_gl.framebufferTexture2D(36160,attachment,textureTarget,properties.get(renderTarget.texture).__webglTexture,0);_gl.bindFramebuffer(36160,null);}// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){_gl.bindRenderbuffer(36161,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){var glInternalFormat=33189;if(isMultisample){var depthTexture=renderTarget.depthTexture;if(depthTexture&&depthTexture.isDepthTexture){if(depthTexture.type===FloatType){glInternalFormat=36012;}else if(depthTexture.type===UnsignedIntType){glInternalFormat=33190;}}var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else{_gl.renderbufferStorage(36161,glInternalFormat,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,36096,36161,renderbuffer);}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer){if(isMultisample){var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,35056,renderTarget.width,renderTarget.height);}else{_gl.renderbufferStorage(36161,34041,renderTarget.width,renderTarget.height);}_gl.framebufferRenderbuffer(36160,33306,36161,renderbuffer);}else{var glFormat=utils.convert(renderTarget.texture.format);var glType=utils.convert(renderTarget.texture.type);var glInternalFormat=getInternalFormat(renderTarget.texture.internalFormat,glFormat,glType);if(isMultisample){var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);}else{_gl.renderbufferStorage(36161,glInternalFormat,renderTarget.width,renderTarget.height);}}_gl.bindRenderbuffer(36161,null);}// Setup resources for a Depth Texture for a FBO (needs an extension)
function setupDepthTexture(framebuffer,renderTarget){var isCube=renderTarget&&renderTarget.isWebGLCubeRenderTarget;if(isCube)throw new Error('Depth Texture with cube render targets is not supported');_gl.bindFramebuffer(36160,framebuffer);if(!(renderTarget.depthTexture&&renderTarget.depthTexture.isDepthTexture)){throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');}// upload an empty depth texture with framebuffer size
if(!properties.get(renderTarget.depthTexture).__webglTexture||renderTarget.depthTexture.image.width!==renderTarget.width||renderTarget.depthTexture.image.height!==renderTarget.height){renderTarget.depthTexture.image.width=renderTarget.width;renderTarget.depthTexture.image.height=renderTarget.height;renderTarget.depthTexture.needsUpdate=true;}setTexture2D(renderTarget.depthTexture,0);var webglDepthTexture=properties.get(renderTarget.depthTexture).__webglTexture;if(renderTarget.depthTexture.format===DepthFormat){_gl.framebufferTexture2D(36160,36096,3553,webglDepthTexture,0);}else if(renderTarget.depthTexture.format===DepthStencilFormat){_gl.framebufferTexture2D(36160,33306,3553,webglDepthTexture,0);}else{throw new Error('Unknown depthTexture format');}}// Setup GL resources for a non-texture depth buffer
function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget);var isCube=renderTarget.isWebGLCubeRenderTarget===true;if(renderTarget.depthTexture){if(isCube)throw new Error('target.depthTexture not supported in Cube render targets');setupDepthTexture(renderTargetProperties.__webglFramebuffer,renderTarget);}else{if(isCube){renderTargetProperties.__webglDepthbuffer=[];for(var i=0;i<6;i++){_gl.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer[i]);renderTargetProperties.__webglDepthbuffer[i]=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i],renderTarget,false);}}else{_gl.bindFramebuffer(36160,renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,false);}}_gl.bindFramebuffer(36160,null);}// Set up GL resources for the render target
function setupRenderTarget(renderTarget){var renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(renderTarget.texture);renderTarget.addEventListener('dispose',onRenderTargetDispose);textureProperties.__webglTexture=_gl.createTexture();info.memory.textures++;var isCube=renderTarget.isWebGLCubeRenderTarget===true;var isMultisample=renderTarget.isWebGLMultisampleRenderTarget===true;var supportsMips=isPowerOfTwo(renderTarget)||isWebGL2;// Handles WebGL2 RGBFormat fallback - #18858
if(isWebGL2&&renderTarget.texture.format===RGBFormat&&(renderTarget.texture.type===FloatType||renderTarget.texture.type===HalfFloatType)){renderTarget.texture.format=RGBAFormat;//console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );
}// Setup framebuffer
if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var i=0;i<6;i++){renderTargetProperties.__webglFramebuffer[i]=_gl.createFramebuffer();}}else{renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();if(isMultisample){if(isWebGL2){renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();renderTargetProperties.__webglColorRenderbuffer=_gl.createRenderbuffer();_gl.bindRenderbuffer(36161,renderTargetProperties.__webglColorRenderbuffer);var glFormat=utils.convert(renderTarget.texture.format);var glType=utils.convert(renderTarget.texture.type);var glInternalFormat=getInternalFormat(renderTarget.texture.internalFormat,glFormat,glType);var samples=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(36161,samples,glInternalFormat,renderTarget.width,renderTarget.height);_gl.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);_gl.framebufferRenderbuffer(36160,36064,36161,renderTargetProperties.__webglColorRenderbuffer);_gl.bindRenderbuffer(36161,null);if(renderTarget.depthBuffer){renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer();setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,true);}_gl.bindFramebuffer(36160,null);}else{//console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );
}}}// Setup color buffer
if(isCube){state.bindTexture(34067,textureProperties.__webglTexture);setTextureParameters(34067,renderTarget.texture,supportsMips);for(var i=0;i<6;i++){setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i],renderTarget,36064,34069+i);}if(textureNeedsGenerateMipmaps(renderTarget.texture,supportsMips)){generateMipmap(34067,renderTarget.texture,renderTarget.width,renderTarget.height);}state.bindTexture(34067,null);}else{state.bindTexture(3553,textureProperties.__webglTexture);setTextureParameters(3553,renderTarget.texture,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,36064,3553);if(textureNeedsGenerateMipmaps(renderTarget.texture,supportsMips)){generateMipmap(3553,renderTarget.texture,renderTarget.width,renderTarget.height);}state.bindTexture(3553,null);}// Setup depth and stencil buffers
if(renderTarget.depthBuffer){setupDepthRenderbuffer(renderTarget);}}function updateRenderTargetMipmap(renderTarget){var texture=renderTarget.texture;var supportsMips=isPowerOfTwo(renderTarget)||isWebGL2;if(textureNeedsGenerateMipmaps(texture,supportsMips)){var target=renderTarget.isWebGLCubeRenderTarget?34067:3553;var webglTexture=properties.get(texture).__webglTexture;state.bindTexture(target,webglTexture);generateMipmap(target,texture,renderTarget.width,renderTarget.height);state.bindTexture(target,null);}}function updateMultisampleRenderTarget(renderTarget){if(renderTarget.isWebGLMultisampleRenderTarget){if(isWebGL2){var renderTargetProperties=properties.get(renderTarget);_gl.bindFramebuffer(36008,renderTargetProperties.__webglMultisampledFramebuffer);_gl.bindFramebuffer(36009,renderTargetProperties.__webglFramebuffer);var width=renderTarget.width;var height=renderTarget.height;var mask=16384;if(renderTarget.depthBuffer)mask|=256;if(renderTarget.stencilBuffer)mask|=1024;_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,9728);_gl.bindFramebuffer(36160,renderTargetProperties.__webglMultisampledFramebuffer);// see #18905
}else{//console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );
}}}function getRenderTargetSamples(renderTarget){return isWebGL2&&renderTarget.isWebGLMultisampleRenderTarget?Math.min(maxSamples,renderTarget.samples):0;}function updateVideoTexture(texture){var frame=info.render.frame;// Check the last frame we updated the VideoTexture
if(_videoTextures.get(texture)!==frame){_videoTextures.set(texture,frame);texture.update();}}// backwards compatibility
var warnedTexture2D=false;var warnedTextureCube=false;function safeSetTexture2D(texture,slot){if(texture&&texture.isWebGLRenderTarget){if(warnedTexture2D===false){console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");warnedTexture2D=true;}texture=texture.texture;}setTexture2D(texture,slot);}function safeSetTextureCube(texture,slot){if(texture&&texture.isWebGLCubeRenderTarget){if(warnedTextureCube===false){console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");warnedTextureCube=true;}texture=texture.texture;}// currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
// TODO: unify these code paths
if(texture&&texture.isCubeTexture||(0,_isArray.default)(texture.image)&&texture.image.length===6){// CompressedTexture can have Array in image :/
// this function alone should take care of cube textures
setTextureCube(texture,slot);}else{// assumed: texture property of THREE.WebGLCubeRenderTarget
setTextureCubeDynamic(texture,slot);}}//
this.allocateTextureUnit=allocateTextureUnit;this.resetTextureUnits=resetTextureUnits;this.setTexture2D=setTexture2D;this.setTexture2DArray=setTexture2DArray;this.setTexture3D=setTexture3D;this.setTextureCube=setTextureCube;this.setTextureCubeDynamic=setTextureCubeDynamic;this.setupRenderTarget=setupRenderTarget;this.updateRenderTargetMipmap=updateRenderTargetMipmap;this.updateMultisampleRenderTarget=updateMultisampleRenderTarget;this.safeSetTexture2D=safeSetTexture2D;this.safeSetTextureCube=safeSetTextureCube;}/**
 * @author thespite / http://www.twitter.com/thespite
 */function WebGLUtils(gl,extensions,capabilities){var isWebGL2=capabilities.isWebGL2;function convert(p){var extension;if(p===UnsignedByteType)return 5121;if(p===UnsignedShort4444Type)return 32819;if(p===UnsignedShort5551Type)return 32820;if(p===UnsignedShort565Type)return 33635;if(p===ByteType)return 5120;if(p===ShortType)return 5122;if(p===UnsignedShortType)return 5123;if(p===IntType)return 5124;if(p===UnsignedIntType)return 5125;if(p===FloatType)return 5126;if(p===HalfFloatType){if(isWebGL2)return 5131;extension=extensions.get('OES_texture_half_float');if(extension!==null){return extension.HALF_FLOAT_OES;}else{return null;}}if(p===AlphaFormat)return 6406;if(p===RGBFormat)return 6407;if(p===RGBAFormat)return 6408;if(p===LuminanceFormat)return 6409;if(p===LuminanceAlphaFormat)return 6410;if(p===DepthFormat)return 6402;if(p===DepthStencilFormat)return 34041;if(p===RedFormat)return 6403;// WebGL2 formats.
if(p===RedIntegerFormat)return 36244;if(p===RGFormat)return 33319;if(p===RGIntegerFormat)return 33320;if(p===RGBIntegerFormat)return 36248;if(p===RGBAIntegerFormat)return 36249;if(p===RGB_S3TC_DXT1_Format||p===RGBA_S3TC_DXT1_Format||p===RGBA_S3TC_DXT3_Format||p===RGBA_S3TC_DXT5_Format){extension=extensions.get('WEBGL_compressed_texture_s3tc');if(extension!==null){if(p===RGB_S3TC_DXT1_Format)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT1_Format)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(p===RGBA_S3TC_DXT3_Format)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(p===RGBA_S3TC_DXT5_Format)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;}else{return null;}}if(p===RGB_PVRTC_4BPPV1_Format||p===RGB_PVRTC_2BPPV1_Format||p===RGBA_PVRTC_4BPPV1_Format||p===RGBA_PVRTC_2BPPV1_Format){extension=extensions.get('WEBGL_compressed_texture_pvrtc');if(extension!==null){if(p===RGB_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(p===RGB_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(p===RGBA_PVRTC_4BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(p===RGBA_PVRTC_2BPPV1_Format)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;}else{return null;}}if(p===RGB_ETC1_Format){extension=extensions.get('WEBGL_compressed_texture_etc1');if(extension!==null){return extension.COMPRESSED_RGB_ETC1_WEBGL;}else{return null;}}if(p===RGB_ETC2_Format||p===RGBA_ETC2_EAC_Format){extension=extensions.get('WEBGL_compressed_texture_etc');if(extension!==null){if(p===RGB_ETC2_Format)return extension.COMPRESSED_RGB8_ETC2;if(p===RGBA_ETC2_EAC_Format)return extension.COMPRESSED_RGBA8_ETC2_EAC;}}if(p===RGBA_ASTC_4x4_Format||p===RGBA_ASTC_5x4_Format||p===RGBA_ASTC_5x5_Format||p===RGBA_ASTC_6x5_Format||p===RGBA_ASTC_6x6_Format||p===RGBA_ASTC_8x5_Format||p===RGBA_ASTC_8x6_Format||p===RGBA_ASTC_8x8_Format||p===RGBA_ASTC_10x5_Format||p===RGBA_ASTC_10x6_Format||p===RGBA_ASTC_10x8_Format||p===RGBA_ASTC_10x10_Format||p===RGBA_ASTC_12x10_Format||p===RGBA_ASTC_12x12_Format||p===SRGB8_ALPHA8_ASTC_4x4_Format||p===SRGB8_ALPHA8_ASTC_5x4_Format||p===SRGB8_ALPHA8_ASTC_5x5_Format||p===SRGB8_ALPHA8_ASTC_6x5_Format||p===SRGB8_ALPHA8_ASTC_6x6_Format||p===SRGB8_ALPHA8_ASTC_8x5_Format||p===SRGB8_ALPHA8_ASTC_8x6_Format||p===SRGB8_ALPHA8_ASTC_8x8_Format||p===SRGB8_ALPHA8_ASTC_10x5_Format||p===SRGB8_ALPHA8_ASTC_10x6_Format||p===SRGB8_ALPHA8_ASTC_10x8_Format||p===SRGB8_ALPHA8_ASTC_10x10_Format||p===SRGB8_ALPHA8_ASTC_12x10_Format||p===SRGB8_ALPHA8_ASTC_12x12_Format){extension=extensions.get('WEBGL_compressed_texture_astc');if(extension!==null){// TODO Complete?
return p;}else{return null;}}if(p===RGBA_BPTC_Format){extension=extensions.get('EXT_texture_compression_bptc');if(extension!==null){// TODO Complete?
return p;}else{return null;}}if(p===UnsignedInt248Type){if(isWebGL2)return 34042;extension=extensions.get('WEBGL_depth_texture');if(extension!==null){return extension.UNSIGNED_INT_24_8_WEBGL;}else{return null;}}}return{convert:convert};}/**
 * @author mrdoob / http://mrdoob.com/
 */function ArrayCamera(array){PerspectiveCamera.call(this);this.cameras=array||[];}ArrayCamera.prototype=(0,_assign.default)((0,_create.default)(PerspectiveCamera.prototype),{constructor:ArrayCamera,isArrayCamera:true});/**
 * @author mrdoob / http://mrdoob.com/
 */function Group(){Object3D.call(this);this.type='Group';}Group.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Group,isGroup:true});/**
 * @author mrdoob / http://mrdoob.com/
 */function WebXRManager(renderer,gl){var scope=this;var session=null;var framebufferScaleFactor=1.0;var referenceSpace=null;var referenceSpaceType='local-floor';var pose=null;var controllers=[];var inputSourcesMap=new _map.default();//
var cameraL=new PerspectiveCamera();cameraL.layers.enable(1);cameraL.viewport=new Vector4();var cameraR=new PerspectiveCamera();cameraR.layers.enable(2);cameraR.viewport=new Vector4();var cameraVR=new ArrayCamera([cameraL,cameraR]);cameraVR.layers.enable(1);cameraVR.layers.enable(2);var _currentDepthNear=null;var _currentDepthFar=null;//
this.enabled=false;this.isPresenting=false;this.getController=function(id){var controller=controllers[id];if(controller===undefined){controller={};controllers[id]=controller;}if(controller.targetRay===undefined){controller.targetRay=new Group();controller.targetRay.matrixAutoUpdate=false;controller.targetRay.visible=false;}return controller.targetRay;};this.getControllerGrip=function(id){var controller=controllers[id];if(controller===undefined){controller={};controllers[id]=controller;}if(controller.grip===undefined){controller.grip=new Group();controller.grip.matrixAutoUpdate=false;controller.grip.visible=false;}return controller.grip;};//
function onSessionEvent(event){var controller=inputSourcesMap.get(event.inputSource);if(controller){if(controller.targetRay){controller.targetRay.dispatchEvent({type:event.type});}if(controller.grip){controller.grip.dispatchEvent({type:event.type});}}}function onSessionEnd(){inputSourcesMap.forEach(function(controller,inputSource){if(controller.targetRay){controller.targetRay.dispatchEvent({type:'disconnected',data:inputSource});controller.targetRay.visible=false;}if(controller.grip){controller.grip.dispatchEvent({type:'disconnected',data:inputSource});controller.grip.visible=false;}});inputSourcesMap.clear();//
renderer.setFramebuffer(null);renderer.setRenderTarget(renderer.getRenderTarget());// Hack #15830
animation.stop();scope.isPresenting=false;scope.dispatchEvent({type:'sessionend'});}function onRequestReferenceSpace(value){referenceSpace=value;animation.setContext(session);animation.start();scope.isPresenting=true;scope.dispatchEvent({type:'sessionstart'});}this.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value;// Warn if function is used while presenting
if(scope.isPresenting==true){console.warn("WebXRManager: Cannot change framebuffer scale while presenting VR content");}};this.setReferenceSpaceType=function(value){referenceSpaceType=value;};this.getReferenceSpace=function(){return referenceSpace;};this.getSession=function(){return session;};this.setSession=function(value){session=value;if(session!==null){session.addEventListener('select',onSessionEvent);session.addEventListener('selectstart',onSessionEvent);session.addEventListener('selectend',onSessionEvent);session.addEventListener('squeeze',onSessionEvent);session.addEventListener('squeezestart',onSessionEvent);session.addEventListener('squeezeend',onSessionEvent);session.addEventListener('end',onSessionEnd);var attributes=gl.getContextAttributes();var layerInit={antialias:attributes.antialias,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor:framebufferScaleFactor};// eslint-disable-next-line no-undef
var baseLayer=new XRWebGLLayer(session,gl,layerInit);session.updateRenderState({baseLayer:baseLayer});session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);//
session.addEventListener('inputsourceschange',updateInputSources);}};function updateInputSources(event){var inputSources=session.inputSources;// Assign inputSources to available controllers
for(var i=0;i<controllers.length;i++){inputSourcesMap.set(inputSources[i],controllers[i]);}// Notify disconnected
for(var i=0;i<event.removed.length;i++){var inputSource=event.removed[i];var controller=inputSourcesMap.get(inputSource);if(controller){if(controller.targetRay){controller.targetRay.dispatchEvent({type:'disconnected',data:inputSource});}if(controller.grip){controller.grip.dispatchEvent({type:'disconnected',data:inputSource});}inputSourcesMap.delete(inputSource);}}// Notify connected
for(var i=0;i<event.added.length;i++){var inputSource=event.added[i];var controller=inputSourcesMap.get(inputSource);if(controller){if(controller.targetRay){controller.targetRay.dispatchEvent({type:'connected',data:inputSource});}if(controller.grip){controller.grip.dispatchEvent({type:'connected',data:inputSource});}}}}//
var cameraLPos=new Vector3();var cameraRPos=new Vector3();/**
	 * @author jsantell / https://www.jsantell.com/
	 *
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */function setProjectionFromUnion(camera,cameraL,cameraR){cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);var ipd=cameraLPos.distanceTo(cameraRPos);var projL=cameraL.projectionMatrix.elements;var projR=cameraR.projectionMatrix.elements;// VR systems will have identical far and near planes, and
// most likely identical top and bottom frustum extents.
// Use the left camera for these values.
var near=projL[14]/(projL[10]-1);var far=projL[14]/(projL[10]+1);var topFov=(projL[9]+1)/projL[5];var bottomFov=(projL[9]-1)/projL[5];var leftFov=(projL[8]-1)/projL[0];var rightFov=(projR[8]+1)/projR[0];var left=near*leftFov;var right=near*rightFov;// Calculate the new camera's position offset from the
// left camera. xOffset should be roughly half `ipd`.
var zOffset=ipd/(-leftFov+rightFov);var xOffset=zOffset*-leftFov;// TODO: Better way to apply this offset?
cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale);camera.translateX(xOffset);camera.translateZ(zOffset);camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale);camera.matrixWorldInverse.getInverse(camera.matrixWorld);// Find the union of the frustum values of the cameras and scale
// the values so that the near plane's position does not change in world space,
// although must now be relative to the new union camera.
var near2=near+zOffset;var far2=far+zOffset;var left2=left-xOffset;var right2=right+(ipd-xOffset);var top2=topFov*far/far2*near2;var bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2);}function updateCamera(camera,parent){if(parent===null){camera.matrixWorld.copy(camera.matrix);}else{camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);}camera.matrixWorldInverse.getInverse(camera.matrixWorld);}this.getCamera=function(camera){cameraVR.near=cameraR.near=cameraL.near=camera.near;cameraVR.far=cameraR.far=cameraL.far=camera.far;if(_currentDepthNear!==cameraVR.near||_currentDepthFar!==cameraVR.far){// Note that the new renderState won't apply until the next frame. See #18320
session.updateRenderState({depthNear:cameraVR.near,depthFar:cameraVR.far});_currentDepthNear=cameraVR.near;_currentDepthFar=cameraVR.far;}var parent=camera.parent;var cameras=cameraVR.cameras;updateCamera(cameraVR,parent);for(var i=0;i<cameras.length;i++){updateCamera(cameras[i],parent);}// update camera and its children
camera.matrixWorld.copy(cameraVR.matrixWorld);var children=camera.children;for(var i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(true);}setProjectionFromUnion(cameraVR,cameraL,cameraR);return cameraVR;};// Animation Loop
var onAnimationFrameCallback=null;function onAnimationFrame(time,frame){pose=frame.getViewerPose(referenceSpace);if(pose!==null){var views=pose.views;var baseLayer=session.renderState.baseLayer;renderer.setFramebuffer(baseLayer.framebuffer);for(var i=0;i<views.length;i++){var view=views[i];var viewport=baseLayer.getViewport(view);var camera=cameraVR.cameras[i];camera.matrix.fromArray(view.transform.matrix);camera.projectionMatrix.fromArray(view.projectionMatrix);camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);if(i===0){cameraVR.matrix.copy(camera.matrix);}}}//
var inputSources=session.inputSources;for(var i=0;i<controllers.length;i++){var controller=controllers[i];var inputSource=inputSources[i];var inputPose=null;var gripPose=null;if(inputSource){if(controller.targetRay){inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace);if(inputPose!==null){controller.targetRay.matrix.fromArray(inputPose.transform.matrix);controller.targetRay.matrix.decompose(controller.targetRay.position,controller.targetRay.rotation,controller.targetRay.scale);}}if(controller.grip&&inputSource.gripSpace){gripPose=frame.getPose(inputSource.gripSpace,referenceSpace);if(gripPose!==null){controller.grip.matrix.fromArray(gripPose.transform.matrix);controller.grip.matrix.decompose(controller.grip.position,controller.grip.rotation,controller.grip.scale);}}}if(controller.targetRay){controller.targetRay.visible=inputPose!==null;}if(controller.grip){controller.grip.visible=gripPose!==null;}}if(onAnimationFrameCallback)onAnimationFrameCallback(time,frame);}var animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;};this.dispose=function(){};}(0,_assign.default)(WebXRManager.prototype,EventDispatcher.prototype);/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */function WebGLRenderer(parameters){parameters=parameters||{};var _canvas=parameters.canvas!==undefined?parameters.canvas:document.createElementNS('http://www.w3.org/1999/xhtml','canvas'),_context=parameters.context!==undefined?parameters.context:null,_alpha=parameters.alpha!==undefined?parameters.alpha:false,_depth=parameters.depth!==undefined?parameters.depth:true,_stencil=parameters.stencil!==undefined?parameters.stencil:true,_antialias=parameters.antialias!==undefined?parameters.antialias:false,_premultipliedAlpha=parameters.premultipliedAlpha!==undefined?parameters.premultipliedAlpha:true,_preserveDrawingBuffer=parameters.preserveDrawingBuffer!==undefined?parameters.preserveDrawingBuffer:false,_powerPreference=parameters.powerPreference!==undefined?parameters.powerPreference:'default',_failIfMajorPerformanceCaveat=parameters.failIfMajorPerformanceCaveat!==undefined?parameters.failIfMajorPerformanceCaveat:false;var currentRenderList=null;var currentRenderState=null;// public properties
this.domElement=_canvas;// Debug configuration container
this.debug={/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */checkShaderErrors:true};// clearing
this.autoClear=true;this.autoClearColor=true;this.autoClearDepth=true;this.autoClearStencil=true;// scene graph
this.sortObjects=true;// user-defined clipping
this.clippingPlanes=[];this.localClippingEnabled=false;// physically based shading
this.gammaFactor=2.0;// for backwards compatibility
this.outputEncoding=LinearEncoding;// physical lights
this.physicallyCorrectLights=false;// tone mapping
this.toneMapping=LinearToneMapping;this.toneMappingExposure=1.0;this.toneMappingWhitePoint=1.0;// morphs
this.maxMorphTargets=8;this.maxMorphNormals=4;// internal properties
var _this=this,_isContextLost=false,// internal state cache
_framebuffer=null,_currentActiveCubeFace=0,_currentActiveMipmapLevel=0,_currentRenderTarget=null,_currentFramebuffer=null,_currentMaterialId=-1,// geometry and program caching
_currentGeometryProgram={geometry:null,program:null,wireframe:false},_currentCamera=null,_currentArrayCamera=null,_currentViewport=new Vector4(),_currentScissor=new Vector4(),_currentScissorTest=null,//
_width=_canvas.width,_height=_canvas.height,_pixelRatio=1,_opaqueSort=null,_transparentSort=null,_viewport=new Vector4(0,0,_width,_height),_scissor=new Vector4(0,0,_width,_height),_scissorTest=false,// frustum
_frustum=new Frustum(),// clipping
_clipping=new WebGLClipping(),_clippingEnabled=false,_localClippingEnabled=false,// camera matrices cache
_projScreenMatrix=new Matrix4(),_vector3=new Vector3();function getTargetPixelRatio(){return _currentRenderTarget===null?_pixelRatio:1;}// initialize
var _gl;try{var contextAttributes={alpha:_alpha,depth:_depth,stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer,powerPreference:_powerPreference,failIfMajorPerformanceCaveat:_failIfMajorPerformanceCaveat,xrCompatible:true};// event listeners must be registered before WebGL context is created, see #12753
_canvas.addEventListener('webglcontextlost',onContextLost,false);_canvas.addEventListener('webglcontextrestored',onContextRestore,false);_gl=_context||_canvas.getContext('webgl',contextAttributes)||_canvas.getContext('experimental-webgl',contextAttributes);if(_gl===null){if(_canvas.getContext('webgl')!==null){throw new Error('Error creating WebGL context with your selected attributes.');}else{throw new Error('Error creating WebGL context.');}}// Some experimental-webgl implementations do not have getShaderPrecisionFormat
if(_gl.getShaderPrecisionFormat===undefined){_gl.getShaderPrecisionFormat=function(){return{'rangeMin':1,'rangeMax':1,'precision':1};};}}catch(error){console.error('THREE.WebGLRenderer: '+error.message);throw error;}var extensions,capabilities,state,info;var properties,textures,attributes,geometries,objects;var programCache,renderLists,renderStates;var background,morphtargets,bufferRenderer,indexedBufferRenderer;var utils;function initGLContext(){extensions=new WebGLExtensions(_gl);capabilities=new WebGLCapabilities(_gl,extensions,parameters);if(capabilities.isWebGL2===false){extensions.get('WEBGL_depth_texture');extensions.get('OES_texture_float');extensions.get('OES_texture_half_float');extensions.get('OES_texture_half_float_linear');extensions.get('OES_standard_derivatives');extensions.get('OES_element_index_uint');extensions.get('ANGLE_instanced_arrays');}extensions.get('OES_texture_float_linear');utils=new WebGLUtils(_gl,extensions,capabilities);state=new WebGLState(_gl,extensions,capabilities);state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());info=new WebGLInfo(_gl);properties=new WebGLProperties();textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);attributes=new WebGLAttributes(_gl,capabilities);geometries=new WebGLGeometries(_gl,attributes,info);objects=new WebGLObjects(_gl,geometries,attributes,info);morphtargets=new WebGLMorphtargets(_gl);programCache=new WebGLPrograms(_this,extensions,capabilities);renderLists=new WebGLRenderLists();renderStates=new WebGLRenderStates();background=new WebGLBackground(_this,state,objects,_premultipliedAlpha);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info,capabilities);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info,capabilities);info.programs=programCache.programs;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.state=state;_this.info=info;}initGLContext();// xr
var xr=new WebXRManager(_this,_gl);this.xr=xr;// shadow map
var shadowMap=new WebGLShadowMap(_this,objects,capabilities.maxTextureSize);this.shadowMap=shadowMap;// API
this.getContext=function(){return _gl;};this.getContextAttributes=function(){return _gl.getContextAttributes();};this.forceContextLoss=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.loseContext();};this.forceContextRestore=function(){var extension=extensions.get('WEBGL_lose_context');if(extension)extension.restoreContext();};this.getPixelRatio=function(){return _pixelRatio;};this.setPixelRatio=function(value){if(value===undefined)return;_pixelRatio=value;this.setSize(_width,_height,false);};this.getSize=function(target){if(target===undefined){console.warn('WebGLRenderer: .getsize() now requires a Vector2 as an argument');target=new Vector2();}return target.set(_width,_height);};this.setSize=function(width,height,updateStyle){if(xr.isPresenting){console.warn('THREE.WebGLRenderer: Can\'t change size while VR device is presenting.');return;}_width=width;_height=height;_canvas.width=Math.floor(width*_pixelRatio);_canvas.height=Math.floor(height*_pixelRatio);if(updateStyle!==false){_canvas.style.width=width+'px';_canvas.style.height=height+'px';}this.setViewport(0,0,width,height);};this.getDrawingBufferSize=function(target){if(target===undefined){console.warn('WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument');target=new Vector2();}return target.set(_width*_pixelRatio,_height*_pixelRatio).floor();};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;_canvas.width=Math.floor(width*pixelRatio);_canvas.height=Math.floor(height*pixelRatio);this.setViewport(0,0,width,height);};this.getCurrentViewport=function(target){if(target===undefined){console.warn('WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument');target=new Vector4();}return target.copy(_currentViewport);};this.getViewport=function(target){return target.copy(_viewport);};this.setViewport=function(x,y,width,height){if(x.isVector4){_viewport.set(x.x,x.y,x.z,x.w);}else{_viewport.set(x,y,width,height);}state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());};this.getScissor=function(target){return target.copy(_scissor);};this.setScissor=function(x,y,width,height){if(x.isVector4){_scissor.set(x.x,x.y,x.z,x.w);}else{_scissor.set(x,y,width,height);}state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());};this.getScissorTest=function(){return _scissorTest;};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean);};this.setOpaqueSort=function(method){_opaqueSort=method;};this.setTransparentSort=function(method){_transparentSort=method;};// Clearing
this.getClearColor=function(){return background.getClearColor();};this.setClearColor=function(){background.setClearColor.apply(background,arguments);};this.getClearAlpha=function(){return background.getClearAlpha();};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments);};this.clear=function(color,depth,stencil){var bits=0;if(color===undefined||color)bits|=16384;if(depth===undefined||depth)bits|=256;if(stencil===undefined||stencil)bits|=1024;_gl.clear(bits);};this.clearColor=function(){this.clear(true,false,false);};this.clearDepth=function(){this.clear(false,true,false);};this.clearStencil=function(){this.clear(false,false,true);};//
this.dispose=function(){_canvas.removeEventListener('webglcontextlost',onContextLost,false);_canvas.removeEventListener('webglcontextrestored',onContextRestore,false);renderLists.dispose();renderStates.dispose();properties.dispose();objects.dispose();xr.dispose();animation.stop();this.forceContextLoss();};// Events
function onContextLost(event){event.preventDefault();console.log('THREE.WebGLRenderer: Context Lost.');_isContextLost=true;}function onContextRestore()/* event */{console.log('THREE.WebGLRenderer: Context Restored.');_isContextLost=false;initGLContext();}function onMaterialDispose(event){var material=event.target;material.removeEventListener('dispose',onMaterialDispose);deallocateMaterial(material);}// Buffer deallocation
function deallocateMaterial(material){releaseMaterialProgramReference(material);properties.remove(material);}function releaseMaterialProgramReference(material){var programInfo=properties.get(material).program;material.program=undefined;if(programInfo!==undefined){programCache.releaseProgram(programInfo);}}// Buffer rendering
function renderObjectImmediate(object,program){object.render(function(object){_this.renderBufferImmediate(object,program);});}this.renderBufferImmediate=function(object,program){state.initAttributes();var buffers=properties.get(object);if(object.hasPositions&&!buffers.position)buffers.position=_gl.createBuffer();if(object.hasNormals&&!buffers.normal)buffers.normal=_gl.createBuffer();if(object.hasUvs&&!buffers.uv)buffers.uv=_gl.createBuffer();if(object.hasColors&&!buffers.color)buffers.color=_gl.createBuffer();var programAttributes=program.getAttributes();if(object.hasPositions){_gl.bindBuffer(34962,buffers.position);_gl.bufferData(34962,object.positionArray,35048);state.enableAttribute(programAttributes.position);_gl.vertexAttribPointer(programAttributes.position,3,5126,false,0,0);}if(object.hasNormals){_gl.bindBuffer(34962,buffers.normal);_gl.bufferData(34962,object.normalArray,35048);state.enableAttribute(programAttributes.normal);_gl.vertexAttribPointer(programAttributes.normal,3,5126,false,0,0);}if(object.hasUvs){_gl.bindBuffer(34962,buffers.uv);_gl.bufferData(34962,object.uvArray,35048);state.enableAttribute(programAttributes.uv);_gl.vertexAttribPointer(programAttributes.uv,2,5126,false,0,0);}if(object.hasColors){_gl.bindBuffer(34962,buffers.color);_gl.bufferData(34962,object.colorArray,35048);state.enableAttribute(programAttributes.color);_gl.vertexAttribPointer(programAttributes.color,3,5126,false,0,0);}state.disableUnusedAttributes();_gl.drawArrays(4,0,object.count);object.count=0;};var tempScene=new Scene();this.renderBufferDirect=function(camera,scene,geometry,material,object,group){if(scene===null)scene=tempScene;// renderBufferDirect second parameter used to be fog (could be null)
var frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;var program=setProgram(camera,scene,material,object);state.setMaterial(material,frontFaceCW);var updateBuffers=false;if(_currentGeometryProgram.geometry!==geometry.id||_currentGeometryProgram.program!==program.id||_currentGeometryProgram.wireframe!==(material.wireframe===true)){_currentGeometryProgram.geometry=geometry.id;_currentGeometryProgram.program=program.id;_currentGeometryProgram.wireframe=material.wireframe===true;updateBuffers=true;}if(material.morphTargets||material.morphNormals){morphtargets.update(object,geometry,material,program);updateBuffers=true;}//
var index=geometry.index;var position=geometry.attributes.position;//
if(index===null){if(position===undefined||position.count===0)return;}else if(index.count===0){return;}//
var rangeFactor=1;if(material.wireframe===true){index=geometries.getWireframeAttribute(geometry);rangeFactor=2;}var attribute;var renderer=bufferRenderer;if(index!==null){attribute=attributes.get(index);renderer=indexedBufferRenderer;renderer.setIndex(attribute);}if(updateBuffers){setupVertexAttributes(object,geometry,material,program);if(index!==null){_gl.bindBuffer(34963,attribute.buffer);}}//
var dataCount=index!==null?index.count:position.count;var rangeStart=geometry.drawRange.start*rangeFactor;var rangeCount=geometry.drawRange.count*rangeFactor;var groupStart=group!==null?group.start*rangeFactor:0;var groupCount=group!==null?group.count*rangeFactor:Infinity;var drawStart=Math.max(rangeStart,groupStart);var drawEnd=Math.min(dataCount,rangeStart+rangeCount,groupStart+groupCount)-1;var drawCount=Math.max(0,drawEnd-drawStart+1);if(drawCount===0)return;//
if(object.isMesh){if(material.wireframe===true){state.setLineWidth(material.wireframeLinewidth*getTargetPixelRatio());renderer.setMode(1);}else{renderer.setMode(4);}}else if(object.isLine){var lineWidth=material.linewidth;if(lineWidth===undefined)lineWidth=1;// Not using Line*Material
state.setLineWidth(lineWidth*getTargetPixelRatio());if(object.isLineSegments){renderer.setMode(1);}else if(object.isLineLoop){renderer.setMode(2);}else{renderer.setMode(3);}}else if(object.isPoints){renderer.setMode(0);}else if(object.isSprite){renderer.setMode(4);}if(object.isInstancedMesh){renderer.renderInstances(geometry,drawStart,drawCount,object.count);}else if(geometry.isInstancedBufferGeometry){renderer.renderInstances(geometry,drawStart,drawCount,geometry.maxInstancedCount);}else{renderer.render(drawStart,drawCount);}};function setupVertexAttributes(object,geometry,material,program){if(capabilities.isWebGL2===false&&(object.isInstancedMesh||geometry.isInstancedBufferGeometry)){if(extensions.get('ANGLE_instanced_arrays')===null)return;}state.initAttributes();var geometryAttributes=geometry.attributes;var programAttributes=program.getAttributes();var materialDefaultAttributeValues=material.defaultAttributeValues;for(var name in programAttributes){var programAttribute=programAttributes[name];if(programAttribute>=0){var geometryAttribute=geometryAttributes[name];if(geometryAttribute!==undefined){var normalized=geometryAttribute.normalized;var size=geometryAttribute.itemSize;var attribute=attributes.get(geometryAttribute);// TODO Attribute may not be available on context restore
if(attribute===undefined)continue;var buffer=attribute.buffer;var type=attribute.type;var bytesPerElement=attribute.bytesPerElement;if(geometryAttribute.isInterleavedBufferAttribute){var data=geometryAttribute.data;var stride=data.stride;var offset=geometryAttribute.offset;if(data&&data.isInstancedInterleavedBuffer){state.enableAttributeAndDivisor(programAttribute,data.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=data.meshPerAttribute*data.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(34962,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,stride*bytesPerElement,offset*bytesPerElement);}else{if(geometryAttribute.isInstancedBufferAttribute){state.enableAttributeAndDivisor(programAttribute,geometryAttribute.meshPerAttribute);if(geometry.maxInstancedCount===undefined){geometry.maxInstancedCount=geometryAttribute.meshPerAttribute*geometryAttribute.count;}}else{state.enableAttribute(programAttribute);}_gl.bindBuffer(34962,buffer);_gl.vertexAttribPointer(programAttribute,size,type,normalized,0,0);}}else if(name==='instanceMatrix'){var attribute=attributes.get(object.instanceMatrix);// TODO Attribute may not be available on context restore
if(attribute===undefined)continue;var buffer=attribute.buffer;var type=attribute.type;state.enableAttributeAndDivisor(programAttribute+0,1);state.enableAttributeAndDivisor(programAttribute+1,1);state.enableAttributeAndDivisor(programAttribute+2,1);state.enableAttributeAndDivisor(programAttribute+3,1);_gl.bindBuffer(34962,buffer);_gl.vertexAttribPointer(programAttribute+0,4,type,false,64,0);_gl.vertexAttribPointer(programAttribute+1,4,type,false,64,16);_gl.vertexAttribPointer(programAttribute+2,4,type,false,64,32);_gl.vertexAttribPointer(programAttribute+3,4,type,false,64,48);}else if(materialDefaultAttributeValues!==undefined){var value=materialDefaultAttributeValues[name];if(value!==undefined){switch(value.length){case 2:_gl.vertexAttrib2fv(programAttribute,value);break;case 3:_gl.vertexAttrib3fv(programAttribute,value);break;case 4:_gl.vertexAttrib4fv(programAttribute,value);break;default:_gl.vertexAttrib1fv(programAttribute,value);}}}}}state.disableUnusedAttributes();}// Compile
this.compile=function(scene,camera){currentRenderState=renderStates.get(scene,camera);currentRenderState.init();scene.traverse(function(object){if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}});currentRenderState.setupLights(camera);var compiled={};scene.traverse(function(object){if(object.material){if((0,_isArray.default)(object.material)){for(var i=0;i<object.material.length;i++){if(object.material[i].uuid in compiled===false){initMaterial(object.material[i],scene,object);compiled[object.material[i].uuid]=true;}}}else if(object.material.uuid in compiled===false){initMaterial(object.material,scene,object);compiled[object.material.uuid]=true;}}});};// Animation Loop
var onAnimationFrameCallback=null;function onAnimationFrame(time){if(xr.isPresenting)return;if(onAnimationFrameCallback)onAnimationFrameCallback(time);}var animation=new WebGLAnimation();animation.setAnimationLoop(onAnimationFrame);if(typeof window!=='undefined')animation.setContext(window);this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback;xr.setAnimationLoop(callback);animation.start();};// Rendering
this.render=function(scene,camera){var renderTarget,forceClear;if(arguments[2]!==undefined){console.warn('THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');renderTarget=arguments[2];}if(arguments[3]!==undefined){console.warn('THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.');forceClear=arguments[3];}if(!(camera&&camera.isCamera)){console.error('THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.');return;}if(_isContextLost)return;// reset caching for this frame
_currentGeometryProgram.geometry=null;_currentGeometryProgram.program=null;_currentGeometryProgram.wireframe=false;_currentMaterialId=-1;_currentCamera=null;// update scene graph
if(scene.autoUpdate===true)scene.updateMatrixWorld();// update camera matrices and frustum
if(camera.parent===null)camera.updateMatrixWorld();if(xr.enabled&&xr.isPresenting){camera=xr.getCamera(camera);}//
currentRenderState=renderStates.get(scene,camera);currentRenderState.init();scene.onBeforeRender(_this,scene,camera,renderTarget||_currentRenderTarget);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromProjectionMatrix(_projScreenMatrix);_localClippingEnabled=this.localClippingEnabled;_clippingEnabled=_clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,camera);currentRenderList.init();projectObject(scene,camera,0,_this.sortObjects);currentRenderList.finish();if(_this.sortObjects===true){currentRenderList.sort(_opaqueSort,_transparentSort);}//
if(_clippingEnabled)_clipping.beginShadows();var shadowsArray=currentRenderState.state.shadowsArray;shadowMap.render(shadowsArray,scene,camera);currentRenderState.setupLights(camera);if(_clippingEnabled)_clipping.endShadows();//
if(this.info.autoReset)this.info.reset();if(renderTarget!==undefined){this.setRenderTarget(renderTarget);}//
background.render(currentRenderList,scene,camera,forceClear);// render scene
var opaqueObjects=currentRenderList.opaque;var transparentObjects=currentRenderList.transparent;if(scene.overrideMaterial){var overrideMaterial=scene.overrideMaterial;if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera,overrideMaterial);if(transparentObjects.length)renderObjects(transparentObjects,scene,camera,overrideMaterial);}else{// opaque pass (front-to-back order)
if(opaqueObjects.length)renderObjects(opaqueObjects,scene,camera);// transparent pass (back-to-front order)
if(transparentObjects.length)renderObjects(transparentObjects,scene,camera);}//
scene.onAfterRender(_this,scene,camera);//
if(_currentRenderTarget!==null){// Generate mipmap if we're using any kind of mipmap filtering
textures.updateRenderTargetMipmap(_currentRenderTarget);// resolve multisample renderbuffers to a single-sample texture if necessary
textures.updateMultisampleRenderTarget(_currentRenderTarget);}// Ensure depth buffer writing is enabled so it can be cleared on next render
state.buffers.depth.setTest(true);state.buffers.depth.setMask(true);state.buffers.color.setMask(true);state.setPolygonOffset(false);// _gl.finish();
currentRenderList=null;currentRenderState=null;};function projectObject(object,camera,groupOrder,sortObjects){if(object.visible===false)return;var visible=object.layers.test(camera.layers);if(visible){if(object.isGroup){groupOrder=object.renderOrder;}else if(object.isLOD){if(object.autoUpdate===true)object.update(camera);}else if(object.isLight){currentRenderState.pushLight(object);if(object.castShadow){currentRenderState.pushShadow(object);}}else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);}}}else if(object.isImmediateRenderObject){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}currentRenderList.push(object,null,object.material,groupOrder,_vector3.z,null);}else if(object.isMesh||object.isLine||object.isPoints){if(object.isSkinnedMesh){// update skeleton only once in a frame
if(object.skeleton.frame!==info.render.frame){object.skeleton.update();object.skeleton.frame=info.render.frame;}}if(!object.frustumCulled||_frustum.intersectsObject(object)){if(sortObjects){_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);}var geometry=objects.update(object);var material=object.material;if((0,_isArray.default)(material)){var groups=geometry.groups;for(var i=0,l=groups.length;i<l;i++){var group=groups[i];var groupMaterial=material[group.materialIndex];if(groupMaterial&&groupMaterial.visible){currentRenderList.push(object,geometry,groupMaterial,groupOrder,_vector3.z,group);}}}else if(material.visible){currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);}}}}var children=object.children;for(var i=0,l=children.length;i<l;i++){projectObject(children[i],camera,groupOrder,sortObjects);}}function renderObjects(renderList,scene,camera,overrideMaterial){for(var i=0,l=renderList.length;i<l;i++){var renderItem=renderList[i];var object=renderItem.object;var geometry=renderItem.geometry;var material=overrideMaterial===undefined?renderItem.material:overrideMaterial;var group=renderItem.group;if(camera.isArrayCamera){_currentArrayCamera=camera;var cameras=camera.cameras;for(var j=0,jl=cameras.length;j<jl;j++){var camera2=cameras[j];if(object.layers.test(camera2.layers)){state.viewport(_currentViewport.copy(camera2.viewport));currentRenderState.setupLights(camera2);renderObject(object,scene,camera2,geometry,material,group);}}}else{_currentArrayCamera=null;renderObject(object,scene,camera,geometry,material,group);}}}function renderObject(object,scene,camera,geometry,material,group){object.onBeforeRender(_this,scene,camera,geometry,material,group);currentRenderState=renderStates.get(scene,_currentArrayCamera||camera);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);if(object.isImmediateRenderObject){var program=setProgram(camera,scene,material,object);state.setMaterial(material);_currentGeometryProgram.geometry=null;_currentGeometryProgram.program=null;_currentGeometryProgram.wireframe=false;renderObjectImmediate(object,program);}else{// console.log(3124125535)
_this.renderBufferDirect(camera,scene,geometry,material,object,group);}object.onAfterRender(_this,scene,camera,geometry,material,group);currentRenderState=renderStates.get(scene,_currentArrayCamera||camera);}function initMaterial(material,scene,object){// console.log("i",material)
var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;var shadowsArray=currentRenderState.state.shadowsArray;var lightsStateVersion=lights.state.version;var parameters=programCache.getParameters(material,lights.state,shadowsArray,scene,_clipping.numPlanes,_clipping.numIntersection,object);var programCacheKey=programCache.getProgramCacheKey(parameters);var program=materialProperties.program;var programChange=true;if(program===undefined){// new material
material.addEventListener('dispose',onMaterialDispose);}else if(program.cacheKey!==programCacheKey){// changed glsl or parameters
releaseMaterialProgramReference(material);}else if(materialProperties.lightsStateVersion!==lightsStateVersion){materialProperties.lightsStateVersion=lightsStateVersion;programChange=false;}else if(parameters.shaderID!==undefined){// same glsl and uniform list
return;}else{// only rebuild uniform list
programChange=false;}// console.log(234234325)
if(programChange){program=programCache.acquireProgram(parameters,programCacheKey);materialProperties.program=program;materialProperties.uniforms=parameters.uniforms;materialProperties.environment=material.isMeshStandardMaterial?scene.environment:null;materialProperties.outputEncoding=_this.outputEncoding;material.program=program;}var programAttributes=program.getAttributes();if(material.morphTargets){material.numSupportedMorphTargets=0;for(var i=0;i<_this.maxMorphTargets;i++){if(programAttributes['morphTarget'+i]>=0){material.numSupportedMorphTargets++;}}}if(material.morphNormals){material.numSupportedMorphNormals=0;for(var i=0;i<_this.maxMorphNormals;i++){if(programAttributes['morphNormal'+i]>=0){material.numSupportedMorphNormals++;}}}var uniforms=materialProperties.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||material.clipping===true){materialProperties.numClippingPlanes=_clipping.numPlanes;materialProperties.numIntersection=_clipping.numIntersection;uniforms.clippingPlanes=_clipping.uniform;}materialProperties.fog=scene.fog;// store the light setup it was created for
materialProperties.needsLights=materialNeedsLights(material);materialProperties.lightsStateVersion=lightsStateVersion;if(materialProperties.needsLights){// wire up the material to this renderer's lighting state
uniforms.ambientLightColor.value=lights.state.ambient;uniforms.lightProbe.value=lights.state.probe;uniforms.directionalLights.value=lights.state.directional;uniforms.directionalLightShadows.value=lights.state.directionalShadow;uniforms.spotLights.value=lights.state.spot;uniforms.spotLightShadows.value=lights.state.spotShadow;uniforms.rectAreaLights.value=lights.state.rectArea;uniforms.pointLights.value=lights.state.point;uniforms.pointLightShadows.value=lights.state.pointShadow;uniforms.hemisphereLights.value=lights.state.hemi;uniforms.directionalShadowMap.value=lights.state.directionalShadowMap;uniforms.directionalShadowMatrix.value=lights.state.directionalShadowMatrix;uniforms.spotShadowMap.value=lights.state.spotShadowMap;uniforms.spotShadowMatrix.value=lights.state.spotShadowMatrix;uniforms.pointShadowMap.value=lights.state.pointShadowMap;uniforms.pointShadowMatrix.value=lights.state.pointShadowMatrix;// TODO (abelnation): add area lights shadow info to uniforms
}var progUniforms=materialProperties.program.getUniforms(),uniformsList=WebGLUniforms.seqWithValue(progUniforms.seq,uniforms);materialProperties.uniformsList=uniformsList;}function setProgram(camera,scene,material,object){textures.resetTextureUnits();var fog=scene.fog;var environment=material.isMeshStandardMaterial?scene.environment:null;var materialProperties=properties.get(material);var lights=currentRenderState.state.lights;if(_clippingEnabled){if(_localClippingEnabled||camera!==_currentCamera){var useCache=camera===_currentCamera&&material.id===_currentMaterialId;// we might want to call this function with some ClippingGroup
// object instead of the material, once it becomes feasible
// (#8465, #8379)
_clipping.setState(material.clippingPlanes,material.clipIntersection,material.clipShadows,camera,materialProperties,useCache);}}if(material.version===materialProperties.__version){if(materialProperties.program===undefined){initMaterial(material,scene,object);}else if(material.fog&&materialProperties.fog!==fog){initMaterial(material,scene,object);}else if(materialProperties.environment!==environment){initMaterial(material,scene,object);}else if(materialProperties.needsLights&&materialProperties.lightsStateVersion!==lights.state.version){initMaterial(material,scene,object);}else if(materialProperties.numClippingPlanes!==undefined&&(materialProperties.numClippingPlanes!==_clipping.numPlanes||materialProperties.numIntersection!==_clipping.numIntersection)){initMaterial(material,scene,object);}else if(materialProperties.outputEncoding!==_this.outputEncoding){initMaterial(material,scene,object);}}else{initMaterial(material,scene,object);materialProperties.__version=material.version;}var refreshProgram=false;var refreshMaterial=false;var refreshLights=false;var program=materialProperties.program,p_uniforms=program.getUniforms(),m_uniforms=materialProperties.uniforms;// console.log(materialProperties)
if(state.useProgram(program.program)){refreshProgram=true;refreshMaterial=true;refreshLights=true;}if(material.id!==_currentMaterialId){_currentMaterialId=material.id;refreshMaterial=true;}if(refreshProgram||_currentCamera!==camera){p_uniforms.setValue(_gl,'projectionMatrix',camera.projectionMatrix);if(capabilities.logarithmicDepthBuffer){p_uniforms.setValue(_gl,'logDepthBufFC',2.0/(Math.log(camera.far+1.0)/Math.LN2));}if(_currentCamera!==camera){_currentCamera=camera;// lighting uniforms depend on the camera so enforce an update
// now, in case this material supports lights - or later, when
// the next material that does gets activated:
refreshMaterial=true;// set to true on material change
refreshLights=true;// remains set until update done
}// load material specific uniforms
// (shader material also gets them for the sake of genericity)
if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshStandardMaterial||material.envMap){var uCamPos=p_uniforms.map.cameraPosition;if(uCamPos!==undefined){uCamPos.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));}}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial){p_uniforms.setValue(_gl,'isOrthographic',camera.isOrthographicCamera===true);}if(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.skinning){p_uniforms.setValue(_gl,'viewMatrix',camera.matrixWorldInverse);}}// skinning uniforms must be set even if material didn't change
// auto-setting of texture unit for bone texture must go before other textures
// otherwise textures used for skinning can take over texture units reserved for other material textures
if(material.skinning){p_uniforms.setOptional(_gl,object,'bindMatrix');p_uniforms.setOptional(_gl,object,'bindMatrixInverse');var skeleton=object.skeleton;if(skeleton){var bones=skeleton.bones;if(capabilities.floatVertexTextures){if(skeleton.boneTexture===undefined){// layout (1 matrix = 4 pixels)
//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
var size=Math.sqrt(bones.length*4);// 4 pixels needed for 1 matrix
size=MathUtils.ceilPowerOfTwo(size);size=Math.max(size,4);var boneMatrices=new Float32Array(size*size*4);// 4 floats per RGBA pixel
boneMatrices.set(skeleton.boneMatrices);// copy current values
var boneTexture=new DataTexture(boneMatrices,size,size,RGBAFormat,FloatType);skeleton.boneMatrices=boneMatrices;skeleton.boneTexture=boneTexture;skeleton.boneTextureSize=size;}p_uniforms.setValue(_gl,'boneTexture',skeleton.boneTexture,textures);p_uniforms.setValue(_gl,'boneTextureSize',skeleton.boneTextureSize);}else{p_uniforms.setOptional(_gl,skeleton,'boneMatrices');}}}if(refreshMaterial||materialProperties.receiveShadow!==object.receiveShadow){materialProperties.receiveShadow=object.receiveShadow;p_uniforms.setValue(_gl,'receiveShadow',object.receiveShadow);}// 
if(refreshMaterial){p_uniforms.setValue(_gl,'toneMappingExposure',_this.toneMappingExposure);p_uniforms.setValue(_gl,'toneMappingWhitePoint',_this.toneMappingWhitePoint);if(materialProperties.needsLights){// the current material requires lighting info
// note: all lighting uniforms are always set correctly
// they simply reference the renderer's state for their
// values
//
// use the current material's .needsUpdate flags to set
// the GL state when required
markUniformsLightsNeedsUpdate(m_uniforms,refreshLights);}// refresh uniforms common to several materials
if(fog&&material.fog){refreshUniformsFog(m_uniforms,fog);}if(material.isMeshBasicMaterial){refreshUniformsCommon(m_uniforms,material);}else if(material.isMeshLambertMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsLambert(m_uniforms,material);}else if(material.isMeshToonMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsToon(m_uniforms,material);}else if(material.isMeshPhongMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsPhong(m_uniforms,material);}else if(material.isMeshStandardMaterial){refreshUniformsCommon(m_uniforms,material,environment);if(material.isMeshPhysicalMaterial){refreshUniformsPhysical(m_uniforms,material,environment);}else{refreshUniformsStandard(m_uniforms,material,environment);}}else if(material.isMeshMatcapMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsMatcap(m_uniforms,material);}else if(material.isMeshDepthMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsDepth(m_uniforms,material);}else if(material.isMeshDistanceMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsDistance(m_uniforms,material);}else if(material.isMeshNormalMaterial){refreshUniformsCommon(m_uniforms,material);refreshUniformsNormal(m_uniforms,material);}else if(material.isLineBasicMaterial){refreshUniformsLine(m_uniforms,material);if(material.isLineDashedMaterial){refreshUniformsDash(m_uniforms,material);}}else if(material.isPointsMaterial){refreshUniformsPoints(m_uniforms,material);}else if(material.isSpriteMaterial){refreshUniformsSprites(m_uniforms,material);}else if(material.isShadowMaterial){m_uniforms.color.value.copy(material.color);m_uniforms.opacity.value=material.opacity;}// RectAreaLight Texture
// TODO (mrdoob): Find a nicer implementation
if(m_uniforms.ltc_1!==undefined)m_uniforms.ltc_1.value=UniformsLib.LTC_1;if(m_uniforms.ltc_2!==undefined)m_uniforms.ltc_2.value=UniformsLib.LTC_2;WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);if(material.isShaderMaterial){material.uniformsNeedUpdate=false;// #15581
}}if(material.isShaderMaterial&&material.uniformsNeedUpdate===true){WebGLUniforms.upload(_gl,materialProperties.uniformsList,m_uniforms,textures);material.uniformsNeedUpdate=false;}if(material.isSpriteMaterial){p_uniforms.setValue(_gl,'center',object.center);}// common matrices
p_uniforms.setValue(_gl,'modelViewMatrix',object.modelViewMatrix);p_uniforms.setValue(_gl,'normalMatrix',object.normalMatrix);p_uniforms.setValue(_gl,'modelMatrix',object.matrixWorld);return program;}// Uniforms (refresh uniforms objects)
function refreshUniformsCommon(uniforms,material,environment){uniforms.opacity.value=material.opacity;(0,_assign.default)(uniforms,material.uniforms);if(material.color){uniforms.diffuse.value.copy(material.color);}if(material.emissive){uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);}if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}if(material.specularMap){uniforms.specularMap.value=material.specularMap;}var envMap=material.envMap||environment;if(envMap){uniforms.envMap.value=envMap;uniforms.flipEnvMap.value=envMap.isCubeTexture?-1:1;uniforms.reflectivity.value=material.reflectivity;uniforms.refractionRatio.value=material.refractionRatio;uniforms.maxMipLevel.value=properties.get(envMap).__maxMipLevel;}if(material.lightMap){uniforms.lightMap.value=material.lightMap;uniforms.lightMapIntensity.value=material.lightMapIntensity;}if(material.aoMap){uniforms.aoMap.value=material.aoMap;uniforms.aoMapIntensity.value=material.aoMapIntensity;}// uv repeat and offset setting priorities
// 1. color map
// 2. specular map
// 3. normal map
// 4. bump map
// 5. alpha map
// 6. emissive map
var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.specularMap){uvScaleMap=material.specularMap;}else if(material.displacementMap){uvScaleMap=material.displacementMap;}else if(material.normalMap){uvScaleMap=material.normalMap;}else if(material.bumpMap){uvScaleMap=material.bumpMap;}else if(material.roughnessMap){uvScaleMap=material.roughnessMap;}else if(material.metalnessMap){uvScaleMap=material.metalnessMap;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}else if(material.emissiveMap){uvScaleMap=material.emissiveMap;}if(uvScaleMap!==undefined){// backwards compatibility
if(uvScaleMap.isWebGLRenderTarget){uvScaleMap=uvScaleMap.texture;}if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}// uv repeat and offset setting priorities for uv2
// 1. ao map
// 2. light map
var uv2ScaleMap;if(material.aoMap){uv2ScaleMap=material.aoMap;}else if(material.lightMap){uv2ScaleMap=material.lightMap;}if(uv2ScaleMap!==undefined){// backwards compatibility
if(uv2ScaleMap.isWebGLRenderTarget){uv2ScaleMap=uv2ScaleMap.texture;}if(uv2ScaleMap.matrixAutoUpdate===true){uv2ScaleMap.updateMatrix();}uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);}}function refreshUniformsLine(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;}function refreshUniformsDash(uniforms,material){uniforms.dashSize.value=material.dashSize;uniforms.totalSize.value=material.dashSize+material.gapSize;uniforms.scale.value=material.scale;}function refreshUniformsPoints(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*_pixelRatio;uniforms.scale.value=_height*0.5;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}// uv repeat and offset setting priorities
// 1. color map
// 2. alpha map
var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsSprites(uniforms,material){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.rotation.value=material.rotation;if(material.map){uniforms.map.value=material.map;}if(material.alphaMap){uniforms.alphaMap.value=material.alphaMap;}// uv repeat and offset setting priorities
// 1. color map
// 2. alpha map
var uvScaleMap;if(material.map){uvScaleMap=material.map;}else if(material.alphaMap){uvScaleMap=material.alphaMap;}if(uvScaleMap!==undefined){if(uvScaleMap.matrixAutoUpdate===true){uvScaleMap.updateMatrix();}uniforms.uvTransform.value.copy(uvScaleMap.matrix);}}function refreshUniformsFog(uniforms,fog){uniforms.fogColor.value.copy(fog.color);if(fog.isFog){uniforms.fogNear.value=fog.near;uniforms.fogFar.value=fog.far;}else if(fog.isFogExp2){uniforms.fogDensity.value=fog.density;}}function refreshUniformsLambert(uniforms,material){if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}}function refreshUniformsPhong(uniforms,material){uniforms.specular.value.copy(material.specular);uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsToon(uniforms,material){uniforms.specular.value.copy(material.specular);uniforms.shininess.value=Math.max(material.shininess,1e-4);// to prevent pow( 0.0, 0.0 )
if(material.gradientMap){uniforms.gradientMap.value=material.gradientMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsStandard(uniforms,material,environment){uniforms.roughness.value=material.roughness;uniforms.metalness.value=material.metalness;if(material.roughnessMap){uniforms.roughnessMap.value=material.roughnessMap;}if(material.metalnessMap){uniforms.metalnessMap.value=material.metalnessMap;}if(material.emissiveMap){uniforms.emissiveMap.value=material.emissiveMap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}if(material.envMap||environment){//uniforms.envMap.value = material.envMap; // part of uniforms common
uniforms.envMapIntensity.value=material.envMapIntensity;}}function refreshUniformsPhysical(uniforms,material,environment){refreshUniformsStandard(uniforms,material,environment);uniforms.reflectivity.value=material.reflectivity;// also part of uniforms common
uniforms.clearcoat.value=material.clearcoat;uniforms.clearcoatRoughness.value=material.clearcoatRoughness;if(material.sheen)uniforms.sheen.value.copy(material.sheen);if(material.clearcoatMap){uniforms.clearcoatMap.value=material.clearcoatMap;}if(material.clearcoatRoughnessMap){uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap;}if(material.clearcoatNormalMap){uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap;if(material.side===BackSide){uniforms.clearcoatNormalScale.value.negate();}}uniforms.transparency.value=material.transparency;}function refreshUniformsMatcap(uniforms,material){if(material.matcap){uniforms.matcap.value=material.matcap;}if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDepth(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}function refreshUniformsDistance(uniforms,material){if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}uniforms.referencePosition.value.copy(material.referencePosition);uniforms.nearDistance.value=material.nearDistance;uniforms.farDistance.value=material.farDistance;}function refreshUniformsNormal(uniforms,material){if(material.bumpMap){uniforms.bumpMap.value=material.bumpMap;uniforms.bumpScale.value=material.bumpScale;if(material.side===BackSide)uniforms.bumpScale.value*=-1;}if(material.normalMap){uniforms.normalMap.value=material.normalMap;uniforms.normalScale.value.copy(material.normalScale);if(material.side===BackSide)uniforms.normalScale.value.negate();}if(material.displacementMap){uniforms.displacementMap.value=material.displacementMap;uniforms.displacementScale.value=material.displacementScale;uniforms.displacementBias.value=material.displacementBias;}}// If uniforms are marked as clean, they don't need to be loaded to the GPU.
function markUniformsLightsNeedsUpdate(uniforms,value){uniforms.ambientLightColor.needsUpdate=value;uniforms.lightProbe.needsUpdate=value;uniforms.directionalLights.needsUpdate=value;uniforms.directionalLightShadows.needsUpdate=value;uniforms.pointLights.needsUpdate=value;uniforms.pointLightShadows.needsUpdate=value;uniforms.spotLights.needsUpdate=value;uniforms.spotLightShadows.needsUpdate=value;uniforms.rectAreaLights.needsUpdate=value;uniforms.hemisphereLights.needsUpdate=value;}function materialNeedsLights(material){return material.isMeshLambertMaterial||material.isMeshToonMaterial||material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&material.lights===true;}//
this.setFramebuffer=function(value){if(_framebuffer!==value&&_currentRenderTarget===null)_gl.bindFramebuffer(36160,value);_framebuffer=value;};this.getActiveCubeFace=function(){return _currentActiveCubeFace;};this.getActiveMipmapLevel=function(){return _currentActiveMipmapLevel;};this.getRenderTarget=function(){return _currentRenderTarget;};this.setRenderTarget=function(renderTarget,activeCubeFace,activeMipmapLevel){_currentRenderTarget=renderTarget;_currentActiveCubeFace=activeCubeFace;_currentActiveMipmapLevel=activeMipmapLevel;if(renderTarget&&properties.get(renderTarget).__webglFramebuffer===undefined){textures.setupRenderTarget(renderTarget);}var framebuffer=_framebuffer;var isCube=false;if(renderTarget){var __webglFramebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget){framebuffer=__webglFramebuffer[activeCubeFace||0];isCube=true;}else if(renderTarget.isWebGLMultisampleRenderTarget){framebuffer=properties.get(renderTarget).__webglMultisampledFramebuffer;}else{framebuffer=__webglFramebuffer;}_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest;}else{_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();_currentScissorTest=_scissorTest;}if(_currentFramebuffer!==framebuffer){_gl.bindFramebuffer(36160,framebuffer);_currentFramebuffer=framebuffer;}state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);if(isCube){var textureProperties=properties.get(renderTarget.texture);_gl.framebufferTexture2D(36160,36064,34069+(activeCubeFace||0),textureProperties.__webglTexture,activeMipmapLevel||0);}};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){if(!(renderTarget&&renderTarget.isWebGLRenderTarget)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.');return;}var framebuffer=properties.get(renderTarget).__webglFramebuffer;if(renderTarget.isWebGLCubeRenderTarget&&activeCubeFaceIndex!==undefined){framebuffer=framebuffer[activeCubeFaceIndex];}if(framebuffer){var restore=false;if(framebuffer!==_currentFramebuffer){_gl.bindFramebuffer(36160,framebuffer);restore=true;}try{var texture=renderTarget.texture;var textureFormat=texture.format;var textureType=texture.type;if(textureFormat!==RGBAFormat&&utils.convert(textureFormat)!==_gl.getParameter(35739)){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.');return;}if(textureType!==UnsignedByteType&&utils.convert(textureType)!==_gl.getParameter(35738)&&// IE11, Edge and Chrome Mac < 52 (#9513)
!(textureType===FloatType&&(capabilities.isWebGL2||extensions.get('OES_texture_float')||extensions.get('WEBGL_color_buffer_float')))&&// Chrome Mac >= 52 and Firefox
!(textureType===HalfFloatType&&(capabilities.isWebGL2?extensions.get('EXT_color_buffer_float'):extensions.get('EXT_color_buffer_half_float')))){console.error('THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.');return;}if(_gl.checkFramebufferStatus(36160)===36053){// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
if(x>=0&&x<=renderTarget.width-width&&y>=0&&y<=renderTarget.height-height){_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer);}}else{console.error('THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.');}}finally{if(restore){_gl.bindFramebuffer(36160,_currentFramebuffer);}}}};this.copyFramebufferToTexture=function(position,texture,level){if(level===undefined)level=0;var levelScale=Math.pow(2,-level);var width=Math.floor(texture.image.width*levelScale);var height=Math.floor(texture.image.height*levelScale);var glFormat=utils.convert(texture.format);textures.setTexture2D(texture,0);_gl.copyTexImage2D(3553,level,glFormat,position.x,position.y,width,height,0);state.unbindTexture();};this.copyTextureToTexture=function(position,srcTexture,dstTexture,level){var width=srcTexture.image.width;var height=srcTexture.image.height;var glFormat=utils.convert(dstTexture.format);var glType=utils.convert(dstTexture.type);textures.setTexture2D(dstTexture,0);if(srcTexture.isDataTexture){_gl.texSubImage2D(3553,level||0,position.x,position.y,width,height,glFormat,glType,srcTexture.image.data);}else{_gl.texSubImage2D(3553,level||0,position.x,position.y,glFormat,glType,srcTexture.image);}state.unbindTexture();};this.initTexture=function(texture){textures.setTexture2D(texture,0);state.unbindTexture();};if(typeof __THREE_DEVTOOLS__!=='undefined'){__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe',{detail:this}));// eslint-disable-line no-undef
}}/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function FogExp2(color,density){this.name='';this.color=new Color(color);this.density=density!==undefined?density:0.00025;}(0,_assign.default)(FogExp2.prototype,{isFogExp2:true,clone:function clone(){return new FogExp2(this.color,this.density);},toJSON:function toJSON()/* meta */{return{type:'FogExp2',color:this.color.getHex(),density:this.density};}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function Fog(color,near,far){this.name='';this.color=new Color(color);this.near=near!==undefined?near:1;this.far=far!==undefined?far:1000;}(0,_assign.default)(Fog.prototype,{isFog:true,clone:function clone(){return new Fog(this.color,this.near,this.far);},toJSON:function toJSON()/* meta */{return{type:'Fog',color:this.color.getHex(),near:this.near,far:this.far};}});/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */function InterleavedBuffer(array,stride){this.array=array;this.stride=stride;this.count=array!==undefined?array.length/stride:0;this.usage=StaticDrawUsage;this.updateRange={offset:0,count:-1};this.version=0;}(0,_defineProperty3.default)(InterleavedBuffer.prototype,'needsUpdate',{set:function set(value){if(value===true)this.version++;}});(0,_assign.default)(InterleavedBuffer.prototype,{isInterleavedBuffer:true,onUploadCallback:function onUploadCallback(){},setUsage:function setUsage(value){this.usage=value;return this;},copy:function copy(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.usage=source.usage;return this;},copyAt:function copyAt(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(var i=0,l=this.stride;i<l;i++){this.array[index1+i]=attribute.array[index2+i];}return this;},set:function set(value,offset){if(offset===undefined)offset=0;this.array.set(value,offset);return this;},clone:function clone(){return new this.constructor().copy(this);},onUpload:function onUpload(callback){this.onUploadCallback=callback;return this;}});/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */var _vector$6=new Vector3();function InterleavedBufferAttribute(interleavedBuffer,itemSize,offset,normalized){this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=normalized===true;}(0,_defineProperties.default)(InterleavedBufferAttribute.prototype,{count:{get:function get(){return this.data.count;}},array:{get:function get(){return this.data.array;}}});(0,_assign.default)(InterleavedBufferAttribute.prototype,{isInterleavedBufferAttribute:true,applyMatrix4:function applyMatrix4(m){for(var i=0,l=this.data.count;i<l;i++){_vector$6.x=this.getX(i);_vector$6.y=this.getY(i);_vector$6.z=this.getZ(i);_vector$6.applyMatrix4(m);this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);}return this;},setX:function setX(index,x){this.data.array[index*this.data.stride+this.offset]=x;return this;},setY:function setY(index,y){this.data.array[index*this.data.stride+this.offset+1]=y;return this;},setZ:function setZ(index,z){this.data.array[index*this.data.stride+this.offset+2]=z;return this;},setW:function setW(index,w){this.data.array[index*this.data.stride+this.offset+3]=w;return this;},getX:function getX(index){return this.data.array[index*this.data.stride+this.offset];},getY:function getY(index){return this.data.array[index*this.data.stride+this.offset+1];},getZ:function getZ(index){return this.data.array[index*this.data.stride+this.offset+2];},getW:function getW(index){return this.data.array[index*this.data.stride+this.offset+3];},setXY:function setXY(index,x,y){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;return this;},setXYZ:function setXYZ(index,x,y,z){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;return this;},setXYZW:function setXYZW(index,x,y,z,w){index=index*this.data.stride+this.offset;this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this;}});/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */function SpriteMaterial(parameters){Material.call(this);this.type='SpriteMaterial';this.color=new Color(0xffffff);this.map=null;this.alphaMap=null;this.rotation=0;this.sizeAttenuation=true;this.transparent=true;this.setValues(parameters);}SpriteMaterial.prototype=(0,_create.default)(Material.prototype);SpriteMaterial.prototype.constructor=SpriteMaterial;SpriteMaterial.prototype.isSpriteMaterial=true;SpriteMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.rotation=source.rotation;this.sizeAttenuation=source.sizeAttenuation;return this;};/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */var _geometry;var _intersectPoint=new Vector3();var _worldScale=new Vector3();var _mvPosition=new Vector3();var _alignedPosition=new Vector2();var _rotatedPosition=new Vector2();var _viewWorldMatrix=new Matrix4();var _vA$1=new Vector3();var _vB$1=new Vector3();var _vC$1=new Vector3();var _uvA$1=new Vector2();var _uvB$1=new Vector2();var _uvC$1=new Vector2();function Sprite(material){Object3D.call(this);this.type='Sprite';if(_geometry===undefined){_geometry=new BufferGeometry();var float32Array=new Float32Array([-0.5,-0.5,0,0,0,0.5,-0.5,0,1,0,0.5,0.5,0,1,1,-0.5,0.5,0,0,1]);var interleavedBuffer=new InterleavedBuffer(float32Array,5);_geometry.setIndex([0,1,2,0,2,3]);_geometry.setAttribute('position',new InterleavedBufferAttribute(interleavedBuffer,3,0,false));_geometry.setAttribute('uv',new InterleavedBufferAttribute(interleavedBuffer,2,3,false));}this.geometry=_geometry;this.material=material!==undefined?material:new SpriteMaterial();this.center=new Vector2(0.5,0.5);}Sprite.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Sprite,isSprite:true,raycast:function raycast(raycaster,intersects){if(raycaster.camera===null){console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');}_worldScale.setFromMatrixScale(this.matrixWorld);_viewWorldMatrix.copy(raycaster.camera.matrixWorld);this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse,this.matrixWorld);_mvPosition.setFromMatrixPosition(this.modelViewMatrix);if(raycaster.camera.isPerspectiveCamera&&this.material.sizeAttenuation===false){_worldScale.multiplyScalar(-_mvPosition.z);}var rotation=this.material.rotation;var sin,cos;if(rotation!==0){cos=Math.cos(rotation);sin=Math.sin(rotation);}var center=this.center;transformVertex(_vA$1.set(-0.5,-0.5,0),_mvPosition,center,_worldScale,sin,cos);transformVertex(_vB$1.set(0.5,-0.5,0),_mvPosition,center,_worldScale,sin,cos);transformVertex(_vC$1.set(0.5,0.5,0),_mvPosition,center,_worldScale,sin,cos);_uvA$1.set(0,0);_uvB$1.set(1,0);_uvC$1.set(1,1);// check first triangle
var intersect=raycaster.ray.intersectTriangle(_vA$1,_vB$1,_vC$1,false,_intersectPoint);if(intersect===null){// check second triangle
transformVertex(_vB$1.set(-0.5,0.5,0),_mvPosition,center,_worldScale,sin,cos);_uvB$1.set(0,1);intersect=raycaster.ray.intersectTriangle(_vA$1,_vC$1,_vB$1,false,_intersectPoint);if(intersect===null){return;}}var distance=raycaster.ray.origin.distanceTo(_intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,point:_intersectPoint.clone(),uv:Triangle.getUV(_intersectPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2()),face:null,object:this});},clone:function clone(){return new this.constructor(this.material).copy(this);},copy:function copy(source){Object3D.prototype.copy.call(this,source);if(source.center!==undefined)this.center.copy(source.center);return this;}});function transformVertex(vertexPosition,mvPosition,center,scale,sin,cos){// compute position in camera space
_alignedPosition.subVectors(vertexPosition,center).addScalar(0.5).multiply(scale);// to check if rotation is not zero
if(sin!==undefined){_rotatedPosition.x=cos*_alignedPosition.x-sin*_alignedPosition.y;_rotatedPosition.y=sin*_alignedPosition.x+cos*_alignedPosition.y;}else{_rotatedPosition.copy(_alignedPosition);}vertexPosition.copy(mvPosition);vertexPosition.x+=_rotatedPosition.x;vertexPosition.y+=_rotatedPosition.y;// transform to world space
vertexPosition.applyMatrix4(_viewWorldMatrix);}/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */var _v1$4=new Vector3();var _v2$2=new Vector3();function LOD(){Object3D.call(this);this._currentLevel=0;this.type='LOD';(0,_defineProperties.default)(this,{levels:{enumerable:true,value:[]}});this.autoUpdate=true;}LOD.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:LOD,isLOD:true,copy:function copy(source){Object3D.prototype.copy.call(this,source,false);var levels=source.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];this.addLevel(level.object.clone(),level.distance);}this.autoUpdate=source.autoUpdate;return this;},addLevel:function addLevel(object,distance){if(distance===undefined)distance=0;distance=Math.abs(distance);var levels=this.levels;for(var l=0;l<levels.length;l++){if(distance<levels[l].distance){break;}}levels.splice(l,0,{distance:distance,object:object});this.add(object);return this;},getCurrentLevel:function getCurrentLevel(){return this._currentLevel;},getObjectForDistance:function getObjectForDistance(distance){var levels=this.levels;if(levels.length>0){for(var i=1,l=levels.length;i<l;i++){if(distance<levels[i].distance){break;}}return levels[i-1].object;}return null;},raycast:function raycast(raycaster,intersects){var levels=this.levels;if(levels.length>0){_v1$4.setFromMatrixPosition(this.matrixWorld);var distance=raycaster.ray.origin.distanceTo(_v1$4);this.getObjectForDistance(distance).raycast(raycaster,intersects);}},update:function update(camera){var levels=this.levels;if(levels.length>1){_v1$4.setFromMatrixPosition(camera.matrixWorld);_v2$2.setFromMatrixPosition(this.matrixWorld);var distance=_v1$4.distanceTo(_v2$2)/camera.zoom;levels[0].object.visible=true;for(var i=1,l=levels.length;i<l;i++){if(distance>=levels[i].distance){levels[i-1].object.visible=false;levels[i].object.visible=true;}else{break;}}this._currentLevel=i-1;for(;i<l;i++){levels[i].object.visible=false;}}},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);if(this.autoUpdate===false)data.object.autoUpdate=false;data.object.levels=[];var levels=this.levels;for(var i=0,l=levels.length;i<l;i++){var level=levels[i];data.object.levels.push({object:level.object.uuid,distance:level.distance});}return data;}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */function SkinnedMesh(geometry,material){if(geometry&&geometry.isGeometry){console.error('THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.');}Mesh.call(this,geometry,material);this.type='SkinnedMesh';this.bindMode='attached';this.bindMatrix=new Matrix4();this.bindMatrixInverse=new Matrix4();}SkinnedMesh.prototype=(0,_assign.default)((0,_create.default)(Mesh.prototype),{constructor:SkinnedMesh,isSkinnedMesh:true,bind:function bind(skeleton,bindMatrix){this.skeleton=skeleton;if(bindMatrix===undefined){this.updateMatrixWorld(true);this.skeleton.calculateInverses();bindMatrix=this.matrixWorld;}this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.getInverse(bindMatrix);},pose:function pose(){this.skeleton.pose();},normalizeSkinWeights:function normalizeSkinWeights(){var vector=new Vector4();var skinWeight=this.geometry.attributes.skinWeight;for(var i=0,l=skinWeight.count;i<l;i++){vector.x=skinWeight.getX(i);vector.y=skinWeight.getY(i);vector.z=skinWeight.getZ(i);vector.w=skinWeight.getW(i);var scale=1.0/vector.manhattanLength();if(scale!==Infinity){vector.multiplyScalar(scale);}else{vector.set(1,0,0,0);// do something reasonable
}skinWeight.setXYZW(i,vector.x,vector.y,vector.z,vector.w);}},updateMatrixWorld:function updateMatrixWorld(force){Mesh.prototype.updateMatrixWorld.call(this,force);if(this.bindMode==='attached'){this.bindMatrixInverse.getInverse(this.matrixWorld);}else if(this.bindMode==='detached'){this.bindMatrixInverse.getInverse(this.bindMatrix);}else{console.warn('THREE.SkinnedMesh: Unrecognized bindMode: '+this.bindMode);}},clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */var _offsetMatrix=new Matrix4();var _identityMatrix=new Matrix4();function Skeleton(bones,boneInverses){// copy the bone array
bones=bones||[];this.bones=bones.slice(0);this.boneMatrices=new Float32Array(this.bones.length*16);this.frame=-1;// use the supplied bone inverses or calculate the inverses
if(boneInverses===undefined){this.calculateInverses();}else{if(this.bones.length===boneInverses.length){this.boneInverses=boneInverses.slice(0);}else{console.warn('THREE.Skeleton boneInverses is the wrong length.');this.boneInverses=[];for(var i=0,il=this.bones.length;i<il;i++){this.boneInverses.push(new Matrix4());}}}}(0,_assign.default)(Skeleton.prototype,{calculateInverses:function calculateInverses(){this.boneInverses=[];for(var i=0,il=this.bones.length;i<il;i++){var inverse=new Matrix4();if(this.bones[i]){inverse.getInverse(this.bones[i].matrixWorld);}this.boneInverses.push(inverse);}},pose:function pose(){var bone,i,il;// recover the bind-time world matrices
for(i=0,il=this.bones.length;i<il;i++){bone=this.bones[i];if(bone){bone.matrixWorld.getInverse(this.boneInverses[i]);}}// compute the local matrices, positions, rotations and scales
for(i=0,il=this.bones.length;i<il;i++){bone=this.bones[i];if(bone){if(bone.parent&&bone.parent.isBone){bone.matrix.getInverse(bone.parent.matrixWorld);bone.matrix.multiply(bone.matrixWorld);}else{bone.matrix.copy(bone.matrixWorld);}bone.matrix.decompose(bone.position,bone.quaternion,bone.scale);}}},update:function update(){var bones=this.bones;var boneInverses=this.boneInverses;var boneMatrices=this.boneMatrices;var boneTexture=this.boneTexture;// flatten bone matrices to array
for(var i=0,il=bones.length;i<il;i++){// compute the offset between the current and the original transform
var matrix=bones[i]?bones[i].matrixWorld:_identityMatrix;_offsetMatrix.multiplyMatrices(matrix,boneInverses[i]);_offsetMatrix.toArray(boneMatrices,i*16);}if(boneTexture!==undefined){boneTexture.needsUpdate=true;}},clone:function clone(){return new Skeleton(this.bones,this.boneInverses);},getBoneByName:function getBoneByName(name){for(var i=0,il=this.bones.length;i<il;i++){var bone=this.bones[i];if(bone.name===name){return bone;}}return undefined;},dispose:function dispose(){if(this.boneTexture){this.boneTexture.dispose();this.boneTexture=undefined;}}});/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */function Bone(){Object3D.call(this);this.type='Bone';}Bone.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Bone,isBone:true});/**
 * @author mrdoob / http://mrdoob.com/
 */var _instanceLocalMatrix=new Matrix4();var _instanceWorldMatrix=new Matrix4();var _instanceIntersects=[];var _mesh=new Mesh();function InstancedMesh(geometry,material,count){Mesh.call(this,geometry,material);this.instanceMatrix=new BufferAttribute(new Float32Array(count*16),16);this.count=count;this.frustumCulled=false;}InstancedMesh.prototype=(0,_assign.default)((0,_create.default)(Mesh.prototype),{constructor:InstancedMesh,isInstancedMesh:true,getMatrixAt:function getMatrixAt(index,matrix){matrix.fromArray(this.instanceMatrix.array,index*16);},raycast:function raycast(raycaster,intersects){var matrixWorld=this.matrixWorld;var raycastTimes=this.count;_mesh.geometry=this.geometry;_mesh.material=this.material;if(_mesh.material===undefined)return;for(var instanceId=0;instanceId<raycastTimes;instanceId++){// calculate the world matrix for each instance
this.getMatrixAt(instanceId,_instanceLocalMatrix);_instanceWorldMatrix.multiplyMatrices(matrixWorld,_instanceLocalMatrix);// the mesh represents this single instance
_mesh.matrixWorld=_instanceWorldMatrix;_mesh.raycast(raycaster,_instanceIntersects);// process the result of raycast
if(_instanceIntersects.length>0){_instanceIntersects[0].instanceId=instanceId;_instanceIntersects[0].object=this;intersects.push(_instanceIntersects[0]);_instanceIntersects.length=0;}}},setMatrixAt:function setMatrixAt(index,matrix){matrix.toArray(this.instanceMatrix.array,index*16);},updateMorphTargets:function updateMorphTargets(){}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */function LineBasicMaterial(parameters){Material.call(this);this.type='LineBasicMaterial';this.color=new Color(0xffffff);this.linewidth=1;this.linecap='round';this.linejoin='round';this.setValues(parameters);}LineBasicMaterial.prototype=(0,_create.default)(Material.prototype);LineBasicMaterial.prototype.constructor=LineBasicMaterial;LineBasicMaterial.prototype.isLineBasicMaterial=true;LineBasicMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 */var _start=new Vector3();var _end=new Vector3();var _inverseMatrix$1=new Matrix4();var _ray$1=new Ray();var _sphere$2=new Sphere();function Line(geometry,material,mode){if(mode===1){console.error('THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.');}Object3D.call(this);this.type='Line';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new LineBasicMaterial();}Line.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Line,isLine:true,computeLineDistances:function computeLineDistances(){var geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
if(geometry.index===null){var positionAttribute=geometry.attributes.position;var lineDistances=[0];for(var i=1,l=positionAttribute.count;i<l;i++){_start.fromBufferAttribute(positionAttribute,i-1);_end.fromBufferAttribute(positionAttribute,i);lineDistances[i]=lineDistances[i-1];lineDistances[i]+=_start.distanceTo(_end);}geometry.setAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else{console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){var vertices=geometry.vertices;var lineDistances=geometry.lineDistances;lineDistances[0]=0;for(var i=1,l=vertices.length;i<l;i++){lineDistances[i]=lineDistances[i-1];lineDistances[i]+=vertices[i-1].distanceTo(vertices[i]);}}return this;},raycast:function raycast(raycaster,intersects){var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Line.threshold;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$2.copy(geometry.boundingSphere);_sphere$2.applyMatrix4(matrixWorld);_sphere$2.radius+=threshold;if(raycaster.ray.intersectsSphere(_sphere$2)===false)return;//
_inverseMatrix$1.getInverse(matrixWorld);_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;var vStart=new Vector3();var vEnd=new Vector3();var interSegment=new Vector3();var interRay=new Vector3();var step=this&&this.isLineSegments?2:1;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,l=indices.length-1;i<l;i+=step){var a=indices[i];var b=indices[i+1];vStart.fromArray(positions,a*3);vEnd.fromArray(positions,b*3);var distSq=_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}else{for(var i=0,l=positions.length/3-1;i<l;i+=step){vStart.fromArray(positions,3*i);vEnd.fromArray(positions,3*i+3);var distSq=_ray$1.distanceSqToSegment(vStart,vEnd,interRay,interSegment);if(distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}}else if(geometry.isGeometry){var vertices=geometry.vertices;var nbVertices=vertices.length;for(var i=0;i<nbVertices-1;i+=step){var distSq=_ray$1.distanceSqToSegment(vertices[i],vertices[i+1],interRay,interSegment);if(distSq>localThresholdSq)continue;interRay.applyMatrix4(this.matrixWorld);//Move back to world space for distance calculation
var distance=raycaster.ray.origin.distanceTo(interRay);if(distance<raycaster.near||distance>raycaster.far)continue;intersects.push({distance:distance,// What do we want? intersection point on the ray or on the segment??
// point: raycaster.ray.at( distance ),
point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this});}}},clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});/**
 * @author mrdoob / http://mrdoob.com/
 */var _start$1=new Vector3();var _end$1=new Vector3();function LineSegments(geometry,material){Line.call(this,geometry,material);this.type='LineSegments';}LineSegments.prototype=(0,_assign.default)((0,_create.default)(Line.prototype),{constructor:LineSegments,isLineSegments:true,computeLineDistances:function computeLineDistances(){var geometry=this.geometry;if(geometry.isBufferGeometry){// we assume non-indexed geometry
if(geometry.index===null){var positionAttribute=geometry.attributes.position;var lineDistances=[];for(var i=0,l=positionAttribute.count;i<l;i+=2){_start$1.fromBufferAttribute(positionAttribute,i);_end$1.fromBufferAttribute(positionAttribute,i+1);lineDistances[i]=i===0?0:lineDistances[i-1];lineDistances[i+1]=lineDistances[i]+_start$1.distanceTo(_end$1);}geometry.setAttribute('lineDistance',new Float32BufferAttribute(lineDistances,1));}else{console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');}}else if(geometry.isGeometry){var vertices=geometry.vertices;var lineDistances=geometry.lineDistances;for(var i=0,l=vertices.length;i<l;i+=2){_start$1.copy(vertices[i]);_end$1.copy(vertices[i+1]);lineDistances[i]=i===0?0:lineDistances[i-1];lineDistances[i+1]=lineDistances[i]+_start$1.distanceTo(_end$1);}}return this;}});/**
 * @author mgreter / http://github.com/mgreter
 */function LineLoop(geometry,material){Line.call(this,geometry,material);this.type='LineLoop';}LineLoop.prototype=(0,_assign.default)((0,_create.default)(Line.prototype),{constructor:LineLoop,isLineLoop:true});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */function PointsMaterial(parameters){Material.call(this);this.type='PointsMaterial';this.color=new Color(0xffffff);this.map=null;this.alphaMap=null;this.size=1;this.sizeAttenuation=true;this.morphTargets=false;this.setValues(parameters);}PointsMaterial.prototype=(0,_create.default)(Material.prototype);PointsMaterial.prototype.constructor=PointsMaterial;PointsMaterial.prototype.isPointsMaterial=true;PointsMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.size=source.size;this.sizeAttenuation=source.sizeAttenuation;this.morphTargets=source.morphTargets;return this;};/**
 * @author alteredq / http://alteredqualia.com/
 */var _inverseMatrix$2=new Matrix4();var _ray$2=new Ray();var _sphere$3=new Sphere();var _position$1=new Vector3();function Points(geometry,material){Object3D.call(this);this.type='Points';this.geometry=geometry!==undefined?geometry:new BufferGeometry();this.material=material!==undefined?material:new PointsMaterial();this.updateMorphTargets();}Points.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Points,isPoints:true,raycast:function raycast(raycaster,intersects){var geometry=this.geometry;var matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold;// Checking boundingSphere distance to ray
if(geometry.boundingSphere===null)geometry.computeBoundingSphere();_sphere$3.copy(geometry.boundingSphere);_sphere$3.applyMatrix4(matrixWorld);_sphere$3.radius+=threshold;if(raycaster.ray.intersectsSphere(_sphere$3)===false)return;//
_inverseMatrix$2.getInverse(matrixWorld);_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);var localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);var localThresholdSq=localThreshold*localThreshold;if(geometry.isBufferGeometry){var index=geometry.index;var attributes=geometry.attributes;var positions=attributes.position.array;if(index!==null){var indices=index.array;for(var i=0,il=indices.length;i<il;i++){var a=indices[i];_position$1.fromArray(positions,a*3);testPoint(_position$1,a,localThresholdSq,matrixWorld,raycaster,intersects,this);}}else{for(var i=0,l=positions.length/3;i<l;i++){_position$1.fromArray(positions,i*3);testPoint(_position$1,i,localThresholdSq,matrixWorld,raycaster,intersects,this);}}}else{var vertices=geometry.vertices;for(var i=0,l=vertices.length;i<l;i++){testPoint(vertices[i],i,localThresholdSq,matrixWorld,raycaster,intersects,this);}}},updateMorphTargets:function updateMorphTargets(){var geometry=this.geometry;var m,ml,name;if(geometry.isBufferGeometry){var morphAttributes=geometry.morphAttributes;var keys=(0,_keys.default)(morphAttributes);if(keys.length>0){var morphAttribute=morphAttributes[keys[0]];if(morphAttribute!==undefined){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(m=0,ml=morphAttribute.length;m<ml;m++){name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0);this.morphTargetDictionary[name]=m;}}}}else{var morphTargets=geometry.morphTargets;if(morphTargets!==undefined&&morphTargets.length>0){console.error('THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.');}}},clone:function clone(){return new this.constructor(this.geometry,this.material).copy(this);}});function testPoint(point,index,localThresholdSq,matrixWorld,raycaster,intersects,object){var rayPointDistanceSq=_ray$2.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){var intersectPoint=new Vector3();_ray$2.closestPointToPoint(point,intersectPoint);intersectPoint.applyMatrix4(matrixWorld);var distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint,index:index,face:null,object:object});}}/**
 * @author mrdoob / http://mrdoob.com/
 */function VideoTexture(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.format=format!==undefined?format:RGBFormat;this.minFilter=minFilter!==undefined?minFilter:LinearFilter;this.magFilter=magFilter!==undefined?magFilter:LinearFilter;this.generateMipmaps=false;}VideoTexture.prototype=(0,_assign.default)((0,_create.default)(Texture.prototype),{constructor:VideoTexture,isVideoTexture:true,update:function update(){var video=this.image;if(video.readyState>=video.HAVE_CURRENT_DATA){this.needsUpdate=true;}}});/**
 * @author alteredq / http://alteredqualia.com/
 */function CompressedTexture(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.image={width:width,height:height};this.mipmaps=mipmaps;// no flipping for cube textures
// (also flipping doesn't work for compressed textures )
this.flipY=false;// can't generate mipmaps for compressed textures
// mips must be embedded in DDS files
this.generateMipmaps=false;}CompressedTexture.prototype=(0,_create.default)(Texture.prototype);CompressedTexture.prototype.constructor=CompressedTexture;CompressedTexture.prototype.isCompressedTexture=true;/**
 * @author mrdoob / http://mrdoob.com/
 */function CanvasTexture(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){Texture.call(this,canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.needsUpdate=true;}CanvasTexture.prototype=(0,_create.default)(Texture.prototype);CanvasTexture.prototype.constructor=CanvasTexture;CanvasTexture.prototype.isCanvasTexture=true;/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */function DepthTexture(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){format=format!==undefined?format:DepthFormat;if(format!==DepthFormat&&format!==DepthStencilFormat){throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');}if(type===undefined&&format===DepthFormat)type=UnsignedShortType;if(type===undefined&&format===DepthStencilFormat)type=UnsignedInt248Type;Texture.call(this,null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.image={width:width,height:height};this.magFilter=magFilter!==undefined?magFilter:NearestFilter;this.minFilter=minFilter!==undefined?minFilter:NearestFilter;this.flipY=false;this.generateMipmaps=false;}DepthTexture.prototype=(0,_create.default)(Texture.prototype);DepthTexture.prototype.constructor=DepthTexture;DepthTexture.prototype.isDepthTexture=true;/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */function WireframeGeometry(geometry){BufferGeometry.call(this);this.type='WireframeGeometry';// buffer
var vertices=[];// helper variables
var i,j,l,o,ol;var edge=[0,0],edges={},e,edge1,edge2;var key,keys=['a','b','c'];var vertex;// different logic for Geometry and BufferGeometry
if(geometry&&geometry.isGeometry){// create a data structure that contains all edges without duplicates
var faces=geometry.faces;for(i=0,l=faces.length;i<l;i++){var face=faces[i];for(j=0;j<3;j++){edge1=face[keys[j]];edge2=face[keys[(j+1)%3]];edge[0]=Math.min(edge1,edge2);// sorting prevents duplicates
edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1]};}}}// generate vertices
for(key in edges){e=edges[key];vertex=geometry.vertices[e.index1];vertices.push(vertex.x,vertex.y,vertex.z);vertex=geometry.vertices[e.index2];vertices.push(vertex.x,vertex.y,vertex.z);}}else if(geometry&&geometry.isBufferGeometry){var position,indices,groups;var group,start,count;var index1,index2;vertex=new Vector3();if(geometry.index!==null){// indexed BufferGeometry
position=geometry.attributes.position;indices=geometry.index;groups=geometry.groups;if(groups.length===0){groups=[{start:0,count:indices.count,materialIndex:0}];}// create a data structure that contains all eges without duplicates
for(o=0,ol=groups.length;o<ol;++o){group=groups[o];start=group.start;count=group.count;for(i=start,l=start+count;i<l;i+=3){for(j=0;j<3;j++){edge1=indices.getX(i+j);edge2=indices.getX(i+(j+1)%3);edge[0]=Math.min(edge1,edge2);// sorting prevents duplicates
edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1]};}}}}// generate vertices
for(key in edges){e=edges[key];vertex.fromBufferAttribute(position,e.index1);vertices.push(vertex.x,vertex.y,vertex.z);vertex.fromBufferAttribute(position,e.index2);vertices.push(vertex.x,vertex.y,vertex.z);}}else{// non-indexed BufferGeometry
position=geometry.attributes.position;for(i=0,l=position.count/3;i<l;i++){for(j=0;j<3;j++){// three edges per triangle, an edge is represented as (index1, index2)
// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
index1=3*i+j;vertex.fromBufferAttribute(position,index1);vertices.push(vertex.x,vertex.y,vertex.z);index2=3*i+(j+1)%3;vertex.fromBufferAttribute(position,index2);vertices.push(vertex.x,vertex.y,vertex.z);}}}}// build geometry
this.setAttribute('position',new Float32BufferAttribute(vertices,3));}WireframeGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);WireframeGeometry.prototype.constructor=WireframeGeometry;/**
 * @author zz85 / https://github.com/zz85
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */ // ParametricGeometry
function ParametricGeometry(func,slices,stacks){Geometry.call(this);this.type='ParametricGeometry';this.parameters={func:func,slices:slices,stacks:stacks};this.fromBufferGeometry(new ParametricBufferGeometry(func,slices,stacks));this.mergeVertices();}ParametricGeometry.prototype=(0,_create.default)(Geometry.prototype);ParametricGeometry.prototype.constructor=ParametricGeometry;// ParametricBufferGeometry
function ParametricBufferGeometry(func,slices,stacks){BufferGeometry.call(this);this.type='ParametricBufferGeometry';this.parameters={func:func,slices:slices,stacks:stacks};// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];var EPS=0.00001;var normal=new Vector3();var p0=new Vector3(),p1=new Vector3();var pu=new Vector3(),pv=new Vector3();var i,j;if(func.length<3){console.error('THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.');}// generate vertices, normals and uvs
var sliceCount=slices+1;for(i=0;i<=stacks;i++){var v=i/stacks;for(j=0;j<=slices;j++){var u=j/slices;// vertex
func(u,v,p0);vertices.push(p0.x,p0.y,p0.z);// normal
// approximate tangent vectors via finite differences
if(u-EPS>=0){func(u-EPS,v,p1);pu.subVectors(p0,p1);}else{func(u+EPS,v,p1);pu.subVectors(p1,p0);}if(v-EPS>=0){func(u,v-EPS,p1);pv.subVectors(p0,p1);}else{func(u,v+EPS,p1);pv.subVectors(p1,p0);}// cross product of tangent vectors returns surface normal
normal.crossVectors(pu,pv).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,v);}}// generate indices
for(i=0;i<stacks;i++){for(j=0;j<slices;j++){var a=i*sliceCount+j;var b=i*sliceCount+j+1;var c=(i+1)*sliceCount+j+1;var d=(i+1)*sliceCount+j;// faces one and two
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}ParametricBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);ParametricBufferGeometry.prototype.constructor=ParametricBufferGeometry;/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */ // PolyhedronGeometry
function PolyhedronGeometry(vertices,indices,radius,detail){Geometry.call(this);this.type='PolyhedronGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices,indices,radius,detail));this.mergeVertices();}PolyhedronGeometry.prototype=(0,_create.default)(Geometry.prototype);PolyhedronGeometry.prototype.constructor=PolyhedronGeometry;// PolyhedronBufferGeometry
function PolyhedronBufferGeometry(vertices,indices,radius,detail){BufferGeometry.call(this);this.type='PolyhedronBufferGeometry';this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};radius=radius||1;detail=detail||0;// default buffer data
var vertexBuffer=[];var uvBuffer=[];// the subdivision creates the vertex buffer data
subdivide(detail);// all vertices should lie on a conceptual sphere with a given radius
applyRadius(radius);// finally, create the uv data
generateUVs();// build non-indexed geometry
this.setAttribute('position',new Float32BufferAttribute(vertexBuffer,3));this.setAttribute('normal',new Float32BufferAttribute(vertexBuffer.slice(),3));this.setAttribute('uv',new Float32BufferAttribute(uvBuffer,2));if(detail===0){this.computeVertexNormals();// flat normals
}else{this.normalizeNormals();// smooth normals
}// helper functions
function subdivide(detail){var a=new Vector3();var b=new Vector3();var c=new Vector3();// iterate over all faces and apply a subdivison with the given detail value
for(var i=0;i<indices.length;i+=3){// get the vertices of the face
getVertexByIndex(indices[i+0],a);getVertexByIndex(indices[i+1],b);getVertexByIndex(indices[i+2],c);// perform subdivision
subdivideFace(a,b,c,detail);}}function subdivideFace(a,b,c,detail){var cols=Math.pow(2,detail);// we use this multidimensional array as a data structure for creating the subdivision
var v=[];var i,j;// construct all of the vertices for this subdivision
for(i=0;i<=cols;i++){v[i]=[];var aj=a.clone().lerp(c,i/cols);var bj=b.clone().lerp(c,i/cols);var rows=cols-i;for(j=0;j<=rows;j++){if(j===0&&i===cols){v[i][j]=aj;}else{v[i][j]=aj.clone().lerp(bj,j/rows);}}}// construct all of the faces
for(i=0;i<cols;i++){for(j=0;j<2*(cols-i)-1;j++){var k=Math.floor(j/2);if(j%2===0){pushVertex(v[i][k+1]);pushVertex(v[i+1][k]);pushVertex(v[i][k]);}else{pushVertex(v[i][k+1]);pushVertex(v[i+1][k+1]);pushVertex(v[i+1][k]);}}}}function applyRadius(radius){var vertex=new Vector3();// iterate over the entire buffer and apply the radius to each vertex
for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];vertex.normalize().multiplyScalar(radius);vertexBuffer[i+0]=vertex.x;vertexBuffer[i+1]=vertex.y;vertexBuffer[i+2]=vertex.z;}}function generateUVs(){var vertex=new Vector3();for(var i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0];vertex.y=vertexBuffer[i+1];vertex.z=vertexBuffer[i+2];var u=azimuth(vertex)/2/Math.PI+0.5;var v=inclination(vertex)/Math.PI+0.5;uvBuffer.push(u,1-v);}correctUVs();correctSeam();}function correctSeam(){// handle case when face straddles the seam, see #3269
for(var i=0;i<uvBuffer.length;i+=6){// uv data of a single face
var x0=uvBuffer[i+0];var x1=uvBuffer[i+2];var x2=uvBuffer[i+4];var max=Math.max(x0,x1,x2);var min=Math.min(x0,x1,x2);// 0.9 is somewhat arbitrary
if(max>0.9&&min<0.1){if(x0<0.2)uvBuffer[i+0]+=1;if(x1<0.2)uvBuffer[i+2]+=1;if(x2<0.2)uvBuffer[i+4]+=1;}}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z);}function getVertexByIndex(index,vertex){var stride=index*3;vertex.x=vertices[stride+0];vertex.y=vertices[stride+1];vertex.z=vertices[stride+2];}function correctUVs(){var a=new Vector3();var b=new Vector3();var c=new Vector3();var centroid=new Vector3();var uvA=new Vector2();var uvB=new Vector2();var uvC=new Vector2();for(var i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(a).add(b).add(c).divideScalar(3);var azi=azimuth(centroid);correctUV(uvA,j+0,a,azi);correctUV(uvB,j+2,b,azi);correctUV(uvC,j+4,c,azi);}}function correctUV(uv,stride,vector,azimuth){if(azimuth<0&&uv.x===1){uvBuffer[stride]=uv.x-1;}if(vector.x===0&&vector.z===0){uvBuffer[stride]=azimuth/2/Math.PI+0.5;}}// Angle around the Y axis, counter-clockwise when looking from above.
function azimuth(vector){return Math.atan2(vector.z,-vector.x);}// Angle above the XZ plane.
function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z));}}PolyhedronBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);PolyhedronBufferGeometry.prototype.constructor=PolyhedronBufferGeometry;/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // TetrahedronGeometry
function TetrahedronGeometry(radius,detail){Geometry.call(this);this.type='TetrahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new TetrahedronBufferGeometry(radius,detail));this.mergeVertices();}TetrahedronGeometry.prototype=(0,_create.default)(Geometry.prototype);TetrahedronGeometry.prototype.constructor=TetrahedronGeometry;// TetrahedronBufferGeometry
function TetrahedronBufferGeometry(radius,detail){var vertices=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1];var indices=[2,1,0,0,3,2,1,3,0,2,3,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='TetrahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}TetrahedronBufferGeometry.prototype=(0,_create.default)(PolyhedronBufferGeometry.prototype);TetrahedronBufferGeometry.prototype.constructor=TetrahedronBufferGeometry;/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // OctahedronGeometry
function OctahedronGeometry(radius,detail){Geometry.call(this);this.type='OctahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new OctahedronBufferGeometry(radius,detail));this.mergeVertices();}OctahedronGeometry.prototype=(0,_create.default)(Geometry.prototype);OctahedronGeometry.prototype.constructor=OctahedronGeometry;// OctahedronBufferGeometry
function OctahedronBufferGeometry(radius,detail){var vertices=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1];var indices=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='OctahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}OctahedronBufferGeometry.prototype=(0,_create.default)(PolyhedronBufferGeometry.prototype);OctahedronBufferGeometry.prototype.constructor=OctahedronBufferGeometry;/**
 * @author timothypratley / https://github.com/timothypratley
 * @author Mugen87 / https://github.com/Mugen87
 */ // IcosahedronGeometry
function IcosahedronGeometry(radius,detail){Geometry.call(this);this.type='IcosahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new IcosahedronBufferGeometry(radius,detail));this.mergeVertices();}IcosahedronGeometry.prototype=(0,_create.default)(Geometry.prototype);IcosahedronGeometry.prototype.constructor=IcosahedronGeometry;// IcosahedronBufferGeometry
function IcosahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var vertices=[-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1];var indices=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='IcosahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}IcosahedronBufferGeometry.prototype=(0,_create.default)(PolyhedronBufferGeometry.prototype);IcosahedronBufferGeometry.prototype.constructor=IcosahedronBufferGeometry;/**
 * @author Abe Pazos / https://hamoid.com
 * @author Mugen87 / https://github.com/Mugen87
 */ // DodecahedronGeometry
function DodecahedronGeometry(radius,detail){Geometry.call(this);this.type='DodecahedronGeometry';this.parameters={radius:radius,detail:detail};this.fromBufferGeometry(new DodecahedronBufferGeometry(radius,detail));this.mergeVertices();}DodecahedronGeometry.prototype=(0,_create.default)(Geometry.prototype);DodecahedronGeometry.prototype.constructor=DodecahedronGeometry;// DodecahedronBufferGeometry
function DodecahedronBufferGeometry(radius,detail){var t=(1+Math.sqrt(5))/2;var r=1/t;var vertices=[// (±1, ±1, ±1)
-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,// (0, ±1/φ, ±φ)
0,-r,-t,0,-r,t,0,r,-t,0,r,t,// (±1/φ, ±φ, 0)
-r,-t,0,-r,t,0,r,-t,0,r,t,0,// (±φ, 0, ±1/φ)
-t,0,-r,t,0,-r,-t,0,r,t,0,r];var indices=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];PolyhedronBufferGeometry.call(this,vertices,indices,radius,detail);this.type='DodecahedronBufferGeometry';this.parameters={radius:radius,detail:detail};}DodecahedronBufferGeometry.prototype=(0,_create.default)(PolyhedronBufferGeometry.prototype);DodecahedronBufferGeometry.prototype.constructor=DodecahedronBufferGeometry;/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 * @author Mugen87 / https://github.com/Mugen87
 *
 */ // TubeGeometry
function TubeGeometry(path,tubularSegments,radius,radialSegments,closed,taper){Geometry.call(this);this.type='TubeGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};if(taper!==undefined)console.warn('THREE.TubeGeometry: taper has been removed.');var bufferGeometry=new TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed);// expose internals
this.tangents=bufferGeometry.tangents;this.normals=bufferGeometry.normals;this.binormals=bufferGeometry.binormals;// create geometry
this.fromBufferGeometry(bufferGeometry);this.mergeVertices();}TubeGeometry.prototype=(0,_create.default)(Geometry.prototype);TubeGeometry.prototype.constructor=TubeGeometry;// TubeBufferGeometry
function TubeBufferGeometry(path,tubularSegments,radius,radialSegments,closed){BufferGeometry.call(this);this.type='TubeBufferGeometry';this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};tubularSegments=tubularSegments||64;radius=radius||1;radialSegments=radialSegments||8;closed=closed||false;var frames=path.computeFrenetFrames(tubularSegments,closed);// expose internals
this.tangents=frames.tangents;this.normals=frames.normals;this.binormals=frames.binormals;// helper variables
var vertex=new Vector3();var normal=new Vector3();var uv=new Vector2();var P=new Vector3();var i,j;// buffer
var vertices=[];var normals=[];var uvs=[];var indices=[];// create buffer data
generateBufferData();// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// functions
function generateBufferData(){for(i=0;i<tubularSegments;i++){generateSegment(i);}// if the geometry is not closed, generate the last row of vertices and normals
// at the regular position on the given path
//
// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
generateSegment(closed===false?tubularSegments:0);// uvs are generated in a separate function.
// this makes it easy compute correct values for closed geometries
generateUVs();// finally create faces
generateIndices();}function generateSegment(i){// we use getPointAt to sample evenly distributed points from the given path
P=path.getPointAt(i/tubularSegments,P);// retrieve corresponding normal and binormal
var N=frames.normals[i];var B=frames.binormals[i];// generate normals and vertices for the current segment
for(j=0;j<=radialSegments;j++){var v=j/radialSegments*Math.PI*2;var sin=Math.sin(v);var cos=-Math.cos(v);// normal
normal.x=cos*N.x+sin*B.x;normal.y=cos*N.y+sin*B.y;normal.z=cos*N.z+sin*B.z;normal.normalize();normals.push(normal.x,normal.y,normal.z);// vertex
vertex.x=P.x+radius*normal.x;vertex.y=P.y+radius*normal.y;vertex.z=P.z+radius*normal.z;vertices.push(vertex.x,vertex.y,vertex.z);}}function generateIndices(){for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}}function generateUVs(){for(i=0;i<=tubularSegments;i++){for(j=0;j<=radialSegments;j++){uv.x=i/tubularSegments;uv.y=j/radialSegments;uvs.push(uv.x,uv.y);}}}}TubeBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);TubeBufferGeometry.prototype.constructor=TubeBufferGeometry;TubeBufferGeometry.prototype.toJSON=function(){var data=BufferGeometry.prototype.toJSON.call(this);data.path=this.parameters.path.toJSON();return data;};/**
 * @author oosmoxiecode
 * @author Mugen87 / https://github.com/Mugen87
 *
 * based on http://www.blackpawn.com/texts/pqtorus/
 */ // TorusKnotGeometry
function TorusKnotGeometry(radius,tube,tubularSegments,radialSegments,p,q,heightScale){Geometry.call(this);this.type='TorusKnotGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};if(heightScale!==undefined)console.warn('THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.');this.fromBufferGeometry(new TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q));this.mergeVertices();}TorusKnotGeometry.prototype=(0,_create.default)(Geometry.prototype);TorusKnotGeometry.prototype.constructor=TorusKnotGeometry;// TorusKnotBufferGeometry
function TorusKnotBufferGeometry(radius,tube,tubularSegments,radialSegments,p,q){BufferGeometry.call(this);this.type='TorusKnotBufferGeometry';this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q};radius=radius||1;tube=tube||0.4;tubularSegments=Math.floor(tubularSegments)||64;radialSegments=Math.floor(radialSegments)||8;p=p||2;q=q||3;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var i,j;var vertex=new Vector3();var normal=new Vector3();var P1=new Vector3();var P2=new Vector3();var B=new Vector3();var T=new Vector3();var N=new Vector3();// generate vertices, normals and uvs
for(i=0;i<=tubularSegments;++i){// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
var u=i/tubularSegments*p*Math.PI*2;// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
calculatePositionOnCurve(u,p,q,radius,P1);calculatePositionOnCurve(u+0.01,p,q,radius,P2);// calculate orthonormal basis
T.subVectors(P2,P1);N.addVectors(P2,P1);B.crossVectors(T,N);N.crossVectors(B,T);// normalize B, N. T can be ignored, we don't use it
B.normalize();N.normalize();for(j=0;j<=radialSegments;++j){// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
var v=j/radialSegments*Math.PI*2;var cx=-tube*Math.cos(v);var cy=tube*Math.sin(v);// now calculate the final vertex position.
// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
vertex.x=P1.x+(cx*N.x+cy*B.x);vertex.y=P1.y+(cx*N.y+cy*B.y);vertex.z=P1.z+(cx*N.z+cy*B.z);vertices.push(vertex.x,vertex.y,vertex.z);// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
normal.subVectors(vertex,P1).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(i/tubularSegments);uvs.push(j/radialSegments);}}// generate indices
for(j=1;j<=tubularSegments;j++){for(i=1;i<=radialSegments;i++){// indices
var a=(radialSegments+1)*(j-1)+(i-1);var b=(radialSegments+1)*j+(i-1);var c=(radialSegments+1)*j+i;var d=(radialSegments+1)*(j-1)+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// this function calculates the current position on the torus curve
function calculatePositionOnCurve(u,p,q,radius,position){var cu=Math.cos(u);var su=Math.sin(u);var quOverP=q/p*u;var cs=Math.cos(quOverP);position.x=radius*(2+cs)*0.5*cu;position.y=radius*(2+cs)*su*0.5;position.z=radius*Math.sin(quOverP)*0.5;}}TorusKnotBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);TorusKnotBufferGeometry.prototype.constructor=TorusKnotBufferGeometry;/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // TorusGeometry
function TorusGeometry(radius,tube,radialSegments,tubularSegments,arc){Geometry.call(this);this.type='TorusGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};this.fromBufferGeometry(new TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc));this.mergeVertices();}TorusGeometry.prototype=(0,_create.default)(Geometry.prototype);TorusGeometry.prototype.constructor=TorusGeometry;// TorusBufferGeometry
function TorusBufferGeometry(radius,tube,radialSegments,tubularSegments,arc){BufferGeometry.call(this);this.type='TorusBufferGeometry';this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc};radius=radius||1;tube=tube||0.4;radialSegments=Math.floor(radialSegments)||8;tubularSegments=Math.floor(tubularSegments)||6;arc=arc||Math.PI*2;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var center=new Vector3();var vertex=new Vector3();var normal=new Vector3();var j,i;// generate vertices, normals and uvs
for(j=0;j<=radialSegments;j++){for(i=0;i<=tubularSegments;i++){var u=i/tubularSegments*arc;var v=j/radialSegments*Math.PI*2;// vertex
vertex.x=(radius+tube*Math.cos(v))*Math.cos(u);vertex.y=(radius+tube*Math.cos(v))*Math.sin(u);vertex.z=tube*Math.sin(v);vertices.push(vertex.x,vertex.y,vertex.z);// normal
center.x=radius*Math.cos(u);center.y=radius*Math.sin(u);normal.subVectors(vertex,center).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(i/tubularSegments);uvs.push(j/radialSegments);}}// generate indices
for(j=1;j<=radialSegments;j++){for(i=1;i<=tubularSegments;i++){// indices
var a=(tubularSegments+1)*j+i-1;var b=(tubularSegments+1)*(j-1)+i-1;var c=(tubularSegments+1)*(j-1)+i;var d=(tubularSegments+1)*j+i;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}TorusBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);TorusBufferGeometry.prototype.constructor=TorusBufferGeometry;/**
 * @author Mugen87 / https://github.com/Mugen87
 * Port from https://github.com/mapbox/earcut (v2.1.5)
 */var Earcut={triangulate:function triangulate(data,holeIndices,dim){dim=dim||2;var hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length,outerNode=linkedList(data,0,outerLen,dim,true),triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;var minX,minY,maxX,maxY,x,y,invSize;if(hasHoles)outerNode=eliminateHoles(data,holeIndices,outerNode,dim);// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
if(data.length>80*dim){minX=maxX=data[0];minY=maxY=data[1];for(var i=dim;i<outerLen;i+=dim){x=data[i];y=data[i+1];if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}// minX, minY and invSize are later used to transform coords into integers for z-order calculation
invSize=Math.max(maxX-minX,maxY-minY);invSize=invSize!==0?1/invSize:0;}earcutLinked(outerNode,triangles,dim,minX,minY,invSize);return triangles;}};// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data,start,end,dim,clockwise){var i,last;if(clockwise===signedArea(data,start,end,dim)>0){for(i=start;i<end;i+=dim){last=insertNode(i,data[i],data[i+1],last);}}else{for(i=end-dim;i>=start;i-=dim){last=insertNode(i,data[i],data[i+1],last);}}if(last&&equals(last,last.next)){removeNode(last);last=last.next;}return last;}// eliminate colinear or duplicate points
function filterPoints(start,end){if(!start)return start;if(!end)end=start;var p=start,again;do{again=false;if(!p.steiner&&(equals(p,p.next)||area(p.prev,p,p.next)===0)){removeNode(p);p=end=p.prev;if(p===p.next)break;again=true;}else{p=p.next;}}while(again||p!==end);return end;}// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;// interlink polygon nodes in z-order
if(!pass&&invSize)indexCurve(ear,minX,minY,invSize);var stop=ear,prev,next;// iterate through ears, slicing them one by one
while(ear.prev!==ear.next){prev=ear.prev;next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear)){// cut off the triangle
triangles.push(prev.i/dim);triangles.push(ear.i/dim);triangles.push(next.i/dim);removeNode(ear);// skipping the next vertex leads to less sliver triangles
ear=next.next;stop=next.next;continue;}ear=next;// if we looped through the whole remaining polygon and can't find any more ears
if(ear===stop){// try filtering points and slicing again
if(!pass){earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);// if this didn't work, try curing all small self-intersections locally
}else if(pass===1){ear=cureLocalIntersections(ear,triangles,dim);earcutLinked(ear,triangles,dim,minX,minY,invSize,2);// as a last resort, try splitting the remaining polygon into two
}else if(pass===2){splitEarcut(ear,triangles,dim,minX,minY,invSize);}break;}}}// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// now make sure we don't have other points inside the potential ear
var p=ear.next.next;while(p!==ear.prev){if(pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.next;}return true;}function isEarHashed(ear,minX,minY,invSize){var a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return false;// reflex, can't be an ear
// triangle bbox; min & max are calculated like this for speed
var minTX=a.x<b.x?a.x<c.x?a.x:c.x:b.x<c.x?b.x:c.x,minTY=a.y<b.y?a.y<c.y?a.y:c.y:b.y<c.y?b.y:c.y,maxTX=a.x>b.x?a.x>c.x?a.x:c.x:b.x>c.x?b.x:c.x,maxTY=a.y>b.y?a.y>c.y?a.y:c.y:b.y>c.y?b.y:c.y;// z-order range for the current triangle bbox;
var minZ=zOrder(minTX,minTY,minX,minY,invSize),maxZ=zOrder(maxTX,maxTY,minX,minY,invSize);var p=ear.prevZ,n=ear.nextZ;// look for points inside the triangle in both directions
while(p&&p.z>=minZ&&n&&n.z<=maxZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}// look for remaining points in decreasing z-order
while(p&&p.z>=minZ){if(p!==ear.prev&&p!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,p.x,p.y)&&area(p.prev,p,p.next)>=0)return false;p=p.prevZ;}// look for remaining points in increasing z-order
while(n&&n.z<=maxZ){if(n!==ear.prev&&n!==ear.next&&pointInTriangle(a.x,a.y,b.x,b.y,c.x,c.y,n.x,n.y)&&area(n.prev,n,n.next)>=0)return false;n=n.nextZ;}return true;}// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start,triangles,dim){var p=start;do{var a=p.prev,b=p.next.next;if(!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)){triangles.push(a.i/dim);triangles.push(p.i/dim);triangles.push(b.i/dim);// remove two nodes involved
removeNode(p);removeNode(p.next);p=start=b;}p=p.next;}while(p!==start);return p;}// try splitting polygon into two and triangulate them independently
function splitEarcut(start,triangles,dim,minX,minY,invSize){// look for a valid diagonal that divides the polygon into two
var a=start;do{var b=a.next.next;while(b!==a.prev){if(a.i!==b.i&&isValidDiagonal(a,b)){// split the polygon in two by the diagonal
var c=splitPolygon(a,b);// filter colinear points around the cuts
a=filterPoints(a,a.next);c=filterPoints(c,c.next);// run earcut on each half
earcutLinked(a,triangles,dim,minX,minY,invSize);earcutLinked(c,triangles,dim,minX,minY,invSize);return;}b=b.next;}a=a.next;}while(a!==start);}// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data,holeIndices,outerNode,dim){var queue=[],i,len,start,end,list;for(i=0,len=holeIndices.length;i<len;i++){start=holeIndices[i]*dim;end=i<len-1?holeIndices[i+1]*dim:data.length;list=linkedList(data,start,end,dim,false);if(list===list.next)list.steiner=true;queue.push(getLeftmost(list));}queue.sort(compareX);// process holes from left to right
for(i=0;i<queue.length;i++){eliminateHole(queue[i],outerNode);outerNode=filterPoints(outerNode,outerNode.next);}return outerNode;}function compareX(a,b){return a.x-b.x;}// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole,outerNode){outerNode=findHoleBridge(hole,outerNode);if(outerNode){var b=splitPolygon(outerNode,hole);filterPoints(b,b.next);}}// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole,outerNode){var p=outerNode,hx=hole.x,hy=hole.y,qx=-Infinity,m;// find a segment intersected by a ray from the hole's leftmost point to the left;
// segment's endpoint with lesser x will be potential connection point
do{if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){var x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx){qx=x;if(x===hx){if(hy===p.y)return p;if(hy===p.next.y)return p.next;}m=p.x<p.next.x?p:p.next;}}p=p.next;}while(p!==outerNode);if(!m)return null;if(hx===qx)return m.prev;// hole touches outer segment; pick lower endpoint
// look for points inside the triangle of hole point, segment intersection and endpoint;
// if there are no points found, we have a valid connection;
// otherwise choose the point of the minimum angle with the ray as connection point
var stop=m,mx=m.x,my=m.y,tanMin=Infinity,tan;p=m.next;while(p!==stop){if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){tan=Math.abs(hy-p.y)/(hx-p.x);// tangential
if((tan<tanMin||tan===tanMin&&p.x>m.x)&&locallyInside(p,hole)){m=p;tanMin=tan;}}p=p.next;}return m;}// interlink polygon nodes in z-order
function indexCurve(start,minX,minY,invSize){var p=start;do{if(p.z===null)p.z=zOrder(p.x,p.y,minX,minY,invSize);p.prevZ=p.prev;p.nextZ=p.next;p=p.next;}while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;sortLinked(p);}// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list){var i,p,q,e,tail,numMerges,pSize,qSize,inSize=1;do{p=list;list=null;tail=null;numMerges=0;while(p){numMerges++;q=p;pSize=0;for(i=0;i<inSize;i++){pSize++;q=q.nextZ;if(!q)break;}qSize=inSize;while(pSize>0||qSize>0&&q){if(pSize!==0&&(qSize===0||!q||p.z<=q.z)){e=p;p=p.nextZ;pSize--;}else{e=q;q=q.nextZ;qSize--;}if(tail)tail.nextZ=e;else list=e;e.prevZ=tail;tail=e;}p=q;}tail.nextZ=null;inSize*=2;}while(numMerges>1);return list;}// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x,y,minX,minY,invSize){// coords are transformed into non-negative 15-bit integer range
x=32767*(x-minX)*invSize;y=32767*(y-minY)*invSize;x=(x|x<<8)&0x00FF00FF;x=(x|x<<4)&0x0F0F0F0F;x=(x|x<<2)&0x33333333;x=(x|x<<1)&0x55555555;y=(y|y<<8)&0x00FF00FF;y=(y|y<<4)&0x0F0F0F0F;y=(y|y<<2)&0x33333333;y=(y|y<<1)&0x55555555;return x|y<<1;}// find the leftmost node of a polygon ring
function getLeftmost(start){var p=start,leftmost=start;do{if(p.x<leftmost.x||p.x===leftmost.x&&p.y<leftmost.y)leftmost=p;p=p.next;}while(p!==start);return leftmost;}// check if a point lies within a convex triangle
function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)-(ax-px)*(cy-py)>=0&&(ax-px)*(by-py)-(bx-px)*(ay-py)>=0&&(bx-px)*(cy-py)-(cx-px)*(by-py)>=0;}// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!intersectsPolygon(a,b)&&locallyInside(a,b)&&locallyInside(b,a)&&middleInside(a,b);}// signed area of a triangle
function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y);}// check if two points are equal
function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y;}// check if two segments intersect
function intersects(p1,q1,p2,q2){if(equals(p1,p2)&&equals(q1,q2)||equals(p1,q2)&&equals(p2,q1))return true;return area(p1,q1,p2)>0!==area(p1,q1,q2)>0&&area(p2,q2,p1)>0!==area(p2,q2,q1)>0;}// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a,b){var p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return true;p=p.next;}while(p!==a);return false;}// check if a polygon diagonal is locally inside the polygon
function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0;}// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a,b){var p=a,inside=false,px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{if(p.y>py!==p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x)inside=!inside;p=p.next;}while(p!==a);return inside;}// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a,b){var a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2;}// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i,x,y,last){var p=new Node(i,x,y);if(!last){p.prev=p;p.next=p;}else{p.next=last.next;p.prev=last;last.next.prev=p;last.next=p;}return p;}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;if(p.prevZ)p.prevZ.nextZ=p.nextZ;if(p.nextZ)p.nextZ.prevZ=p.prevZ;}function Node(i,x,y){// vertex index in coordinates array
this.i=i;// vertex coordinates
this.x=x;this.y=y;// previous and next vertex nodes in a polygon ring
this.prev=null;this.next=null;// z-order curve value
this.z=null;// previous and next nodes in z-order
this.prevZ=null;this.nextZ=null;// indicates whether this is a steiner point
this.steiner=false;}function signedArea(data,start,end,dim){var sum=0;for(var i=start,j=end-dim;i<end;i+=dim){sum+=(data[j]-data[i])*(data[i+1]+data[j+1]);j=i;}return sum;}/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */var ShapeUtils={// calculate area of the contour polygon
area:function area(contour){var n=contour.length;var a=0.0;for(var p=n-1,q=0;q<n;p=q++){a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;}return a*0.5;},isClockWise:function isClockWise(pts){return ShapeUtils.area(pts)<0;},triangulateShape:function triangulateShape(contour,holes){var vertices=[];// flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
var holeIndices=[];// array of hole indices
var faces=[];// final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
removeDupEndPts(contour);addContour(vertices,contour);//
var holeIndex=contour.length;holes.forEach(removeDupEndPts);for(var i=0;i<holes.length;i++){holeIndices.push(holeIndex);holeIndex+=holes[i].length;addContour(vertices,holes[i]);}//
var triangles=Earcut.triangulate(vertices,holeIndices);//
for(var i=0;i<triangles.length;i+=3){faces.push(triangles.slice(i,i+3));}return faces;}};exports.ShapeUtils=ShapeUtils;function removeDupEndPts(points){var l=points.length;if(l>2&&points[l-1].equals(points[0])){points.pop();}}function addContour(vertices,contour){for(var i=0;i<contour.length;i++){vertices.push(contour[i].x);vertices.push(contour[i].y);}}/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */ // ExtrudeGeometry
function ExtrudeGeometry(shapes,options){Geometry.call(this);this.type='ExtrudeGeometry';this.parameters={shapes:shapes,options:options};this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes,options));this.mergeVertices();}ExtrudeGeometry.prototype=(0,_create.default)(Geometry.prototype);ExtrudeGeometry.prototype.constructor=ExtrudeGeometry;ExtrudeGeometry.prototype.toJSON=function(){var data=Geometry.prototype.toJSON.call(this);var shapes=this.parameters.shapes;var options=this.parameters.options;return toJSON(shapes,options,data);};// ExtrudeBufferGeometry
function ExtrudeBufferGeometry(shapes,options){BufferGeometry.call(this);this.type='ExtrudeBufferGeometry';this.parameters={shapes:shapes,options:options};shapes=(0,_isArray.default)(shapes)?shapes:[shapes];var scope=this;var verticesArray=[];var uvArray=[];for(var i=0,l=shapes.length;i<l;i++){var shape=shapes[i];addShape(shape);}// build geometry
this.setAttribute('position',new Float32BufferAttribute(verticesArray,3));this.setAttribute('uv',new Float32BufferAttribute(uvArray,2));this.computeVertexNormals();// functions
function addShape(shape){var placeholder=[];// options
var curveSegments=options.curveSegments!==undefined?options.curveSegments:12;var steps=options.steps!==undefined?options.steps:1;var depth=options.depth!==undefined?options.depth:100;var bevelEnabled=options.bevelEnabled!==undefined?options.bevelEnabled:true;var bevelThickness=options.bevelThickness!==undefined?options.bevelThickness:6;var bevelSize=options.bevelSize!==undefined?options.bevelSize:bevelThickness-2;var bevelOffset=options.bevelOffset!==undefined?options.bevelOffset:0;var bevelSegments=options.bevelSegments!==undefined?options.bevelSegments:3;var extrudePath=options.extrudePath;var uvgen=options.UVGenerator!==undefined?options.UVGenerator:WorldUVGenerator;// deprecated options
if(options.amount!==undefined){console.warn('THREE.ExtrudeBufferGeometry: amount has been renamed to depth.');depth=options.amount;}//
var extrudePts,extrudeByPath=false;var splineTube,binormal,normal,position2;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=true;bevelEnabled=false;// bevels not supported for path extrusion
// SETUP TNB variables
// TODO1 - have a .isClosed in spline?
splineTube=extrudePath.computeFrenetFrames(steps,false);// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
binormal=new Vector3();normal=new Vector3();position2=new Vector3();}// Safeguards if bevels are not enabled
if(!bevelEnabled){bevelSegments=0;bevelThickness=0;bevelSize=0;bevelOffset=0;}// Variables initialization
var ahole,h,hl;// looping of holes
var shapePoints=shape.extractPoints(curveSegments);var vertices=shapePoints.shape;var holes=shapePoints.holes;var reverse=!ShapeUtils.isClockWise(vertices);if(reverse){vertices=vertices.reverse();// Maybe we should also check if holes are in the opposite direction, just to be safe ...
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];if(ShapeUtils.isClockWise(ahole)){holes[h]=ahole.reverse();}}}var faces=ShapeUtils.triangulateShape(vertices,holes);/* Vertices */var contour=vertices;// vertices has all points but contour has only points of circumference
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];vertices=vertices.concat(ahole);}function scalePt2(pt,vec,size){if(!vec)console.error("THREE.ExtrudeGeometry: vec does not exist");return vec.clone().multiplyScalar(size).add(pt);}var b,bs,t,z,vert,vlen=vertices.length,face,flen=faces.length;// Find directions for point movement
function getBevelVec(inPt,inPrev,inNext){// computes for inPt the corresponding point inPt' on a new contour
//   shifted by 1 unit (length of normalized vector) to the left
// if we walk along contour clockwise, this new contour is outside the old one
//
// inPt' is the intersection of the two lines parallel to the two
//  adjacent edges of inPt at a distance of 1 unit on the left side.
var v_trans_x,v_trans_y,shrink_by;// resulting translation vector for inPt
// good reading for geometry algorithms (here: line-line intersection)
// http://geomalgorithms.com/a05-_intersect-1.html
var v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y;var v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y;var v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y;// check for collinear edges
var collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>_epsilon.default){// not collinear
// length of vectors for normalizing
var v_prev_len=Math.sqrt(v_prev_lensq);var v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y);// shift adjacent points by unit vectors to the left
var ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len;var ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len;var ptNextShift_x=inNext.x-v_next_y/v_next_len;var ptNextShift_y=inNext.y+v_next_x/v_next_len;// scaling factor for v_prev to intersection point
var sf=((ptNextShift_x-ptPrevShift_x)*v_next_y-(ptNextShift_y-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);// vector from inPt to intersection point
v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x;v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;// Don't normalize!, otherwise sharp corners become ugly
//  but prevent crazy spikes
var v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2){return new Vector2(v_trans_x,v_trans_y);}else{shrink_by=Math.sqrt(v_trans_lensq/2);}}else{// handle special case of collinear edges
var direction_eq=false;// assumes: opposite
if(v_prev_x>_epsilon.default){if(v_next_x>_epsilon.default){direction_eq=true;}}else{if(v_prev_x<-_epsilon.default){if(v_next_x<-_epsilon.default){direction_eq=true;}}else{if(Math.sign(v_prev_y)===Math.sign(v_next_y)){direction_eq=true;}}}if(direction_eq){// console.log("Warning: lines are a straight sequence");
v_trans_x=-v_prev_y;v_trans_y=v_prev_x;shrink_by=Math.sqrt(v_prev_lensq);}else{// console.log("Warning: lines are a straight spike");
v_trans_x=v_prev_x;v_trans_y=v_prev_y;shrink_by=Math.sqrt(v_prev_lensq/2);}}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by);}var contourMovements=[];for(var i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
// console.log('i,j,k', i, j , k)
contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);}var holesMovements=[],oneHoleMovements,verticesMovements=contourMovements.concat();for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=[];for(i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++){if(j===il)j=0;if(k===il)k=0;//  (j)---(i)---(k)
oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);}holesMovements.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements);}// Loop bevelSegments, 1 for the front, 1 for the back
for(b=0;b<bevelSegments;b++){//for ( b = bevelSegments; b > 0; b -- ) {
t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;// contract shape
for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,-z);}// expand holes
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z);}}}bs=bevelSize+bevelOffset;// Back facing vertices
for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,0);}else{// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);position2.copy(extrudePts[0]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}// Add stepped vertices...
// Including front facing vertices
var s;for(s=1;s<=steps;s++){for(i=0;i<vlen;i++){vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];if(!extrudeByPath){v(vert.x,vert.y,depth/steps*s);}else{// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);position2.copy(extrudePts[s]).add(normal).add(binormal);v(position2.x,position2.y,position2.z);}}}// Add bevel segments planes
//for ( b = 1; b <= bevelSegments; b ++ ) {
for(b=bevelSegments-1;b>=0;b--){t=b/bevelSegments;z=bevelThickness*Math.cos(t*Math.PI/2);bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;// contract shape
for(i=0,il=contour.length;i<il;i++){vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,depth+z);}// expand holes
for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];oneHoleMovements=holesMovements[h];for(i=0,il=ahole.length;i<il;i++){vert=scalePt2(ahole[i],oneHoleMovements[i],bs);if(!extrudeByPath){v(vert.x,vert.y,depth+z);}else{v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z);}}}}/* Faces */ // Top and bottom faces
buildLidFaces();// Sides faces
buildSideFaces();/////  Internal functions
function buildLidFaces(){var start=verticesArray.length/3;if(bevelEnabled){var layer=0;// steps + 1
var offset=vlen*layer;// Bottom faces
for(i=0;i<flen;i++){face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset);}layer=steps+bevelSegments*2;offset=vlen*layer;// Top faces
for(i=0;i<flen;i++){face=faces[i];f3(face[0]+offset,face[1]+offset,face[2]+offset);}}else{// Bottom faces
for(i=0;i<flen;i++){face=faces[i];f3(face[2],face[1],face[0]);}// Top faces
for(i=0;i<flen;i++){face=faces[i];f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps);}}scope.addGroup(start,verticesArray.length/3-start,0);}// Create faces for the z-sides of the shape
function buildSideFaces(){var start=verticesArray.length/3;var layeroffset=0;sidewalls(contour,layeroffset);layeroffset+=contour.length;for(h=0,hl=holes.length;h<hl;h++){ahole=holes[h];sidewalls(ahole,layeroffset);//, true
layeroffset+=ahole.length;}scope.addGroup(start,verticesArray.length/3-start,1);}function sidewalls(contour,layeroffset){var j,k;i=contour.length;while(--i>=0){j=i;k=i-1;if(k<0)k=contour.length-1;//console.log('b', i,j, i-1, k,vertices.length);
var s=0,sl=steps+bevelSegments*2;for(s=0;s<sl;s++){var slen1=vlen*s;var slen2=vlen*(s+1);var a=layeroffset+j+slen1,b=layeroffset+k+slen1,c=layeroffset+k+slen2,d=layeroffset+j+slen2;f4(a,b,c,d);}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z);}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[2]);}function f4(a,b,c,d){addVertex(a);addVertex(b);addVertex(d);addVertex(b);addVertex(c);addVertex(d);var nextIndex=verticesArray.length/3;var uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]);addUV(uvs[1]);addUV(uvs[3]);addUV(uvs[1]);addUV(uvs[2]);addUV(uvs[3]);}function addVertex(index){verticesArray.push(placeholder[index*3+0]);verticesArray.push(placeholder[index*3+1]);verticesArray.push(placeholder[index*3+2]);}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y);}}}ExtrudeBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);ExtrudeBufferGeometry.prototype.constructor=ExtrudeBufferGeometry;ExtrudeBufferGeometry.prototype.toJSON=function(){var data=BufferGeometry.prototype.toJSON.call(this);var shapes=this.parameters.shapes;var options=this.parameters.options;return toJSON(shapes,options,data);};//
var WorldUVGenerator={generateTopUV:function generateTopUV(geometry,vertices,indexA,indexB,indexC){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];return[new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)];},generateSideWallUV:function generateSideWallUV(geometry,vertices,indexA,indexB,indexC,indexD){var a_x=vertices[indexA*3];var a_y=vertices[indexA*3+1];var a_z=vertices[indexA*3+2];var b_x=vertices[indexB*3];var b_y=vertices[indexB*3+1];var b_z=vertices[indexB*3+2];var c_x=vertices[indexC*3];var c_y=vertices[indexC*3+1];var c_z=vertices[indexC*3+2];var d_x=vertices[indexD*3];var d_y=vertices[indexD*3+1];var d_z=vertices[indexD*3+2];if(Math.abs(a_y-b_y)<0.01){return[new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)];}else{return[new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)];}}};function toJSON(shapes,options,data){//
data.shapes=[];if((0,_isArray.default)(shapes)){for(var i=0,l=shapes.length;i<l;i++){var shape=shapes[i];data.shapes.push(shape.uuid);}}else{data.shapes.push(shapes.uuid);}//
if(options.extrudePath!==undefined)data.options.extrudePath=options.extrudePath.toJSON();return data;}/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */ // TextGeometry
function TextGeometry(text,parameters){Geometry.call(this);this.type='TextGeometry';this.parameters={text:text,parameters:parameters};this.fromBufferGeometry(new TextBufferGeometry(text,parameters));this.mergeVertices();}TextGeometry.prototype=(0,_create.default)(Geometry.prototype);TextGeometry.prototype.constructor=TextGeometry;// TextBufferGeometry
function TextBufferGeometry(text,parameters){parameters=parameters||{};var font=parameters.font;if(!(font&&font.isFont)){console.error('THREE.TextGeometry: font parameter is not an instance of THREE.Font.');return new Geometry();}var shapes=font.generateShapes(text,parameters.size);// translate parameters to ExtrudeGeometry API
parameters.depth=parameters.height!==undefined?parameters.height:50;// defaults
if(parameters.bevelThickness===undefined)parameters.bevelThickness=10;if(parameters.bevelSize===undefined)parameters.bevelSize=8;if(parameters.bevelEnabled===undefined)parameters.bevelEnabled=false;ExtrudeBufferGeometry.call(this,shapes,parameters);this.type='TextBufferGeometry';}TextBufferGeometry.prototype=(0,_create.default)(ExtrudeBufferGeometry.prototype);TextBufferGeometry.prototype.constructor=TextBufferGeometry;/**
 * @author mrdoob / http://mrdoob.com/
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 */ // SphereGeometry
function SphereGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){Geometry.call(this);this.type='SphereGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength));this.mergeVertices();}SphereGeometry.prototype=(0,_create.default)(Geometry.prototype);SphereGeometry.prototype.constructor=SphereGeometry;// SphereBufferGeometry
function SphereBufferGeometry(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){BufferGeometry.call(this);this.type='SphereBufferGeometry';this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||1;widthSegments=Math.max(3,Math.floor(widthSegments)||8);heightSegments=Math.max(2,Math.floor(heightSegments)||6);phiStart=phiStart!==undefined?phiStart:0;phiLength=phiLength!==undefined?phiLength:Math.PI*2;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI;var thetaEnd=Math.min(thetaStart+thetaLength,Math.PI);var ix,iy;var index=0;var grid=[];var vertex=new Vector3();var normal=new Vector3();// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// generate vertices, normals and uvs
for(iy=0;iy<=heightSegments;iy++){var verticesRow=[];var v=iy/heightSegments;// special case for the poles
var uOffset=0;if(iy==0&&thetaStart==0){uOffset=0.5/widthSegments;}else if(iy==heightSegments&&thetaEnd==Math.PI){uOffset=-0.5/widthSegments;}for(ix=0;ix<=widthSegments;ix++){var u=ix/widthSegments;// vertex
vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normal.copy(vertex).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u+uOffset,1-v);verticesRow.push(index++);}grid.push(verticesRow);}// indices
for(iy=0;iy<heightSegments;iy++){for(ix=0;ix<widthSegments;ix++){var a=grid[iy][ix+1];var b=grid[iy][ix];var c=grid[iy+1][ix];var d=grid[iy+1][ix+1];if(iy!==0||thetaStart>0)indices.push(a,b,d);if(iy!==heightSegments-1||thetaEnd<Math.PI)indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}SphereBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);SphereBufferGeometry.prototype.constructor=SphereBufferGeometry;/**
 * @author Kaleb Murphy
 * @author Mugen87 / https://github.com/Mugen87
 */ // RingGeometry
function RingGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){Geometry.call(this);this.type='RingGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength));this.mergeVertices();}RingGeometry.prototype=(0,_create.default)(Geometry.prototype);RingGeometry.prototype.constructor=RingGeometry;// RingBufferGeometry
function RingBufferGeometry(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='RingBufferGeometry';this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength};innerRadius=innerRadius||0.5;outerRadius=outerRadius||1;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;thetaSegments=thetaSegments!==undefined?Math.max(3,thetaSegments):8;phiSegments=phiSegments!==undefined?Math.max(1,phiSegments):1;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// some helper variables
var segment;var radius=innerRadius;var radiusStep=(outerRadius-innerRadius)/phiSegments;var vertex=new Vector3();var uv=new Vector2();var j,i;// generate vertices, normals and uvs
for(j=0;j<=phiSegments;j++){for(i=0;i<=thetaSegments;i++){// values are generate from the inside of the ring to the outside
segment=thetaStart+i/thetaSegments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,0,1);// uv
uv.x=(vertex.x/outerRadius+1)/2;uv.y=(vertex.y/outerRadius+1)/2;uvs.push(uv.x,uv.y);}// increase the radius for next row of vertices
radius+=radiusStep;}// indices
for(j=0;j<phiSegments;j++){var thetaSegmentLevel=j*(thetaSegments+1);for(i=0;i<thetaSegments;i++){segment=i+thetaSegmentLevel;var a=segment;var b=segment+thetaSegments+1;var c=segment+thetaSegments+2;var d=segment+1;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}RingBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);RingBufferGeometry.prototype.constructor=RingBufferGeometry;/**
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 * @author Mugen87 / https://github.com/Mugen87
 */ // LatheGeometry
function LatheGeometry(points,segments,phiStart,phiLength){Geometry.call(this);this.type='LatheGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};this.fromBufferGeometry(new LatheBufferGeometry(points,segments,phiStart,phiLength));this.mergeVertices();}LatheGeometry.prototype=(0,_create.default)(Geometry.prototype);LatheGeometry.prototype.constructor=LatheGeometry;// LatheBufferGeometry
function LatheBufferGeometry(points,segments,phiStart,phiLength){BufferGeometry.call(this);this.type='LatheBufferGeometry';this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength};segments=Math.floor(segments)||12;phiStart=phiStart||0;phiLength=phiLength||Math.PI*2;// clamp phiLength so it's in range of [ 0, 2PI ]
phiLength=MathUtils.clamp(phiLength,0,Math.PI*2);// buffers
var indices=[];var vertices=[];var uvs=[];// helper variables
var base;var inverseSegments=1.0/segments;var vertex=new Vector3();var uv=new Vector2();var i,j;// generate vertices and uvs
for(i=0;i<=segments;i++){var phi=phiStart+i*inverseSegments*phiLength;var sin=Math.sin(phi);var cos=Math.cos(phi);for(j=0;j<=points.length-1;j++){// vertex
vertex.x=points[j].x*sin;vertex.y=points[j].y;vertex.z=points[j].x*cos;vertices.push(vertex.x,vertex.y,vertex.z);// uv
uv.x=i/segments;uv.y=j/(points.length-1);uvs.push(uv.x,uv.y);}}// indices
for(i=0;i<segments;i++){for(j=0;j<points.length-1;j++){base=j+i*points.length;var a=base;var b=base+points.length;var c=base+points.length+1;var d=base+1;// faces
indices.push(a,b,d);indices.push(b,c,d);}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// generate normals
this.computeVertexNormals();// if the geometry is closed, we need to average the normals along the seam.
// because the corresponding vertices are identical (but still have different UVs).
if(phiLength===Math.PI*2){var normals=this.attributes.normal.array;var n1=new Vector3();var n2=new Vector3();var n=new Vector3();// this is the buffer offset for the last line of vertices
base=segments*points.length*3;for(i=0,j=0;i<points.length;i++,j+=3){// select the normal of the vertex in the first line
n1.x=normals[j+0];n1.y=normals[j+1];n1.z=normals[j+2];// select the normal of the vertex in the last line
n2.x=normals[base+j+0];n2.y=normals[base+j+1];n2.z=normals[base+j+2];// average normals
n.addVectors(n1,n2).normalize();// assign the new values to both normals
normals[j+0]=normals[base+j+0]=n.x;normals[j+1]=normals[base+j+1]=n.y;normals[j+2]=normals[base+j+2]=n.z;}}}LatheBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);LatheBufferGeometry.prototype.constructor=LatheBufferGeometry;/**
 * @author jonobr1 / http://jonobr1.com
 * @author Mugen87 / https://github.com/Mugen87
 */ // ShapeGeometry
function ShapeGeometry(shapes,curveSegments){Geometry.call(this);this.type='ShapeGeometry';if((0,_typeof2.default)(curveSegments)==='object'){console.warn('THREE.ShapeGeometry: Options parameter has been removed.');curveSegments=curveSegments.curveSegments;}this.parameters={shapes:shapes,curveSegments:curveSegments};this.fromBufferGeometry(new ShapeBufferGeometry(shapes,curveSegments));this.mergeVertices();}ShapeGeometry.prototype=(0,_create.default)(Geometry.prototype);ShapeGeometry.prototype.constructor=ShapeGeometry;ShapeGeometry.prototype.toJSON=function(){var data=Geometry.prototype.toJSON.call(this);var shapes=this.parameters.shapes;return toJSON$1(shapes,data);};// ShapeBufferGeometry
function ShapeBufferGeometry(shapes,curveSegments){BufferGeometry.call(this);this.type='ShapeBufferGeometry';this.parameters={shapes:shapes,curveSegments:curveSegments};curveSegments=curveSegments||12;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var groupStart=0;var groupCount=0;// allow single and array values for "shapes" parameter
if((0,_isArray.default)(shapes)===false){addShape(shapes);}else{for(var i=0;i<shapes.length;i++){addShape(shapes[i]);this.addGroup(groupStart,groupCount,i);// enables MultiMaterial support
groupStart+=groupCount;groupCount=0;}}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));// helper functions
function addShape(shape){var i,l,shapeHole;var indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);var shapeVertices=points.shape;var shapeHoles=points.holes;// check direction of vertices
if(ShapeUtils.isClockWise(shapeVertices)===false){shapeVertices=shapeVertices.reverse();}for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];if(ShapeUtils.isClockWise(shapeHole)===true){shapeHoles[i]=shapeHole.reverse();}}var faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);// join vertices of inner and outer paths to a single array
for(i=0,l=shapeHoles.length;i<l;i++){shapeHole=shapeHoles[i];shapeVertices=shapeVertices.concat(shapeHole);}// vertices, normals, uvs
for(i=0,l=shapeVertices.length;i<l;i++){var vertex=shapeVertices[i];vertices.push(vertex.x,vertex.y,0);normals.push(0,0,1);uvs.push(vertex.x,vertex.y);// world uvs
}// incides
for(i=0,l=faces.length;i<l;i++){var face=faces[i];var a=face[0]+indexOffset;var b=face[1]+indexOffset;var c=face[2]+indexOffset;indices.push(a,b,c);groupCount+=3;}}}ShapeBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);ShapeBufferGeometry.prototype.constructor=ShapeBufferGeometry;ShapeBufferGeometry.prototype.toJSON=function(){var data=BufferGeometry.prototype.toJSON.call(this);var shapes=this.parameters.shapes;return toJSON$1(shapes,data);};//
function toJSON$1(shapes,data){data.shapes=[];if((0,_isArray.default)(shapes)){for(var i=0,l=shapes.length;i<l;i++){var shape=shapes[i];data.shapes.push(shape.uuid);}}else{data.shapes.push(shapes.uuid);}return data;}/**
 * @author WestLangley / http://github.com/WestLangley
 * @author Mugen87 / https://github.com/Mugen87
 */function EdgesGeometry(geometry,thresholdAngle){BufferGeometry.call(this);this.type='EdgesGeometry';this.parameters={thresholdAngle:thresholdAngle};thresholdAngle=thresholdAngle!==undefined?thresholdAngle:1;// buffer
var vertices=[];// helper variables
var thresholdDot=Math.cos(MathUtils.DEG2RAD*thresholdAngle);var edge=[0,0],edges={},edge1,edge2;var key,keys=['a','b','c'];// prepare source geometry
var geometry2;if(geometry.isBufferGeometry){geometry2=new Geometry();geometry2.fromBufferGeometry(geometry);}else{geometry2=geometry.clone();}geometry2.mergeVertices();geometry2.computeFaceNormals();var sourceVertices=geometry2.vertices;var faces=geometry2.faces;// now create a data structure where each entry represents an edge with its adjoining faces
for(var i=0,l=faces.length;i<l;i++){var face=faces[i];for(var j=0;j<3;j++){edge1=face[keys[j]];edge2=face[keys[(j+1)%3]];edge[0]=Math.min(edge1,edge2);edge[1]=Math.max(edge1,edge2);key=edge[0]+','+edge[1];if(edges[key]===undefined){edges[key]={index1:edge[0],index2:edge[1],face1:i,face2:undefined};}else{edges[key].face2=i;}}}// generate vertices
for(key in edges){var e=edges[key];// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
if(e.face2===undefined||faces[e.face1].normal.dot(faces[e.face2].normal)<=thresholdDot){var vertex=sourceVertices[e.index1];vertices.push(vertex.x,vertex.y,vertex.z);vertex=sourceVertices[e.index2];vertices.push(vertex.x,vertex.y,vertex.z);}}// build geometry
this.setAttribute('position',new Float32BufferAttribute(vertices,3));}EdgesGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);EdgesGeometry.prototype.constructor=EdgesGeometry;/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */ // CylinderGeometry
function CylinderGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){Geometry.call(this);this.type='CylinderGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength));this.mergeVertices();}CylinderGeometry.prototype=(0,_create.default)(Geometry.prototype);CylinderGeometry.prototype.constructor=CylinderGeometry;// CylinderBufferGeometry
function CylinderBufferGeometry(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CylinderBufferGeometry';this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};var scope=this;radiusTop=radiusTop!==undefined?radiusTop:1;radiusBottom=radiusBottom!==undefined?radiusBottom:1;height=height||1;radialSegments=Math.floor(radialSegments)||8;heightSegments=Math.floor(heightSegments)||1;openEnded=openEnded!==undefined?openEnded:false;thetaStart=thetaStart!==undefined?thetaStart:0.0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var index=0;var indexArray=[];var halfHeight=height/2;var groupStart=0;// generate geometry
generateTorso();if(openEnded===false){if(radiusTop>0)generateCap(true);if(radiusBottom>0)generateCap(false);}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));function generateTorso(){var x,y;var normal=new Vector3();var vertex=new Vector3();var groupCount=0;// this will be used to calculate the normal
var slope=(radiusBottom-radiusTop)/height;// generate vertices, normals and uvs
for(y=0;y<=heightSegments;y++){var indexRow=[];var v=y/heightSegments;// calculate the radius of the current row
var radius=v*(radiusBottom-radiusTop)+radiusTop;for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var sinTheta=Math.sin(theta);var cosTheta=Math.cos(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=-v*height+halfHeight;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
normal.set(sinTheta,slope,cosTheta).normalize();normals.push(normal.x,normal.y,normal.z);// uv
uvs.push(u,1-v);// save index of vertex in respective row
indexRow.push(index++);}// now save vertices of the row in our index array
indexArray.push(indexRow);}// generate indices
for(x=0;x<radialSegments;x++){for(y=0;y<heightSegments;y++){// we use the index array to access the correct indices
var a=indexArray[y][x];var b=indexArray[y+1][x];var c=indexArray[y+1][x+1];var d=indexArray[y][x+1];// faces
indices.push(a,b,d);indices.push(b,c,d);// update group counter
groupCount+=6;}}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,0);// calculate new start value for groups
groupStart+=groupCount;}function generateCap(top){var x,centerIndexStart,centerIndexEnd;var uv=new Vector2();var vertex=new Vector3();var groupCount=0;var radius=top===true?radiusTop:radiusBottom;var sign=top===true?1:-1;// save the index of the first center vertex
centerIndexStart=index;// first we generate the center vertex data of the cap.
// because the geometry needs one set of uvs per face,
// we must generate a center vertex per face/segment
for(x=1;x<=radialSegments;x++){// vertex
vertices.push(0,halfHeight*sign,0);// normal
normals.push(0,sign,0);// uv
uvs.push(0.5,0.5);// increase index
index++;}// save the index of the last center vertex
centerIndexEnd=index;// now we generate the surrounding vertices, normals and uvs
for(x=0;x<=radialSegments;x++){var u=x/radialSegments;var theta=u*thetaLength+thetaStart;var cosTheta=Math.cos(theta);var sinTheta=Math.sin(theta);// vertex
vertex.x=radius*sinTheta;vertex.y=halfHeight*sign;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,sign,0);// uv
uv.x=cosTheta*0.5+0.5;uv.y=sinTheta*0.5*sign+0.5;uvs.push(uv.x,uv.y);// increase index
index++;}// generate indices
for(x=0;x<radialSegments;x++){var c=centerIndexStart+x;var i=centerIndexEnd+x;if(top===true){// face top
indices.push(i,i+1,c);}else{// face bottom
indices.push(i+1,i,c);}groupCount+=3;}// add a group to the geometry. this will ensure multi material support
scope.addGroup(groupStart,groupCount,top===true?1:2);// calculate new start value for groups
groupStart+=groupCount;}}CylinderBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);CylinderBufferGeometry.prototype.constructor=CylinderBufferGeometry;/**
 * @author abelnation / http://github.com/abelnation
 */ // ConeGeometry
function ConeGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeGeometry.prototype=(0,_create.default)(CylinderGeometry.prototype);ConeGeometry.prototype.constructor=ConeGeometry;// ConeBufferGeometry
function ConeBufferGeometry(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){CylinderBufferGeometry.call(this,0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type='ConeBufferGeometry';this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};}ConeBufferGeometry.prototype=(0,_create.default)(CylinderBufferGeometry.prototype);ConeBufferGeometry.prototype.constructor=ConeBufferGeometry;/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * @author Mugen87 / https://github.com/Mugen87
 * @author hughes
 */ // CircleGeometry
function CircleGeometry(radius,segments,thetaStart,thetaLength){Geometry.call(this);this.type='CircleGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};this.fromBufferGeometry(new CircleBufferGeometry(radius,segments,thetaStart,thetaLength));this.mergeVertices();}CircleGeometry.prototype=(0,_create.default)(Geometry.prototype);CircleGeometry.prototype.constructor=CircleGeometry;// CircleBufferGeometry
function CircleBufferGeometry(radius,segments,thetaStart,thetaLength){BufferGeometry.call(this);this.type='CircleBufferGeometry';this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength};radius=radius||1;segments=segments!==undefined?Math.max(3,segments):8;thetaStart=thetaStart!==undefined?thetaStart:0;thetaLength=thetaLength!==undefined?thetaLength:Math.PI*2;// buffers
var indices=[];var vertices=[];var normals=[];var uvs=[];// helper variables
var i,s;var vertex=new Vector3();var uv=new Vector2();// center point
vertices.push(0,0,0);normals.push(0,0,1);uvs.push(0.5,0.5);for(s=0,i=3;s<=segments;s++,i+=3){var segment=thetaStart+s/segments*thetaLength;// vertex
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);// normal
normals.push(0,0,1);// uvs
uv.x=(vertices[i]/radius+1)/2;uv.y=(vertices[i+1]/radius+1)/2;uvs.push(uv.x,uv.y);}// indices
for(i=1;i<=segments;i++){indices.push(i,i+1,0);}// build geometry
this.setIndex(indices);this.setAttribute('position',new Float32BufferAttribute(vertices,3));this.setAttribute('normal',new Float32BufferAttribute(normals,3));this.setAttribute('uv',new Float32BufferAttribute(uvs,2));}CircleBufferGeometry.prototype=(0,_create.default)(BufferGeometry.prototype);CircleBufferGeometry.prototype.constructor=CircleBufferGeometry;var Geometries=/*#__PURE__*/(0,_freeze.default)({__proto__:null,WireframeGeometry:WireframeGeometry,ParametricGeometry:ParametricGeometry,ParametricBufferGeometry:ParametricBufferGeometry,TetrahedronGeometry:TetrahedronGeometry,TetrahedronBufferGeometry:TetrahedronBufferGeometry,OctahedronGeometry:OctahedronGeometry,OctahedronBufferGeometry:OctahedronBufferGeometry,IcosahedronGeometry:IcosahedronGeometry,IcosahedronBufferGeometry:IcosahedronBufferGeometry,DodecahedronGeometry:DodecahedronGeometry,DodecahedronBufferGeometry:DodecahedronBufferGeometry,PolyhedronGeometry:PolyhedronGeometry,PolyhedronBufferGeometry:PolyhedronBufferGeometry,TubeGeometry:TubeGeometry,TubeBufferGeometry:TubeBufferGeometry,TorusKnotGeometry:TorusKnotGeometry,TorusKnotBufferGeometry:TorusKnotBufferGeometry,TorusGeometry:TorusGeometry,TorusBufferGeometry:TorusBufferGeometry,TextGeometry:TextGeometry,TextBufferGeometry:TextBufferGeometry,SphereGeometry:SphereGeometry,SphereBufferGeometry:SphereBufferGeometry,RingGeometry:RingGeometry,RingBufferGeometry:RingBufferGeometry,PlaneGeometry:PlaneGeometry,PlaneBufferGeometry:PlaneBufferGeometry,LatheGeometry:LatheGeometry,LatheBufferGeometry:LatheBufferGeometry,ShapeGeometry:ShapeGeometry,ShapeBufferGeometry:ShapeBufferGeometry,ExtrudeGeometry:ExtrudeGeometry,ExtrudeBufferGeometry:ExtrudeBufferGeometry,EdgesGeometry:EdgesGeometry,ConeGeometry:ConeGeometry,ConeBufferGeometry:ConeBufferGeometry,CylinderGeometry:CylinderGeometry,CylinderBufferGeometry:CylinderBufferGeometry,CircleGeometry:CircleGeometry,CircleBufferGeometry:CircleBufferGeometry,BoxGeometry:BoxGeometry,BoxBufferGeometry:BoxBufferGeometry});/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <THREE.Color>
 * }
 */function ShadowMaterial(parameters){Material.call(this);this.type='ShadowMaterial';this.color=new Color(0x000000);this.transparent=true;this.setValues(parameters);}ShadowMaterial.prototype=(0,_create.default)(Material.prototype);ShadowMaterial.prototype.constructor=ShadowMaterial;ShadowMaterial.prototype.isShadowMaterial=true;ShadowMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);return this;};/**
 * @author mrdoob / http://mrdoob.com/
 */function RawShaderMaterial(parameters){ShaderMaterial.call(this,parameters);this.type='RawShaderMaterial';}RawShaderMaterial.prototype=(0,_create.default)(ShaderMaterial.prototype);RawShaderMaterial.prototype.constructor=RawShaderMaterial;RawShaderMaterial.prototype.isRawShaderMaterial=true;/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshStandardMaterial(parameters){Material.call(this);this.defines={'STANDARD':''};this.type='MeshStandardMaterial';this.color=new Color(0xffffff);// diffuse
this.roughness=1.0;this.metalness=0.0;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.roughnessMap=null;this.metalnessMap=null;this.alphaMap=null;this.envMap=null;this.envMapIntensity=1.0;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.vertexTangents=false;this.setValues(parameters);}MeshStandardMaterial.prototype=(0,_create.default)(Material.prototype);MeshStandardMaterial.prototype.constructor=MeshStandardMaterial;MeshStandardMaterial.prototype.isMeshStandardMaterial=true;MeshStandardMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.defines={'STANDARD':''};this.color.copy(source.color);this.roughness=source.roughness;this.metalness=source.metalness;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.roughnessMap=source.roughnessMap;this.metalnessMap=source.metalnessMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;this.vertexTangents=source.vertexTangents;return this;};/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *
 *  sheen: <Color>,
 *
 *  transparency: <float>
 * }
 */function MeshPhysicalMaterial(parameters){MeshStandardMaterial.call(this);this.defines={'STANDARD':'','PHYSICAL':''};this.type='MeshPhysicalMaterial';this.clearcoat=0.0;this.clearcoatMap=null;this.clearcoatRoughness=0.0;this.clearcoatRoughnessMap=null;this.clearcoatNormalScale=new Vector2(1,1);this.clearcoatNormalMap=null;this.reflectivity=0.5;// maps to F0 = 0.04
this.sheen=null;// null will disable sheen bsdf
this.transparency=0.0;this.setValues(parameters);}MeshPhysicalMaterial.prototype=(0,_create.default)(MeshStandardMaterial.prototype);MeshPhysicalMaterial.prototype.constructor=MeshPhysicalMaterial;MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial=true;MeshPhysicalMaterial.prototype.copy=function(source){MeshStandardMaterial.prototype.copy.call(this,source);this.defines={'STANDARD':'','PHYSICAL':''};this.clearcoat=source.clearcoat;this.clearcoatMap=source.clearcoatMap;this.clearcoatRoughness=source.clearcoatRoughness;this.clearcoatRoughnessMap=source.clearcoatRoughnessMap;this.clearcoatNormalMap=source.clearcoatNormalMap;this.clearcoatNormalScale.copy(source.clearcoatNormalScale);this.reflectivity=source.reflectivity;if(source.sheen){this.sheen=(this.sheen||new Color()).copy(source.sheen);}else{this.sheen=null;}this.transparency=source.transparency;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshPhongMaterial(parameters){Material.call(this);this.type='MeshPhongMaterial';this.color=new Color(0xffffff);// diffuse
this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshPhongMaterial.prototype=(0,_create.default)(Material.prototype);MeshPhongMaterial.prototype.constructor=MeshPhongMaterial;MeshPhongMaterial.prototype.isMeshPhongMaterial=true;MeshPhongMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshToonMaterial(parameters){Material.call(this);this.defines={'TOON':''};this.type='MeshToonMaterial';this.color=new Color(0xffffff);this.specular=new Color(0x111111);this.shininess=30;this.map=null;this.gradientMap=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.specularMap=null;this.alphaMap=null;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshToonMaterial.prototype=(0,_create.default)(Material.prototype);MeshToonMaterial.prototype.constructor=MeshToonMaterial;MeshToonMaterial.prototype.isMeshToonMaterial=true;MeshToonMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.gradientMap=source.gradientMap;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshNormalMaterial(parameters){Material.call(this);this.type='MeshNormalMaterial';this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=false;this.wireframeLinewidth=1;this.fog=false;this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshNormalMaterial.prototype=(0,_create.default)(Material.prototype);MeshNormalMaterial.prototype.constructor=MeshNormalMaterial;MeshNormalMaterial.prototype.isMeshNormalMaterial=true;MeshNormalMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshLambertMaterial(parameters){Material.call(this);this.type='MeshLambertMaterial';this.color=new Color(0xffffff);// diffuse
this.map=null;this.lightMap=null;this.lightMapIntensity=1.0;this.aoMap=null;this.aoMapIntensity=1.0;this.emissive=new Color(0x000000);this.emissiveIntensity=1.0;this.emissiveMap=null;this.specularMap=null;this.alphaMap=null;this.envMap=null;this.combine=MultiplyOperation;this.reflectivity=1;this.refractionRatio=0.98;this.wireframe=false;this.wireframeLinewidth=1;this.wireframeLinecap='round';this.wireframeLinejoin='round';this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshLambertMaterial.prototype=(0,_create.default)(Material.prototype);MeshLambertMaterial.prototype.constructor=MeshLambertMaterial;MeshLambertMaterial.prototype.isMeshLambertMaterial=true;MeshLambertMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */function MeshMatcapMaterial(parameters){Material.call(this);this.defines={'MATCAP':''};this.type='MeshMatcapMaterial';this.color=new Color(0xffffff);// diffuse
this.matcap=null;this.map=null;this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=TangentSpaceNormalMap;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.skinning=false;this.morphTargets=false;this.morphNormals=false;this.setValues(parameters);}MeshMatcapMaterial.prototype=(0,_create.default)(Material.prototype);MeshMatcapMaterial.prototype.constructor=MeshMatcapMaterial;MeshMatcapMaterial.prototype.isMeshMatcapMaterial=true;MeshMatcapMaterial.prototype.copy=function(source){Material.prototype.copy.call(this,source);this.defines={'MATCAP':''};this.color.copy(source.color);this.matcap=source.matcap;this.map=source.map;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.alphaMap=source.alphaMap;this.skinning=source.skinning;this.morphTargets=source.morphTargets;this.morphNormals=source.morphNormals;return this;};/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */function LineDashedMaterial(parameters){LineBasicMaterial.call(this);this.type='LineDashedMaterial';this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(parameters);}LineDashedMaterial.prototype=(0,_create.default)(LineBasicMaterial.prototype);LineDashedMaterial.prototype.constructor=LineDashedMaterial;LineDashedMaterial.prototype.isLineDashedMaterial=true;LineDashedMaterial.prototype.copy=function(source){LineBasicMaterial.prototype.copy.call(this,source);this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this;};var Materials=/*#__PURE__*/(0,_freeze.default)({__proto__:null,ShadowMaterial:ShadowMaterial,SpriteMaterial:SpriteMaterial,RawShaderMaterial:RawShaderMaterial,ShaderMaterial:ShaderMaterial,PointsMaterial:PointsMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshToonMaterial:MeshToonMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshDistanceMaterial:MeshDistanceMaterial,MeshBasicMaterial:MeshBasicMaterial,MeshMatcapMaterial:MeshMatcapMaterial,LineDashedMaterial:LineDashedMaterial,LineBasicMaterial:LineBasicMaterial,Material:Material});/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */var AnimationUtils={// same as Array.prototype.slice, but also works on typed arrays
arraySlice:function arraySlice(array,from,to){if(AnimationUtils.isTypedArray(array)){// in ios9 array.subarray(from, undefined) will return empty array
// but array.subarray(from) or array.subarray(from, len) is correct
return new array.constructor(array.subarray(from,to!==undefined?to:array.length));}return array.slice(from,to);},// converts an array to a specific type
convertArray:function convertArray(array,type,forceClone){if(!array||// let 'undefined' and 'null' pass
!forceClone&&array.constructor===type)return array;if(typeof type.BYTES_PER_ELEMENT==='number'){return new type(array);// create typed array
}return Array.prototype.slice.call(array);// create Array
},isTypedArray:function isTypedArray(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView);},// returns an array by which times and values can be sorted
getKeyframeOrder:function getKeyframeOrder(times){function compareTime(i,j){return times[i]-times[j];}var n=times.length;var result=new Array(n);for(var i=0;i!==n;++i){result[i]=i;}result.sort(compareTime);return result;},// uses the array previously returned by 'getKeyframeOrder' to sort data
sortedArray:function sortedArray(values,stride,order){var nValues=values.length;var result=new values.constructor(nValues);for(var i=0,dstOffset=0;dstOffset!==nValues;++i){var srcOffset=order[i]*stride;for(var j=0;j!==stride;++j){result[dstOffset++]=values[srcOffset+j];}}return result;},// function for parsing AOS keyframe formats
flattenJSON:function flattenJSON(jsonKeys,times,values,valuePropertyName){var i=1,key=jsonKeys[0];while(key!==undefined&&key[valuePropertyName]===undefined){key=jsonKeys[i++];}if(key===undefined)return;// no data
var value=key[valuePropertyName];if(value===undefined)return;// no data
if((0,_isArray.default)(value)){do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push.apply(values,value);// push all elements
}key=jsonKeys[i++];}while(key!==undefined);}else if(value.toArray!==undefined){// ...assume THREE.Math-ish
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);value.toArray(values,values.length);}key=jsonKeys[i++];}while(key!==undefined);}else{// otherwise push as-is
do{value=key[valuePropertyName];if(value!==undefined){times.push(key.time);values.push(value);}key=jsonKeys[i++];}while(key!==undefined);}},subclip:function subclip(sourceClip,name,startFrame,endFrame,fps){fps=fps||30;var clip=sourceClip.clone();clip.name=name;var tracks=[];for(var i=0;i<clip.tracks.length;++i){var track=clip.tracks[i];var valueSize=track.getValueSize();var times=[];var values=[];for(var j=0;j<track.times.length;++j){var frame=track.times[j]*fps;if(frame<startFrame||frame>=endFrame)continue;times.push(track.times[j]);for(var k=0;k<valueSize;++k){values.push(track.values[j*valueSize+k]);}}if(times.length===0)continue;track.times=AnimationUtils.convertArray(times,track.times.constructor);track.values=AnimationUtils.convertArray(values,track.values.constructor);tracks.push(track);}clip.tracks=tracks;// find minimum .times value across all tracks in the trimmed clip
var minStartTime=Infinity;for(var i=0;i<clip.tracks.length;++i){if(minStartTime>clip.tracks[i].times[0]){minStartTime=clip.tracks[i].times[0];}}// shift all tracks such that clip begins at t=0
for(var i=0;i<clip.tracks.length;++i){clip.tracks[i].shift(-1*minStartTime);}clip.resetDuration();return clip;}};/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */exports.AnimationUtils=AnimationUtils;function Interpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=resultBuffer!==undefined?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;}(0,_assign.default)(Interpolant.prototype,{evaluate:function evaluate(t){var pp=this.parameterPositions,i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{var right;linear_scan:{//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
forward_scan:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(t1===undefined){if(t<t0)break forward_scan;// after end
i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t,t0);}if(i1===giveUpAt)break;// this loop
t0=t1;t1=pp[++i1];if(t<t1){// we have arrived at the sought interval
break seek;}}// prepare binary search on the right side of the index
right=pp.length;break linear_scan;}//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
if(!(t>=t0)){// looping?
var t1global=pp[1];if(t<t1global){i1=2;// + 1, using the scan for the details
t0=t1global;}// linear reverse scan
for(var giveUpAt=i1-2;;){if(t0===undefined){// before start
this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(i1===giveUpAt)break;// this loop
t1=t0;t0=pp[--i1-1];if(t>=t0){// we have arrived at the sought interval
break seek;}}// prepare binary search on the left side of the index
right=i1;i1=0;break linear_scan;}// the interval is valid
break validate_interval;}// linear scan
// binary search
while(i1<right){var mid=i1+right>>>1;if(t<pp[mid]){right=mid;}else{i1=mid+1;}}t1=pp[i1];t0=pp[i1-1];// check boundary cases, again
if(t0===undefined){this._cachedIndex=0;return this.beforeStart_(0,t,t1);}if(t1===undefined){i1=pp.length;this._cachedIndex=i1;return this.afterEnd_(i1-1,t0,t);}}// seek
this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1);}// validate_interval
return this.interpolate_(i1,t0,t,t1);},settings:null,// optional, subclass-specific settings structure
// Note: The indirection allows central control of many interpolants.
// --- Protected interface
DefaultSettings_:{},getSettings_:function getSettings_(){return this.settings||this.DefaultSettings_;},copySampleValue_:function copySampleValue_(index){// copies a sample value to the result buffer
var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(var i=0;i!==stride;++i){result[i]=values[offset+i];}return result;},// Template methods for derived classes:
interpolate_:function interpolate_()/* i1, t0, t, t1 */{throw new Error('call to abstract method');// implementations shall return this.resultBuffer
},intervalChanged_:function intervalChanged_()/* i1, t0, t1 */{// empty
}});// DECLARE ALIAS AFTER assign prototype
(0,_assign.default)(Interpolant.prototype,{//( 0, t, t0 ), returns this.resultBuffer
beforeStart_:Interpolant.prototype.copySampleValue_,//( N-1, tN-1, t ), returns this.resultBuffer
afterEnd_:Interpolant.prototype.copySampleValue_});/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */function CubicInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);this._weightPrev=-0;this._offsetPrev=-0;this._weightNext=-0;this._offsetNext=-0;}CubicInterpolant.prototype=(0,_assign.default)((0,_create.default)(Interpolant.prototype),{constructor:CubicInterpolant,DefaultSettings_:{endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding},intervalChanged_:function intervalChanged_(i1,t0,t1){var pp=this.parameterPositions,iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(tPrev===undefined){switch(this.getSettings_().endingStart){case ZeroSlopeEnding:// f'(t0) = 0
iPrev=i1;tPrev=2*t0-t1;break;case WrapAroundEnding:// use the other end of the curve
iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:// ZeroCurvatureEnding
// f''(t0) = 0 a.k.a. Natural Spline
iPrev=i1;tPrev=t1;}}if(tNext===undefined){switch(this.getSettings_().endingEnd){case ZeroSlopeEnding:// f'(tN) = 0
iNext=i1;tNext=2*t1-t0;break;case WrapAroundEnding:// use the other end of the curve
iNext=1;tNext=t1+pp[1]-pp[0];break;default:// ZeroCurvatureEnding
// f''(tN) = 0, a.k.a. Natural Spline
iNext=i1-1;tNext=t0;}}var halfDt=(t1-t0)*0.5,stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev);this._weightNext=halfDt/(tNext-t1);this._offsetPrev=iPrev*stride;this._offsetNext=iNext*stride;},interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p;// evaluate polynomials
var sP=-wP*ppp+2*wP*pp-wP*p;var s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-0.5+wP)*p+1;var s1=(-1-wN)*ppp+(1.5+wN)*pp+0.5*p;var sN=wN*ppp-wN*pp;// combine data linearly
for(var i=0;i!==stride;++i){result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];}return result;}});/**
 * @author tschw
 */function LinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}LinearInterpolant.prototype=(0,_assign.default)((0,_create.default)(Interpolant.prototype),{constructor:LinearInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(var i=0;i!==stride;++i){result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;}return result;}});/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */function DiscreteInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}DiscreteInterpolant.prototype=(0,_assign.default)((0,_create.default)(Interpolant.prototype),{constructor:DiscreteInterpolant,interpolate_:function interpolate_(i1/*, t0, t, t1 */){return this.copySampleValue_(i1-1);}});/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function KeyframeTrack(name,times,values,interpolation){if(name===undefined)throw new Error('THREE.KeyframeTrack: track name is undefined');if(times===undefined||times.length===0)throw new Error('THREE.KeyframeTrack: no keyframes in track named '+name);this.name=name;this.times=AnimationUtils.convertArray(times,this.TimeBufferType);this.values=AnimationUtils.convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation);}// Static methods
(0,_assign.default)(KeyframeTrack,{// Serialization (in static context, because of constructor invocation
// and automatic invocation of .toJSON):
toJSON:function toJSON(track){var trackType=track.constructor;var json;// derived classes can define a static toJSON method
if(trackType.toJSON!==undefined){json=trackType.toJSON(track);}else{// by default, we assume the data can be serialized as-is
json={'name':track.name,'times':AnimationUtils.convertArray(track.times,Array),'values':AnimationUtils.convertArray(track.values,Array)};var interpolation=track.getInterpolation();if(interpolation!==track.DefaultInterpolation){json.interpolation=interpolation;}}json.type=track.ValueTypeName;// mandatory
return json;}});(0,_assign.default)(KeyframeTrack.prototype,{constructor:KeyframeTrack,TimeBufferType:Float32Array,ValueBufferType:Float32Array,DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodDiscrete:function InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:function InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result);},setInterpolation:function setInterpolation(interpolation){var factoryMethod;switch(interpolation){case InterpolateDiscrete:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case InterpolateLinear:factoryMethod=this.InterpolantFactoryMethodLinear;break;case InterpolateSmooth:factoryMethod=this.InterpolantFactoryMethodSmooth;break;}if(factoryMethod===undefined){var message="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===undefined){// fall back to default, unless the default itself is messed up
if(interpolation!==this.DefaultInterpolation){this.setInterpolation(this.DefaultInterpolation);}else{throw new Error(message);// fatal, in this case
}}console.warn('THREE.KeyframeTrack:',message);return this;}this.createInterpolant=factoryMethod;return this;},getInterpolation:function getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return InterpolateDiscrete;case this.InterpolantFactoryMethodLinear:return InterpolateLinear;case this.InterpolantFactoryMethodSmooth:return InterpolateSmooth;}},getValueSize:function getValueSize(){return this.values.length/this.times.length;},// move all keyframes either forwards or backwards in time
shift:function shift(timeOffset){if(timeOffset!==0.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]+=timeOffset;}}return this;},// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
scale:function scale(timeScale){if(timeScale!==1.0){var times=this.times;for(var i=0,n=times.length;i!==n;++i){times[i]*=timeScale;}}return this;},// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
trim:function trim(startTime,endTime){var times=this.times,nKeys=times.length,from=0,to=nKeys-1;while(from!==nKeys&&times[from]<startTime){++from;}while(to!==-1&&times[to]>endTime){--to;}++to;// inclusive -> exclusive bound
if(from!==0||to!==nKeys){// empty tracks are forbidden, so keep at least one keyframe
if(from>=to){to=Math.max(to,1);from=to-1;}var stride=this.getValueSize();this.times=AnimationUtils.arraySlice(times,from,to);this.values=AnimationUtils.arraySlice(this.values,from*stride,to*stride);}return this;},// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
validate:function validate(){var valid=true;var valueSize=this.getValueSize();if(valueSize-Math.floor(valueSize)!==0){console.error('THREE.KeyframeTrack: Invalid value size in track.',this);valid=false;}var times=this.times,values=this.values,nKeys=times.length;if(nKeys===0){console.error('THREE.KeyframeTrack: Track is empty.',this);valid=false;}var prevTime=null;for(var i=0;i!==nKeys;i++){var currTime=times[i];if(typeof currTime==='number'&&isNaN(currTime)){console.error('THREE.KeyframeTrack: Time is not a valid number.',this,i,currTime);valid=false;break;}if(prevTime!==null&&prevTime>currTime){console.error('THREE.KeyframeTrack: Out of order keys.',this,i,currTime,prevTime);valid=false;break;}prevTime=currTime;}if(values!==undefined){if(AnimationUtils.isTypedArray(values)){for(var i=0,n=values.length;i!==n;++i){var value=values[i];if(isNaN(value)){console.error('THREE.KeyframeTrack: Value is not a valid number.',this,i,value);valid=false;break;}}}}return valid;},// removes equivalent sequential keys as common in morph target sequences
// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
optimize:function optimize(){// times or values may be shared with other tracks, so overwriting is unsafe
var times=AnimationUtils.arraySlice(this.times),values=AnimationUtils.arraySlice(this.values),stride=this.getValueSize(),smoothInterpolation=this.getInterpolation()===InterpolateSmooth,writeIndex=1,lastIndex=times.length-1;for(var i=1;i<lastIndex;++i){var keep=false;var time=times[i];var timeNext=times[i+1];// remove adjacent keyframes scheduled at the same time
if(time!==timeNext&&(i!==1||time!==time[0])){if(!smoothInterpolation){// remove unnecessary keyframes same as their neighbors
var offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(var j=0;j!==stride;++j){var value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=true;break;}}}else{keep=true;}}// in-place compaction
if(keep){if(i!==writeIndex){times[writeIndex]=times[i];var readOffset=i*stride,writeOffset=writeIndex*stride;for(var j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}}++writeIndex;}}// flush last keyframe (compaction looks ahead)
if(lastIndex>0){times[writeIndex]=times[lastIndex];for(var readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j){values[writeOffset+j]=values[readOffset+j];}++writeIndex;}if(writeIndex!==times.length){this.times=AnimationUtils.arraySlice(times,0,writeIndex);this.values=AnimationUtils.arraySlice(values,0,writeIndex*stride);}else{this.times=times;this.values=values;}return this;},clone:function clone(){var times=AnimationUtils.arraySlice(this.times,0);var values=AnimationUtils.arraySlice(this.values,0);var TypedKeyframeTrack=this.constructor;var track=new TypedKeyframeTrack(this.name,times,values);// Interpolant argument to constructor is not saved, so copy the factory method directly.
track.createInterpolant=this.createInterpolant;return track;}});/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function BooleanKeyframeTrack(name,times,values){KeyframeTrack.call(this,name,times,values);}BooleanKeyframeTrack.prototype=(0,_assign.default)((0,_create.default)(KeyframeTrack.prototype),{constructor:BooleanKeyframeTrack,ValueTypeName:'bool',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined// Note: Actually this track could have a optimized / compressed
// representation of a single value and a custom interpolant that
// computes "firstValue ^ isOdd( index )".
});/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function ColorKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}ColorKeyframeTrack.prototype=(0,_assign.default)((0,_create.default)(KeyframeTrack.prototype),{constructor:ColorKeyframeTrack,ValueTypeName:'color'// ValueBufferType is inherited
// DefaultInterpolation is inherited
// Note: Very basic implementation and nothing special yet.
// However, this is the place for color space parameterization.
});/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function NumberKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}NumberKeyframeTrack.prototype=(0,_assign.default)((0,_create.default)(KeyframeTrack.prototype),{constructor:NumberKeyframeTrack,ValueTypeName:'number'// ValueBufferType is inherited
// DefaultInterpolation is inherited
});/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */function QuaternionLinearInterpolant(parameterPositions,sampleValues,sampleSize,resultBuffer){Interpolant.call(this,parameterPositions,sampleValues,sampleSize,resultBuffer);}QuaternionLinearInterpolant.prototype=(0,_assign.default)((0,_create.default)(Interpolant.prototype),{constructor:QuaternionLinearInterpolant,interpolate_:function interpolate_(i1,t0,t,t1){var result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=i1*stride,alpha=(t-t0)/(t1-t0);for(var end=offset+stride;offset!==end;offset+=4){Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);}return result;}});/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function QuaternionKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}QuaternionKeyframeTrack.prototype=(0,_assign.default)((0,_create.default)(KeyframeTrack.prototype),{constructor:QuaternionKeyframeTrack,ValueTypeName:'quaternion',// ValueBufferType is inherited
DefaultInterpolation:InterpolateLinear,InterpolantFactoryMethodLinear:function InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result);},InterpolantFactoryMethodSmooth:undefined// not yet implemented
});/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function StringKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}StringKeyframeTrack.prototype=(0,_assign.default)((0,_create.default)(KeyframeTrack.prototype),{constructor:StringKeyframeTrack,ValueTypeName:'string',ValueBufferType:Array,DefaultInterpolation:InterpolateDiscrete,InterpolantFactoryMethodLinear:undefined,InterpolantFactoryMethodSmooth:undefined});/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function VectorKeyframeTrack(name,times,values,interpolation){KeyframeTrack.call(this,name,times,values,interpolation);}VectorKeyframeTrack.prototype=(0,_assign.default)((0,_create.default)(KeyframeTrack.prototype),{constructor:VectorKeyframeTrack,ValueTypeName:'vector'// ValueBufferType is inherited
// DefaultInterpolation is inherited
});/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */function AnimationClip(name,duration,tracks){this.name=name;this.tracks=tracks;this.duration=duration!==undefined?duration:-1;this.uuid=MathUtils.generateUUID();// this means it should figure out its duration by scanning the tracks
if(this.duration<0){this.resetDuration();}}function getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case'scalar':case'double':case'float':case'number':case'integer':return NumberKeyframeTrack;case'vector':case'vector2':case'vector3':case'vector4':return VectorKeyframeTrack;case'color':return ColorKeyframeTrack;case'quaternion':return QuaternionKeyframeTrack;case'bool':case'boolean':return BooleanKeyframeTrack;case'string':return StringKeyframeTrack;}throw new Error('THREE.KeyframeTrack: Unsupported typeName: '+typeName);}function parseKeyframeTrack(json){if(json.type===undefined){throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');}var trackType=getTrackTypeForValueTypeName(json.type);if(json.times===undefined){var times=[],values=[];AnimationUtils.flattenJSON(json.keys,times,values,'value');json.times=times;json.values=values;}// derived classes can define a static parse method
if(trackType.parse!==undefined){return trackType.parse(json);}else{// by default, we assume a constructor compatible with the base
return new trackType(json.name,json.times,json.values,json.interpolation);}}(0,_assign.default)(AnimationClip,{parse:function parse(json){var tracks=[],jsonTracks=json.tracks,frameTime=1.0/(json.fps||1.0);for(var i=0,n=jsonTracks.length;i!==n;++i){tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));}return new AnimationClip(json.name,json.duration,tracks);},toJSON:function toJSON(clip){var tracks=[],clipTracks=clip.tracks;var json={'name':clip.name,'duration':clip.duration,'tracks':tracks,'uuid':clip.uuid};for(var i=0,n=clipTracks.length;i!==n;++i){tracks.push(KeyframeTrack.toJSON(clipTracks[i]));}return json;},CreateFromMorphTargetSequence:function CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){var numMorphTargets=morphTargetSequence.length;var tracks=[];for(var i=0;i<numMorphTargets;i++){var times=[];var values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets);values.push(0,1,0);var order=AnimationUtils.getKeyframeOrder(times);times=AnimationUtils.sortedArray(times,1,order);values=AnimationUtils.sortedArray(values,1,order);// if there is a key at the first frame, duplicate it as the
// last frame as well for perfect loop.
if(!noLoop&&times[0]===0){times.push(numMorphTargets);values.push(values[0]);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluences['+morphTargetSequence[i].name+']',times,values).scale(1.0/fps));}return new AnimationClip(name,-1,tracks);},findByName:function findByName(objectOrClipArray,name){var clipArray=objectOrClipArray;if(!(0,_isArray.default)(objectOrClipArray)){var o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations;}for(var i=0;i<clipArray.length;i++){if(clipArray[i].name===name){return clipArray[i];}}return null;},CreateClipsFromMorphTargetSequences:function CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){var animationToMorphTargets={};// tested with https://regex101.com/ on trick sequences
// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
var pattern=/^([\w-]*?)([\d]+)$/;// sort morph target names into animation groups based
// patterns like Walk_001, Walk_002, Run_001, Run_002
for(var i=0,il=morphTargets.length;i<il;i++){var morphTarget=morphTargets[i];var parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){var name=parts[1];var animationMorphTargets=animationToMorphTargets[name];if(!animationMorphTargets){animationToMorphTargets[name]=animationMorphTargets=[];}animationMorphTargets.push(morphTarget);}}var clips=[];for(var name in animationToMorphTargets){clips.push(AnimationClip.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));}return clips;},// parse the animation.hierarchy format
parseAnimation:function parseAnimation(animation,bones){if(!animation){console.error('THREE.AnimationClip: No animation in JSONLoader data.');return null;}var addNonemptyTrack=function addNonemptyTrack(trackType,trackName,animationKeys,propertyName,destTracks){// only return track if there are actually keys.
if(animationKeys.length!==0){var times=[];var values=[];AnimationUtils.flattenJSON(animationKeys,times,values,propertyName);// empty keys are filtered out, so check again
if(times.length!==0){destTracks.push(new trackType(trackName,times,values));}}};var tracks=[];var clipName=animation.name||'default';// automatic length determination in AnimationClip.
var duration=animation.length||-1;var fps=animation.fps||30;var hierarchyTracks=animation.hierarchy||[];for(var h=0;h<hierarchyTracks.length;h++){var animationKeys=hierarchyTracks[h].keys;// skip empty tracks
if(!animationKeys||animationKeys.length===0)continue;// process morph targets
if(animationKeys[0].morphTargets){// figure out all morph targets used in this track
var morphTargetNames={};for(var k=0;k<animationKeys.length;k++){if(animationKeys[k].morphTargets){for(var m=0;m<animationKeys[k].morphTargets.length;m++){morphTargetNames[animationKeys[k].morphTargets[m]]=-1;}}}// create a track for each morph target with all zero
// morphTargetInfluences except for the keys in which
// the morphTarget is named.
for(var morphTargetName in morphTargetNames){var times=[];var values=[];for(var m=0;m!==animationKeys[k].morphTargets.length;++m){var animationKey=animationKeys[k];times.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0);}tracks.push(new NumberKeyframeTrack('.morphTargetInfluence['+morphTargetName+']',times,values));}duration=morphTargetNames.length*(fps||1.0);}else{// ...assume skeletal animation
var boneName='.bones['+bones[h].name+']';addNonemptyTrack(VectorKeyframeTrack,boneName+'.position',animationKeys,'pos',tracks);addNonemptyTrack(QuaternionKeyframeTrack,boneName+'.quaternion',animationKeys,'rot',tracks);addNonemptyTrack(VectorKeyframeTrack,boneName+'.scale',animationKeys,'scl',tracks);}}if(tracks.length===0){return null;}var clip=new AnimationClip(clipName,duration,tracks);return clip;}});(0,_assign.default)(AnimationClip.prototype,{resetDuration:function resetDuration(){var tracks=this.tracks,duration=0;for(var i=0,n=tracks.length;i!==n;++i){var track=this.tracks[i];duration=Math.max(duration,track.times[track.times.length-1]);}this.duration=duration;return this;},trim:function trim(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].trim(0,this.duration);}return this;},validate:function validate(){var valid=true;for(var i=0;i<this.tracks.length;i++){valid=valid&&this.tracks[i].validate();}return valid;},optimize:function optimize(){for(var i=0;i<this.tracks.length;i++){this.tracks[i].optimize();}return this;},clone:function clone(){var tracks=[];for(var i=0;i<this.tracks.length;i++){tracks.push(this.tracks[i].clone());}return new AnimationClip(this.name,this.duration,tracks);}});/**
 * @author mrdoob / http://mrdoob.com/
 */var Cache={enabled:false,files:{},add:function add(key,file){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Adding key:', key );
this.files[key]=file;},get:function get(key){if(this.enabled===false)return;// console.log( 'THREE.Cache', 'Checking key:', key );
return this.files[key];},remove:function remove(key){delete this.files[key];},clear:function clear(){this.files={};}};/**
 * @author mrdoob / http://mrdoob.com/
 */exports.Cache=Cache;function LoadingManager(onLoad,onProgress,onError){var scope=this;var isLoading=false;var itemsLoaded=0;var itemsTotal=0;var urlModifier=undefined;var handlers=[];// Refer to #5689 for the reason why we don't set .onStart
// in the constructor
this.onStart=undefined;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(isLoading===false){if(scope.onStart!==undefined){scope.onStart(url,itemsLoaded,itemsTotal);}}isLoading=true;};this.itemEnd=function(url){itemsLoaded++;if(scope.onProgress!==undefined){scope.onProgress(url,itemsLoaded,itemsTotal);}if(itemsLoaded===itemsTotal){isLoading=false;if(scope.onLoad!==undefined){scope.onLoad();}}};this.itemError=function(url){if(scope.onError!==undefined){scope.onError(url);}};this.resolveURL=function(url){if(urlModifier){return urlModifier(url);}return url;};this.setURLModifier=function(transform){urlModifier=transform;return this;};this.addHandler=function(regex,loader){handlers.push(regex,loader);return this;};this.removeHandler=function(regex){var index=handlers.indexOf(regex);if(index!==-1){handlers.splice(index,2);}return this;};this.getHandler=function(file){for(var i=0,l=handlers.length;i<l;i+=2){var regex=handlers[i];var loader=handlers[i+1];if(regex.global)regex.lastIndex=0;// see #17920
if(regex.test(file)){return loader;}}return null;};}var DefaultLoadingManager=new LoadingManager();/**
 * @author alteredq / http://alteredqualia.com/
 */exports.DefaultLoadingManager=DefaultLoadingManager;function Loader(manager){this.manager=manager!==undefined?manager:DefaultLoadingManager;this.crossOrigin='anonymous';this.path='';this.resourcePath='';}(0,_assign.default)(Loader.prototype,{load:function load()/* url, onLoad, onProgress, onError */{},parse:function parse()/* data */{},setCrossOrigin:function setCrossOrigin(crossOrigin){this.crossOrigin=crossOrigin;return this;},setPath:function setPath(path){this.path=path;return this;},setResourcePath:function setResourcePath(resourcePath){this.resourcePath=resourcePath;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */var loading={};function FileLoader(manager){Loader.call(this,manager);}FileLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:FileLoader,load:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}// Check if request is duplicate
if(loading[url]!==undefined){loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});return;}// Check for data: URI
var dataUriRegex=/^data:(.*?)(;base64)?,(.*)$/;var dataUriRegexResult=url.match(dataUriRegex);// Safari can not handle Data URIs through XMLHttpRequest so process manually
if(dataUriRegexResult){var mimeType=dataUriRegexResult[1];var isBase64=!!dataUriRegexResult[2];var data=dataUriRegexResult[3];data=decodeURIComponent(data);if(isBase64)data=atob(data);try{var response;var responseType=(this.responseType||'').toLowerCase();switch(responseType){case'arraybuffer':case'blob':var view=new Uint8Array(data.length);for(var i=0;i<data.length;i++){view[i]=data.charCodeAt(i);}if(responseType==='blob'){response=new Blob([view.buffer],{type:mimeType});}else{response=view.buffer;}break;case'document':var parser=new DOMParser();response=parser.parseFromString(data,mimeType);break;case'json':response=JSON.parse(data);break;default:// 'text' or other
response=data;break;}// Wait for next browser tick like standard XMLHttpRequest event dispatching does
setTimeout(function(){if(onLoad)onLoad(response);scope.manager.itemEnd(url);},0);}catch(error){// Wait for next browser tick like standard XMLHttpRequest event dispatching does
setTimeout(function(){if(onError)onError(error);scope.manager.itemError(url);scope.manager.itemEnd(url);},0);}}else{// Initialise array for duplicate requests
loading[url]=[];loading[url].push({onLoad:onLoad,onProgress:onProgress,onError:onError});var request=new XMLHttpRequest();request.open('GET',url,true);request.addEventListener('load',function(event){var response=this.response;var callbacks=loading[url];delete loading[url];if(this.status===200||this.status===0){// Some browsers return HTTP Status 0 when using non-http protocol
// e.g. 'file://' or 'data://'. Handle as success.
if(this.status===0)console.warn('THREE.FileLoader: HTTP Status 0 received.');// Add to cache only on HTTP success, so that we do not cache
// error response bodies as proper responses to requests.
Cache.add(url,response);for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onLoad)callback.onLoad(response);}scope.manager.itemEnd(url);}else{for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);}},false);request.addEventListener('progress',function(event){var callbacks=loading[url];for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onProgress)callback.onProgress(event);}},false);request.addEventListener('error',function(event){var callbacks=loading[url];delete loading[url];for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);},false);request.addEventListener('abort',function(event){var callbacks=loading[url];delete loading[url];for(var i=0,il=callbacks.length;i<il;i++){var callback=callbacks[i];if(callback.onError)callback.onError(event);}scope.manager.itemError(url);scope.manager.itemEnd(url);},false);if(this.responseType!==undefined)request.responseType=this.responseType;if(this.withCredentials!==undefined)request.withCredentials=this.withCredentials;if(request.overrideMimeType)request.overrideMimeType(this.mimeType!==undefined?this.mimeType:'text/plain');for(var header in this.requestHeader){request.setRequestHeader(header,this.requestHeader[header]);}request.send(null);}scope.manager.itemStart(url);return request;},setResponseType:function setResponseType(value){this.responseType=value;return this;},setWithCredentials:function setWithCredentials(value){this.withCredentials=value;return this;},setMimeType:function setMimeType(value){this.mimeType=value;return this;},setRequestHeader:function setRequestHeader(value){this.requestHeader=value;return this;}});/**
 * @author bhouston / http://clara.io/
 */function AnimationLoader(manager){Loader.call(this,manager);}AnimationLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:AnimationLoader,load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.setPath(scope.path);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},parse:function parse(json){var animations=[];for(var i=0;i<json.length;i++){var clip=AnimationClip.parse(json[i]);animations.push(clip);}return animations;}});/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */function CompressedTextureLoader(manager){Loader.call(this,manager);}CompressedTextureLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:CompressedTextureLoader,load:function load(url,onLoad,onProgress,onError){var scope=this;var images=[];var texture=new CompressedTexture();texture.image=images;var loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType('arraybuffer');function loadTexture(i){loader.load(url[i],function(buffer){var texDatas=scope.parse(buffer,true);images[i]={width:texDatas.width,height:texDatas.height,format:texDatas.format,mipmaps:texDatas.mipmaps};loaded+=1;if(loaded===6){if(texDatas.mipmapCount===1)texture.minFilter=LinearFilter;texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);}},onProgress,onError);}if((0,_isArray.default)(url)){var loaded=0;for(var i=0,il=url.length;i<il;++i){loadTexture(i);}}else{// compressed cubemap texture stored in a single DDS file
loader.load(url,function(buffer){var texDatas=scope.parse(buffer,true);if(texDatas.isCubemap){var faces=texDatas.mipmaps.length/texDatas.mipmapCount;for(var f=0;f<faces;f++){images[f]={mipmaps:[]};for(var i=0;i<texDatas.mipmapCount;i++){images[f].mipmaps.push(texDatas.mipmaps[f*texDatas.mipmapCount+i]);images[f].format=texDatas.format;images[f].width=texDatas.width;images[f].height=texDatas.height;}}}else{texture.image.width=texDatas.width;texture.image.height=texDatas.height;texture.mipmaps=texDatas.mipmaps;}if(texDatas.mipmapCount===1){texture.minFilter=LinearFilter;}texture.format=texDatas.format;texture.needsUpdate=true;if(onLoad)onLoad(texture);},onProgress,onError);}return texture;}});/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */function DataTextureLoader(manager){Loader.call(this,manager);}DataTextureLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:DataTextureLoader,load:function load(url,onLoad,onProgress,onError){var scope=this;var texture=new DataTexture();var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.setPath(this.path);loader.load(url,function(buffer){var texData=scope.parse(buffer);if(!texData)return;if(texData.image!==undefined){texture.image=texData.image;}else if(texData.data!==undefined){texture.image.width=texData.width;texture.image.height=texData.height;texture.image.data=texData.data;}texture.wrapS=texData.wrapS!==undefined?texData.wrapS:ClampToEdgeWrapping;texture.wrapT=texData.wrapT!==undefined?texData.wrapT:ClampToEdgeWrapping;texture.magFilter=texData.magFilter!==undefined?texData.magFilter:LinearFilter;texture.minFilter=texData.minFilter!==undefined?texData.minFilter:LinearFilter;texture.anisotropy=texData.anisotropy!==undefined?texData.anisotropy:1;if(texData.format!==undefined){texture.format=texData.format;}if(texData.type!==undefined){texture.type=texData.type;}if(texData.mipmaps!==undefined){texture.mipmaps=texData.mipmaps;texture.minFilter=LinearMipmapLinearFilter;// presumably...
}if(texData.mipmapCount===1){texture.minFilter=LinearFilter;}texture.needsUpdate=true;if(onLoad)onLoad(texture,texData);},onProgress,onError);return texture;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function ImageLoader(manager){Loader.call(this,manager);}ImageLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:ImageLoader,load:function load(url,onLoad,onProgress,onError){if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}var image=document.createElementNS('http://www.w3.org/1999/xhtml','img');function onImageLoad(){image.removeEventListener('load',onImageLoad,false);image.removeEventListener('error',onImageError,false);Cache.add(url,this);if(onLoad)onLoad(this);scope.manager.itemEnd(url);}function onImageError(event){image.removeEventListener('load',onImageLoad,false);image.removeEventListener('error',onImageError,false);if(onError)onError(event);scope.manager.itemError(url);scope.manager.itemEnd(url);}image.addEventListener('load',onImageLoad,false);image.addEventListener('error',onImageError,false);if(url.substr(0,5)!=='data:'){if(this.crossOrigin!==undefined)image.crossOrigin=this.crossOrigin;}scope.manager.itemStart(url);image.src=url;return image;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function CubeTextureLoader(manager){Loader.call(this,manager);}CubeTextureLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:CubeTextureLoader,load:function load(urls,onLoad,onProgress,onError){var texture=new CubeTexture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);var loaded=0;function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;if(loaded===6){texture.needsUpdate=true;if(onLoad)onLoad(texture);}},undefined,onError);}for(var i=0;i<urls.length;++i){loadTexture(i);}return texture;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function TextureLoader(manager){Loader.call(this,manager);}TextureLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:TextureLoader,load:function load(url,onLoad,onProgress,onError){var texture=new Texture();var loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);loader.load(url,function(image){texture.image=image;// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
var isJPEG=url.search(/\.jpe?g($|\?)/i)>0||url.search(/^data\:image\/jpeg/)===0;texture.format=isJPEG?RGBFormat:RGBAFormat;texture.needsUpdate=true;if(onLoad!==undefined){onLoad(texture);}},onProgress,onError);return texture;}});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/ /**************************************************************
 *	Abstract Curve base class
 **************************************************************/function Curve(){this.type='Curve';this.arcLengthDivisions=200;}(0,_assign.default)(Curve.prototype,{// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]
getPoint:function getPoint()/* t, optionalTarget */{console.warn('THREE.Curve: .getPoint() not implemented.');return null;},// Get point at relative position in curve according to arc length
// - u [0 .. 1]
getPointAt:function getPointAt(u,optionalTarget){var t=this.getUtoTmapping(u);return this.getPoint(t,optionalTarget);},// Get sequence of points using getPoint( t )
getPoints:function getPoints(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPoint(d/divisions));}return points;},// Get sequence of points using getPointAt( u )
getSpacedPoints:function getSpacedPoints(divisions){if(divisions===undefined)divisions=5;var points=[];for(var d=0;d<=divisions;d++){points.push(this.getPointAt(d/divisions));}return points;},// Get total curve arc length
getLength:function getLength(){var lengths=this.getLengths();return lengths[lengths.length-1];},// Get list of cumulative segment lengths
getLengths:function getLengths(divisions){if(divisions===undefined)divisions=this.arcLengthDivisions;if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate){return this.cacheArcLengths;}this.needsUpdate=false;var cache=[];var current,last=this.getPoint(0);var p,sum=0;cache.push(0);for(p=1;p<=divisions;p++){current=this.getPoint(p/divisions);sum+=current.distanceTo(last);cache.push(sum);last=current;}this.cacheArcLengths=cache;return cache;// { sums: cache, sum: sum }; Sum is in the last element.
},updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.getLengths();},// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
getUtoTmapping:function getUtoTmapping(u,distance){var arcLengths=this.getLengths();var i=0,il=arcLengths.length;var targetArcLength;// The targeted u distance value to get
if(distance){targetArcLength=distance;}else{targetArcLength=u*arcLengths[il-1];}// binary search for the index with largest value smaller than target u distance
var low=0,high=il-1,comparison;while(low<=high){i=Math.floor(low+(high-low)/2);// less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
comparison=arcLengths[i]-targetArcLength;if(comparison<0){low=i+1;}else if(comparison>0){high=i-1;}else{high=i;break;// DONE
}}i=high;if(arcLengths[i]===targetArcLength){return i/(il-1);}// we could get finer grain at lengths, or use simple interpolation between two points
var lengthBefore=arcLengths[i];var lengthAfter=arcLengths[i+1];var segmentLength=lengthAfter-lengthBefore;// determine where we are between the 'before' and 'after' points
var segmentFraction=(targetArcLength-lengthBefore)/segmentLength;// add that fractional amount to t
var t=(i+segmentFraction)/(il-1);return t;},// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation
getTangent:function getTangent(t){var delta=0.0001;var t1=t-delta;var t2=t+delta;// Capping in case of danger
if(t1<0)t1=0;if(t2>1)t2=1;var pt1=this.getPoint(t1);var pt2=this.getPoint(t2);var vec=pt2.clone().sub(pt1);return vec.normalize();},getTangentAt:function getTangentAt(u){var t=this.getUtoTmapping(u);return this.getTangent(t);},computeFrenetFrames:function computeFrenetFrames(segments,closed){// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
var normal=new Vector3();var tangents=[];var normals=[];var binormals=[];var vec=new Vector3();var mat=new Matrix4();var i,u,theta;// compute the tangent vectors for each segment on the curve
for(i=0;i<=segments;i++){u=i/segments;tangents[i]=this.getTangentAt(u);tangents[i].normalize();}// select an initial normal vector perpendicular to the first tangent vector,
// and in the direction of the minimum tangent xyz component
normals[0]=new Vector3();binormals[0]=new Vector3();var min=Number.MAX_VALUE;var tx=Math.abs(tangents[0].x);var ty=Math.abs(tangents[0].y);var tz=Math.abs(tangents[0].z);if(tx<=min){min=tx;normal.set(1,0,0);}if(ty<=min){min=ty;normal.set(0,1,0);}if(tz<=min){normal.set(0,0,1);}vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);// compute the slowly-varying normal and binormal vectors for each segment on the curve
for(i=1;i<=segments;i++){normals[i]=normals[i-1].clone();binormals[i]=binormals[i-1].clone();vec.crossVectors(tangents[i-1],tangents[i]);if(vec.length()>_epsilon.default){vec.normalize();theta=Math.acos(MathUtils.clamp(tangents[i-1].dot(tangents[i]),-1,1));// clamp for floating pt errors
normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta));}binormals[i].crossVectors(tangents[i],normals[i]);}// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
if(closed===true){theta=Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]),-1,1));theta/=segments;if(tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0){theta=-theta;}for(i=1;i<=segments;i++){// twist a little...
normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i));binormals[i].crossVectors(tangents[i],normals[i]);}}return{tangents:tangents,normals:normals,binormals:binormals};},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(source){this.arcLengthDivisions=source.arcLengthDivisions;return this;},toJSON:function toJSON(){var data={metadata:{version:4.5,type:'Curve',generator:'Curve.toJSON'}};data.arcLengthDivisions=this.arcLengthDivisions;data.type=this.type;return data;},fromJSON:function fromJSON(json){this.arcLengthDivisions=json.arcLengthDivisions;return this;}});function EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){Curve.call(this);this.type='EllipseCurve';this.aX=aX||0;this.aY=aY||0;this.xRadius=xRadius||1;this.yRadius=yRadius||1;this.aStartAngle=aStartAngle||0;this.aEndAngle=aEndAngle||2*Math.PI;this.aClockwise=aClockwise||false;this.aRotation=aRotation||0;}EllipseCurve.prototype=(0,_create.default)(Curve.prototype);EllipseCurve.prototype.constructor=EllipseCurve;EllipseCurve.prototype.isEllipseCurve=true;EllipseCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var twoPi=Math.PI*2;var deltaAngle=this.aEndAngle-this.aStartAngle;var samePoints=Math.abs(deltaAngle)<_epsilon.default;// ensures that deltaAngle is 0 .. 2 PI
while(deltaAngle<0){deltaAngle+=twoPi;}while(deltaAngle>twoPi){deltaAngle-=twoPi;}if(deltaAngle<_epsilon.default){if(samePoints){deltaAngle=0;}else{deltaAngle=twoPi;}}if(this.aClockwise===true&&!samePoints){if(deltaAngle===twoPi){deltaAngle=-twoPi;}else{deltaAngle=deltaAngle-twoPi;}}var angle=this.aStartAngle+t*deltaAngle;var x=this.aX+this.xRadius*Math.cos(angle);var y=this.aY+this.yRadius*Math.sin(angle);if(this.aRotation!==0){var cos=Math.cos(this.aRotation);var sin=Math.sin(this.aRotation);var tx=x-this.aX;var ty=y-this.aY;// Rotate the point about the center of the ellipse.
x=tx*cos-ty*sin+this.aX;y=tx*sin+ty*cos+this.aY;}return point.set(x,y);};EllipseCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.aX=source.aX;this.aY=source.aY;this.xRadius=source.xRadius;this.yRadius=source.yRadius;this.aStartAngle=source.aStartAngle;this.aEndAngle=source.aEndAngle;this.aClockwise=source.aClockwise;this.aRotation=source.aRotation;return this;};EllipseCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.aX=this.aX;data.aY=this.aY;data.xRadius=this.xRadius;data.yRadius=this.yRadius;data.aStartAngle=this.aStartAngle;data.aEndAngle=this.aEndAngle;data.aClockwise=this.aClockwise;data.aRotation=this.aRotation;return data;};EllipseCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.aX=json.aX;this.aY=json.aY;this.xRadius=json.xRadius;this.yRadius=json.yRadius;this.aStartAngle=json.aStartAngle;this.aEndAngle=json.aEndAngle;this.aClockwise=json.aClockwise;this.aRotation=json.aRotation;return this;};function ArcCurve(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){EllipseCurve.call(this,aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);this.type='ArcCurve';}ArcCurve.prototype=(0,_create.default)(EllipseCurve.prototype);ArcCurve.prototype.constructor=ArcCurve;ArcCurve.prototype.isArcCurve=true;/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */ /*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/function CubicPoly(){var c0=0,c1=0,c2=0,c3=0;/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */function init(x0,x1,t0,t1){c0=x0;c1=t0;c2=-3*x0+3*x1-2*t0-t1;c3=2*x0-2*x1+t0+t1;}return{initCatmullRom:function initCatmullRom(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1));},initNonuniformCatmullRom:function initNonuniformCatmullRom(x0,x1,x2,x3,dt0,dt1,dt2){// compute tangents when parameterized in [t1,t2]
var t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1;var t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;// rescale tangents for parametrization in [0,1]
t1*=dt1;t2*=dt1;init(x1,x2,t1,t2);},calc:function calc(t){var t2=t*t;var t3=t2*t;return c0+c1*t+c2*t2+c3*t3;}};}//
var tmp=new Vector3();var px=new CubicPoly(),py=new CubicPoly(),pz=new CubicPoly();function CatmullRomCurve3(points,closed,curveType,tension){Curve.call(this);this.type='CatmullRomCurve3';this.points=points||[];this.closed=closed||false;this.curveType=curveType||'centripetal';this.tension=tension||0.5;}CatmullRomCurve3.prototype=(0,_create.default)(Curve.prototype);CatmullRomCurve3.prototype.constructor=CatmullRomCurve3;CatmullRomCurve3.prototype.isCatmullRomCurve3=true;CatmullRomCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var points=this.points;var l=points.length;var p=(l-(this.closed?0:1))*t;var intPoint=Math.floor(p);var weight=p-intPoint;if(this.closed){intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/l)+1)*l;}else if(weight===0&&intPoint===l-1){intPoint=l-2;weight=1;}var p0,p1,p2,p3;// 4 points
if(this.closed||intPoint>0){p0=points[(intPoint-1)%l];}else{// extrapolate first point
tmp.subVectors(points[0],points[1]).add(points[0]);p0=tmp;}p1=points[intPoint%l];p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l){p3=points[(intPoint+2)%l];}else{// extrapolate last point
tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]);p3=tmp;}if(this.curveType==='centripetal'||this.curveType==='chordal'){// init Centripetal / Chordal Catmull-Rom
var pow=this.curveType==='chordal'?0.5:0.25;var dt0=Math.pow(p0.distanceToSquared(p1),pow);var dt1=Math.pow(p1.distanceToSquared(p2),pow);var dt2=Math.pow(p2.distanceToSquared(p3),pow);// safety check for repeated points
if(dt1<1e-4)dt1=1.0;if(dt0<1e-4)dt0=dt1;if(dt2<1e-4)dt2=dt1;px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2);}else if(this.curveType==='catmullrom'){px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,this.tension);py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,this.tension);pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,this.tension);}point.set(px.calc(weight),py.calc(weight),pz.calc(weight));return point;};CatmullRomCurve3.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.points=[];for(var i=0,l=source.points.length;i<l;i++){var point=source.points[i];this.points.push(point.clone());}this.closed=source.closed;this.curveType=source.curveType;this.tension=source.tension;return this;};CatmullRomCurve3.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.points=[];for(var i=0,l=this.points.length;i<l;i++){var point=this.points[i];data.points.push(point.toArray());}data.closed=this.closed;data.curveType=this.curveType;data.tension=this.tension;return data;};CatmullRomCurve3.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.points=[];for(var i=0,l=json.points.length;i<l;i++){var point=json.points[i];this.points.push(new Vector3().fromArray(point));}this.closed=json.closed;this.curveType=json.curveType;this.tension=json.tension;return this;};/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */function CatmullRom(t,p0,p1,p2,p3){var v0=(p2-p0)*0.5;var v1=(p3-p1)*0.5;var t2=t*t;var t3=t*t2;return(2*p1-2*p2+v0+v1)*t3+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1;}//
function QuadraticBezierP0(t,p){var k=1-t;return k*k*p;}function QuadraticBezierP1(t,p){return 2*(1-t)*t*p;}function QuadraticBezierP2(t,p){return t*t*p;}function QuadraticBezier(t,p0,p1,p2){return QuadraticBezierP0(t,p0)+QuadraticBezierP1(t,p1)+QuadraticBezierP2(t,p2);}//
function CubicBezierP0(t,p){var k=1-t;return k*k*k*p;}function CubicBezierP1(t,p){var k=1-t;return 3*k*k*t*p;}function CubicBezierP2(t,p){return 3*(1-t)*t*t*p;}function CubicBezierP3(t,p){return t*t*t*p;}function CubicBezier(t,p0,p1,p2,p3){return CubicBezierP0(t,p0)+CubicBezierP1(t,p1)+CubicBezierP2(t,p2)+CubicBezierP3(t,p3);}function CubicBezierCurve(v0,v1,v2,v3){Curve.call(this);this.type='CubicBezierCurve';this.v0=v0||new Vector2();this.v1=v1||new Vector2();this.v2=v2||new Vector2();this.v3=v3||new Vector2();}CubicBezierCurve.prototype=(0,_create.default)(Curve.prototype);CubicBezierCurve.prototype.constructor=CubicBezierCurve;CubicBezierCurve.prototype.isCubicBezierCurve=true;CubicBezierCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));return point;};CubicBezierCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;};CubicBezierCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;};CubicBezierCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;};function CubicBezierCurve3(v0,v1,v2,v3){Curve.call(this);this.type='CubicBezierCurve3';this.v0=v0||new Vector3();this.v1=v1||new Vector3();this.v2=v2||new Vector3();this.v3=v3||new Vector3();}CubicBezierCurve3.prototype=(0,_create.default)(Curve.prototype);CubicBezierCurve3.prototype.constructor=CubicBezierCurve3;CubicBezierCurve3.prototype.isCubicBezierCurve3=true;CubicBezierCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));return point;};CubicBezierCurve3.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this;};CubicBezierCurve3.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data;};CubicBezierCurve3.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this;};function LineCurve(v1,v2){Curve.call(this);this.type='LineCurve';this.v1=v1||new Vector2();this.v2=v2||new Vector2();}LineCurve.prototype=(0,_create.default)(Curve.prototype);LineCurve.prototype.constructor=LineCurve;LineCurve.prototype.isLineCurve=true;LineCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();if(t===1){point.copy(this.v2);}else{point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;};// Line curve is linear, so we can overwrite default getPointAt
LineCurve.prototype.getPointAt=function(u,optionalTarget){return this.getPoint(u,optionalTarget);};LineCurve.prototype.getTangent=function()/* t */{var tangent=this.v2.clone().sub(this.v1);return tangent.normalize();};LineCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;};LineCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;};LineCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;};function LineCurve3(v1,v2){Curve.call(this);this.type='LineCurve3';this.v1=v1||new Vector3();this.v2=v2||new Vector3();}LineCurve3.prototype=(0,_create.default)(Curve.prototype);LineCurve3.prototype.constructor=LineCurve3;LineCurve3.prototype.isLineCurve3=true;LineCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();if(t===1){point.copy(this.v2);}else{point.copy(this.v2).sub(this.v1);point.multiplyScalar(t).add(this.v1);}return point;};// Line curve is linear, so we can overwrite default getPointAt
LineCurve3.prototype.getPointAt=function(u,optionalTarget){return this.getPoint(u,optionalTarget);};LineCurve3.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;};LineCurve3.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;};LineCurve3.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;};function QuadraticBezierCurve(v0,v1,v2){Curve.call(this);this.type='QuadraticBezierCurve';this.v0=v0||new Vector2();this.v1=v1||new Vector2();this.v2=v2||new Vector2();}QuadraticBezierCurve.prototype=(0,_create.default)(Curve.prototype);QuadraticBezierCurve.prototype.constructor=QuadraticBezierCurve;QuadraticBezierCurve.prototype.isQuadraticBezierCurve=true;QuadraticBezierCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));return point;};QuadraticBezierCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;};QuadraticBezierCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;};QuadraticBezierCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;};function QuadraticBezierCurve3(v0,v1,v2){Curve.call(this);this.type='QuadraticBezierCurve3';this.v0=v0||new Vector3();this.v1=v1||new Vector3();this.v2=v2||new Vector3();}QuadraticBezierCurve3.prototype=(0,_create.default)(Curve.prototype);QuadraticBezierCurve3.prototype.constructor=QuadraticBezierCurve3;QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3=true;QuadraticBezierCurve3.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector3();var v0=this.v0,v1=this.v1,v2=this.v2;point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));return point;};QuadraticBezierCurve3.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this;};QuadraticBezierCurve3.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data;};QuadraticBezierCurve3.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this;};function SplineCurve(points/* array of Vector2 */){Curve.call(this);this.type='SplineCurve';this.points=points||[];}SplineCurve.prototype=(0,_create.default)(Curve.prototype);SplineCurve.prototype.constructor=SplineCurve;SplineCurve.prototype.isSplineCurve=true;SplineCurve.prototype.getPoint=function(t,optionalTarget){var point=optionalTarget||new Vector2();var points=this.points;var p=(points.length-1)*t;var intPoint=Math.floor(p);var weight=p-intPoint;var p0=points[intPoint===0?intPoint:intPoint-1];var p1=points[intPoint];var p2=points[intPoint>points.length-2?points.length-1:intPoint+1];var p3=points[intPoint>points.length-3?points.length-1:intPoint+2];point.set(CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),CatmullRom(weight,p0.y,p1.y,p2.y,p3.y));return point;};SplineCurve.prototype.copy=function(source){Curve.prototype.copy.call(this,source);this.points=[];for(var i=0,l=source.points.length;i<l;i++){var point=source.points[i];this.points.push(point.clone());}return this;};SplineCurve.prototype.toJSON=function(){var data=Curve.prototype.toJSON.call(this);data.points=[];for(var i=0,l=this.points.length;i<l;i++){var point=this.points[i];data.points.push(point.toArray());}return data;};SplineCurve.prototype.fromJSON=function(json){Curve.prototype.fromJSON.call(this,json);this.points=[];for(var i=0,l=json.points.length;i<l;i++){var point=json.points[i];this.points.push(new Vector2().fromArray(point));}return this;};var Curves=/*#__PURE__*/(0,_freeze.default)({__proto__:null,ArcCurve:ArcCurve,CatmullRomCurve3:CatmullRomCurve3,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:LineCurve3,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/ /**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/function CurvePath(){Curve.call(this);this.type='CurvePath';this.curves=[];this.autoClose=false;// Automatically closes the path
}CurvePath.prototype=(0,_assign.default)((0,_create.default)(Curve.prototype),{constructor:CurvePath,add:function add(curve){this.curves.push(curve);},closePath:function closePath(){// Add a line curve if start and end of lines are not connected
var startPoint=this.curves[0].getPoint(0);var endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){this.curves.push(new LineCurve(endPoint,startPoint));}},// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:
// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')
getPoint:function getPoint(t){var d=t*this.getLength();var curveLengths=this.getCurveLengths();var i=0;// To think about boundaries points.
while(i<curveLengths.length){if(curveLengths[i]>=d){var diff=curveLengths[i]-d;var curve=this.curves[i];var segmentLength=curve.getLength();var u=segmentLength===0?0:1-diff/segmentLength;return curve.getPointAt(u);}i++;}return null;// loop where sum != 0, sum > d , sum+1 <d
},// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength
getLength:function getLength(){var lens=this.getCurveLengths();return lens[lens.length-1];},// cacheLengths must be recalculated.
updateArcLengths:function updateArcLengths(){this.needsUpdate=true;this.cacheLengths=null;this.getCurveLengths();},// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.
getCurveLengths:function getCurveLengths(){// We use cache values if curves and cache array are same length
if(this.cacheLengths&&this.cacheLengths.length===this.curves.length){return this.cacheLengths;}// Get length of sub-curve
// Push sums into cached array
var lengths=[],sums=0;for(var i=0,l=this.curves.length;i<l;i++){sums+=this.curves[i].getLength();lengths.push(sums);}this.cacheLengths=lengths;return lengths;},getSpacedPoints:function getSpacedPoints(divisions){if(divisions===undefined)divisions=40;var points=[];for(var i=0;i<=divisions;i++){points.push(this.getPoint(i/divisions));}if(this.autoClose){points.push(points[0]);}return points;},getPoints:function getPoints(divisions){divisions=divisions||12;var points=[],last;for(var i=0,curves=this.curves;i<curves.length;i++){var curve=curves[i];var resolution=curve&&curve.isEllipseCurve?divisions*2:curve&&(curve.isLineCurve||curve.isLineCurve3)?1:curve&&curve.isSplineCurve?divisions*curve.points.length:divisions;var pts=curve.getPoints(resolution);for(var j=0;j<pts.length;j++){var point=pts[j];if(last&&last.equals(point))continue;// ensures no consecutive points are duplicates
points.push(point);last=point;}}if(this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])){points.push(points[0]);}return points;},copy:function copy(source){Curve.prototype.copy.call(this,source);this.curves=[];for(var i=0,l=source.curves.length;i<l;i++){var curve=source.curves[i];this.curves.push(curve.clone());}this.autoClose=source.autoClose;return this;},toJSON:function toJSON(){var data=Curve.prototype.toJSON.call(this);data.autoClose=this.autoClose;data.curves=[];for(var i=0,l=this.curves.length;i<l;i++){var curve=this.curves[i];data.curves.push(curve.toJSON());}return data;},fromJSON:function fromJSON(json){Curve.prototype.fromJSON.call(this,json);this.autoClose=json.autoClose;this.curves=[];for(var i=0,l=json.curves.length;i<l;i++){var curve=json.curves[i];this.curves.push(new Curves[curve.type]().fromJSON(curve));}return this;}});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 **/function Path(points){CurvePath.call(this);this.type='Path';this.currentPoint=new Vector2();if(points){this.setFromPoints(points);}}Path.prototype=(0,_assign.default)((0,_create.default)(CurvePath.prototype),{constructor:Path,setFromPoints:function setFromPoints(points){this.moveTo(points[0].x,points[0].y);for(var i=1,l=points.length;i<l;i++){this.lineTo(points[i].x,points[i].y);}return this;},moveTo:function moveTo(x,y){this.currentPoint.set(x,y);// TODO consider referencing vectors instead of copying?
return this;},lineTo:function lineTo(x,y){var curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);return this;},quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){var curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);return this;},bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){var curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(curve);this.currentPoint.set(aX,aY);return this;},splineThru:function splineThru(pts/*Array of Vector*/){var npts=[this.currentPoint.clone()].concat(pts);var curve=new SplineCurve(npts);this.curves.push(curve);this.currentPoint.copy(pts[pts.length-1]);return this;},arc:function arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise);return this;},absarc:function absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);return this;},ellipse:function ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var x0=this.currentPoint.x;var y0=this.currentPoint.y;this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);return this;},absellipse:function absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){var curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){// if a previous curve is present, attempt to join
var firstPoint=curve.getPoint(0);if(!firstPoint.equals(this.currentPoint)){this.lineTo(firstPoint.x,firstPoint.y);}}this.curves.push(curve);var lastPoint=curve.getPoint(1);this.currentPoint.copy(lastPoint);return this;},copy:function copy(source){CurvePath.prototype.copy.call(this,source);this.currentPoint.copy(source.currentPoint);return this;},toJSON:function toJSON(){var data=CurvePath.prototype.toJSON.call(this);data.currentPoint=this.currentPoint.toArray();return data;},fromJSON:function fromJSON(json){CurvePath.prototype.fromJSON.call(this,json);this.currentPoint.fromArray(json.currentPoint);return this;}});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/ // STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.
function Shape(points){Path.call(this,points);this.uuid=MathUtils.generateUUID();this.type='Shape';this.holes=[];}Shape.prototype=(0,_assign.default)((0,_create.default)(Path.prototype),{constructor:Shape,getPointsHoles:function getPointsHoles(divisions){var holesPts=[];for(var i=0,l=this.holes.length;i<l;i++){holesPts[i]=this.holes[i].getPoints(divisions);}return holesPts;},// get points of shape and holes (keypoints based on segments parameter)
extractPoints:function extractPoints(divisions){return{shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)};},copy:function copy(source){Path.prototype.copy.call(this,source);this.holes=[];for(var i=0,l=source.holes.length;i<l;i++){var hole=source.holes[i];this.holes.push(hole.clone());}return this;},toJSON:function toJSON(){var data=Path.prototype.toJSON.call(this);data.uuid=this.uuid;data.holes=[];for(var i=0,l=this.holes.length;i<l;i++){var hole=this.holes[i];data.holes.push(hole.toJSON());}return data;},fromJSON:function fromJSON(json){Path.prototype.fromJSON.call(this,json);this.uuid=json.uuid;this.holes=[];for(var i=0,l=json.holes.length;i<l;i++){var hole=json.holes[i];this.holes.push(new Path().fromJSON(hole));}return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function Light(color,intensity){Object3D.call(this);this.type='Light';this.color=new Color(color);this.intensity=intensity!==undefined?intensity:1;this.receiveShadow=undefined;}Light.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Light,isLight:true,copy:function copy(source){Object3D.prototype.copy.call(this,source);this.color.copy(source.color);this.intensity=source.intensity;return this;},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.color=this.color.getHex();data.object.intensity=this.intensity;if(this.groundColor!==undefined)data.object.groundColor=this.groundColor.getHex();if(this.distance!==undefined)data.object.distance=this.distance;if(this.angle!==undefined)data.object.angle=this.angle;if(this.decay!==undefined)data.object.decay=this.decay;if(this.penumbra!==undefined)data.object.penumbra=this.penumbra;if(this.shadow!==undefined)data.object.shadow=this.shadow.toJSON();return data;}});/**
 * @author alteredq / http://alteredqualia.com/
 */function HemisphereLight(skyColor,groundColor,intensity){Light.call(this,skyColor,intensity);this.type='HemisphereLight';this.castShadow=undefined;this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor);}HemisphereLight.prototype=(0,_assign.default)((0,_create.default)(Light.prototype),{constructor:HemisphereLight,isHemisphereLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.groundColor.copy(source.groundColor);return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function LightShadow(camera){this.camera=camera;this.bias=0;this.radius=1;this.mapSize=new Vector2(512,512);this.map=null;this.mapPass=null;this.matrix=new Matrix4();this._frustum=new Frustum();this._frameExtents=new Vector2(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)];}(0,_assign.default)(LightShadow.prototype,{_projScreenMatrix:new Matrix4(),_lightPositionWorld:new Vector3(),_lookTarget:new Vector3(),getViewportCount:function getViewportCount(){return this._viewportCount;},getFrustum:function getFrustum(){return this._frustum;},updateMatrices:function updateMatrices(light){var shadowCamera=this.camera,shadowMatrix=this.matrix,projScreenMatrix=this._projScreenMatrix,lookTarget=this._lookTarget,lightPositionWorld=this._lightPositionWorld;lightPositionWorld.setFromMatrixPosition(light.matrixWorld);shadowCamera.position.copy(lightPositionWorld);lookTarget.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(lookTarget);shadowCamera.updateMatrixWorld();projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(projScreenMatrix);shadowMatrix.set(0.5,0.0,0.0,0.5,0.0,0.5,0.0,0.5,0.0,0.0,0.5,0.5,0.0,0.0,0.0,1.0);shadowMatrix.multiply(shadowCamera.projectionMatrix);shadowMatrix.multiply(shadowCamera.matrixWorldInverse);},getViewport:function getViewport(viewportIndex){return this._viewports[viewportIndex];},getFrameExtents:function getFrameExtents(){return this._frameExtents;},copy:function copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this;},clone:function clone(){return new this.constructor().copy(this);},toJSON:function toJSON(){var object={};if(this.bias!==0)object.bias=this.bias;if(this.radius!==1)object.radius=this.radius;if(this.mapSize.x!==512||this.mapSize.y!==512)object.mapSize=this.mapSize.toArray();object.camera=this.camera.toJSON(false).object;delete object.camera.matrix;return object;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function SpotLightShadow(){LightShadow.call(this,new PerspectiveCamera(50,1,0.5,500));}SpotLightShadow.prototype=(0,_assign.default)((0,_create.default)(LightShadow.prototype),{constructor:SpotLightShadow,isSpotLightShadow:true,updateMatrices:function updateMatrices(light){var camera=this.camera;var fov=MathUtils.RAD2DEG*2*light.angle;var aspect=this.mapSize.width/this.mapSize.height;var far=light.distance||camera.far;if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far){camera.fov=fov;camera.aspect=aspect;camera.far=far;camera.updateProjectionMatrix();}LightShadow.prototype.updateMatrices.call(this,light);}});/**
 * @author alteredq / http://alteredqualia.com/
 */function SpotLight(color,intensity,distance,angle,penumbra,decay){Light.call(this,color,intensity);this.type='SpotLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();(0,_defineProperty3.default)(this,'power',{get:function get(){// intensity = power per solid angle.
// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
return this.intensity*Math.PI;},set:function set(power){// intensity = power per solid angle.
// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
this.intensity=power/Math.PI;}});this.distance=distance!==undefined?distance:0;this.angle=angle!==undefined?angle:Math.PI/3;this.penumbra=penumbra!==undefined?penumbra:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
this.shadow=new SpotLightShadow();}SpotLight.prototype=(0,_assign.default)((0,_create.default)(Light.prototype),{constructor:SpotLight,isSpotLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});function PointLightShadow(){LightShadow.call(this,new PerspectiveCamera(90,1,0.5,500));this._frameExtents=new Vector2(4,2);this._viewportCount=6;this._viewports=[// These viewports map a cube-map onto a 2D texture with the
// following orientation:
//
//  xzXZ
//   y Y
//
// X - Positive x direction
// x - Negative x direction
// Y - Positive y direction
// y - Negative y direction
// Z - Positive z direction
// z - Negative z direction
// positive X
new Vector4(2,1,1,1),// negative X
new Vector4(0,1,1,1),// positive Z
new Vector4(3,1,1,1),// negative Z
new Vector4(1,1,1,1),// positive Y
new Vector4(3,0,1,1),// negative Y
new Vector4(1,0,1,1)];this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,0,-1)];}PointLightShadow.prototype=(0,_assign.default)((0,_create.default)(LightShadow.prototype),{constructor:PointLightShadow,isPointLightShadow:true,updateMatrices:function updateMatrices(light,viewportIndex){if(viewportIndex===undefined)viewportIndex=0;var camera=this.camera,shadowMatrix=this.matrix,lightPositionWorld=this._lightPositionWorld,lookTarget=this._lookTarget,projScreenMatrix=this._projScreenMatrix;lightPositionWorld.setFromMatrixPosition(light.matrixWorld);camera.position.copy(lightPositionWorld);lookTarget.copy(camera.position);lookTarget.add(this._cubeDirections[viewportIndex]);camera.up.copy(this._cubeUps[viewportIndex]);camera.lookAt(lookTarget);camera.updateMatrixWorld();shadowMatrix.makeTranslation(-lightPositionWorld.x,-lightPositionWorld.y,-lightPositionWorld.z);projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(projScreenMatrix);}});/**
 * @author mrdoob / http://mrdoob.com/
 */function PointLight(color,intensity,distance,decay){Light.call(this,color,intensity);this.type='PointLight';(0,_defineProperty3.default)(this,'power',{get:function get(){// intensity = power per solid angle.
// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
return this.intensity*4*Math.PI;},set:function set(power){// intensity = power per solid angle.
// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
this.intensity=power/(4*Math.PI);}});this.distance=distance!==undefined?distance:0;this.decay=decay!==undefined?decay:1;// for physically correct lights, should be 2.
this.shadow=new PointLightShadow();}PointLight.prototype=(0,_assign.default)((0,_create.default)(Light.prototype),{constructor:PointLight,isPointLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this;}});/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */function OrthographicCamera(left,right,top,bottom,near,far){Camera.call(this);this.type='OrthographicCamera';this.zoom=1;this.view=null;this.left=left!==undefined?left:-1;this.right=right!==undefined?right:1;this.top=top!==undefined?top:1;this.bottom=bottom!==undefined?bottom:-1;this.near=near!==undefined?near:0.1;this.far=far!==undefined?far:2000;this.updateProjectionMatrix();}OrthographicCamera.prototype=(0,_assign.default)((0,_create.default)(Camera.prototype),{constructor:OrthographicCamera,isOrthographicCamera:true,copy:function copy(source,recursive){Camera.prototype.copy.call(this,source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=source.view===null?null:(0,_assign.default)({},source.view);return this;},setViewOffset:function setViewOffset(fullWidth,fullHeight,x,y,width,height){if(this.view===null){this.view={enabled:true,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1};}this.view.enabled=true;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix();},clearViewOffset:function clearViewOffset(){if(this.view!==null){this.view.enabled=false;}this.updateProjectionMatrix();},updateProjectionMatrix:function updateProjectionMatrix(){var dx=(this.right-this.left)/(2*this.zoom);var dy=(this.top-this.bottom)/(2*this.zoom);var cx=(this.right+this.left)/2;var cy=(this.top+this.bottom)/2;var left=cx-dx;var right=cx+dx;var top=cy+dy;var bottom=cy-dy;if(this.view!==null&&this.view.enabled){var scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom;var scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX;right=left+scaleW*this.view.width;top-=scaleH*this.view.offsetY;bottom=top-scaleH*this.view.height;}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far);this.projectionMatrixInverse.getInverse(this.projectionMatrix);},toJSON:function toJSON(meta){var data=Object3D.prototype.toJSON.call(this,meta);data.object.zoom=this.zoom;data.object.left=this.left;data.object.right=this.right;data.object.top=this.top;data.object.bottom=this.bottom;data.object.near=this.near;data.object.far=this.far;if(this.view!==null)data.object.view=(0,_assign.default)({},this.view);return data;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function DirectionalLightShadow(){LightShadow.call(this,new OrthographicCamera(-5,5,5,-5,0.5,500));}DirectionalLightShadow.prototype=(0,_assign.default)((0,_create.default)(LightShadow.prototype),{constructor:DirectionalLightShadow,isDirectionalLightShadow:true,updateMatrices:function updateMatrices(light){LightShadow.prototype.updateMatrices.call(this,light);}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */function DirectionalLight(color,intensity){Light.call(this,color,intensity);this.type='DirectionalLight';this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D();this.shadow=new DirectionalLightShadow();}DirectionalLight.prototype=(0,_assign.default)((0,_create.default)(Light.prototype),{constructor:DirectionalLight,isDirectionalLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function AmbientLight(color,intensity){Light.call(this,color,intensity);this.type='AmbientLight';this.castShadow=undefined;}AmbientLight.prototype=(0,_assign.default)((0,_create.default)(Light.prototype),{constructor:AmbientLight,isAmbientLight:true});/**
 * @author abelnation / http://github.com/abelnation
 */function RectAreaLight(color,intensity,width,height){Light.call(this,color,intensity);this.type='RectAreaLight';this.width=width!==undefined?width:10;this.height=height!==undefined?height:10;}RectAreaLight.prototype=(0,_assign.default)((0,_create.default)(Light.prototype),{constructor:RectAreaLight,isRectAreaLight:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.width=source.width;this.height=source.height;return this;},toJSON:function toJSON(meta){var data=Light.prototype.toJSON.call(this,meta);data.object.width=this.width;data.object.height=this.height;return data;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function MaterialLoader(manager){Loader.call(this,manager);this.textures={};}MaterialLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:MaterialLoader,load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.setPath(scope.path);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},parse:function parse(json){var textures=this.textures;function getTexture(name){if(textures[name]===undefined){console.warn('THREE.MaterialLoader: Undefined texture',name);}return textures[name];}var material=new Materials[json.type]();if(json.uuid!==undefined)material.uuid=json.uuid;if(json.name!==undefined)material.name=json.name;if(json.color!==undefined)material.color.setHex(json.color);if(json.roughness!==undefined)material.roughness=json.roughness;if(json.metalness!==undefined)material.metalness=json.metalness;if(json.sheen!==undefined)material.sheen=new Color().setHex(json.sheen);if(json.emissive!==undefined)material.emissive.setHex(json.emissive);if(json.specular!==undefined)material.specular.setHex(json.specular);if(json.shininess!==undefined)material.shininess=json.shininess;if(json.clearcoat!==undefined)material.clearcoat=json.clearcoat;if(json.clearcoatRoughness!==undefined)material.clearcoatRoughness=json.clearcoatRoughness;if(json.fog!==undefined)material.fog=json.fog;if(json.flatShading!==undefined)material.flatShading=json.flatShading;if(json.blending!==undefined)material.blending=json.blending;if(json.combine!==undefined)material.combine=json.combine;if(json.side!==undefined)material.side=json.side;if(json.opacity!==undefined)material.opacity=json.opacity;if(json.transparent!==undefined)material.transparent=json.transparent;if(json.alphaTest!==undefined)material.alphaTest=json.alphaTest;if(json.depthTest!==undefined)material.depthTest=json.depthTest;if(json.depthWrite!==undefined)material.depthWrite=json.depthWrite;if(json.colorWrite!==undefined)material.colorWrite=json.colorWrite;if(json.stencilWrite!==undefined)material.stencilWrite=json.stencilWrite;if(json.stencilWriteMask!==undefined)material.stencilWriteMask=json.stencilWriteMask;if(json.stencilFunc!==undefined)material.stencilFunc=json.stencilFunc;if(json.stencilRef!==undefined)material.stencilRef=json.stencilRef;if(json.stencilFuncMask!==undefined)material.stencilFuncMask=json.stencilFuncMask;if(json.stencilFail!==undefined)material.stencilFail=json.stencilFail;if(json.stencilZFail!==undefined)material.stencilZFail=json.stencilZFail;if(json.stencilZPass!==undefined)material.stencilZPass=json.stencilZPass;if(json.wireframe!==undefined)material.wireframe=json.wireframe;if(json.wireframeLinewidth!==undefined)material.wireframeLinewidth=json.wireframeLinewidth;if(json.wireframeLinecap!==undefined)material.wireframeLinecap=json.wireframeLinecap;if(json.wireframeLinejoin!==undefined)material.wireframeLinejoin=json.wireframeLinejoin;if(json.rotation!==undefined)material.rotation=json.rotation;if(json.linewidth!==1)material.linewidth=json.linewidth;if(json.dashSize!==undefined)material.dashSize=json.dashSize;if(json.gapSize!==undefined)material.gapSize=json.gapSize;if(json.scale!==undefined)material.scale=json.scale;if(json.polygonOffset!==undefined)material.polygonOffset=json.polygonOffset;if(json.polygonOffsetFactor!==undefined)material.polygonOffsetFactor=json.polygonOffsetFactor;if(json.polygonOffsetUnits!==undefined)material.polygonOffsetUnits=json.polygonOffsetUnits;if(json.skinning!==undefined)material.skinning=json.skinning;if(json.morphTargets!==undefined)material.morphTargets=json.morphTargets;if(json.morphNormals!==undefined)material.morphNormals=json.morphNormals;if(json.dithering!==undefined)material.dithering=json.dithering;if(json.vertexTangents!==undefined)material.vertexTangents=json.vertexTangents;if(json.visible!==undefined)material.visible=json.visible;if(json.toneMapped!==undefined)material.toneMapped=json.toneMapped;if(json.userData!==undefined)material.userData=json.userData;if(json.vertexColors!==undefined){if(typeof json.vertexColors==='number'){material.vertexColors=json.vertexColors>0?true:false;}else{material.vertexColors=json.vertexColors;}}// Shader Material
if(json.uniforms!==undefined){for(var name in json.uniforms){var uniform=json.uniforms[name];material.uniforms[name]={};switch(uniform.type){case't':material.uniforms[name].value=getTexture(uniform.value);break;case'c':material.uniforms[name].value=new Color().setHex(uniform.value);break;case'v2':material.uniforms[name].value=new Vector2().fromArray(uniform.value);break;case'v3':material.uniforms[name].value=new Vector3().fromArray(uniform.value);break;case'v4':material.uniforms[name].value=new Vector4().fromArray(uniform.value);break;case'm3':material.uniforms[name].value=new Matrix3().fromArray(uniform.value);case'm4':material.uniforms[name].value=new Matrix4().fromArray(uniform.value);break;default:material.uniforms[name].value=uniform.value;}}}if(json.defines!==undefined)material.defines=json.defines;if(json.vertexShader!==undefined)material.vertexShader=json.vertexShader;if(json.fragmentShader!==undefined)material.fragmentShader=json.fragmentShader;if(json.extensions!==undefined){for(var key in json.extensions){material.extensions[key]=json.extensions[key];}}// Deprecated
if(json.shading!==undefined)material.flatShading=json.shading===1;// THREE.FlatShading
// for PointsMaterial
if(json.size!==undefined)material.size=json.size;if(json.sizeAttenuation!==undefined)material.sizeAttenuation=json.sizeAttenuation;// maps
if(json.map!==undefined)material.map=getTexture(json.map);if(json.matcap!==undefined)material.matcap=getTexture(json.matcap);if(json.alphaMap!==undefined)material.alphaMap=getTexture(json.alphaMap);if(json.bumpMap!==undefined)material.bumpMap=getTexture(json.bumpMap);if(json.bumpScale!==undefined)material.bumpScale=json.bumpScale;if(json.normalMap!==undefined)material.normalMap=getTexture(json.normalMap);if(json.normalMapType!==undefined)material.normalMapType=json.normalMapType;if(json.normalScale!==undefined){var normalScale=json.normalScale;if((0,_isArray.default)(normalScale)===false){// Blender exporter used to export a scalar. See #7459
normalScale=[normalScale,normalScale];}material.normalScale=new Vector2().fromArray(normalScale);}if(json.displacementMap!==undefined)material.displacementMap=getTexture(json.displacementMap);if(json.displacementScale!==undefined)material.displacementScale=json.displacementScale;if(json.displacementBias!==undefined)material.displacementBias=json.displacementBias;if(json.roughnessMap!==undefined)material.roughnessMap=getTexture(json.roughnessMap);if(json.metalnessMap!==undefined)material.metalnessMap=getTexture(json.metalnessMap);if(json.emissiveMap!==undefined)material.emissiveMap=getTexture(json.emissiveMap);if(json.emissiveIntensity!==undefined)material.emissiveIntensity=json.emissiveIntensity;if(json.specularMap!==undefined)material.specularMap=getTexture(json.specularMap);if(json.envMap!==undefined)material.envMap=getTexture(json.envMap);if(json.envMapIntensity!==undefined)material.envMapIntensity=json.envMapIntensity;if(json.reflectivity!==undefined)material.reflectivity=json.reflectivity;if(json.refractionRatio!==undefined)material.refractionRatio=json.refractionRatio;if(json.lightMap!==undefined)material.lightMap=getTexture(json.lightMap);if(json.lightMapIntensity!==undefined)material.lightMapIntensity=json.lightMapIntensity;if(json.aoMap!==undefined)material.aoMap=getTexture(json.aoMap);if(json.aoMapIntensity!==undefined)material.aoMapIntensity=json.aoMapIntensity;if(json.gradientMap!==undefined)material.gradientMap=getTexture(json.gradientMap);if(json.clearcoatMap!==undefined)material.clearcoatMap=getTexture(json.clearcoatMap);if(json.clearcoatRoughnessMap!==undefined)material.clearcoatRoughnessMap=getTexture(json.clearcoatRoughnessMap);if(json.clearcoatNormalMap!==undefined)material.clearcoatNormalMap=getTexture(json.clearcoatNormalMap);if(json.clearcoatNormalScale!==undefined)material.clearcoatNormalScale=new Vector2().fromArray(json.clearcoatNormalScale);return material;},setTextures:function setTextures(value){this.textures=value;return this;}});/**
 * @author Don McCurdy / https://www.donmccurdy.com
 */var LoaderUtils={decodeText:function decodeText(array){if(typeof TextDecoder!=='undefined'){return new TextDecoder().decode(array);}// Avoid the String.fromCharCode.apply(null, array) shortcut, which
// throws a "maximum call stack size exceeded" error for large arrays.
var s='';for(var i=0,il=array.length;i<il;i++){// Implicitly assumes little-endian.
s+=String.fromCharCode(array[i]);}try{// merges multi-byte utf-8 characters.
return decodeURIComponent(escape(s));}catch(e){// see #16358
return s;}},extractUrlBase:function extractUrlBase(url){var index=url.lastIndexOf('/');if(index===-1)return'./';return url.substr(0,index+1);}};/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */exports.LoaderUtils=LoaderUtils;function InstancedBufferGeometry(){BufferGeometry.call(this);this.type='InstancedBufferGeometry';this.maxInstancedCount=undefined;}InstancedBufferGeometry.prototype=(0,_assign.default)((0,_create.default)(BufferGeometry.prototype),{constructor:InstancedBufferGeometry,isInstancedBufferGeometry:true,copy:function copy(source){BufferGeometry.prototype.copy.call(this,source);this.maxInstancedCount=source.maxInstancedCount;return this;},clone:function clone(){return new this.constructor().copy(this);},toJSON:function toJSON(){var data=BufferGeometry.prototype.toJSON.call(this);data.maxInstancedCount=this.maxInstancedCount;data.isInstancedBufferGeometry=true;return data;}});/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */function InstancedBufferAttribute(array,itemSize,normalized,meshPerAttribute){if(typeof normalized==='number'){meshPerAttribute=normalized;normalized=false;console.error('THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.');}BufferAttribute.call(this,array,itemSize,normalized);this.meshPerAttribute=meshPerAttribute||1;}InstancedBufferAttribute.prototype=(0,_assign.default)((0,_create.default)(BufferAttribute.prototype),{constructor:InstancedBufferAttribute,isInstancedBufferAttribute:true,copy:function copy(source){BufferAttribute.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;},toJSON:function toJSON(){var data=BufferAttribute.prototype.toJSON.call(this);data.meshPerAttribute=this.meshPerAttribute;data.isInstancedBufferAttribute=true;return data;}});/**
 * @author mrdoob / http://mrdoob.com/
 */function BufferGeometryLoader(manager){Loader.call(this,manager);}BufferGeometryLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:BufferGeometryLoader,load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(scope.manager);loader.setPath(scope.path);loader.load(url,function(text){onLoad(scope.parse(JSON.parse(text)));},onProgress,onError);},parse:function parse(json){var geometry=json.isInstancedBufferGeometry?new InstancedBufferGeometry():new BufferGeometry();var index=json.data.index;if(index!==undefined){var typedArray=new TYPED_ARRAYS[index.type](index.array);geometry.setIndex(new BufferAttribute(typedArray,1));}var attributes=json.data.attributes;for(var key in attributes){var attribute=attributes[key];var typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);var bufferAttributeConstr=attribute.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute;var bufferAttribute=new bufferAttributeConstr(typedArray,attribute.itemSize,attribute.normalized);if(attribute.name!==undefined)bufferAttribute.name=attribute.name;geometry.setAttribute(key,bufferAttribute);}var morphAttributes=json.data.morphAttributes;if(morphAttributes){for(var key in morphAttributes){var attributeArray=morphAttributes[key];var array=[];for(var i=0,il=attributeArray.length;i<il;i++){var attribute=attributeArray[i];var typedArray=new TYPED_ARRAYS[attribute.type](attribute.array);var bufferAttribute=new BufferAttribute(typedArray,attribute.itemSize,attribute.normalized);if(attribute.name!==undefined)bufferAttribute.name=attribute.name;array.push(bufferAttribute);}geometry.morphAttributes[key]=array;}}var morphTargetsRelative=json.data.morphTargetsRelative;if(morphTargetsRelative){geometry.morphTargetsRelative=true;}var groups=json.data.groups||json.data.drawcalls||json.data.offsets;if(groups!==undefined){for(var i=0,n=groups.length;i!==n;++i){var group=groups[i];geometry.addGroup(group.start,group.count,group.materialIndex);}}var boundingSphere=json.data.boundingSphere;if(boundingSphere!==undefined){var center=new Vector3();if(boundingSphere.center!==undefined){center.fromArray(boundingSphere.center);}geometry.boundingSphere=new Sphere(center,boundingSphere.radius);}if(json.name)geometry.name=json.name;if(json.userData)geometry.userData=json.userData;return geometry;}});var TYPED_ARRAYS={Int8Array:Int8Array,Uint8Array:Uint8Array,// Workaround for IE11 pre KB2929437. See #11440
Uint8ClampedArray:typeof Uint8ClampedArray!=='undefined'?Uint8ClampedArray:Uint8Array,Int16Array:Int16Array,Uint16Array:Uint16Array,Int32Array:Int32Array,Uint32Array:Uint32Array,Float32Array:Float32Array,Float64Array:Float64Array};/**
 * @author mrdoob / http://mrdoob.com/
 */function ObjectLoader(manager){Loader.call(this,manager);}ObjectLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:ObjectLoader,load:function load(url,onLoad,onProgress,onError){var scope=this;var path=this.path===''?LoaderUtils.extractUrlBase(url):this.path;this.resourcePath=this.resourcePath||path;var loader=new FileLoader(scope.manager);loader.setPath(this.path);loader.load(url,function(text){var json=null;try{json=JSON.parse(text);}catch(error){if(onError!==undefined)onError(error);console.error('THREE:ObjectLoader: Can\'t parse '+url+'.',error.message);return;}var metadata=json.metadata;if(metadata===undefined||metadata.type===undefined||metadata.type.toLowerCase()==='geometry'){console.error('THREE.ObjectLoader: Can\'t load '+url);return;}scope.parse(json,onLoad);},onProgress,onError);},parse:function parse(json,onLoad){var shapes=this.parseShape(json.shapes);var geometries=this.parseGeometries(json.geometries,shapes);var images=this.parseImages(json.images,function(){if(onLoad!==undefined)onLoad(object);});var textures=this.parseTextures(json.textures,images);var materials=this.parseMaterials(json.materials,textures);var object=this.parseObject(json.object,geometries,materials);if(json.animations){object.animations=this.parseAnimations(json.animations);}if(json.images===undefined||json.images.length===0){if(onLoad!==undefined)onLoad(object);}return object;},parseShape:function parseShape(json){var shapes={};if(json!==undefined){for(var i=0,l=json.length;i<l;i++){var shape=new Shape().fromJSON(json[i]);shapes[shape.uuid]=shape;}}return shapes;},parseGeometries:function parseGeometries(json,shapes){var geometries={};if(json!==undefined){var bufferGeometryLoader=new BufferGeometryLoader();for(var i=0,l=json.length;i<l;i++){var geometry;var data=json[i];switch(data.type){case'PlaneGeometry':case'PlaneBufferGeometry':geometry=new Geometries[data.type](data.width,data.height,data.widthSegments,data.heightSegments);break;case'BoxGeometry':case'BoxBufferGeometry':case'CubeGeometry':// backwards compatible
geometry=new Geometries[data.type](data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments);break;case'CircleGeometry':case'CircleBufferGeometry':geometry=new Geometries[data.type](data.radius,data.segments,data.thetaStart,data.thetaLength);break;case'CylinderGeometry':case'CylinderBufferGeometry':geometry=new Geometries[data.type](data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'ConeGeometry':case'ConeBufferGeometry':geometry=new Geometries[data.type](data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength);break;case'SphereGeometry':case'SphereBufferGeometry':geometry=new Geometries[data.type](data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength);break;case'DodecahedronGeometry':case'DodecahedronBufferGeometry':case'IcosahedronGeometry':case'IcosahedronBufferGeometry':case'OctahedronGeometry':case'OctahedronBufferGeometry':case'TetrahedronGeometry':case'TetrahedronBufferGeometry':geometry=new Geometries[data.type](data.radius,data.detail);break;case'RingGeometry':case'RingBufferGeometry':geometry=new Geometries[data.type](data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength);break;case'TorusGeometry':case'TorusBufferGeometry':geometry=new Geometries[data.type](data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc);break;case'TorusKnotGeometry':case'TorusKnotBufferGeometry':geometry=new Geometries[data.type](data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q);break;case'TubeGeometry':case'TubeBufferGeometry':// This only works for built-in curves (e.g. CatmullRomCurve3).
// User defined curves or instances of CurvePath will not be deserialized.
geometry=new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path),data.tubularSegments,data.radius,data.radialSegments,data.closed);break;case'LatheGeometry':case'LatheBufferGeometry':geometry=new Geometries[data.type](data.points,data.segments,data.phiStart,data.phiLength);break;case'PolyhedronGeometry':case'PolyhedronBufferGeometry':geometry=new Geometries[data.type](data.vertices,data.indices,data.radius,data.details);break;case'ShapeGeometry':case'ShapeBufferGeometry':var geometryShapes=[];for(var j=0,jl=data.shapes.length;j<jl;j++){var shape=shapes[data.shapes[j]];geometryShapes.push(shape);}geometry=new Geometries[data.type](geometryShapes,data.curveSegments);break;case'ExtrudeGeometry':case'ExtrudeBufferGeometry':var geometryShapes=[];for(var j=0,jl=data.shapes.length;j<jl;j++){var shape=shapes[data.shapes[j]];geometryShapes.push(shape);}var extrudePath=data.options.extrudePath;if(extrudePath!==undefined){data.options.extrudePath=new Curves[extrudePath.type]().fromJSON(extrudePath);}geometry=new Geometries[data.type](geometryShapes,data.options);break;case'BufferGeometry':case'InstancedBufferGeometry':geometry=bufferGeometryLoader.parse(data);break;case'Geometry':console.error('THREE.ObjectLoader: Loading "Geometry" is not supported anymore.');break;default:console.warn('THREE.ObjectLoader: Unsupported geometry type "'+data.type+'"');continue;}geometry.uuid=data.uuid;if(data.name!==undefined)geometry.name=data.name;if(geometry.isBufferGeometry===true&&data.userData!==undefined)geometry.userData=data.userData;geometries[data.uuid]=geometry;}}return geometries;},parseMaterials:function parseMaterials(json,textures){var cache={};// MultiMaterial
var materials={};if(json!==undefined){var loader=new MaterialLoader();loader.setTextures(textures);for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.type==='MultiMaterial'){// Deprecated
var array=[];for(var j=0;j<data.materials.length;j++){var material=data.materials[j];if(cache[material.uuid]===undefined){cache[material.uuid]=loader.parse(material);}array.push(cache[material.uuid]);}materials[data.uuid]=array;}else{if(cache[data.uuid]===undefined){cache[data.uuid]=loader.parse(data);}materials[data.uuid]=cache[data.uuid];}}}return materials;},parseAnimations:function parseAnimations(json){var animations=[];for(var i=0;i<json.length;i++){var data=json[i];var clip=AnimationClip.parse(data);if(data.uuid!==undefined)clip.uuid=data.uuid;animations.push(clip);}return animations;},parseImages:function parseImages(json,onLoad){var scope=this;var images={};function loadImage(url){scope.manager.itemStart(url);return loader.load(url,function(){scope.manager.itemEnd(url);},undefined,function(){scope.manager.itemError(url);scope.manager.itemEnd(url);});}if(json!==undefined&&json.length>0){var manager=new LoadingManager(onLoad);var loader=new ImageLoader(manager);loader.setCrossOrigin(this.crossOrigin);for(var i=0,il=json.length;i<il;i++){var image=json[i];var url=image.url;if((0,_isArray.default)(url)){// load array of images e.g CubeTexture
images[image.uuid]=[];for(var j=0,jl=url.length;j<jl;j++){var currentUrl=url[j];var path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(currentUrl)?currentUrl:scope.resourcePath+currentUrl;images[image.uuid].push(loadImage(path));}}else{// load single image
var path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(image.url)?image.url:scope.resourcePath+image.url;images[image.uuid]=loadImage(path);}}}return images;},parseTextures:function parseTextures(json,images){function parseConstant(value,type){if(typeof value==='number')return value;console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',value);return type[value];}var textures={};if(json!==undefined){for(var i=0,l=json.length;i<l;i++){var data=json[i];if(data.image===undefined){console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid);}if(images[data.image]===undefined){console.warn('THREE.ObjectLoader: Undefined image',data.image);}var texture;if((0,_isArray.default)(images[data.image])){texture=new CubeTexture(images[data.image]);}else{texture=new Texture(images[data.image]);}texture.needsUpdate=true;texture.uuid=data.uuid;if(data.name!==undefined)texture.name=data.name;if(data.mapping!==undefined)texture.mapping=parseConstant(data.mapping,TEXTURE_MAPPING);if(data.offset!==undefined)texture.offset.fromArray(data.offset);if(data.repeat!==undefined)texture.repeat.fromArray(data.repeat);if(data.center!==undefined)texture.center.fromArray(data.center);if(data.rotation!==undefined)texture.rotation=data.rotation;if(data.wrap!==undefined){texture.wrapS=parseConstant(data.wrap[0],TEXTURE_WRAPPING);texture.wrapT=parseConstant(data.wrap[1],TEXTURE_WRAPPING);}if(data.format!==undefined)texture.format=data.format;if(data.type!==undefined)texture.type=data.type;if(data.encoding!==undefined)texture.encoding=data.encoding;if(data.minFilter!==undefined)texture.minFilter=parseConstant(data.minFilter,TEXTURE_FILTER);if(data.magFilter!==undefined)texture.magFilter=parseConstant(data.magFilter,TEXTURE_FILTER);if(data.anisotropy!==undefined)texture.anisotropy=data.anisotropy;if(data.flipY!==undefined)texture.flipY=data.flipY;if(data.premultiplyAlpha!==undefined)texture.premultiplyAlpha=data.premultiplyAlpha;if(data.unpackAlignment!==undefined)texture.unpackAlignment=data.unpackAlignment;textures[data.uuid]=texture;}}return textures;},parseObject:function parseObject(data,geometries,materials){var object;function getGeometry(name){if(geometries[name]===undefined){console.warn('THREE.ObjectLoader: Undefined geometry',name);}return geometries[name];}function getMaterial(name){if(name===undefined)return undefined;if((0,_isArray.default)(name)){var array=[];for(var i=0,l=name.length;i<l;i++){var uuid=name[i];if(materials[uuid]===undefined){console.warn('THREE.ObjectLoader: Undefined material',uuid);}array.push(materials[uuid]);}return array;}if(materials[name]===undefined){console.warn('THREE.ObjectLoader: Undefined material',name);}return materials[name];}switch(data.type){case'Scene':object=new Scene();if(data.background!==undefined){if((0,_isInteger.default)(data.background)){object.background=new Color(data.background);}}if(data.fog!==undefined){if(data.fog.type==='Fog'){object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far);}else if(data.fog.type==='FogExp2'){object.fog=new FogExp2(data.fog.color,data.fog.density);}}break;case'PerspectiveCamera':object=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);if(data.focus!==undefined)object.focus=data.focus;if(data.zoom!==undefined)object.zoom=data.zoom;if(data.filmGauge!==undefined)object.filmGauge=data.filmGauge;if(data.filmOffset!==undefined)object.filmOffset=data.filmOffset;if(data.view!==undefined)object.view=(0,_assign.default)({},data.view);break;case'OrthographicCamera':object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);if(data.zoom!==undefined)object.zoom=data.zoom;if(data.view!==undefined)object.view=(0,_assign.default)({},data.view);break;case'AmbientLight':object=new AmbientLight(data.color,data.intensity);break;case'DirectionalLight':object=new DirectionalLight(data.color,data.intensity);break;case'PointLight':object=new PointLight(data.color,data.intensity,data.distance,data.decay);break;case'RectAreaLight':object=new RectAreaLight(data.color,data.intensity,data.width,data.height);break;case'SpotLight':object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);break;case'HemisphereLight':object=new HemisphereLight(data.color,data.groundColor,data.intensity);break;case'SkinnedMesh':console.warn('THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.');case'Mesh':var geometry=getGeometry(data.geometry);var material=getMaterial(data.material);object=new Mesh(geometry,material);break;case'InstancedMesh':var geometry=getGeometry(data.geometry);var material=getMaterial(data.material);var count=data.count;var instanceMatrix=data.instanceMatrix;object=new InstancedMesh(geometry,material,count);object.instanceMatrix=new BufferAttribute(new Float32Array(instanceMatrix.array),16);break;case'LOD':object=new LOD();break;case'Line':object=new Line(getGeometry(data.geometry),getMaterial(data.material),data.mode);break;case'LineLoop':object=new LineLoop(getGeometry(data.geometry),getMaterial(data.material));break;case'LineSegments':object=new LineSegments(getGeometry(data.geometry),getMaterial(data.material));break;case'PointCloud':case'Points':object=new Points(getGeometry(data.geometry),getMaterial(data.material));break;case'Sprite':object=new Sprite(getMaterial(data.material));break;case'Group':object=new Group();break;default:object=new Object3D();}object.uuid=data.uuid;if(data.name!==undefined)object.name=data.name;if(data.matrix!==undefined){object.matrix.fromArray(data.matrix);if(data.matrixAutoUpdate!==undefined)object.matrixAutoUpdate=data.matrixAutoUpdate;if(object.matrixAutoUpdate)object.matrix.decompose(object.position,object.quaternion,object.scale);}else{if(data.position!==undefined)object.position.fromArray(data.position);if(data.rotation!==undefined)object.rotation.fromArray(data.rotation);if(data.quaternion!==undefined)object.quaternion.fromArray(data.quaternion);if(data.scale!==undefined)object.scale.fromArray(data.scale);}if(data.castShadow!==undefined)object.castShadow=data.castShadow;if(data.receiveShadow!==undefined)object.receiveShadow=data.receiveShadow;if(data.shadow){if(data.shadow.bias!==undefined)object.shadow.bias=data.shadow.bias;if(data.shadow.radius!==undefined)object.shadow.radius=data.shadow.radius;if(data.shadow.mapSize!==undefined)object.shadow.mapSize.fromArray(data.shadow.mapSize);if(data.shadow.camera!==undefined)object.shadow.camera=this.parseObject(data.shadow.camera);}if(data.visible!==undefined)object.visible=data.visible;if(data.frustumCulled!==undefined)object.frustumCulled=data.frustumCulled;if(data.renderOrder!==undefined)object.renderOrder=data.renderOrder;if(data.userData!==undefined)object.userData=data.userData;if(data.layers!==undefined)object.layers.mask=data.layers;if(data.children!==undefined){var children=data.children;for(var i=0;i<children.length;i++){object.add(this.parseObject(children[i],geometries,materials));}}if(data.type==='LOD'){if(data.autoUpdate!==undefined)object.autoUpdate=data.autoUpdate;var levels=data.levels;for(var l=0;l<levels.length;l++){var level=levels[l];var child=object.getObjectByProperty('uuid',level.object);if(child!==undefined){object.addLevel(child,level.distance);}}}return object;}});var TEXTURE_MAPPING={UVMapping:UVMapping,CubeReflectionMapping:CubeReflectionMapping,CubeRefractionMapping:CubeRefractionMapping,EquirectangularReflectionMapping:EquirectangularReflectionMapping,EquirectangularRefractionMapping:EquirectangularRefractionMapping,SphericalReflectionMapping:SphericalReflectionMapping,CubeUVReflectionMapping:CubeUVReflectionMapping,CubeUVRefractionMapping:CubeUVRefractionMapping};var TEXTURE_WRAPPING={RepeatWrapping:RepeatWrapping,ClampToEdgeWrapping:ClampToEdgeWrapping,MirroredRepeatWrapping:MirroredRepeatWrapping};var TEXTURE_FILTER={NearestFilter:NearestFilter,NearestMipmapNearestFilter:NearestMipmapNearestFilter,NearestMipmapLinearFilter:NearestMipmapLinearFilter,LinearFilter:LinearFilter,LinearMipmapNearestFilter:LinearMipmapNearestFilter,LinearMipmapLinearFilter:LinearMipmapLinearFilter};/**
 * @author thespite / http://clicktorelease.com/
 */function ImageBitmapLoader(manager){if(typeof createImageBitmap==='undefined'){console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');}if(typeof fetch==='undefined'){console.warn('THREE.ImageBitmapLoader: fetch() not supported.');}Loader.call(this,manager);this.options=undefined;}ImageBitmapLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:ImageBitmapLoader,setOptions:function setOptions(options){this.options=options;return this;},load:function load(url,onLoad,onProgress,onError){if(url===undefined)url='';if(this.path!==undefined)url=this.path+url;url=this.manager.resolveURL(url);var scope=this;var cached=Cache.get(url);if(cached!==undefined){scope.manager.itemStart(url);setTimeout(function(){if(onLoad)onLoad(cached);scope.manager.itemEnd(url);},0);return cached;}fetch(url).then(function(res){return res.blob();}).then(function(blob){if(scope.options===undefined){// Workaround for FireFox. It causes an error if you pass options.
return createImageBitmap(blob);}else{return createImageBitmap(blob,scope.options);}}).then(function(imageBitmap){Cache.add(url,imageBitmap);if(onLoad)onLoad(imageBitmap);scope.manager.itemEnd(url);}).catch(function(e){if(onError)onError(e);scope.manager.itemError(url);scope.manager.itemEnd(url);});scope.manager.itemStart(url);}});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
 **/function ShapePath(){this.type='ShapePath';this.color=new Color();this.subPaths=[];this.currentPath=null;}(0,_assign.default)(ShapePath.prototype,{moveTo:function moveTo(x,y){this.currentPath=new Path();this.subPaths.push(this.currentPath);this.currentPath.moveTo(x,y);return this;},lineTo:function lineTo(x,y){this.currentPath.lineTo(x,y);return this;},quadraticCurveTo:function quadraticCurveTo(aCPx,aCPy,aX,aY){this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);return this;},bezierCurveTo:function bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY);return this;},splineThru:function splineThru(pts){this.currentPath.splineThru(pts);return this;},toShapes:function toShapes(isCCW,noHoles){function toShapesNoHoles(inSubpaths){var shapes=[];for(var i=0,l=inSubpaths.length;i<l;i++){var tmpPath=inSubpaths[i];var tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);}return shapes;}function isPointInsidePolygon(inPt,inPolygon){var polyLen=inPolygon.length;// inPt on polygon contour => immediate success    or
// toggling of inside/outside at every single! intersection point of an edge
//  with the horizontal line through inPt, left of inPt
//  not counting lowerY endpoints of edges and whole edges on that line
var inside=false;for(var p=polyLen-1,q=0;q<polyLen;p=q++){var edgeLowPt=inPolygon[p];var edgeHighPt=inPolygon[q];var edgeDx=edgeHighPt.x-edgeLowPt.x;var edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>_epsilon.default){// not parallel
if(edgeDy<0){edgeLowPt=inPolygon[q];edgeDx=-edgeDx;edgeHighPt=inPolygon[p];edgeDy=-edgeDy;}if(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y)continue;if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return true;// inPt is on contour ?
// continue;				// no intersection or edgeLowPt => doesn't count !!!
}else{var perpEdge=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(perpEdge===0)return true;// inPt is on contour ?
if(perpEdge<0)continue;inside=!inside;// true intersection left of inPt
}}else{// parallel or collinear
if(inPt.y!==edgeLowPt.y)continue;// parallel
// edge lies on the same horizontal line as inPt
if(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=edgeHighPt.x)return true;// inPt: Point on contour !
// continue;
}}return inside;}var isClockWise=ShapeUtils.isClockWise;var subPaths=this.subPaths;if(subPaths.length===0)return[];if(noHoles===true)return toShapesNoHoles(subPaths);var solid,tmpPath,tmpShape,shapes=[];if(subPaths.length===1){tmpPath=subPaths[0];tmpShape=new Shape();tmpShape.curves=tmpPath.curves;shapes.push(tmpShape);return shapes;}var holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;// console.log("Holes first", holesFirst);
var betterShapeHoles=[];var newShapes=[];var newShapeHoles=[];var mainIdx=0;var tmpPoints;newShapes[mainIdx]=undefined;newShapeHoles[mainIdx]=[];for(var i=0,l=subPaths.length;i<l;i++){tmpPath=subPaths[i];tmpPoints=tmpPath.getPoints();solid=isClockWise(tmpPoints);solid=isCCW?!solid:solid;if(solid){if(!holesFirst&&newShapes[mainIdx])mainIdx++;newShapes[mainIdx]={s:new Shape(),p:tmpPoints};newShapes[mainIdx].s.curves=tmpPath.curves;if(holesFirst)mainIdx++;newShapeHoles[mainIdx]=[];//console.log('cw', i);
}else{newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]});//console.log('ccw', i);
}}// only Holes? -> probably all Shapes with wrong orientation
if(!newShapes[0])return toShapesNoHoles(subPaths);if(newShapes.length>1){var ambiguous=false;var toChange=[];for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){betterShapeHoles[sIdx]=[];}for(var sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++){var sho=newShapeHoles[sIdx];for(var hIdx=0;hIdx<sho.length;hIdx++){var ho=sho[hIdx];var hole_unassigned=true;for(var s2Idx=0;s2Idx<newShapes.length;s2Idx++){if(isPointInsidePolygon(ho.p,newShapes[s2Idx].p)){if(sIdx!==s2Idx)toChange.push({froms:sIdx,tos:s2Idx,hole:hIdx});if(hole_unassigned){hole_unassigned=false;betterShapeHoles[s2Idx].push(ho);}else{ambiguous=true;}}}if(hole_unassigned){betterShapeHoles[sIdx].push(ho);}}}// console.log("ambiguous: ", ambiguous);
if(toChange.length>0){// console.log("to change: ", toChange);
if(!ambiguous)newShapeHoles=betterShapeHoles;}}var tmpHoles;for(var i=0,il=newShapes.length;i<il;i++){tmpShape=newShapes[i].s;shapes.push(tmpShape);tmpHoles=newShapeHoles[i];for(var j=0,jl=tmpHoles.length;j<jl;j++){tmpShape.holes.push(tmpHoles[j].h);}}//console.log("shape", shapes);
return shapes;}});/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */function Font(data){this.type='Font';this.data=data;}(0,_assign.default)(Font.prototype,{isFont:true,generateShapes:function generateShapes(text,size){if(size===undefined)size=100;var shapes=[];var paths=createPaths(text,size,this.data);for(var p=0,pl=paths.length;p<pl;p++){Array.prototype.push.apply(shapes,paths[p].toShapes());}return shapes;}});function createPaths(text,size,data){var chars=_from.default?(0,_from.default)(text):String(text).split('');// workaround for IE11, see #13988
var scale=size/data.resolution;var line_height=(data.boundingBox.yMax-data.boundingBox.yMin+data.underlineThickness)*scale;var paths=[];var offsetX=0,offsetY=0;for(var i=0;i<chars.length;i++){var char=chars[i];if(char==='\n'){offsetX=0;offsetY-=line_height;}else{var ret=createPath(char,scale,offsetX,offsetY,data);offsetX+=ret.offsetX;paths.push(ret.path);}}return paths;}function createPath(char,scale,offsetX,offsetY,data){var glyph=data.glyphs[char]||data.glyphs['?'];if(!glyph){console.error('THREE.Font: character "'+char+'" does not exists in font family '+data.familyName+'.');return;}var path=new ShapePath();var x,y,cpx,cpy,cpx1,cpy1,cpx2,cpy2;if(glyph.o){var outline=glyph._cachedOutline||(glyph._cachedOutline=glyph.o.split(' '));for(var i=0,l=outline.length;i<l;){var action=outline[i++];switch(action){case'm':// moveTo
x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.moveTo(x,y);break;case'l':// lineTo
x=outline[i++]*scale+offsetX;y=outline[i++]*scale+offsetY;path.lineTo(x,y);break;case'q':// quadraticCurveTo
cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;path.quadraticCurveTo(cpx1,cpy1,cpx,cpy);break;case'b':// bezierCurveTo
cpx=outline[i++]*scale+offsetX;cpy=outline[i++]*scale+offsetY;cpx1=outline[i++]*scale+offsetX;cpy1=outline[i++]*scale+offsetY;cpx2=outline[i++]*scale+offsetX;cpy2=outline[i++]*scale+offsetY;path.bezierCurveTo(cpx1,cpy1,cpx2,cpy2,cpx,cpy);break;}}}return{offsetX:glyph.ha*scale,path:path};}/**
 * @author mrdoob / http://mrdoob.com/
 */function FontLoader(manager){Loader.call(this,manager);}FontLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:FontLoader,load:function load(url,onLoad,onProgress,onError){var scope=this;var loader=new FileLoader(this.manager);loader.setPath(this.path);loader.load(url,function(text){var json;try{json=JSON.parse(text);}catch(e){console.warn('THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.');json=JSON.parse(text.substring(65,text.length-2));}var font=scope.parse(json);if(onLoad)onLoad(font);},onProgress,onError);},parse:function parse(json){return new Font(json);}});/**
 * @author mrdoob / http://mrdoob.com/
 */var _context;var AudioContext={getContext:function getContext(){if(_context===undefined){_context=new(window.AudioContext||window.webkitAudioContext)();}return _context;},setContext:function setContext(value){_context=value;}};/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */exports.AudioContext=AudioContext;function AudioLoader(manager){Loader.call(this,manager);}AudioLoader.prototype=(0,_assign.default)((0,_create.default)(Loader.prototype),{constructor:AudioLoader,load:function load(url,onLoad,onProgress,onError){var loader=new FileLoader(this.manager);loader.setResponseType('arraybuffer');loader.setPath(this.path);loader.load(url,function(buffer){// Create a copy of the buffer. The `decodeAudioData` method
// detaches the buffer when complete, preventing reuse.
var bufferCopy=buffer.slice(0);var context=AudioContext.getContext();context.decodeAudioData(bufferCopy,function(audioBuffer){onLoad(audioBuffer);});},onProgress,onError);}});/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */ // 3-band SH defined by 9 coefficients
function SphericalHarmonics3(){this.coefficients=[];for(var i=0;i<9;i++){this.coefficients.push(new Vector3());}}(0,_assign.default)(SphericalHarmonics3.prototype,{isSphericalHarmonics3:true,set:function set(coefficients){for(var i=0;i<9;i++){this.coefficients[i].copy(coefficients[i]);}return this;},zero:function zero(){for(var i=0;i<9;i++){this.coefficients[i].set(0,0,0);}return this;},// get the radiance in the direction of the normal
// target is a Vector3
getAt:function getAt(normal,target){// normal is assumed to be unit length
var x=normal.x,y=normal.y,z=normal.z;var coeff=this.coefficients;// band 0
target.copy(coeff[0]).multiplyScalar(0.282095);// band 1
target.addScaledVector(coeff[1],0.488603*y);target.addScaledVector(coeff[2],0.488603*z);target.addScaledVector(coeff[3],0.488603*x);// band 2
target.addScaledVector(coeff[4],1.092548*(x*y));target.addScaledVector(coeff[5],1.092548*(y*z));target.addScaledVector(coeff[6],0.315392*(3.0*z*z-1.0));target.addScaledVector(coeff[7],1.092548*(x*z));target.addScaledVector(coeff[8],0.546274*(x*x-y*y));return target;},// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
// target is a Vector3
// https://graphics.stanford.edu/papers/envmap/envmap.pdf
getIrradianceAt:function getIrradianceAt(normal,target){// normal is assumed to be unit length
var x=normal.x,y=normal.y,z=normal.z;var coeff=this.coefficients;// band 0
target.copy(coeff[0]).multiplyScalar(0.886227);// π * 0.282095
// band 1
target.addScaledVector(coeff[1],2.0*0.511664*y);// ( 2 * π / 3 ) * 0.488603
target.addScaledVector(coeff[2],2.0*0.511664*z);target.addScaledVector(coeff[3],2.0*0.511664*x);// band 2
target.addScaledVector(coeff[4],2.0*0.429043*x*y);// ( π / 4 ) * 1.092548
target.addScaledVector(coeff[5],2.0*0.429043*y*z);target.addScaledVector(coeff[6],0.743125*z*z-0.247708);// ( π / 4 ) * 0.315392 * 3
target.addScaledVector(coeff[7],2.0*0.429043*x*z);target.addScaledVector(coeff[8],0.429043*(x*x-y*y));// ( π / 4 ) * 0.546274
return target;},add:function add(sh){for(var i=0;i<9;i++){this.coefficients[i].add(sh.coefficients[i]);}return this;},addScaledSH:function addScaledSH(sh,s){for(var i=0;i<9;i++){this.coefficients[i].addScaledVector(sh.coefficients[i],s);}return this;},scale:function scale(s){for(var i=0;i<9;i++){this.coefficients[i].multiplyScalar(s);}return this;},lerp:function lerp(sh,alpha){for(var i=0;i<9;i++){this.coefficients[i].lerp(sh.coefficients[i],alpha);}return this;},equals:function equals(sh){for(var i=0;i<9;i++){if(!this.coefficients[i].equals(sh.coefficients[i])){return false;}}return true;},copy:function copy(sh){return this.set(sh.coefficients);},clone:function clone(){return new this.constructor().copy(this);},fromArray:function fromArray(array,offset){if(offset===undefined)offset=0;var coefficients=this.coefficients;for(var i=0;i<9;i++){coefficients[i].fromArray(array,offset+i*3);}return this;},toArray:function toArray(array,offset){if(array===undefined)array=[];if(offset===undefined)offset=0;var coefficients=this.coefficients;for(var i=0;i<9;i++){coefficients[i].toArray(array,offset+i*3);}return array;}});(0,_assign.default)(SphericalHarmonics3,{// evaluate the basis functions
// shBasis is an Array[ 9 ]
getBasisAt:function getBasisAt(normal,shBasis){// normal is assumed to be unit length
var x=normal.x,y=normal.y,z=normal.z;// band 0
shBasis[0]=0.282095;// band 1
shBasis[1]=0.488603*y;shBasis[2]=0.488603*z;shBasis[3]=0.488603*x;// band 2
shBasis[4]=1.092548*x*y;shBasis[5]=1.092548*y*z;shBasis[6]=0.315392*(3*z*z-1);shBasis[7]=1.092548*x*z;shBasis[8]=0.546274*(x*x-y*y);}});/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * A LightProbe is a source of indirect-diffuse light
 */function LightProbe(sh,intensity){Light.call(this,undefined,intensity);this.sh=sh!==undefined?sh:new SphericalHarmonics3();}LightProbe.prototype=(0,_assign.default)((0,_create.default)(Light.prototype),{constructor:LightProbe,isLightProbe:true,copy:function copy(source){Light.prototype.copy.call(this,source);this.sh.copy(source.sh);this.intensity=source.intensity;return this;},toJSON:function toJSON(meta){var data=Light.prototype.toJSON.call(this,meta);// data.sh = this.sh.toArray(); // todo
return data;}});/**
 * @author WestLangley / http://github.com/WestLangley
 */function HemisphereLightProbe(skyColor,groundColor,intensity){LightProbe.call(this,undefined,intensity);var color1=new Color().set(skyColor);var color2=new Color().set(groundColor);var sky=new Vector3(color1.r,color1.g,color1.b);var ground=new Vector3(color2.r,color2.g,color2.b);// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
var c0=Math.sqrt(Math.PI);var c1=c0*Math.sqrt(0.75);this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);}HemisphereLightProbe.prototype=(0,_assign.default)((0,_create.default)(LightProbe.prototype),{constructor:HemisphereLightProbe,isHemisphereLightProbe:true,copy:function copy(source){// modifying colors not currently supported
LightProbe.prototype.copy.call(this,source);return this;},toJSON:function toJSON(meta){var data=LightProbe.prototype.toJSON.call(this,meta);// data.sh = this.sh.toArray(); // todo
return data;}});/**
 * @author WestLangley / http://github.com/WestLangley
 */function AmbientLightProbe(color,intensity){LightProbe.call(this,undefined,intensity);var color1=new Color().set(color);// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
this.sh.coefficients[0].set(color1.r,color1.g,color1.b).multiplyScalar(2*Math.sqrt(Math.PI));}AmbientLightProbe.prototype=(0,_assign.default)((0,_create.default)(LightProbe.prototype),{constructor:AmbientLightProbe,isAmbientLightProbe:true,copy:function copy(source){// modifying color not currently supported
LightProbe.prototype.copy.call(this,source);return this;},toJSON:function toJSON(meta){var data=LightProbe.prototype.toJSON.call(this,meta);// data.sh = this.sh.toArray(); // todo
return data;}});var _eyeRight=new Matrix4();var _eyeLeft=new Matrix4();/**
 * @author mrdoob / http://mrdoob.com/
 */function StereoCamera(){this.type='StereoCamera';this.aspect=1;this.eyeSep=0.064;this.cameraL=new PerspectiveCamera();this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=false;this.cameraR=new PerspectiveCamera();this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=false;this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null};}(0,_assign.default)(StereoCamera.prototype,{update:function update(camera){var cache=this._cache;var needsUpdate=cache.focus!==camera.focus||cache.fov!==camera.fov||cache.aspect!==camera.aspect*this.aspect||cache.near!==camera.near||cache.far!==camera.far||cache.zoom!==camera.zoom||cache.eyeSep!==this.eyeSep;if(needsUpdate){cache.focus=camera.focus;cache.fov=camera.fov;cache.aspect=camera.aspect*this.aspect;cache.near=camera.near;cache.far=camera.far;cache.zoom=camera.zoom;cache.eyeSep=this.eyeSep;// Off-axis stereoscopic effect based on
// http://paulbourke.net/stereographics/stereorender/
var projectionMatrix=camera.projectionMatrix.clone();var eyeSepHalf=cache.eyeSep/2;var eyeSepOnProjection=eyeSepHalf*cache.near/cache.focus;var ymax=cache.near*Math.tan(MathUtils.DEG2RAD*cache.fov*0.5)/cache.zoom;var xmin,xmax;// translate xOffset
_eyeLeft.elements[12]=-eyeSepHalf;_eyeRight.elements[12]=eyeSepHalf;// for left eye
xmin=-ymax*cache.aspect+eyeSepOnProjection;xmax=ymax*cache.aspect+eyeSepOnProjection;projectionMatrix.elements[0]=2*cache.near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraL.projectionMatrix.copy(projectionMatrix);// for right eye
xmin=-ymax*cache.aspect-eyeSepOnProjection;xmax=ymax*cache.aspect-eyeSepOnProjection;projectionMatrix.elements[0]=2*cache.near/(xmax-xmin);projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin);this.cameraR.projectionMatrix.copy(projectionMatrix);}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);}});/**
 * @author alteredq / http://alteredqualia.com/
 */function Clock(autoStart){this.autoStart=autoStart!==undefined?autoStart:true;this.startTime=0;this.oldTime=0;this.elapsedTime=0;this.running=false;}(0,_assign.default)(Clock.prototype,{start:function start(){this.startTime=(typeof performance==='undefined'?Date:performance).now();// see #10732
this.oldTime=this.startTime;this.elapsedTime=0;this.running=true;},stop:function stop(){this.getElapsedTime();this.running=false;this.autoStart=false;},getElapsedTime:function getElapsedTime(){this.getDelta();return this.elapsedTime;},getDelta:function getDelta(){var diff=0;if(this.autoStart&&!this.running){this.start();return 0;}if(this.running){var newTime=(typeof performance==='undefined'?Date:performance).now();diff=(newTime-this.oldTime)/1000;this.oldTime=newTime;this.elapsedTime+=diff;}return diff;}});/**
 * @author mrdoob / http://mrdoob.com/
 */var _position$2=new Vector3();var _quaternion$3=new Quaternion();var _scale$1=new Vector3();var _orientation=new Vector3();function AudioListener(){Object3D.call(this);this.type='AudioListener';this.context=AudioContext.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null;this.timeDelta=0;// private
this._clock=new Clock();}AudioListener.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:AudioListener,getInput:function getInput(){return this.gain;},removeFilter:function removeFilter(){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);this.gain.connect(this.context.destination);this.filter=null;}return this;},getFilter:function getFilter(){return this.filter;},setFilter:function setFilter(value){if(this.filter!==null){this.gain.disconnect(this.filter);this.filter.disconnect(this.context.destination);}else{this.gain.disconnect(this.context.destination);}this.filter=value;this.gain.connect(this.filter);this.filter.connect(this.context.destination);return this;},getMasterVolume:function getMasterVolume(){return this.gain.gain.value;},setMasterVolume:function setMasterVolume(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);return this;},updateMatrixWorld:function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);var listener=this.context.listener;var up=this.up;this.timeDelta=this._clock.getDelta();this.matrixWorld.decompose(_position$2,_quaternion$3,_scale$1);_orientation.set(0,0,-1).applyQuaternion(_quaternion$3);if(listener.positionX){// code path for Chrome (see #14393)
var endTime=this.context.currentTime+this.timeDelta;listener.positionX.linearRampToValueAtTime(_position$2.x,endTime);listener.positionY.linearRampToValueAtTime(_position$2.y,endTime);listener.positionZ.linearRampToValueAtTime(_position$2.z,endTime);listener.forwardX.linearRampToValueAtTime(_orientation.x,endTime);listener.forwardY.linearRampToValueAtTime(_orientation.y,endTime);listener.forwardZ.linearRampToValueAtTime(_orientation.z,endTime);listener.upX.linearRampToValueAtTime(up.x,endTime);listener.upY.linearRampToValueAtTime(up.y,endTime);listener.upZ.linearRampToValueAtTime(up.z,endTime);}else{listener.setPosition(_position$2.x,_position$2.y,_position$2.z);listener.setOrientation(_orientation.x,_orientation.y,_orientation.z,up.x,up.y,up.z);}}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */function Audio(listener){Object3D.call(this);this.type='Audio';this.listener=listener;this.context=listener.context;this.gain=this.context.createGain();this.gain.connect(listener.getInput());this.autoplay=false;this.buffer=null;this.detune=0;this.loop=false;this.loopStart=0;this.loopEnd=0;this.offset=0;this.duration=undefined;this.playbackRate=1;this.isPlaying=false;this.hasPlaybackControl=true;this.sourceType='empty';this._startedAt=0;this._pausedAt=0;this.filters=[];}Audio.prototype=(0,_assign.default)((0,_create.default)(Object3D.prototype),{constructor:Audio,getOutput:function getOutput(){return this.gain;},setNodeSource:function setNodeSource(audioNode){this.hasPlaybackControl=false;this.sourceType='audioNode';this.source=audioNode;this.connect();return this;},setMediaElementSource:function setMediaElementSource(mediaElement){this.hasPlaybackControl=false;this.sourceType='mediaNode';this.source=this.context.createMediaElementSource(mediaElement);this.connect();return this;},setMediaStreamSource:function setMediaStreamSource(mediaStream){this.hasPlaybackControl=false;this.sourceType='mediaStreamNode';this.source=this.context.createMediaStreamSource(mediaStream);this.connect();return this;},setBuffer:function setBuffer(audioBuffer){this.buffer=audioBuffer;this.sourceType='buffer';if(this.autoplay)this.play();return this;},play:function play(delay){if(delay===undefined)delay=0;if(this.isPlaying===true){console.warn('THREE.Audio: Audio is already playing.');return;}if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this._startedAt=this.context.currentTime+delay;var source=this.context.createBufferSource();source.buffer=this.buffer;source.loop=this.loop;source.loopStart=this.loopStart;source.loopEnd=this.loopEnd;source.onended=this.onEnded.bind(this);source.start(this._startedAt,this._pausedAt+this.offset,this.duration);this.isPlaying=true;this.source=source;this.setDetune(this.detune);this.setPlaybackRate(this.playbackRate);return this.connect();},pause:function pause(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}if(this.isPlaying===true){this._pausedAt+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate;this.source.stop();this.source.onended=null;this.isPlaying=false;}return this;},stop:function stop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this._pausedAt=0;this.source.stop();this.source.onended=null;this.isPlaying=false;return this;},connect:function connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].connect(this.filters[i]);}this.filters[this.filters.length-1].connect(this.getOutput());}else{this.source.connect(this.getOutput());}return this;},disconnect:function disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(var i=1,l=this.filters.length;i<l;i++){this.filters[i-1].disconnect(this.filters[i]);}this.filters[this.filters.length-1].disconnect(this.getOutput());}else{this.source.disconnect(this.getOutput());}return this;},getFilters:function getFilters(){return this.filters;},setFilters:function setFilters(value){if(!value)value=[];if(this.isPlaying===true){this.disconnect();this.filters=value;this.connect();}else{this.filters=value;}return this;},setDetune:function setDetune(value){this.detune=value;if(this.source.detune===undefined)return;// only set detune when available
if(this.isPlaying===true){this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,0.01);}return this;},getDetune:function getDetune(){return this.detune;},getFilter:function getFilter(){return this.getFilters()[0];},setFilter:function setFilter(filter){return this.setFilters(filter?[filter]:[]);},setPlaybackRate:function setPlaybackRate(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.playbackRate=value;if(this.isPlaying===true){this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,0.01);}return this;},getPlaybackRate:function getPlaybackRate(){return this.playbackRate;},onEnded:function onEnded(){this.isPlaying=false;},getLoop:function getLoop(){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return false;}return this.loop;},setLoop:function setLoop(value){if(this.hasPlaybackControl===false){console.warn('THREE.Audio: this Audio has no playback control.');return;}this.loop=value;if(this.isPlaying===true){this.source.loop=this.loop;}return this;},setLoopStart:function setLoopStart(value){this.loopStart=value;return this;},setLoopEnd:function setLoopEnd(value){this.loopEnd=value;return this;},getVolume:function getVolume(){return this.gain.gain.value;},setVolume:function setVolume(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,0.01);return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 */var _position$3=new Vector3();var _quaternion$4=new Quaternion();var _scale$2=new Vector3();var _orientation$1=new Vector3();function PositionalAudio(listener){Audio.call(this,listener);this.panner=this.context.createPanner();this.panner.panningModel='HRTF';this.panner.connect(this.gain);}PositionalAudio.prototype=(0,_assign.default)((0,_create.default)(Audio.prototype),{constructor:PositionalAudio,getOutput:function getOutput(){return this.panner;},getRefDistance:function getRefDistance(){return this.panner.refDistance;},setRefDistance:function setRefDistance(value){this.panner.refDistance=value;return this;},getRolloffFactor:function getRolloffFactor(){return this.panner.rolloffFactor;},setRolloffFactor:function setRolloffFactor(value){this.panner.rolloffFactor=value;return this;},getDistanceModel:function getDistanceModel(){return this.panner.distanceModel;},setDistanceModel:function setDistanceModel(value){this.panner.distanceModel=value;return this;},getMaxDistance:function getMaxDistance(){return this.panner.maxDistance;},setMaxDistance:function setMaxDistance(value){this.panner.maxDistance=value;return this;},setDirectionalCone:function setDirectionalCone(coneInnerAngle,coneOuterAngle,coneOuterGain){this.panner.coneInnerAngle=coneInnerAngle;this.panner.coneOuterAngle=coneOuterAngle;this.panner.coneOuterGain=coneOuterGain;return this;},updateMatrixWorld:function updateMatrixWorld(force){Object3D.prototype.updateMatrixWorld.call(this,force);if(this.hasPlaybackControl===true&&this.isPlaying===false)return;this.matrixWorld.decompose(_position$3,_quaternion$4,_scale$2);_orientation$1.set(0,0,1).applyQuaternion(_quaternion$4);var panner=this.panner;if(panner.positionX){// code path for Chrome and Firefox (see #14393)
var endTime=this.context.currentTime+this.listener.timeDelta;panner.positionX.linearRampToValueAtTime(_position$3.x,endTime);panner.positionY.linearRampToValueAtTime(_position$3.y,endTime);panner.positionZ.linearRampToValueAtTime(_position$3.z,endTime);panner.orientationX.linearRampToValueAtTime(_orientation$1.x,endTime);panner.orientationY.linearRampToValueAtTime(_orientation$1.y,endTime);panner.orientationZ.linearRampToValueAtTime(_orientation$1.z,endTime);}else{panner.setPosition(_position$3.x,_position$3.y,_position$3.z);panner.setOrientation(_orientation$1.x,_orientation$1.y,_orientation$1.z);}}});/**
 * @author mrdoob / http://mrdoob.com/
 */function AudioAnalyser(audio,fftSize){this.analyser=audio.context.createAnalyser();this.analyser.fftSize=fftSize!==undefined?fftSize:2048;this.data=new Uint8Array(this.analyser.frequencyBinCount);audio.getOutput().connect(this.analyser);}(0,_assign.default)(AudioAnalyser.prototype,{getFrequencyData:function getFrequencyData(){this.analyser.getByteFrequencyData(this.data);return this.data;},getAverageFrequency:function getAverageFrequency(){var value=0,data=this.getFrequencyData();for(var i=0;i<data.length;i++){value+=data[i];}return value/data.length;}});/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function PropertyMixer(binding,typeName,valueSize){this.binding=binding;this.valueSize=valueSize;var bufferType=Float64Array,mixFunction;switch(typeName){case'quaternion':mixFunction=this._slerp;break;case'string':case'bool':bufferType=Array;mixFunction=this._select;break;default:mixFunction=this._lerp;}this.buffer=new bufferType(valueSize*4);// layout: [ incoming | accu0 | accu1 | orig ]
//
// interpolators can use .buffer as their .result
// the data then goes to 'incoming'
//
// 'accu0' and 'accu1' are used frame-interleaved for
// the cumulative result and are compared to detect
// changes
//
// 'orig' stores the original state of the property
this._mixBufferRegion=mixFunction;this.cumulativeWeight=0;this.useCount=0;this.referenceCount=0;}(0,_assign.default)(PropertyMixer.prototype,{// accumulate data in the 'incoming' region into 'accu<i>'
accumulate:function accumulate(accuIndex,weight){// note: happily accumulating nothing when weight = 0, the caller knows
// the weight and shouldn't have made the call in the first place
var buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride,currentWeight=this.cumulativeWeight;if(currentWeight===0){// accuN := incoming * weight
for(var i=0;i!==stride;++i){buffer[offset+i]=buffer[i];}currentWeight=weight;}else{// accuN := accuN + incoming * weight
currentWeight+=weight;var mix=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix,stride);}this.cumulativeWeight=currentWeight;},// apply the state of 'accu<i>' to the binding when accus differ
apply:function apply(accuIndex){var stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,binding=this.binding;this.cumulativeWeight=0;if(weight<1){// accuN := accuN + original * ( 1 - cumulativeWeight )
var originalValueOffset=stride*3;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride);}for(var i=stride,e=stride+stride;i!==e;++i){if(buffer[i]!==buffer[i+stride]){// value has changed -> update scene graph
binding.setValue(buffer,offset);break;}}},// remember the state of the bound property and copy it to both accus
saveOriginalState:function saveOriginalState(){var binding=this.binding;var buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*3;binding.getValue(buffer,originalValueOffset);// accu[0..1] := orig -- initially detect changes against the original
for(var i=stride,e=originalValueOffset;i!==e;++i){buffer[i]=buffer[originalValueOffset+i%stride];}this.cumulativeWeight=0;},// apply the state previously taken via 'saveOriginalState' to the binding
restoreOriginalState:function restoreOriginalState(){var originalValueOffset=this.valueSize*3;this.binding.setValue(this.buffer,originalValueOffset);},// mix functions
_select:function _select(buffer,dstOffset,srcOffset,t,stride){if(t>=0.5){for(var i=0;i!==stride;++i){buffer[dstOffset+i]=buffer[srcOffset+i];}}},_slerp:function _slerp(buffer,dstOffset,srcOffset,t){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t);},_lerp:function _lerp(buffer,dstOffset,srcOffset,t,stride){var s=1-t;for(var i=0;i!==stride;++i){var j=dstOffset+i;buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t;}}});/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */ // Characters [].:/ are reserved for track binding syntax.
var _RESERVED_CHARS_RE='\\[\\]\\.:\\/';var _reservedRe=new RegExp('['+_RESERVED_CHARS_RE+']','g');// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
var _wordChar='[^'+_RESERVED_CHARS_RE+']';var _wordCharOrDot='[^'+_RESERVED_CHARS_RE.replace('\\.','')+']';// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
var _directoryRe=/((?:WC+[\/:])*)/.source.replace('WC',_wordChar);// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
var _nodeRe=/(WCOD+)?/.source.replace('WCOD',_wordCharOrDot);// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
var _objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC',_wordChar);// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
var _propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace('WC',_wordChar);var _trackRe=new RegExp(''+'^'+_directoryRe+_nodeRe+_objectRe+_propertyRe+'$');var _supportedObjectNames=['material','materials','bones'];function Composite(targetGroup,path,optionalParsedPath){var parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,parsedPath);}(0,_assign.default)(Composite.prototype,{getValue:function getValue(array,offset){this.bind();// bind all binding
var firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];// and only call .getValue on the first
if(binding!==undefined)binding.getValue(array,offset);},setValue:function setValue(array,offset){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].setValue(array,offset);}},bind:function bind(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].bind();}},unbind:function unbind(){var bindings=this._bindings;for(var i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i){bindings[i].unbind();}}});function PropertyBinding(rootNode,path,parsedPath){this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;}(0,_assign.default)(PropertyBinding,{Composite:Composite,create:function create(root,path,parsedPath){if(!(root&&root.isAnimationObjectGroup)){return new PropertyBinding(root,path,parsedPath);}else{return new PropertyBinding.Composite(root,path,parsedPath);}},/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */sanitizeNodeName:function sanitizeNodeName(name){return name.replace(/\s/g,'_').replace(_reservedRe,'');},parseTrackName:function parseTrackName(trackName){var matches=_trackRe.exec(trackName);if(!matches){throw new Error('PropertyBinding: Cannot parse trackName: '+trackName);}var results={// directoryName: matches[ 1 ], // (tschw) currently unused
nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],// required
propertyIndex:matches[6]};var lastDot=results.nodeName&&results.nodeName.lastIndexOf('.');if(lastDot!==undefined&&lastDot!==-1){var objectName=results.nodeName.substring(lastDot+1);// Object names must be checked against a whitelist. Otherwise, there
// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
// 'bar' could be the objectName, or part of a nodeName (which can
// include '.' characters).
if(_supportedObjectNames.indexOf(objectName)!==-1){results.nodeName=results.nodeName.substring(0,lastDot);results.objectName=objectName;}}if(results.propertyName===null||results.propertyName.length===0){throw new Error('PropertyBinding: can not parse propertyName from trackName: '+trackName);}return results;},findNode:function findNode(root,nodeName){if(!nodeName||nodeName===""||nodeName==="."||nodeName===-1||nodeName===root.name||nodeName===root.uuid){return root;}// search into skeleton bones.
if(root.skeleton){var bone=root.skeleton.getBoneByName(nodeName);if(bone!==undefined){return bone;}}// search into node subtree.
if(root.children){var searchNodeSubtree=function searchNodeSubtree(children){for(var i=0;i<children.length;i++){var childNode=children[i];if(childNode.name===nodeName||childNode.uuid===nodeName){return childNode;}var result=searchNodeSubtree(childNode.children);if(result)return result;}return null;};var subTreeNode=searchNodeSubtree(root.children);if(subTreeNode){return subTreeNode;}}return null;}});(0,_assign.default)(PropertyBinding.prototype,{// prototype, continued
// these are used to "bind" a nonexistent property
_getValue_unavailable:function _getValue_unavailable(){},_setValue_unavailable:function _setValue_unavailable(){},BindingType:{Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},Versioning:{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},GetterByBindingType:[function getValue_direct(buffer,offset){buffer[offset]=this.node[this.propertyName];},function getValue_array(buffer,offset){var source=this.resolvedProperty;for(var i=0,n=source.length;i!==n;++i){buffer[offset++]=source[i];}},function getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex];},function getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset);}],SetterByBindingTypeAndVersioning:[[// Direct
function setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];},function setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// EntireArray
function setValue_array(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}},function setValue_array_setNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.needsUpdate=true;},function setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){var dest=this.resolvedProperty;for(var i=0,n=dest.length;i!==n;++i){dest[i]=buffer[offset++];}this.targetObject.matrixWorldNeedsUpdate=true;}],[// ArrayElement
function setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];},function setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=true;},function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=true;}],[// HasToFromArray
function setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);},function setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=true;},function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=true;}]],getValue:function getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset);// Note: This class uses a State pattern on a per-method basis:
// 'bind' sets 'this.getValue' / 'setValue' and shadows the
// prototype version of these methods with one that represents
// the bound state. When the property is not found, the methods
// become no-ops.
},setValue:function getValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset);},// create getter / setter pair for a property in the scene graph
bind:function bind(){var targetObject=this.node,parsedPath=this.parsedPath,objectName=parsedPath.objectName,propertyName=parsedPath.propertyName,propertyIndex=parsedPath.propertyIndex;if(!targetObject){targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode;this.node=targetObject;}// set fail state so we can just 'return' on error
this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;// ensure there is a value node
if(!targetObject){console.error('THREE.PropertyBinding: Trying to update node for track: '+this.path+' but it wasn\'t found.');return;}if(objectName){var objectIndex=parsedPath.objectIndex;// special cases were we need to reach deeper into the hierarchy to get the face materials....
switch(objectName){case'materials':if(!targetObject.material){console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.',this);return;}if(!targetObject.material.materials){console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',this);return;}targetObject=targetObject.material.materials;break;case'bones':if(!targetObject.skeleton){console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',this);return;}// potential future optimization: skip this if propertyIndex is already an integer
// and convert the integer string to a true integer.
targetObject=targetObject.skeleton.bones;// support resolving morphTarget names into indices.
for(var i=0;i<targetObject.length;i++){if(targetObject[i].name===objectIndex){objectIndex=i;break;}}break;default:if(targetObject[objectName]===undefined){console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.',this);return;}targetObject=targetObject[objectName];}if(objectIndex!==undefined){if(targetObject[objectIndex]===undefined){console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',this,targetObject);return;}targetObject=targetObject[objectIndex];}}// resolve property
var nodeProperty=targetObject[propertyName];if(nodeProperty===undefined){var nodeName=parsedPath.nodeName;console.error('THREE.PropertyBinding: Trying to update property for track: '+nodeName+'.'+propertyName+' but it wasn\'t found.',targetObject);return;}// determine versioning scheme
var versioning=this.Versioning.None;this.targetObject=targetObject;if(targetObject.needsUpdate!==undefined){// material
versioning=this.Versioning.NeedsUpdate;}else if(targetObject.matrixWorldNeedsUpdate!==undefined){// node transform
versioning=this.Versioning.MatrixWorldNeedsUpdate;}// determine how the property gets bound
var bindingType=this.BindingType.Direct;if(propertyIndex!==undefined){// access a sub element of the property array (only primitives are supported right now)
if(propertyName==="morphTargetInfluences"){// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
// support resolving morphTarget names into indices.
if(!targetObject.geometry){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',this);return;}if(targetObject.geometry.isBufferGeometry){if(!targetObject.geometry.morphAttributes){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',this);return;}for(var i=0;i<this.node.geometry.morphAttributes.position.length;i++){if(targetObject.geometry.morphAttributes.position[i].name===propertyIndex){propertyIndex=i;break;}}}else{if(!targetObject.geometry.morphTargets){console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.',this);return;}for(var i=0;i<this.node.geometry.morphTargets.length;i++){if(targetObject.geometry.morphTargets[i].name===propertyIndex){propertyIndex=i;break;}}}}bindingType=this.BindingType.ArrayElement;this.resolvedProperty=nodeProperty;this.propertyIndex=propertyIndex;}else if(nodeProperty.fromArray!==undefined&&nodeProperty.toArray!==undefined){// must use copy for Object3D.Euler/Quaternion
bindingType=this.BindingType.HasFromToArray;this.resolvedProperty=nodeProperty;}else if((0,_isArray.default)(nodeProperty)){bindingType=this.BindingType.EntireArray;this.resolvedProperty=nodeProperty;}else{this.propertyName=propertyName;}// select getter / setter
this.getValue=this.GetterByBindingType[bindingType];this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning];},unbind:function unbind(){this.node=null;// back to the prototype version of getValue / setValue
// note: avoiding to mutate the shape of 'this' via 'delete'
this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound;}});// DECLARE ALIAS AFTER assign prototype
(0,_assign.default)(PropertyBinding.prototype,{// initial state of these methods that calls 'bind'
_getValue_unbound:PropertyBinding.prototype.getValue,_setValue_unbound:PropertyBinding.prototype.setValue});/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 *
 * @author tschw
 */function AnimationObjectGroup(){this.uuid=MathUtils.generateUUID();// cached objects followed by the active ones
this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;// threshold
// note: read by PropertyBinding.Composite
var indices={};this._indicesByUUID=indices;// for bookkeeping
for(var i=0,n=arguments.length;i!==n;++i){indices[arguments[i].uuid]=i;}this._paths=[];// inside: string
this._parsedPaths=[];// inside: { we don't care, here }
this._bindings=[];// inside: Array< PropertyBinding >
this._bindingsIndicesByPath={};// inside: indices in these arrays
var scope=this;this.stats={objects:{get total(){return scope._objects.length;},get inUse(){return this.total-scope.nCachedObjects_;}},get bindingsPerObject(){return scope._bindings.length;}};}(0,_assign.default)(Loader.prototype,{crossOrigin:'anonymous',onLoadStart:function onLoadStart(){},onLoadProgress:function onLoadProgress(){},onLoadComplete:function onLoadComplete(){},initMaterials:function initMaterials(materials,texturePath,crossOrigin){var array=[];for(var i=0;i<materials.length;++i){array[i]=this.createMaterial(materials[i],texturePath,crossOrigin);}return array;},createMaterial:function(){var BlendingMode={NoBlending:NoBlending,NormalBlending:NormalBlending,AdditiveBlending:AdditiveBlending,SubtractiveBlending:SubtractiveBlending,MultiplyBlending:MultiplyBlending,CustomBlending:CustomBlending};var color=new Color();var textureLoader=new TextureLoader();var materialLoader=new MaterialLoader();return function createMaterial(m,texturePath,crossOrigin){// convert from old material format
var textures={};function loadTexture(path,repeat,offset,wrap,anisotropy){var fullPath=texturePath+path;var man=new LoadingManager();var loader=man.getHandler(fullPath);var texture;if(loader!==null){texture=loader.load(fullPath);}else{textureLoader.setCrossOrigin(crossOrigin);texture=textureLoader.load(fullPath);}if(repeat!==undefined){texture.repeat.fromArray(repeat);if(repeat[0]!==1)texture.wrapS=RepeatWrapping;if(repeat[1]!==1)texture.wrapT=RepeatWrapping;}if(offset!==undefined){texture.offset.fromArray(offset);}if(wrap!==undefined){if(wrap[0]==='repeat')texture.wrapS=RepeatWrapping;if(wrap[0]==='mirror')texture.wrapS=MirroredRepeatWrapping;if(wrap[1]==='repeat')texture.wrapT=RepeatWrapping;if(wrap[1]==='mirror')texture.wrapT=MirroredRepeatWrapping;}if(anisotropy!==undefined){texture.anisotropy=anisotropy;}var uuid=MathUtils.generateUUID();textures[uuid]=texture;return uuid;}//
var json={uuid:MathUtils.generateUUID(),type:'MeshLambertMaterial'};for(var name in m){var value=m[name];switch(name){case'DbgColor':case'DbgIndex':case'opticalDensity':case'illumination':break;case'DbgName':json.name=value;break;case'blending':json.blending=BlendingMode[value];break;case'colorAmbient':case'mapAmbient':// console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
break;case'colorDiffuse':json.color=color.fromArray(value).getHex();break;case'colorSpecular':json.specular=color.fromArray(value).getHex();break;case'colorEmissive':json.emissive=color.fromArray(value).getHex();break;case'specularCoef':json.shininess=value;break;case'shading':if(value.toLowerCase()==='basic')json.type='MeshBasicMaterial';if(value.toLowerCase()==='phong')json.type='MeshPhongMaterial';if(value.toLowerCase()==='standard')json.type='MeshStandardMaterial';break;case'mapDiffuse':json.map=loadTexture(value,m.mapDiffuseRepeat,m.mapDiffuseOffset,m.mapDiffuseWrap,m.mapDiffuseAnisotropy);break;case'mapDiffuseRepeat':case'mapDiffuseOffset':case'mapDiffuseWrap':case'mapDiffuseAnisotropy':break;case'mapEmissive':json.emissiveMap=loadTexture(value,m.mapEmissiveRepeat,m.mapEmissiveOffset,m.mapEmissiveWrap,m.mapEmissiveAnisotropy);break;case'mapEmissiveRepeat':case'mapEmissiveOffset':case'mapEmissiveWrap':case'mapEmissiveAnisotropy':break;case'mapLight':json.lightMap=loadTexture(value,m.mapLightRepeat,m.mapLightOffset,m.mapLightWrap,m.mapLightAnisotropy);break;case'mapLightRepeat':case'mapLightOffset':case'mapLightWrap':case'mapLightAnisotropy':break;case'mapAO':json.aoMap=loadTexture(value,m.mapAORepeat,m.mapAOOffset,m.mapAOWrap,m.mapAOAnisotropy);break;case'mapAORepeat':case'mapAOOffset':case'mapAOWrap':case'mapAOAnisotropy':break;case'mapBump':json.bumpMap=loadTexture(value,m.mapBumpRepeat,m.mapBumpOffset,m.mapBumpWrap,m.mapBumpAnisotropy);break;case'mapBumpScale':json.bumpScale=value;break;case'mapBumpRepeat':case'mapBumpOffset':case'mapBumpWrap':case'mapBumpAnisotropy':break;case'mapNormal':json.normalMap=loadTexture(value,m.mapNormalRepeat,m.mapNormalOffset,m.mapNormalWrap,m.mapNormalAnisotropy);break;case'mapNormalFactor':json.normalScale=value;break;case'mapNormalRepeat':case'mapNormalOffset':case'mapNormalWrap':case'mapNormalAnisotropy':break;case'mapSpecular':json.specularMap=loadTexture(value,m.mapSpecularRepeat,m.mapSpecularOffset,m.mapSpecularWrap,m.mapSpecularAnisotropy);break;case'mapSpecularRepeat':case'mapSpecularOffset':case'mapSpecularWrap':case'mapSpecularAnisotropy':break;case'mapMetalness':json.metalnessMap=loadTexture(value,m.mapMetalnessRepeat,m.mapMetalnessOffset,m.mapMetalnessWrap,m.mapMetalnessAnisotropy);break;case'mapMetalnessRepeat':case'mapMetalnessOffset':case'mapMetalnessWrap':case'mapMetalnessAnisotropy':break;case'mapRoughness':json.roughnessMap=loadTexture(value,m.mapRoughnessRepeat,m.mapRoughnessOffset,m.mapRoughnessWrap,m.mapRoughnessAnisotropy);break;case'mapRoughnessRepeat':case'mapRoughnessOffset':case'mapRoughnessWrap':case'mapRoughnessAnisotropy':break;case'mapAlpha':json.alphaMap=loadTexture(value,m.mapAlphaRepeat,m.mapAlphaOffset,m.mapAlphaWrap,m.mapAlphaAnisotropy);break;case'mapAlphaRepeat':case'mapAlphaOffset':case'mapAlphaWrap':case'mapAlphaAnisotropy':break;case'flipSided':json.side=BackSide;break;case'doubleSided':json.side=DoubleSide;break;case'transparency'://console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
json.opacity=value;break;case'depthTest':case'depthWrite':case'colorWrite':case'opacity':case'reflectivity':case'transparent':case'visible':case'wireframe':json[name]=value;break;case'vertexColors':if(value===true)json.vertexColors=VertexColors;if(value==='face')json.vertexColors=FaceColors;break;default:// console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
break;}}if(json.type==='MeshBasicMaterial')delete json.emissive;if(json.type!=='MeshPhongMaterial')delete json.specular;if(json.opacity<1)json.transparent=true;materialLoader.setTextures(textures);return materialLoader.parse(json);};}()});(0,_assign.default)(AnimationObjectGroup.prototype,{isAnimationObjectGroup:true,add:function add(){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length,knownObject=undefined;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index===undefined){// unknown object -> add it to the ACTIVE region
index=nObjects++;indicesByUUID[uuid]=index;objects.push(object);// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]));}}else if(index<nCachedObjects){knownObject=objects[index];// move existing object to the ACTIVE region
var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[uuid]=firstActiveIndex;objects[firstActiveIndex]=object;// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],binding=bindingsForPath[index];bindingsForPath[index]=lastCached;if(binding===undefined){// since we do not bother to create new bindings
// for objects that are cached, the binding may
// or may not exist
binding=new PropertyBinding(object,paths[j],parsedPaths[j]);}bindingsForPath[firstActiveIndex]=binding;}}else if(objects[index]!==knownObject){console.error('THREE.AnimationObjectGroup: Different objects with the same UUID '+'detected. Clean the caches or recreate your infrastructure when reloading scenes.');}// else the object is already where we want it to be
}// for arguments
this.nCachedObjects_=nCachedObjects;},remove:function remove(){var objects=this._objects,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined&&index>=nCachedObjects){// move existing object into the CACHED region
var lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index;objects[index]=firstActiveObject;indicesByUUID[uuid]=lastCachedIndex;objects[lastCachedIndex]=object;// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive;bindingsForPath[lastCachedIndex]=binding;}}}// for arguments
this.nCachedObjects_=nCachedObjects;},// remove & forget
uncache:function uncache(){var objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;for(var i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(index!==undefined){delete indicesByUUID[uuid];if(index<nCachedObjects){// object is cached, shrink the CACHED region
var firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];// last cached object takes this object's place
indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;// last object goes to the activated slot and pop
indicesByUUID[lastObject.uuid]=firstActiveIndex;objects[firstActiveIndex]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached;bindingsForPath[firstActiveIndex]=last;bindingsForPath.pop();}}else{// object is active, just swap with the last and pop
var lastIndex=--nObjects,lastObject=objects[lastIndex];indicesByUUID[lastObject.uuid]=index;objects[index]=lastObject;objects.pop();// accounting is done, now do the same for all bindings
for(var j=0,m=nBindings;j!==m;++j){var bindingsForPath=bindings[j];bindingsForPath[index]=bindingsForPath[lastIndex];bindingsForPath.pop();}}// cached or active
}// if object is known
}// for arguments
this.nCachedObjects_=nCachedObjects;},// Internal interface used by befriended PropertyBinding.Composite:
subscribe_:function subscribe_(path,parsedPath){// returns an array of bindings for the given path that is changed
// according to the contained objects in the group
var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path],bindings=this._bindings;if(index!==undefined)return bindings[index];var paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length;indicesByPath[path]=index;paths.push(path);parsedPaths.push(parsedPath);bindings.push(bindingsForPath);for(var i=nCachedObjects,n=objects.length;i!==n;++i){var object=objects[i];bindingsForPath[i]=new PropertyBinding(object,path,parsedPath);}return bindingsForPath;},unsubscribe_:function unsubscribe_(path){// tells the group to forget about a property path and no longer
// update the array previously obtained with 'subscribe_'
var indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(index!==undefined){var paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex],lastBindingsPath=path[lastBindingsIndex];indicesByPath[lastBindingsPath]=index;bindings[index]=lastBindings;bindings.pop();parsedPaths[index]=parsedPaths[lastBindingsIndex];parsedPaths.pop();paths[index]=paths[lastBindingsIndex];paths.pop();}}});/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */function AnimationAction(mixer,clip,localRoot){this._mixer=mixer;this._clip=clip;this._localRoot=localRoot||null;var tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks);var interpolantSettings={endingStart:ZeroCurvatureEnding,endingEnd:ZeroCurvatureEnding};for(var i=0;i!==nTracks;++i){var interpolant=tracks[i].createInterpolant(null);interpolants[i]=interpolant;interpolant.settings=interpolantSettings;}this._interpolantSettings=interpolantSettings;this._interpolants=interpolants;// bound by the mixer
// inside: PropertyMixer (managed by the mixer)
this._propertyBindings=new Array(nTracks);this._cacheIndex=null;// for the memory manager
this._byClipCacheIndex=null;// for the memory manager
this._timeScaleInterpolant=null;this._weightInterpolant=null;this.loop=LoopRepeat;this._loopCount=-1;// global mixer time when the action is to be started
// it's set back to 'null' upon start of the action
this._startTime=null;// scaled local time of the action
// gets clamped or wrapped to 0..clip.duration according to loop
this.time=0;this.timeScale=1;this._effectiveTimeScale=1;this.weight=1;this._effectiveWeight=1;this.repetitions=Infinity;// no. of repetitions when looping
this.paused=false;// true -> zero effective time scale
this.enabled=true;// false -> zero effective weight
this.clampWhenFinished=false;// keep feeding the last frame?
this.zeroSlopeAtStart=true;// for smooth interpolation w/o separate
this.zeroSlopeAtEnd=true;// clips for start, loop and end
}(0,_assign.default)(AnimationAction.prototype,{// State & Scheduling
play:function play(){this._mixer._activateAction(this);return this;},stop:function stop(){this._mixer._deactivateAction(this);return this.reset();},reset:function reset(){this.paused=false;this.enabled=true;this.time=0;// restart clip
this._loopCount=-1;// forget previous loops
this._startTime=null;// forget scheduling
return this.stopFading().stopWarping();},isRunning:function isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this);},// return true when play has been called
isScheduled:function isScheduled(){return this._mixer._isActiveAction(this);},startAt:function startAt(time){this._startTime=time;return this;},setLoop:function setLoop(mode,repetitions){this.loop=mode;this.repetitions=repetitions;return this;},// Weight
// set the weight stopping any scheduled fading
// although .enabled = false yields an effective weight of zero, this
// method does *not* change .enabled, because it would be confusing
setEffectiveWeight:function setEffectiveWeight(weight){this.weight=weight;// note: same logic as when updated at runtime
this._effectiveWeight=this.enabled?weight:0;return this.stopFading();},// return the weight considering fading and .enabled
getEffectiveWeight:function getEffectiveWeight(){return this._effectiveWeight;},fadeIn:function fadeIn(duration){return this._scheduleFading(duration,0,1);},fadeOut:function fadeOut(duration){return this._scheduleFading(duration,1,0);},crossFadeFrom:function crossFadeFrom(fadeOutAction,duration,warp){fadeOutAction.fadeOut(duration);this.fadeIn(duration);if(warp){var fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1.0,startEndRatio,duration);this.warp(endStartRatio,1.0,duration);}return this;},crossFadeTo:function crossFadeTo(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp);},stopFading:function stopFading(){var weightInterpolant=this._weightInterpolant;if(weightInterpolant!==null){this._weightInterpolant=null;this._mixer._takeBackControlInterpolant(weightInterpolant);}return this;},// Time Scale Control
// set the time scale stopping any scheduled warping
// although .paused = true yields an effective time scale of zero, this
// method does *not* change .paused, because it would be confusing
setEffectiveTimeScale:function setEffectiveTimeScale(timeScale){this.timeScale=timeScale;this._effectiveTimeScale=this.paused?0:timeScale;return this.stopWarping();},// return the time scale considering warping and .paused
getEffectiveTimeScale:function getEffectiveTimeScale(){return this._effectiveTimeScale;},setDuration:function setDuration(duration){this.timeScale=this._clip.duration/duration;return this.stopWarping();},syncWith:function syncWith(action){this.time=action.time;this.timeScale=action.timeScale;return this.stopWarping();},halt:function halt(duration){return this.warp(this._effectiveTimeScale,0,duration);},warp:function warp(startTimeScale,endTimeScale,duration){var mixer=this._mixer,now=mixer.time,interpolant=this._timeScaleInterpolant,timeScale=this.timeScale;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._timeScaleInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;times[1]=now+duration;values[0]=startTimeScale/timeScale;values[1]=endTimeScale/timeScale;return this;},stopWarping:function stopWarping(){var timeScaleInterpolant=this._timeScaleInterpolant;if(timeScaleInterpolant!==null){this._timeScaleInterpolant=null;this._mixer._takeBackControlInterpolant(timeScaleInterpolant);}return this;},// Object Accessors
getMixer:function getMixer(){return this._mixer;},getClip:function getClip(){return this._clip;},getRoot:function getRoot(){return this._localRoot||this._mixer._root;},// Interna
_update:function _update(time,deltaTime,timeDirection,accuIndex){// called by the mixer
if(!this.enabled){// call ._updateWeight() to update ._effectiveWeight
this._updateWeight(time);return;}var startTime=this._startTime;if(startTime!==null){// check for scheduled start of action
var timeRunning=(time-startTime)*timeDirection;if(timeRunning<0||timeDirection===0){return;// yet to come / don't decide when delta = 0
}// start
this._startTime=null;// unschedule
deltaTime=timeDirection*timeRunning;}// apply time scale and advance time
deltaTime*=this._updateTimeScale(time);var clipTime=this._updateTime(deltaTime);// note: _updateTime may disable the action resulting in
// an effective weight of 0
var weight=this._updateWeight(time);if(weight>0){var interpolants=this._interpolants;var propertyMixers=this._propertyBindings;for(var j=0,m=interpolants.length;j!==m;++j){interpolants[j].evaluate(clipTime);propertyMixers[j].accumulate(accuIndex,weight);}}},_updateWeight:function _updateWeight(time){var weight=0;if(this.enabled){weight=this.weight;var interpolant=this._weightInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopFading();if(interpolantValue===0){// faded out, disable
this.enabled=false;}}}}this._effectiveWeight=weight;return weight;},_updateTimeScale:function _updateTimeScale(time){var timeScale=0;if(!this.paused){timeScale=this.timeScale;var interpolant=this._timeScaleInterpolant;if(interpolant!==null){var interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue;if(time>interpolant.parameterPositions[1]){this.stopWarping();if(timeScale===0){// motion has halted, pause
this.paused=true;}else{// warp done - apply final time scale
this.timeScale=timeScale;}}}}this._effectiveTimeScale=timeScale;return timeScale;},_updateTime:function _updateTime(deltaTime){var time=this.time+deltaTime;var duration=this._clip.duration;var loop=this.loop;var loopCount=this._loopCount;var pingPong=loop===LoopPingPong;if(deltaTime===0){if(loopCount===-1)return time;return pingPong&&(loopCount&1)===1?duration-time:time;}if(loop===LoopOnce){if(loopCount===-1){// just started
this._loopCount=0;this._setEndings(true,true,false);}handle_stop:{if(time>=duration){time=duration;}else if(time<0){time=0;}else{this.time=time;break handle_stop;}if(this.clampWhenFinished)this.paused=true;else this.enabled=false;this.time=time;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime<0?-1:1});}}else{// repetitive Repeat or PingPong
if(loopCount===-1){// just started
if(deltaTime>=0){loopCount=0;this._setEndings(true,this.repetitions===0,pingPong);}else{// when looping in reverse direction, the initial
// transition through zero counts as a repetition,
// so leave loopCount at -1
this._setEndings(this.repetitions===0,true,pingPong);}}if(time>=duration||time<0){// wrap around
var loopDelta=Math.floor(time/duration);// signed
time-=duration*loopDelta;loopCount+=Math.abs(loopDelta);var pending=this.repetitions-loopCount;if(pending<=0){// have to stop (switch state, clamp time, fire event)
if(this.clampWhenFinished)this.paused=true;else this.enabled=false;time=deltaTime>0?duration:0;this.time=time;this._mixer.dispatchEvent({type:'finished',action:this,direction:deltaTime>0?1:-1});}else{// keep running
if(pending===1){// entering the last round
var atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong);}else{this._setEndings(false,false,pingPong);}this._loopCount=loopCount;this.time=time;this._mixer.dispatchEvent({type:'loop',action:this,loopDelta:loopDelta});}}else{this.time=time;}if(pingPong&&(loopCount&1)===1){// invert time for the "pong round"
return duration-time;}}return time;},_setEndings:function _setEndings(atStart,atEnd,pingPong){var settings=this._interpolantSettings;if(pingPong){settings.endingStart=ZeroSlopeEnding;settings.endingEnd=ZeroSlopeEnding;}else{// assuming for LoopOnce atStart == atEnd == true
if(atStart){settings.endingStart=this.zeroSlopeAtStart?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingStart=WrapAroundEnding;}if(atEnd){settings.endingEnd=this.zeroSlopeAtEnd?ZeroSlopeEnding:ZeroCurvatureEnding;}else{settings.endingEnd=WrapAroundEnding;}}},_scheduleFading:function _scheduleFading(duration,weightNow,weightThen){var mixer=this._mixer,now=mixer.time,interpolant=this._weightInterpolant;if(interpolant===null){interpolant=mixer._lendControlInterpolant();this._weightInterpolant=interpolant;}var times=interpolant.parameterPositions,values=interpolant.sampleValues;times[0]=now;values[0]=weightNow;times[1]=now+duration;values[1]=weightThen;return this;}});/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */function AnimationMixer(root){this._root=root;this._initMemoryManager();this._accuIndex=0;this.time=0;this.timeScale=1.0;}AnimationMixer.prototype=(0,_assign.default)((0,_create.default)(EventDispatcher.prototype),{constructor:AnimationMixer,_bindAction:function _bindAction(action,prototypeAction){var root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName,bindingsByName=bindingsByRoot[rootUuid];if(bindingsByName===undefined){bindingsByName={};bindingsByRoot[rootUuid]=bindingsByName;}for(var i=0;i!==nTracks;++i){var track=tracks[i],trackName=track.name,binding=bindingsByName[trackName];if(binding!==undefined){bindings[i]=binding;}else{binding=bindings[i];if(binding!==undefined){// existing binding, make sure the cache knows
if(binding._cacheIndex===null){++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);}continue;}var path=prototypeAction&&prototypeAction._propertyBindings[i].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path),track.ValueTypeName,track.getValueSize());++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName);bindings[i]=binding;}interpolants[i].resultBuffer=binding.buffer;}},_activateAction:function _activateAction(action){if(!this._isActiveAction(action)){if(action._cacheIndex===null){// this action has been forgotten by the cache, but the user
// appears to be still using it -> rebind
var rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]);this._addInactiveAction(action,clipUuid,rootUuid);}var bindings=action._propertyBindings;// increment reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(binding.useCount++===0){this._lendBinding(binding);binding.saveOriginalState();}}this._lendAction(action);}},_deactivateAction:function _deactivateAction(action){if(this._isActiveAction(action)){var bindings=action._propertyBindings;// decrement reference counts / sort out state
for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.useCount===0){binding.restoreOriginalState();this._takeBackBinding(binding);}}this._takeBackAction(action);}},// Memory manager
_initMemoryManager:function _initMemoryManager(){this._actions=[];// 'nActiveActions' followed by inactive ones
this._nActiveActions=0;this._actionsByClip={};// inside:
// {
// 	knownActions: Array< AnimationAction > - used as prototypes
// 	actionByRoot: AnimationAction - lookup
// }
this._bindings=[];// 'nActiveBindings' followed by inactive ones
this._nActiveBindings=0;this._bindingsByRootAndName={};// inside: Map< name, PropertyMixer >
this._controlInterpolants=[];// same game as above
this._nActiveControlInterpolants=0;var scope=this;this.stats={actions:{get total(){return scope._actions.length;},get inUse(){return scope._nActiveActions;}},bindings:{get total(){return scope._bindings.length;},get inUse(){return scope._nActiveBindings;}},controlInterpolants:{get total(){return scope._controlInterpolants.length;},get inUse(){return scope._nActiveControlInterpolants;}}};},// Memory management for AnimationAction objects
_isActiveAction:function _isActiveAction(action){var index=action._cacheIndex;return index!==null&&index<this._nActiveActions;},_addInactiveAction:function _addInactiveAction(action,clipUuid,rootUuid){var actions=this._actions,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip===undefined){actionsForClip={knownActions:[action],actionByRoot:{}};action._byClipCacheIndex=0;actionsByClip[clipUuid]=actionsForClip;}else{var knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length;knownActions.push(action);}action._cacheIndex=actions.length;actions.push(action);actionsForClip.actionByRoot[rootUuid]=action;},_removeInactiveAction:function _removeInactiveAction(action){var actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();action._cacheIndex=null;var clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex;knownActionsForClip[byClipCacheIndex]=lastKnownAction;knownActionsForClip.pop();action._byClipCacheIndex=null;var actionByRoot=actionsForClip.actionByRoot,rootUuid=(action._localRoot||this._root).uuid;delete actionByRoot[rootUuid];if(knownActionsForClip.length===0){delete actionsByClip[clipUuid];}this._removeInactiveBindingsForAction(action);},_removeInactiveBindingsForAction:function _removeInactiveBindingsForAction(action){var bindings=action._propertyBindings;for(var i=0,n=bindings.length;i!==n;++i){var binding=bindings[i];if(--binding.referenceCount===0){this._removeInactiveBinding(binding);}}},_lendAction:function _lendAction(action){// [ active actions |  inactive actions  ]
// [  active actions >| inactive actions ]
//                 s        a
//                  <-swap->
//                 a        s
var actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex;actions[lastActiveIndex]=action;firstInactiveAction._cacheIndex=prevIndex;actions[prevIndex]=firstInactiveAction;},_takeBackAction:function _takeBackAction(action){// [  active actions  | inactive actions ]
// [ active actions |< inactive actions  ]
//        a        s
//         <-swap->
//        s        a
var actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex;actions[firstInactiveIndex]=action;lastActiveAction._cacheIndex=prevIndex;actions[prevIndex]=lastActiveAction;},// Memory management for PropertyMixer objects
_addInactiveBinding:function _addInactiveBinding(binding,rootUuid,trackName){var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],bindings=this._bindings;if(bindingByName===undefined){bindingByName={};bindingsByRoot[rootUuid]=bindingByName;}bindingByName[trackName]=binding;binding._cacheIndex=bindings.length;bindings.push(binding);},_removeInactiveBinding:function _removeInactiveBinding(binding){var bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex;bindings[cacheIndex]=lastInactiveBinding;bindings.pop();delete bindingByName[trackName];if((0,_keys.default)(bindingByName).length===0){delete bindingsByRoot[rootUuid];}},_lendBinding:function _lendBinding(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex;bindings[lastActiveIndex]=binding;firstInactiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=firstInactiveBinding;},_takeBackBinding:function _takeBackBinding(binding){var bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex;bindings[firstInactiveIndex]=binding;lastActiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=lastActiveBinding;},// Memory management of Interpolants for weight and time scale
_lendControlInterpolant:function _lendControlInterpolant(){var interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++,interpolant=interpolants[lastActiveIndex];if(interpolant===undefined){interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer);interpolant.__cacheIndex=lastActiveIndex;interpolants[lastActiveIndex]=interpolant;}return interpolant;},_takeBackControlInterpolant:function _takeBackControlInterpolant(interpolant){var interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex;interpolants[firstInactiveIndex]=interpolant;lastActiveInterpolant.__cacheIndex=prevIndex;interpolants[prevIndex]=lastActiveInterpolant;},_controlInterpolantsResultBuffer:new Float32Array(1),// return an action for a clip optionally using a custom root target
// object (this method allocates a lot of dynamic memory in case a
// previously unknown clip/root combination is specified)
clipAction:function clipAction(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject!==null?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid],prototypeAction=null;if(actionsForClip!==undefined){var existingAction=actionsForClip.actionByRoot[rootUuid];if(existingAction!==undefined){return existingAction;}// we know the clip, so we don't have to parse all
// the bindings again but can just copy
prototypeAction=actionsForClip.knownActions[0];// also, take the clip from the prototype action
if(clipObject===null)clipObject=prototypeAction._clip;}// clip must be known when specified via string
if(clipObject===null)return null;// allocate all resources required to run it
var newAction=new AnimationAction(this,clipObject,optionalRoot);this._bindAction(newAction,prototypeAction);// and make the action known to the memory manager
this._addInactiveAction(newAction,clipUuid,rootUuid);return newAction;},// get an existing action
existingAction:function existingAction(clip,optionalRoot){var root=optionalRoot||this._root,rootUuid=root.uuid,clipObject=typeof clip==='string'?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];if(actionsForClip!==undefined){return actionsForClip.actionByRoot[rootUuid]||null;}return null;},// deactivates all previously scheduled actions
stopAllAction:function stopAllAction(){var actions=this._actions,nActions=this._nActiveActions,bindings=this._bindings,nBindings=this._nActiveBindings;this._nActiveActions=0;this._nActiveBindings=0;for(var i=0;i!==nActions;++i){actions[i].reset();}for(var i=0;i!==nBindings;++i){bindings[i].useCount=0;}return this;},// advance the time and update apply the animation
update:function update(deltaTime){deltaTime*=this.timeScale;var actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;// run active actions
for(var i=0;i!==nActions;++i){var action=actions[i];action._update(time,deltaTime,timeDirection,accuIndex);}// update scene graph
var bindings=this._bindings,nBindings=this._nActiveBindings;for(var i=0;i!==nBindings;++i){bindings[i].apply(accuIndex);}return this;},// Allows you to seek to a specific time in an animation.
setTime:function setTime(timeInSeconds){this.time=0;// Zero out time attribute for AnimationMixer object;
for(var i=0;i<this._actions.length;i++){this._actions[i].time=0;// Zero out time attribute for all associated AnimationAction objects.
}return this.update(timeInSeconds);// Update used to set exact time. Returns "this" AnimationMixer object.
},// return this mixer's root target object
getRoot:function getRoot(){return this._root;},// free all resources specific to a particular clip
uncacheClip:function uncacheClip(clip){var actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(actionsForClip!==undefined){// note: just calling _removeInactiveAction would mess up the
// iteration state and also require updating the state we can
// just throw away
var actionsToRemove=actionsForClip.knownActions;for(var i=0,n=actionsToRemove.length;i!==n;++i){var action=actionsToRemove[i];this._deactivateAction(action);var cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null;action._byClipCacheIndex=null;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;actions.pop();this._removeInactiveBindingsForAction(action);}delete actionsByClip[clipUuid];}},// free all resources specific to a particular root target object
uncacheRoot:function uncacheRoot(root){var rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(var clipUuid in actionsByClip){var actionByRoot=actionsByClip[clipUuid].actionByRoot,action=actionByRoot[rootUuid];if(action!==undefined){this._deactivateAction(action);this._removeInactiveAction(action);}}var bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid];if(bindingByName!==undefined){for(var trackName in bindingByName){var binding=bindingByName[trackName];binding.restoreOriginalState();this._removeInactiveBinding(binding);}}},// remove a targeted clip from the cache
uncacheAction:function uncacheAction(clip,optionalRoot){var action=this.existingAction(clip,optionalRoot);if(action!==null){this._deactivateAction(action);this._removeInactiveAction(action);}}});/**
 * @author mrdoob / http://mrdoob.com/
 */function Uniform(value){if(typeof value==='string'){console.warn('THREE.Uniform: Type parameter is no longer needed.');value=arguments[1];}this.value=value;}Uniform.prototype.clone=function(){return new Uniform(this.value.clone===undefined?this.value:this.value.clone());};/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */function InstancedInterleavedBuffer(array,stride,meshPerAttribute){InterleavedBuffer.call(this,array,stride);this.meshPerAttribute=meshPerAttribute||1;}InstancedInterleavedBuffer.prototype=(0,_assign.default)((0,_create.default)(InterleavedBuffer.prototype),{constructor:InstancedInterleavedBuffer,isInstancedInterleavedBuffer:true,copy:function copy(source){InterleavedBuffer.prototype.copy.call(this,source);this.meshPerAttribute=source.meshPerAttribute;return this;}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */function Raycaster(origin,direction,near,far){this.ray=new Ray(origin,direction);// direction is assumed to be normalized (for accurate distance calculations)
this.near=near||0;this.far=far||Infinity;this.camera=null;this.layers=new Layers();this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}};(0,_defineProperties.default)(this.params,{PointCloud:{get:function get(){console.warn('THREE.Raycaster: params.PointCloud has been renamed to params.Points.');return this.Points;}}});}function ascSort(a,b){return a.distance-b.distance;}function _intersectObject(object,raycaster,intersects,recursive){if(object.layers.test(raycaster.layers)){object.raycast(raycaster,intersects);}if(recursive===true){var children=object.children;for(var i=0,l=children.length;i<l;i++){_intersectObject(children[i],raycaster,intersects,true);}}}(0,_assign.default)(Raycaster.prototype,{set:function set(origin,direction){// direction is assumed to be normalized (for accurate distance calculations)
this.ray.set(origin,direction);},setFromCamera:function setFromCamera(coords,camera){if(camera&&camera.isPerspectiveCamera){this.ray.origin.setFromMatrixPosition(camera.matrixWorld);this.ray.direction.set(coords.x,coords.y,0.5).unproject(camera).sub(this.ray.origin).normalize();this.camera=camera;}else if(camera&&camera.isOrthographicCamera){this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera);// set origin in plane of camera
this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld);this.camera=camera;}else{console.error('THREE.Raycaster: Unsupported camera type.');}},intersectObject:function intersectObject(object,recursive,optionalTarget){var intersects=optionalTarget||[];_intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects;},intersectObjects:function intersectObjects(objects,recursive,optionalTarget){var intersects=optionalTarget||[];if((0,_isArray.default)(objects)===false){console.warn('THREE.Raycaster.intersectObjects: objects is not an Array.');return intersects;}for(var i=0,l=objects.length;i<l;i++){_intersectObject(objects[i],this,intersects,recursive);}intersects.sort(ascSort);return intersects;}});/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */function Spherical(radius,phi,theta){this.radius=radius!==undefined?radius:1.0;this.phi=phi!==undefined?phi:0;// polar angle
this.theta=theta!==undefined?theta:0;// azimuthal angle
return this;}(0,_assign.default)(Spherical.prototype,{set:function set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this;},// restrict phi to be betwee EPS and PI-EPS
makeSafe:function makeSafe(){var EPS=0.000001;this.phi=Math.max(EPS,Math.min(Math.PI-EPS,this.phi));return this;},setFromVector3:function setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z);},setFromCartesianCoords:function setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+y*y+z*z);if(this.radius===0){this.theta=0;this.phi=0;}else{this.theta=Math.atan2(x,z);this.phi=Math.acos(MathUtils.clamp(y/this.radius,-1,1));}return this;}});/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */function Cylindrical(radius,theta,y){this.radius=radius!==undefined?radius:1.0;// distance from the origin to a point in the x-z plane
this.theta=theta!==undefined?theta:0;// counterclockwise angle in the x-z plane measured in radians from the positive z-axis
this.y=y!==undefined?y:0;// height above the x-z plane
return this;}(0,_assign.default)(Cylindrical.prototype,{set:function set(radius,theta,y){this.radius=radius;this.theta=theta;this.y=y;return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(other){this.radius=other.radius;this.theta=other.theta;this.y=other.y;return this;},setFromVector3:function setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z);},setFromCartesianCoords:function setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+z*z);this.theta=Math.atan2(x,z);this.y=y;return this;}});/**
 * @author bhouston / http://clara.io
 */var _vector$7=new Vector2();function Box2(min,max){this.min=min!==undefined?min:new Vector2(+Infinity,+Infinity);this.max=max!==undefined?max:new Vector2(-Infinity,-Infinity);}(0,_assign.default)(Box2.prototype,{set:function set(min,max){this.min.copy(min);this.max.copy(max);return this;},setFromPoints:function setFromPoints(points){this.makeEmpty();for(var i=0,il=points.length;i<il;i++){this.expandByPoint(points[i]);}return this;},setFromCenterAndSize:function setFromCenterAndSize(center,size){var halfSize=_vector$7.copy(size).multiplyScalar(0.5);this.min.copy(center).sub(halfSize);this.max.copy(center).add(halfSize);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(box){this.min.copy(box.min);this.max.copy(box.max);return this;},makeEmpty:function makeEmpty(){this.min.x=this.min.y=+Infinity;this.max.x=this.max.y=-Infinity;return this;},isEmpty:function isEmpty(){// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
return this.max.x<this.min.x||this.max.y<this.min.y;},getCenter:function getCenter(target){if(target===undefined){console.warn('THREE.Box2: .getCenter() target is now required');target=new Vector2();}return this.isEmpty()?target.set(0,0):target.addVectors(this.min,this.max).multiplyScalar(0.5);},getSize:function getSize(target){if(target===undefined){console.warn('THREE.Box2: .getSize() target is now required');target=new Vector2();}return this.isEmpty()?target.set(0,0):target.subVectors(this.max,this.min);},expandByPoint:function expandByPoint(point){this.min.min(point);this.max.max(point);return this;},expandByVector:function expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this;},expandByScalar:function expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this;},containsPoint:function containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?false:true;},containsBox:function containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y;},getParameter:function getParameter(point,target){// This can potentially have a divide by zero if the box
// has a size dimension of 0.
if(target===undefined){console.warn('THREE.Box2: .getParameter() target is now required');target=new Vector2();}return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y));},intersectsBox:function intersectsBox(box){// using 4 splitting planes to rule out intersections
return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?false:true;},clampPoint:function clampPoint(point,target){if(target===undefined){console.warn('THREE.Box2: .clampPoint() target is now required');target=new Vector2();}return target.copy(point).clamp(this.min,this.max);},distanceToPoint:function distanceToPoint(point){var clampedPoint=_vector$7.copy(point).clamp(this.min,this.max);return clampedPoint.sub(point).length();},intersect:function intersect(box){this.min.max(box.min);this.max.min(box.max);return this;},union:function union(box){this.min.min(box.min);this.max.max(box.max);return this;},translate:function translate(offset){this.min.add(offset);this.max.add(offset);return this;},equals:function equals(box){return box.min.equals(this.min)&&box.max.equals(this.max);}});/**
 * @author bhouston / http://clara.io
 */var _startP=new Vector3();var _startEnd=new Vector3();function Line3(start,end){this.start=start!==undefined?start:new Vector3();this.end=end!==undefined?end:new Vector3();}(0,_assign.default)(Line3.prototype,{set:function set(start,end){this.start.copy(start);this.end.copy(end);return this;},clone:function clone(){return new this.constructor().copy(this);},copy:function copy(line){this.start.copy(line.start);this.end.copy(line.end);return this;},getCenter:function getCenter(target){if(target===undefined){console.warn('THREE.Line3: .getCenter() target is now required');target=new Vector3();}return target.addVectors(this.start,this.end).multiplyScalar(0.5);},delta:function delta(target){if(target===undefined){console.warn('THREE.Line3: .delta() target is now required');target=new Vector3();}return target.subVectors(this.end,this.start);},distanceSq:function distanceSq(){return this.start.distanceToSquared(this.end);},distance:function distance(){return this.start.distanceTo(this.end);},at:function at(t,target){if(target===undefined){console.warn('THREE.Line3: .at() target is now required');target=new Vector3();}return this.delta(target).multiplyScalar(t).add(this.start);},closestPointToPointParameter:function closestPointToPointParameter(point,clampToLine){_startP.subVectors(point,this.start);_startEnd.subVectors(this.end,this.start);var startEnd2=_startEnd.dot(_startEnd);var startEnd_startP=_startEnd.dot(_startP);var t=startEnd_startP/startEnd2;if(clampToLine){t=MathUtils.clamp(t,0,1);}return t;},closestPointToPoint:function closestPointToPoint(point,clampToLine,target){var t=this.closestPointToPointParameter(point,clampToLine);if(target===undefined){console.warn('THREE.Line3: .closestPointToPoint() target is now required');target=new Vector3();}return this.delta(target).multiplyScalar(t).add(this.start);},applyMatrix4:function applyMatrix4(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this;},equals:function equals(line){return line.start.equals(this.start)&&line.end.equals(this.end);}});/**
 * @author alteredq / http://alteredqualia.com/
 */function ImmediateRenderObject(material){Object3D.call(this);this.material=material;this.render=function()/* renderCallback */{};}ImmediateRenderObject.prototype=(0,_create.default)(Object3D.prototype);ImmediateRenderObject.prototype.constructor=ImmediateRenderObject;ImmediateRenderObject.prototype.isImmediateRenderObject=true;/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */var _vector$8=new Vector3();function SpotLightHelper(light,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;var geometry=new BufferGeometry();var positions=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(var i=0,j=1,l=32;i<l;i++,j++){var p1=i/l*Math.PI*2;var p2=j/l*Math.PI*2;positions.push(Math.cos(p1),Math.sin(p1),1,Math.cos(p2),Math.sin(p2),1);}geometry.setAttribute('position',new Float32BufferAttribute(positions,3));var material=new LineBasicMaterial({fog:false,toneMapped:false});this.cone=new LineSegments(geometry,material);this.add(this.cone);this.update();}SpotLightHelper.prototype=(0,_create.default)(Object3D.prototype);SpotLightHelper.prototype.constructor=SpotLightHelper;SpotLightHelper.prototype.dispose=function(){this.cone.geometry.dispose();this.cone.material.dispose();};SpotLightHelper.prototype.update=function(){this.light.updateMatrixWorld();var coneLength=this.light.distance?this.light.distance:1000;var coneWidth=coneLength*Math.tan(this.light.angle);this.cone.scale.set(coneWidth,coneWidth,coneLength);_vector$8.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(_vector$8);if(this.color!==undefined){this.cone.material.color.set(this.color);}else{this.cone.material.color.copy(this.light.color);}};/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */var _vector$9=new Vector3();var _boneMatrix=new Matrix4();var _matrixWorldInv=new Matrix4();function getBoneList(object){var boneList=[];if(object&&object.isBone){boneList.push(object);}for(var i=0;i<object.children.length;i++){boneList.push.apply(boneList,getBoneList(object.children[i]));}return boneList;}function SkeletonHelper(object){var bones=getBoneList(object);var geometry=new BufferGeometry();var vertices=[];var colors=[];var color1=new Color(0,0,1);var color2=new Color(0,1,0);for(var i=0;i<bones.length;i++){var bone=bones[i];if(bone.parent&&bone.parent.isBone){vertices.push(0,0,0);vertices.push(0,0,0);colors.push(color1.r,color1.g,color1.b);colors.push(color2.r,color2.g,color2.b);}}geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:true,depthTest:false,depthWrite:false,toneMapped:false,transparent:true});LineSegments.call(this,geometry,material);this.root=object;this.bones=bones;this.matrix=object.matrixWorld;this.matrixAutoUpdate=false;}SkeletonHelper.prototype=(0,_create.default)(LineSegments.prototype);SkeletonHelper.prototype.constructor=SkeletonHelper;SkeletonHelper.prototype.isSkeletonHelper=true;SkeletonHelper.prototype.updateMatrixWorld=function(force){var bones=this.bones;var geometry=this.geometry;var position=geometry.getAttribute('position');_matrixWorldInv.getInverse(this.root.matrixWorld);for(var i=0,j=0;i<bones.length;i++){var bone=bones[i];if(bone.parent&&bone.parent.isBone){_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.matrixWorld);_vector$9.setFromMatrixPosition(_boneMatrix);position.setXYZ(j,_vector$9.x,_vector$9.y,_vector$9.z);_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.parent.matrixWorld);_vector$9.setFromMatrixPosition(_boneMatrix);position.setXYZ(j+1,_vector$9.x,_vector$9.y,_vector$9.z);j+=2;}}geometry.getAttribute('position').needsUpdate=true;Object3D.prototype.updateMatrixWorld.call(this,force);};/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */function PointLightHelper(light,sphereSize,color){this.light=light;this.light.updateMatrixWorld();this.color=color;var geometry=new SphereBufferGeometry(sphereSize,4,2);var material=new MeshBasicMaterial({wireframe:true,fog:false,toneMapped:false});Mesh.call(this,geometry,material);this.matrix=this.light.matrixWorld;this.matrixAutoUpdate=false;this.update();/*
	var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/}PointLightHelper.prototype=(0,_create.default)(Mesh.prototype);PointLightHelper.prototype.constructor=PointLightHelper;PointLightHelper.prototype.dispose=function(){this.geometry.dispose();this.material.dispose();};PointLightHelper.prototype.update=function(){if(this.color!==undefined){this.material.color.set(this.color);}else{this.material.color.copy(this.light.color);}/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/};/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */var _vector$a=new Vector3();var _color1=new Color();var _color2=new Color();function HemisphereLightHelper(light,size,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;var geometry=new OctahedronBufferGeometry(size);geometry.rotateY(Math.PI*0.5);this.material=new MeshBasicMaterial({wireframe:true,fog:false,toneMapped:false});if(this.color===undefined)this.material.vertexColors=true;var position=geometry.getAttribute('position');var colors=new Float32Array(position.count*3);geometry.setAttribute('color',new BufferAttribute(colors,3));this.add(new Mesh(geometry,this.material));this.update();}HemisphereLightHelper.prototype=(0,_create.default)(Object3D.prototype);HemisphereLightHelper.prototype.constructor=HemisphereLightHelper;HemisphereLightHelper.prototype.dispose=function(){this.children[0].geometry.dispose();this.children[0].material.dispose();};HemisphereLightHelper.prototype.update=function(){var mesh=this.children[0];if(this.color!==undefined){this.material.color.set(this.color);}else{var colors=mesh.geometry.getAttribute('color');_color1.copy(this.light.color);_color2.copy(this.light.groundColor);for(var i=0,l=colors.count;i<l;i++){var color=i<l/2?_color1:_color2;colors.setXYZ(i,color.r,color.g,color.b);}colors.needsUpdate=true;}mesh.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());};/**
 * @author mrdoob / http://mrdoob.com/
 */function GridHelper(size,divisions,color1,color2){size=size||10;divisions=divisions||10;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var center=divisions/2;var step=size/divisions;var halfSize=size/2;var vertices=[],colors=[];for(var i=0,j=0,k=-halfSize;i<=divisions;i++,k+=step){vertices.push(-halfSize,0,k,halfSize,0,k);vertices.push(k,0,-halfSize,k,0,halfSize);var color=i===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;}var geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:true,toneMapped:false});LineSegments.call(this,geometry,material);}GridHelper.prototype=(0,_assign.default)((0,_create.default)(LineSegments.prototype),{constructor:GridHelper,copy:function copy(source){LineSegments.prototype.copy.call(this,source);this.geometry.copy(source.geometry);this.material.copy(source.material);return this;},clone:function clone(){return new this.constructor().copy(this);}});/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */function PolarGridHelper(radius,radials,circles,divisions,color1,color2){radius=radius||10;radials=radials||16;circles=circles||8;divisions=divisions||64;color1=new Color(color1!==undefined?color1:0x444444);color2=new Color(color2!==undefined?color2:0x888888);var vertices=[];var colors=[];var x,z;var v,i,j,r,color;// create the radials
for(i=0;i<=radials;i++){v=i/radials*(Math.PI*2);x=Math.sin(v)*radius;z=Math.cos(v)*radius;vertices.push(0,0,0);vertices.push(x,0,z);color=i&1?color1:color2;colors.push(color.r,color.g,color.b);colors.push(color.r,color.g,color.b);}// create the circles
for(i=0;i<=circles;i++){color=i&1?color1:color2;r=radius-radius/circles*i;for(j=0;j<divisions;j++){// first vertex
v=j/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);// second vertex
v=(j+1)/divisions*(Math.PI*2);x=Math.sin(v)*r;z=Math.cos(v)*r;vertices.push(x,0,z);colors.push(color.r,color.g,color.b);}}var geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:true,toneMapped:false});LineSegments.call(this,geometry,material);}PolarGridHelper.prototype=(0,_create.default)(LineSegments.prototype);PolarGridHelper.prototype.constructor=PolarGridHelper;/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */var _v1$5=new Vector3();var _v2$3=new Vector3();var _v3$1=new Vector3();function DirectionalLightHelper(light,size,color){Object3D.call(this);this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=false;this.color=color;if(size===undefined)size=1;var geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute([-size,size,0,size,size,0,size,-size,0,-size,-size,0,-size,size,0],3));var material=new LineBasicMaterial({fog:false,toneMapped:false});this.lightPlane=new Line(geometry,material);this.add(this.lightPlane);geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute([0,0,0,0,0,1],3));this.targetLine=new Line(geometry,material);this.add(this.targetLine);this.update();}DirectionalLightHelper.prototype=(0,_create.default)(Object3D.prototype);DirectionalLightHelper.prototype.constructor=DirectionalLightHelper;DirectionalLightHelper.prototype.dispose=function(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose();};DirectionalLightHelper.prototype.update=function(){_v1$5.setFromMatrixPosition(this.light.matrixWorld);_v2$3.setFromMatrixPosition(this.light.target.matrixWorld);_v3$1.subVectors(_v2$3,_v1$5);this.lightPlane.lookAt(_v2$3);if(this.color!==undefined){this.lightPlane.material.color.set(this.color);this.targetLine.material.color.set(this.color);}else{this.lightPlane.material.color.copy(this.light.color);this.targetLine.material.color.copy(this.light.color);}this.targetLine.lookAt(_v2$3);this.targetLine.scale.z=_v3$1.length();};/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */var _vector$b=new Vector3();var camera=new Camera();function CameraHelper(camera){var geometry=new BufferGeometry();var material=new LineBasicMaterial({color:0xffffff,vertexColors:true,toneMapped:false});var vertices=[];var colors=[];var pointMap={};// colors
var colorFrustum=new Color(0xffaa00);var colorCone=new Color(0xff0000);var colorUp=new Color(0x00aaff);var colorTarget=new Color(0xffffff);var colorCross=new Color(0x333333);// near
addLine('n1','n2',colorFrustum);addLine('n2','n4',colorFrustum);addLine('n4','n3',colorFrustum);addLine('n3','n1',colorFrustum);// far
addLine('f1','f2',colorFrustum);addLine('f2','f4',colorFrustum);addLine('f4','f3',colorFrustum);addLine('f3','f1',colorFrustum);// sides
addLine('n1','f1',colorFrustum);addLine('n2','f2',colorFrustum);addLine('n3','f3',colorFrustum);addLine('n4','f4',colorFrustum);// cone
addLine('p','n1',colorCone);addLine('p','n2',colorCone);addLine('p','n3',colorCone);addLine('p','n4',colorCone);// up
addLine('u1','u2',colorUp);addLine('u2','u3',colorUp);addLine('u3','u1',colorUp);// target
addLine('c','t',colorTarget);addLine('p','c',colorCross);// cross
addLine('cn1','cn2',colorCross);addLine('cn3','cn4',colorCross);addLine('cf1','cf2',colorCross);addLine('cf3','cf4',colorCross);function addLine(a,b,color){addPoint(a,color);addPoint(b,color);}function addPoint(id,color){vertices.push(0,0,0);colors.push(color.r,color.g,color.b);if(pointMap[id]===undefined){pointMap[id]=[];}pointMap[id].push(vertices.length/3-1);}geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));LineSegments.call(this,geometry,material);this.camera=camera;if(this.camera.updateProjectionMatrix)this.camera.updateProjectionMatrix();this.matrix=camera.matrixWorld;this.matrixAutoUpdate=false;this.pointMap=pointMap;this.update();}CameraHelper.prototype=(0,_create.default)(LineSegments.prototype);CameraHelper.prototype.constructor=CameraHelper;CameraHelper.prototype.update=function(){var geometry=this.geometry;var pointMap=this.pointMap;var w=1,h=1;// we need just camera projection matrix inverse
// world matrix must be identity
camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);// center / target
setPoint('c',pointMap,geometry,camera,0,0,-1);setPoint('t',pointMap,geometry,camera,0,0,1);// near
setPoint('n1',pointMap,geometry,camera,-w,-h,-1);setPoint('n2',pointMap,geometry,camera,w,-h,-1);setPoint('n3',pointMap,geometry,camera,-w,h,-1);setPoint('n4',pointMap,geometry,camera,w,h,-1);// far
setPoint('f1',pointMap,geometry,camera,-w,-h,1);setPoint('f2',pointMap,geometry,camera,w,-h,1);setPoint('f3',pointMap,geometry,camera,-w,h,1);setPoint('f4',pointMap,geometry,camera,w,h,1);// up
setPoint('u1',pointMap,geometry,camera,w*0.7,h*1.1,-1);setPoint('u2',pointMap,geometry,camera,-w*0.7,h*1.1,-1);setPoint('u3',pointMap,geometry,camera,0,h*2,-1);// cross
setPoint('cf1',pointMap,geometry,camera,-w,0,1);setPoint('cf2',pointMap,geometry,camera,w,0,1);setPoint('cf3',pointMap,geometry,camera,0,-h,1);setPoint('cf4',pointMap,geometry,camera,0,h,1);setPoint('cn1',pointMap,geometry,camera,-w,0,-1);setPoint('cn2',pointMap,geometry,camera,w,0,-1);setPoint('cn3',pointMap,geometry,camera,0,-h,-1);setPoint('cn4',pointMap,geometry,camera,0,h,-1);geometry.getAttribute('position').needsUpdate=true;};function setPoint(point,pointMap,geometry,camera,x,y,z){_vector$b.set(x,y,z).unproject(camera);var points=pointMap[point];if(points!==undefined){var position=geometry.getAttribute('position');for(var i=0,l=points.length;i<l;i++){position.setXYZ(points[i],_vector$b.x,_vector$b.y,_vector$b.z);}}}/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 */var _box$3=new Box3();function BoxHelper(object,color){this.object=object;if(color===undefined)color=0xffff00;var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var positions=new Float32Array(8*3);var geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.setAttribute('position',new BufferAttribute(positions,3));LineSegments.call(this,geometry,new LineBasicMaterial({color:color,toneMapped:false}));this.matrixAutoUpdate=false;this.update();}BoxHelper.prototype=(0,_create.default)(LineSegments.prototype);BoxHelper.prototype.constructor=BoxHelper;BoxHelper.prototype.update=function(object){if(object!==undefined){console.warn('THREE.BoxHelper: .update() has no longer arguments.');}if(this.object!==undefined){_box$3.setFromObject(this.object);}if(_box$3.isEmpty())return;var min=_box$3.min;var max=_box$3.max;/*
	  5____4
	1/___0/|
	| 6__|_7
	2/___3/

	0: max.x, max.y, max.z
	1: min.x, max.y, max.z
	2: min.x, min.y, max.z
	3: max.x, min.y, max.z
	4: max.x, max.y, min.z
	5: min.x, max.y, min.z
	6: min.x, min.y, min.z
	7: max.x, min.y, min.z
	*/var position=this.geometry.attributes.position;var array=position.array;array[0]=max.x;array[1]=max.y;array[2]=max.z;array[3]=min.x;array[4]=max.y;array[5]=max.z;array[6]=min.x;array[7]=min.y;array[8]=max.z;array[9]=max.x;array[10]=min.y;array[11]=max.z;array[12]=max.x;array[13]=max.y;array[14]=min.z;array[15]=min.x;array[16]=max.y;array[17]=min.z;array[18]=min.x;array[19]=min.y;array[20]=min.z;array[21]=max.x;array[22]=min.y;array[23]=min.z;position.needsUpdate=true;this.geometry.computeBoundingSphere();};BoxHelper.prototype.setFromObject=function(object){this.object=object;this.update();return this;};BoxHelper.prototype.copy=function(source){LineSegments.prototype.copy.call(this,source);this.object=source.object;return this;};BoxHelper.prototype.clone=function(){return new this.constructor().copy(this);};/**
 * @author WestLangley / http://github.com/WestLangley
 */function Box3Helper(box,color){this.type='Box3Helper';this.box=box;color=color||0xffff00;var indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]);var positions=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1];var geometry=new BufferGeometry();geometry.setIndex(new BufferAttribute(indices,1));geometry.setAttribute('position',new Float32BufferAttribute(positions,3));LineSegments.call(this,geometry,new LineBasicMaterial({color:color,toneMapped:false}));this.geometry.computeBoundingSphere();}Box3Helper.prototype=(0,_create.default)(LineSegments.prototype);Box3Helper.prototype.constructor=Box3Helper;Box3Helper.prototype.updateMatrixWorld=function(force){var box=this.box;if(box.isEmpty())return;box.getCenter(this.position);box.getSize(this.scale);this.scale.multiplyScalar(0.5);Object3D.prototype.updateMatrixWorld.call(this,force);};/**
 * @author WestLangley / http://github.com/WestLangley
 */function PlaneHelper(plane,size,hex){this.type='PlaneHelper';this.plane=plane;this.size=size===undefined?1:size;var color=hex!==undefined?hex:0xffff00;var positions=[1,-1,1,-1,1,1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,1,0,0,1,0,0,0];var geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(positions,3));geometry.computeBoundingSphere();Line.call(this,geometry,new LineBasicMaterial({color:color,toneMapped:false}));//
var positions2=[1,1,1,-1,1,1,-1,-1,1,1,1,1,-1,-1,1,1,-1,1];var geometry2=new BufferGeometry();geometry2.setAttribute('position',new Float32BufferAttribute(positions2,3));geometry2.computeBoundingSphere();this.add(new Mesh(geometry2,new MeshBasicMaterial({color:color,opacity:0.2,transparent:true,depthWrite:false,toneMapped:false})));}PlaneHelper.prototype=(0,_create.default)(Line.prototype);PlaneHelper.prototype.constructor=PlaneHelper;PlaneHelper.prototype.updateMatrixWorld=function(force){var scale=-this.plane.constant;if(Math.abs(scale)<1e-8)scale=1e-8;// sign does not matter
this.scale.set(0.5*this.size,0.5*this.size,scale);this.children[0].material.side=scale<0?BackSide:FrontSide;// renderer flips side when determinant < 0; flipping not wanted here
this.lookAt(this.plane.normal);Object3D.prototype.updateMatrixWorld.call(this,force);};/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */var _axis=new Vector3();var _lineGeometry,_coneGeometry;function ArrowHelper(dir,origin,length,color,headLength,headWidth){// dir is assumed to be normalized
Object3D.call(this);if(dir===undefined)dir=new Vector3(0,0,1);if(origin===undefined)origin=new Vector3(0,0,0);if(length===undefined)length=1;if(color===undefined)color=0xffff00;if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;if(_lineGeometry===undefined){_lineGeometry=new BufferGeometry();_lineGeometry.setAttribute('position',new Float32BufferAttribute([0,0,0,0,1,0],3));_coneGeometry=new CylinderBufferGeometry(0,0.5,1,5,1);_coneGeometry.translate(0,-0.5,0);}this.position.copy(origin);this.line=new Line(_lineGeometry,new LineBasicMaterial({color:color,toneMapped:false}));this.line.matrixAutoUpdate=false;this.add(this.line);this.cone=new Mesh(_coneGeometry,new MeshBasicMaterial({color:color,toneMapped:false}));this.cone.matrixAutoUpdate=false;this.add(this.cone);this.setDirection(dir);this.setLength(length,headLength,headWidth);}ArrowHelper.prototype=(0,_create.default)(Object3D.prototype);ArrowHelper.prototype.constructor=ArrowHelper;ArrowHelper.prototype.setDirection=function(dir){// dir is assumed to be normalized
if(dir.y>0.99999){this.quaternion.set(0,0,0,1);}else if(dir.y<-0.99999){this.quaternion.set(1,0,0,0);}else{_axis.set(dir.z,0,-dir.x).normalize();var radians=Math.acos(dir.y);this.quaternion.setFromAxisAngle(_axis,radians);}};ArrowHelper.prototype.setLength=function(length,headLength,headWidth){if(headLength===undefined)headLength=0.2*length;if(headWidth===undefined)headWidth=0.2*headLength;this.line.scale.set(1,Math.max(0.0001,length-headLength),1);// see #17458
this.line.updateMatrix();this.cone.scale.set(headWidth,headLength,headWidth);this.cone.position.y=length;this.cone.updateMatrix();};ArrowHelper.prototype.setColor=function(color){this.line.material.color.set(color);this.cone.material.color.set(color);};ArrowHelper.prototype.copy=function(source){Object3D.prototype.copy.call(this,source,false);this.line.copy(source.line);this.cone.copy(source.cone);return this;};ArrowHelper.prototype.clone=function(){return new this.constructor().copy(this);};/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */function AxesHelper(size){size=size||1;var vertices=[0,0,0,size,0,0,0,0,0,0,size,0,0,0,0,0,0,size];var colors=[1,0,0,1,0.6,0,0,1,0,0.6,1,0,0,0,1,0,0.6,1];var geometry=new BufferGeometry();geometry.setAttribute('position',new Float32BufferAttribute(vertices,3));geometry.setAttribute('color',new Float32BufferAttribute(colors,3));var material=new LineBasicMaterial({vertexColors:true,toneMapped:false});LineSegments.call(this,geometry,material);}AxesHelper.prototype=(0,_create.default)(LineSegments.prototype);AxesHelper.prototype.constructor=AxesHelper;/**
 * @author Emmett Lalish / elalish
 *
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */var LOD_MIN=4;var LOD_MAX=8;var SIZE_MAX=Math.pow(2,LOD_MAX);// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
var EXTRA_LOD_SIGMA=[0.125,0.215,0.35,0.446,0.526,0.582];var TOTAL_LODS=LOD_MAX-LOD_MIN+1+EXTRA_LOD_SIGMA.length;// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
var MAX_SAMPLES=20;var ENCODINGS=(_ENCODINGS={},(0,_defineProperty2.default)(_ENCODINGS,LinearEncoding,0),(0,_defineProperty2.default)(_ENCODINGS,sRGBEncoding,1),(0,_defineProperty2.default)(_ENCODINGS,RGBEEncoding,2),(0,_defineProperty2.default)(_ENCODINGS,RGBM7Encoding,3),(0,_defineProperty2.default)(_ENCODINGS,RGBM16Encoding,4),(0,_defineProperty2.default)(_ENCODINGS,RGBDEncoding,5),(0,_defineProperty2.default)(_ENCODINGS,GammaEncoding,6),_ENCODINGS);var _flatCamera=new OrthographicCamera();var _blurMaterial=_getBlurShader(MAX_SAMPLES);var _equirectShader=null;var _cubemapShader=null;var _createPlanes2=_createPlanes(),_lodPlanes=_createPlanes2._lodPlanes,_sizeLods=_createPlanes2._sizeLods,_sigmas=_createPlanes2._sigmas;var _pingPongRenderTarget=null;var _renderer=null;var _oldTarget=null;// Golden Ratio
var PHI=(1+Math.sqrt(5))/2;var INV_PHI=1/PHI;// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
var _axisDirections=[new Vector3(1,1,1),new Vector3(-1,1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,PHI,INV_PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(INV_PHI,0,PHI),new Vector3(-INV_PHI,0,PHI),new Vector3(PHI,INV_PHI,0),new Vector3(-PHI,INV_PHI,0)];function PMREMGenerator(renderer){_renderer=renderer;_compileMaterial(_blurMaterial);}PMREMGenerator.prototype={constructor:PMREMGenerator,/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */fromScene:function fromScene(scene){var sigma=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var near=arguments.length>2&&arguments[2]!==undefined?arguments[2]:0.1;var far=arguments.length>3&&arguments[3]!==undefined?arguments[3]:100;_oldTarget=_renderer.getRenderTarget();var cubeUVRenderTarget=_allocateTargets();_sceneToCubeUV(scene,near,far,cubeUVRenderTarget);if(sigma>0){_blur(cubeUVRenderTarget,0,0,sigma);}_applyPMREM(cubeUVRenderTarget);_cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;},/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromEquirectangular:function fromEquirectangular(equirectangular){equirectangular.magFilter=NearestFilter;equirectangular.minFilter=NearestFilter;equirectangular.generateMipmaps=false;return this.fromCubemap(equirectangular);},/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */fromCubemap:function fromCubemap(cubemap){_oldTarget=_renderer.getRenderTarget();var cubeUVRenderTarget=_allocateTargets(cubemap);_textureToCubeUV(cubemap,cubeUVRenderTarget);_applyPMREM(cubeUVRenderTarget);_cleanup(cubeUVRenderTarget);return cubeUVRenderTarget;},/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileCubemapShader:function compileCubemapShader(){if(_cubemapShader==null){_cubemapShader=_getCubemapShader();_compileMaterial(_cubemapShader);}},/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */compileEquirectangularShader:function compileEquirectangularShader(){if(_equirectShader==null){_equirectShader=_getEquirectShader();_compileMaterial(_equirectShader);}},/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */dispose:function dispose(){_blurMaterial.dispose();if(_cubemapShader!=null)_cubemapShader.dispose();if(_equirectShader!=null)_equirectShader.dispose();for(var i=0;i<_lodPlanes.length;i++){_lodPlanes[i].dispose();}}};function _createPlanes(){var _lodPlanes=[];var _sizeLods=[];var _sigmas=[];var lod=LOD_MAX;for(var i=0;i<TOTAL_LODS;i++){var sizeLod=Math.pow(2,lod);_sizeLods.push(sizeLod);var sigma=1.0/sizeLod;if(i>LOD_MAX-LOD_MIN){sigma=EXTRA_LOD_SIGMA[i-LOD_MAX+LOD_MIN-1];}else if(i==0){sigma=0;}_sigmas.push(sigma);var texelSize=1.0/(sizeLod-1);var min=-texelSize/2;var max=1+texelSize/2;var uv1=[min,min,max,min,max,max,min,min,max,max,min,max];var cubeFaces=6;var vertices=6;var positionSize=3;var uvSize=2;var faceIndexSize=1;var position=new Float32Array(positionSize*vertices*cubeFaces);var uv=new Float32Array(uvSize*vertices*cubeFaces);var faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(var face=0;face<cubeFaces;face++){var x=face%3*2/3-1;var y=face>2?0:-1;var coordinates=[x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0];position.set(coordinates,positionSize*vertices*face);uv.set(uv1,uvSize*vertices*face);var fill=[face,face,face,face,face,face];faceIndex.set(fill,faceIndexSize*vertices*face);}var planes=new BufferGeometry();planes.setAttribute('position',new BufferAttribute(position,positionSize));planes.setAttribute('uv',new BufferAttribute(uv,uvSize));planes.setAttribute('faceIndex',new BufferAttribute(faceIndex,faceIndexSize));_lodPlanes.push(planes);if(lod>LOD_MIN){lod--;}}return{_lodPlanes:_lodPlanes,_sizeLods:_sizeLods,_sigmas:_sigmas};}function _allocateTargets(equirectangular){var params={magFilter:NearestFilter,minFilter:NearestFilter,generateMipmaps:false,type:equirectangular?equirectangular.type:UnsignedByteType,format:equirectangular?equirectangular.format:RGBEFormat,encoding:equirectangular?equirectangular.encoding:RGBEEncoding,depthBuffer:false,stencilBuffer:false};var cubeUVRenderTarget=_createRenderTarget(params);cubeUVRenderTarget.depthBuffer=equirectangular?false:true;_pingPongRenderTarget=_createRenderTarget(params);return cubeUVRenderTarget;}function _cleanup(outputTarget){_pingPongRenderTarget.dispose();_renderer.setRenderTarget(_oldTarget);outputTarget.scissorTest=false;// reset viewport and scissor
outputTarget.setSize(outputTarget.width,outputTarget.height);}function _sceneToCubeUV(scene,near,far,cubeUVRenderTarget){var fov=90;var aspect=1;var cubeCamera=new PerspectiveCamera(fov,aspect,near,far);var upSign=[1,1,1,1,-1,1];var forwardSign=[1,1,-1,-1,-1,1];var outputEncoding=_renderer.outputEncoding;var toneMapping=_renderer.toneMapping;var toneMappingExposure=_renderer.toneMappingExposure;var clearColor=_renderer.getClearColor();var clearAlpha=_renderer.getClearAlpha();_renderer.toneMapping=LinearToneMapping;_renderer.toneMappingExposure=1.0;_renderer.outputEncoding=LinearEncoding;scene.scale.z*=-1;var background=scene.background;if(background&&background.isColor){background.convertSRGBToLinear();// Convert linear to RGBE
var maxComponent=Math.max(background.r,background.g,background.b);var fExp=Math.min(Math.max(Math.ceil(Math.log2(maxComponent)),-128.0),127.0);background=background.multiplyScalar(Math.pow(2.0,-fExp));var alpha=(fExp+128.0)/255.0;_renderer.setClearColor(background,alpha);scene.background=null;}for(var i=0;i<6;i++){var col=i%3;if(col==0){cubeCamera.up.set(0,upSign[i],0);cubeCamera.lookAt(forwardSign[i],0,0);}else if(col==1){cubeCamera.up.set(0,0,upSign[i]);cubeCamera.lookAt(0,forwardSign[i],0);}else{cubeCamera.up.set(0,upSign[i],0);cubeCamera.lookAt(0,0,forwardSign[i]);}_setViewport(cubeUVRenderTarget,col*SIZE_MAX,i>2?SIZE_MAX:0,SIZE_MAX,SIZE_MAX);_renderer.setRenderTarget(cubeUVRenderTarget);_renderer.render(scene,cubeCamera);}_renderer.toneMapping=toneMapping;_renderer.toneMappingExposure=toneMappingExposure;_renderer.outputEncoding=outputEncoding;_renderer.setClearColor(clearColor,clearAlpha);scene.scale.z*=-1;}function _textureToCubeUV(texture,cubeUVRenderTarget){var scene=new Scene();if(texture.isCubeTexture){if(_cubemapShader==null){_cubemapShader=_getCubemapShader();}}else{if(_equirectShader==null){_equirectShader=_getEquirectShader();}}var material=texture.isCubeTexture?_cubemapShader:_equirectShader;scene.add(new Mesh(_lodPlanes[0],material));var uniforms=material.uniforms;uniforms['envMap'].value=texture;if(!texture.isCubeTexture){uniforms['texelSize'].value.set(1.0/texture.image.width,1.0/texture.image.height);}uniforms['inputEncoding'].value=ENCODINGS[texture.encoding];uniforms['outputEncoding'].value=ENCODINGS[texture.encoding];_setViewport(cubeUVRenderTarget,0,0,3*SIZE_MAX,2*SIZE_MAX);_renderer.setRenderTarget(cubeUVRenderTarget);_renderer.render(scene,_flatCamera);}function _compileMaterial(material){var tmpScene=new Scene();tmpScene.add(new Mesh(_lodPlanes[0],material));_renderer.compile(tmpScene,_flatCamera);}function _createRenderTarget(params){var cubeUVRenderTarget=new WebGLRenderTarget(3*SIZE_MAX,3*SIZE_MAX,params);cubeUVRenderTarget.texture.mapping=CubeUVReflectionMapping;cubeUVRenderTarget.texture.name='PMREM.cubeUv';cubeUVRenderTarget.scissorTest=true;return cubeUVRenderTarget;}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height);}function _applyPMREM(cubeUVRenderTarget){var autoClear=_renderer.autoClear;_renderer.autoClear=false;for(var i=1;i<TOTAL_LODS;i++){var sigma=Math.sqrt(_sigmas[i]*_sigmas[i]-_sigmas[i-1]*_sigmas[i-1]);var poleAxis=_axisDirections[(i-1)%_axisDirections.length];_blur(cubeUVRenderTarget,i-1,i,sigma,poleAxis);}_renderer.autoClear=autoClear;}/**
 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
 * vertically and horizontally, but this breaks down on a cube. Here we apply
 * the blur latitudinally (around the poles), and then longitudinally (towards
 * the poles) to approximate the orthogonally-separable blur. It is least
 * accurate at the poles, but still does a decent job.
 */function _blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){_halfBlur(cubeUVRenderTarget,_pingPongRenderTarget,lodIn,lodOut,sigma,'latitudinal',poleAxis);_halfBlur(_pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,'longitudinal',poleAxis);}function _halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){if(direction!=='latitudinal'&&direction!=='longitudinal'){console.error('blur direction must be either latitudinal or longitudinal!');}// Number of standard deviations at which to cut off the discrete approximation.
var STANDARD_DEVIATIONS=3;var blurScene=new Scene();blurScene.add(new Mesh(_lodPlanes[lodOut],_blurMaterial));var blurUniforms=_blurMaterial.uniforms;var pixels=_sizeLods[lodIn]-1;var radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/(2*MAX_SAMPLES-1);var sigmaPixels=sigmaRadians/radiansPerPixel;var samples=isFinite(sigmaRadians)?1+Math.floor(STANDARD_DEVIATIONS*sigmaPixels):MAX_SAMPLES;if(samples>MAX_SAMPLES){console.warn("sigmaRadians, ".concat(sigmaRadians,", is too large and will clip, as it requested ").concat(samples," samples when the maximum is set to ").concat(MAX_SAMPLES));}var weights=[];var sum=0;for(var i=0;i<MAX_SAMPLES;++i){var x=i/sigmaPixels;var weight=Math.exp(-x*x/2);weights.push(weight);if(i==0){sum+=weight;}else if(i<samples){sum+=2*weight;}}for(var i=0;i<weights.length;i++){weights[i]=weights[i]/sum;}blurUniforms['envMap'].value=targetIn.texture;blurUniforms['samples'].value=samples;blurUniforms['weights'].value=weights;blurUniforms['latitudinal'].value=direction==='latitudinal';if(poleAxis){blurUniforms['poleAxis'].value=poleAxis;}blurUniforms['dTheta'].value=radiansPerPixel;blurUniforms['mipInt'].value=LOD_MAX-lodIn;blurUniforms['inputEncoding'].value=ENCODINGS[targetIn.texture.encoding];blurUniforms['outputEncoding'].value=ENCODINGS[targetIn.texture.encoding];var outputSize=_sizeLods[lodOut];var x=3*Math.max(0,SIZE_MAX-2*outputSize);var y=(lodOut===0?0:2*SIZE_MAX)+2*outputSize*(lodOut>LOD_MAX-LOD_MIN?lodOut-LOD_MAX+LOD_MIN:0);_setViewport(targetOut,x,y,3*outputSize,2*outputSize);_renderer.setRenderTarget(targetOut);_renderer.render(blurScene,_flatCamera);}function _getBlurShader(maxSamples){var weights=new Float32Array(maxSamples);var poleAxis=new Vector3(0,1,0);var shaderMaterial=new RawShaderMaterial({defines:{'n':maxSamples},uniforms:{'envMap':{value:null},'samples':{value:1},'weights':{value:weights},'latitudinal':{value:false},'dTheta':{value:0},'mipInt':{value:0},'poleAxis':{value:poleAxis},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:"\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform int samples;\nuniform float weights[n];\nuniform bool latitudinal;\nuniform float dTheta;\nuniform float mipInt;\nuniform vec3 poleAxis;\n\n".concat(_getEncodings(),"\n\n#define ENVMAP_TYPE_CUBE_UV\n#include <cube_uv_reflection_fragment>\n\nvec3 getSample(float theta, vec3 axis) {\n\tfloat cosTheta = cos(theta);\n\t// Rodrigues' axis-angle rotation\n\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t+ cross(axis, vOutputDirection) * sin(theta)\n\t\t+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);\n\treturn bilinearCubeUV(envMap, sampleDirection, mipInt);\n}\n\nvoid main() {\n\tvec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);\n\tif (all(equal(axis, vec3(0.0))))\n\t\taxis = vec3(vOutputDirection.z, 0.0, - vOutputDirection.x);\n\taxis = normalize(axis);\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb += weights[0] * getSample(0.0, axis);\n\tfor (int i = 1; i < n; i++) {\n\t\tif (i >= samples)\n\t\t\tbreak;\n\t\tfloat theta = dTheta * float(i);\n\t\tgl_FragColor.rgb += weights[i] * getSample(-1.0 * theta, axis);\n\t\tgl_FragColor.rgb += weights[i] * getSample(theta, axis);\n\t}\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});shaderMaterial.type='SphericalGaussianBlur';return shaderMaterial;}function _getEquirectShader(){var texelSize=new Vector2(1,1);var shaderMaterial=new RawShaderMaterial({uniforms:{'envMap':{value:null},'texelSize':{value:texelSize},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:"\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform sampler2D envMap;\nuniform vec2 texelSize;\n\n".concat(_getEncodings(),"\n\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tvec3 outputDirection = normalize(vOutputDirection);\n\tvec2 uv;\n\tuv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;\n\tuv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;\n\tvec2 f = fract(uv / texelSize - 0.5);\n\tuv -= f * texelSize;\n\tvec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x += texelSize.x;\n\tvec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.y += texelSize.y;\n\tvec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tuv.x -= texelSize.x;\n\tvec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n\tvec3 tm = mix(tl, tr, f.x);\n\tvec3 bm = mix(bl, br, f.x);\n\tgl_FragColor.rgb = mix(tm, bm, f.y);\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});shaderMaterial.type='EquirectangularToCubeUV';return shaderMaterial;}function _getCubemapShader(){var shaderMaterial=new RawShaderMaterial({uniforms:{'envMap':{value:null},'inputEncoding':{value:ENCODINGS[LinearEncoding]},'outputEncoding':{value:ENCODINGS[LinearEncoding]}},vertexShader:_getCommonVertexShader(),fragmentShader:"\nprecision mediump float;\nprecision mediump int;\nvarying vec3 vOutputDirection;\nuniform samplerCube envMap;\n\n".concat(_getEncodings(),"\n\nvoid main() {\n\tgl_FragColor = vec4(0.0);\n\tgl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;\n\tgl_FragColor = linearToOutputTexel(gl_FragColor);\n}\n\t\t"),blending:NoBlending,depthTest:false,depthWrite:false});shaderMaterial.type='CubemapToCubeUV';return shaderMaterial;}function _getCommonVertexShader(){return"\nprecision mediump float;\nprecision mediump int;\nattribute vec3 position;\nattribute vec2 uv;\nattribute float faceIndex;\nvarying vec3 vOutputDirection;\nvec3 getDirection(vec2 uv, float face) {\n\tuv = 2.0 * uv - 1.0;\n\tvec3 direction = vec3(uv, 1.0);\n\tif (face == 0.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 1.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.z *= -1.0;\n\t} else if (face == 3.0) {\n\t\tdirection = direction.zyx;\n\t\tdirection.x *= -1.0;\n\t} else if (face == 4.0) {\n\t\tdirection = direction.xzy;\n\t\tdirection.y *= -1.0;\n\t} else if (face == 5.0) {\n\t\tdirection.xz *= -1.0;\n\t}\n\treturn direction;\n}\nvoid main() {\n\tvOutputDirection = getDirection(uv, faceIndex);\n\tgl_Position = vec4( position, 1.0 );\n}\n\t";}function _getEncodings(){return"\nuniform int inputEncoding;\nuniform int outputEncoding;\n\n#include <encodings_pars_fragment>\n\nvec4 inputTexelToLinear(vec4 value){\n\tif(inputEncoding == 0){\n\t\treturn value;\n\t}else if(inputEncoding == 1){\n\t\treturn sRGBToLinear(value);\n\t}else if(inputEncoding == 2){\n\t\treturn RGBEToLinear(value);\n\t}else if(inputEncoding == 3){\n\t\treturn RGBMToLinear(value, 7.0);\n\t}else if(inputEncoding == 4){\n\t\treturn RGBMToLinear(value, 16.0);\n\t}else if(inputEncoding == 5){\n\t\treturn RGBDToLinear(value, 256.0);\n\t}else{\n\t\treturn GammaToLinear(value, 2.2);\n\t}\n}\n\nvec4 linearToOutputTexel(vec4 value){\n\tif(outputEncoding == 0){\n\t\treturn value;\n\t}else if(outputEncoding == 1){\n\t\treturn LinearTosRGB(value);\n\t}else if(outputEncoding == 2){\n\t\treturn LinearToRGBE(value);\n\t}else if(outputEncoding == 3){\n\t\treturn LinearToRGBM(value, 7.0);\n\t}else if(outputEncoding == 4){\n\t\treturn LinearToRGBM(value, 16.0);\n\t}else if(outputEncoding == 5){\n\t\treturn LinearToRGBD(value, 256.0);\n\t}else{\n\t\treturn LinearToGamma(value, 2.2);\n\t}\n}\n\nvec4 envMapTexelToLinear(vec4 color) {\n\treturn inputTexelToLinear(color);\n}\n\t";}/**
 * @author mrdoob / http://mrdoob.com/
 */function Face4(a,b,c,d,normal,color,materialIndex){console.warn('THREE.Face4 has been removed. A THREE.Face3 will be created instead.');return new Face3(a,b,c,normal,color,materialIndex);}var LineStrip=0;exports.LineStrip=LineStrip;var LinePieces=1;exports.LinePieces=LinePieces;var NoColors=0;exports.NoColors=NoColors;var FaceColors=1;exports.FaceColors=FaceColors;var VertexColors=2;exports.VertexColors=VertexColors;function MeshFaceMaterial(materials){console.warn('THREE.MeshFaceMaterial has been removed. Use an Array instead.');return materials;}function MultiMaterial(materials){if(materials===undefined)materials=[];console.warn('THREE.MultiMaterial has been removed. Use an Array instead.');materials.isMultiMaterial=true;materials.materials=materials;materials.clone=function(){return materials.slice();};return materials;}function PointCloud(geometry,material){console.warn('THREE.PointCloud has been renamed to THREE.Points.');return new Points(geometry,material);}function Particle(material){console.warn('THREE.Particle has been renamed to THREE.Sprite.');return new Sprite(material);}function ParticleSystem(geometry,material){console.warn('THREE.ParticleSystem has been renamed to THREE.Points.');return new Points(geometry,material);}function PointCloudMaterial(parameters){console.warn('THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleBasicMaterial(parameters){console.warn('THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function ParticleSystemMaterial(parameters){console.warn('THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.');return new PointsMaterial(parameters);}function Vertex(x,y,z){console.warn('THREE.Vertex has been removed. Use THREE.Vector3 instead.');return new Vector3(x,y,z);}//
function DynamicBufferAttribute(array,itemSize){console.warn('THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.');return new BufferAttribute(array,itemSize).setUsage(DynamicDrawUsage);}function Int8Attribute(array,itemSize){console.warn('THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.');return new Int8BufferAttribute(array,itemSize);}function Uint8Attribute(array,itemSize){console.warn('THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.');return new Uint8BufferAttribute(array,itemSize);}function Uint8ClampedAttribute(array,itemSize){console.warn('THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.');return new Uint8ClampedBufferAttribute(array,itemSize);}function Int16Attribute(array,itemSize){console.warn('THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.');return new Int16BufferAttribute(array,itemSize);}function Uint16Attribute(array,itemSize){console.warn('THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.');return new Uint16BufferAttribute(array,itemSize);}function Int32Attribute(array,itemSize){console.warn('THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.');return new Int32BufferAttribute(array,itemSize);}function Uint32Attribute(array,itemSize){console.warn('THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.');return new Uint32BufferAttribute(array,itemSize);}function Float32Attribute(array,itemSize){console.warn('THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.');return new Float32BufferAttribute(array,itemSize);}function Float64Attribute(array,itemSize){console.warn('THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.');return new Float64BufferAttribute(array,itemSize);}//
Curve.create=function(construct,getPoint){console.log('THREE.Curve.create() has been deprecated');construct.prototype=(0,_create.default)(Curve.prototype);construct.prototype.constructor=construct;construct.prototype.getPoint=getPoint;return construct;};//
(0,_assign.default)(CurvePath.prototype,{createPointsGeometry:function createPointsGeometry(divisions){console.warn('THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');// generate geometry from path points (for Line or Points objects)
var pts=this.getPoints(divisions);return this.createGeometry(pts);},createSpacedPointsGeometry:function createSpacedPointsGeometry(divisions){console.warn('THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');// generate geometry from equidistant sampling along the path
var pts=this.getSpacedPoints(divisions);return this.createGeometry(pts);},createGeometry:function createGeometry(points){console.warn('THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.');var geometry=new Geometry();for(var i=0,l=points.length;i<l;i++){var point=points[i];geometry.vertices.push(new Vector3(point.x,point.y,point.z||0));}return geometry;}});//
(0,_assign.default)(Path.prototype,{fromPoints:function fromPoints(points){console.warn('THREE.Path: .fromPoints() has been renamed to .setFromPoints().');return this.setFromPoints(points);}});//
function ClosedSplineCurve3(points){console.warn('THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';this.closed=true;}ClosedSplineCurve3.prototype=(0,_create.default)(CatmullRomCurve3.prototype);//
function SplineCurve3(points){console.warn('THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}SplineCurve3.prototype=(0,_create.default)(CatmullRomCurve3.prototype);//
function Spline(points){console.warn('THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.');CatmullRomCurve3.call(this,points);this.type='catmullrom';}Spline.prototype=(0,_create.default)(CatmullRomCurve3.prototype);(0,_assign.default)(Spline.prototype,{initFromArray:function initFromArray()/* a */{console.error('THREE.Spline: .initFromArray() has been removed.');},getControlPointsArray:function getControlPointsArray()/* optionalTarget */{console.error('THREE.Spline: .getControlPointsArray() has been removed.');},reparametrizeByArcLength:function reparametrizeByArcLength()/* samplingCoef */{console.error('THREE.Spline: .reparametrizeByArcLength() has been removed.');}});//
function AxisHelper(size){console.warn('THREE.AxisHelper has been renamed to THREE.AxesHelper.');return new AxesHelper(size);}function BoundingBoxHelper(object,color){console.warn('THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.');return new BoxHelper(object,color);}function EdgesHelper(object,hex){console.warn('THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.');return new LineSegments(new EdgesGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}GridHelper.prototype.setColors=function(){console.error('THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.');};SkeletonHelper.prototype.update=function(){console.error('THREE.SkeletonHelper: update() no longer needs to be called.');};function WireframeHelper(object,hex){console.warn('THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.');return new LineSegments(new WireframeGeometry(object.geometry),new LineBasicMaterial({color:hex!==undefined?hex:0xffffff}));}//
(0,_assign.default)(Loader.prototype,{extractUrlBase:function extractUrlBase(url){console.warn('THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.');return LoaderUtils.extractUrlBase(url);}});Loader.Handlers={add:function add()/* regex, loader */{console.error('THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.');},get:function get()/* file */{console.error('THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.');}};function XHRLoader(manager){console.warn('THREE.XHRLoader has been renamed to THREE.FileLoader.');return new FileLoader(manager);}function BinaryTextureLoader(manager){console.warn('THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.');return new DataTextureLoader(manager);}(0,_assign.default)(ObjectLoader.prototype,{setTexturePath:function setTexturePath(value){console.warn('THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().');return this.setResourcePath(value);}});//
(0,_assign.default)(Box2.prototype,{center:function center(optionalTarget){console.warn('THREE.Box2: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function empty(){console.warn('THREE.Box2: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},size:function size(optionalTarget){console.warn('THREE.Box2: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});(0,_assign.default)(Box3.prototype,{center:function center(optionalTarget){console.warn('THREE.Box3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);},empty:function empty(){console.warn('THREE.Box3: .empty() has been renamed to .isEmpty().');return this.isEmpty();},isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionSphere:function isIntersectionSphere(sphere){console.warn('THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);},size:function size(optionalTarget){console.warn('THREE.Box3: .size() has been renamed to .getSize().');return this.getSize(optionalTarget);}});Frustum.prototype.setFromMatrix=function(m){console.warn('THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().');return this.setFromProjectionMatrix(m);};Line3.prototype.center=function(optionalTarget){console.warn('THREE.Line3: .center() has been renamed to .getCenter().');return this.getCenter(optionalTarget);};(0,_assign.default)(MathUtils,{random16:function random16(){console.warn('THREE.Math: .random16() has been deprecated. Use Math.random() instead.');return Math.random();},nearestPowerOfTwo:function nearestPowerOfTwo(value){console.warn('THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().');return MathUtils.floorPowerOfTwo(value);},nextPowerOfTwo:function nextPowerOfTwo(value){console.warn('THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().');return MathUtils.ceilPowerOfTwo(value);}});(0,_assign.default)(Matrix3.prototype,{flattenToArrayOffset:function flattenToArrayOffset(array,offset){console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},multiplyVector3:function multiplyVector3(vector){console.warn('THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.');return vector.applyMatrix3(this);},multiplyVector3Array:function multiplyVector3Array()/* a */{console.error('THREE.Matrix3: .multiplyVector3Array() has been removed.');},applyToBufferAttribute:function applyToBufferAttribute(attribute){console.warn('THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.');return attribute.applyMatrix3(this);},applyToVector3Array:function applyToVector3Array()/* array, offset, length */{console.error('THREE.Matrix3: .applyToVector3Array() has been removed.');}});(0,_assign.default)(Matrix4.prototype,{extractPosition:function extractPosition(m){console.warn('THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().');return this.copyPosition(m);},flattenToArrayOffset:function flattenToArrayOffset(array,offset){console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");return this.toArray(array,offset);},getPosition:function getPosition(){console.warn('THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.');return new Vector3().setFromMatrixColumn(this,3);},setRotationFromQuaternion:function setRotationFromQuaternion(q){console.warn('THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().');return this.makeRotationFromQuaternion(q);},multiplyToArray:function multiplyToArray(){console.warn('THREE.Matrix4: .multiplyToArray() has been removed.');},multiplyVector3:function multiplyVector3(vector){console.warn('THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector4:function multiplyVector4(vector){console.warn('THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},multiplyVector3Array:function multiplyVector3Array()/* a */{console.error('THREE.Matrix4: .multiplyVector3Array() has been removed.');},rotateAxis:function rotateAxis(v){console.warn('THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.');v.transformDirection(this);},crossVector:function crossVector(vector){console.warn('THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.');return vector.applyMatrix4(this);},translate:function translate(){console.error('THREE.Matrix4: .translate() has been removed.');},rotateX:function rotateX(){console.error('THREE.Matrix4: .rotateX() has been removed.');},rotateY:function rotateY(){console.error('THREE.Matrix4: .rotateY() has been removed.');},rotateZ:function rotateZ(){console.error('THREE.Matrix4: .rotateZ() has been removed.');},rotateByAxis:function rotateByAxis(){console.error('THREE.Matrix4: .rotateByAxis() has been removed.');},applyToBufferAttribute:function applyToBufferAttribute(attribute){console.warn('THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.');return attribute.applyMatrix4(this);},applyToVector3Array:function applyToVector3Array()/* array, offset, length */{console.error('THREE.Matrix4: .applyToVector3Array() has been removed.');},makeFrustum:function makeFrustum(left,right,bottom,top,near,far){console.warn('THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.');return this.makePerspective(left,right,top,bottom,near,far);}});Plane.prototype.isIntersectionLine=function(line){console.warn('THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().');return this.intersectsLine(line);};Quaternion.prototype.multiplyVector3=function(vector){console.warn('THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.');return vector.applyQuaternion(this);};(0,_assign.default)(Ray.prototype,{isIntersectionBox:function isIntersectionBox(box){console.warn('THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().');return this.intersectsBox(box);},isIntersectionPlane:function isIntersectionPlane(plane){console.warn('THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().');return this.intersectsPlane(plane);},isIntersectionSphere:function isIntersectionSphere(sphere){console.warn('THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().');return this.intersectsSphere(sphere);}});(0,_assign.default)(Triangle.prototype,{area:function area(){console.warn('THREE.Triangle: .area() has been renamed to .getArea().');return this.getArea();},barycoordFromPoint:function barycoordFromPoint(point,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return this.getBarycoord(point,target);},midpoint:function midpoint(target){console.warn('THREE.Triangle: .midpoint() has been renamed to .getMidpoint().');return this.getMidpoint(target);},normal:function normal(target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return this.getNormal(target);},plane:function plane(target){console.warn('THREE.Triangle: .plane() has been renamed to .getPlane().');return this.getPlane(target);}});(0,_assign.default)(Triangle,{barycoordFromPoint:function barycoordFromPoint(point,a,b,c,target){console.warn('THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().');return Triangle.getBarycoord(point,a,b,c,target);},normal:function normal(a,b,c,target){console.warn('THREE.Triangle: .normal() has been renamed to .getNormal().');return Triangle.getNormal(a,b,c,target);}});(0,_assign.default)(Shape.prototype,{extractAllPoints:function extractAllPoints(divisions){console.warn('THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.');return this.extractPoints(divisions);},extrude:function extrude(options){console.warn('THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.');return new ExtrudeGeometry(this,options);},makeGeometry:function makeGeometry(options){console.warn('THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.');return new ShapeGeometry(this,options);}});(0,_assign.default)(Vector2.prototype,{fromAttribute:function fromAttribute(attribute,index,offset){console.warn('THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},distanceToManhattan:function distanceToManhattan(v){console.warn('THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);},lengthManhattan:function lengthManhattan(){console.warn('THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});(0,_assign.default)(Vector3.prototype,{setEulerFromRotationMatrix:function setEulerFromRotationMatrix(){console.error('THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.');},setEulerFromQuaternion:function setEulerFromQuaternion(){console.error('THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.');},getPositionFromMatrix:function getPositionFromMatrix(m){console.warn('THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().');return this.setFromMatrixPosition(m);},getScaleFromMatrix:function getScaleFromMatrix(m){console.warn('THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().');return this.setFromMatrixScale(m);},getColumnFromMatrix:function getColumnFromMatrix(index,matrix){console.warn('THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().');return this.setFromMatrixColumn(matrix,index);},applyProjection:function applyProjection(m){console.warn('THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.');return this.applyMatrix4(m);},fromAttribute:function fromAttribute(attribute,index,offset){console.warn('THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},distanceToManhattan:function distanceToManhattan(v){console.warn('THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().');return this.manhattanDistanceTo(v);},lengthManhattan:function lengthManhattan(){console.warn('THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});(0,_assign.default)(Vector4.prototype,{fromAttribute:function fromAttribute(attribute,index,offset){console.warn('THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().');return this.fromBufferAttribute(attribute,index,offset);},lengthManhattan:function lengthManhattan(){console.warn('THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().');return this.manhattanLength();}});//
(0,_assign.default)(Geometry.prototype,{computeTangents:function computeTangents(){console.error('THREE.Geometry: .computeTangents() has been removed.');},computeLineDistances:function computeLineDistances(){console.error('THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.');},applyMatrix:function applyMatrix(matrix){console.warn('THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);}});(0,_assign.default)(Object3D.prototype,{getChildByName:function getChildByName(name){console.warn('THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().');return this.getObjectByName(name);},renderDepth:function renderDepth(){console.warn('THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.');},translate:function translate(distance,axis){console.warn('THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.');return this.translateOnAxis(axis,distance);},getWorldRotation:function getWorldRotation(){console.error('THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.');},applyMatrix:function applyMatrix(matrix){console.warn('THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);}});(0,_defineProperties.default)(Object3D.prototype,{eulerOrder:{get:function get(){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');return this.rotation.order;},set:function set(value){console.warn('THREE.Object3D: .eulerOrder is now .rotation.order.');this.rotation.order=value;}},useQuaternion:{get:function get(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');},set:function set(){console.warn('THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.');}}});(0,_assign.default)(Mesh.prototype,{setDrawMode:function setDrawMode(){console.error('THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');}});(0,_defineProperties.default)(Mesh.prototype,{drawMode:{get:function get(){console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.');return TrianglesDrawMode;},set:function set(){console.error('THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.');}}});(0,_defineProperties.default)(LOD.prototype,{objects:{get:function get(){console.warn('THREE.LOD: .objects has been renamed to .levels.');return this.levels;}}});(0,_defineProperty3.default)(Skeleton.prototype,'useVertexTexture',{get:function get(){console.warn('THREE.Skeleton: useVertexTexture has been removed.');},set:function set(){console.warn('THREE.Skeleton: useVertexTexture has been removed.');}});SkinnedMesh.prototype.initBones=function(){console.error('THREE.SkinnedMesh: initBones() has been removed.');};(0,_defineProperty3.default)(Curve.prototype,'__arcLengthDivisions',{get:function get(){console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');return this.arcLengthDivisions;},set:function set(value){console.warn('THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.');this.arcLengthDivisions=value;}});//
PerspectiveCamera.prototype.setLens=function(focalLength,filmGauge){console.warn("THREE.PerspectiveCamera.setLens is deprecated. "+"Use .setFocalLength and .filmGauge for a photographic setup.");if(filmGauge!==undefined)this.filmGauge=filmGauge;this.setFocalLength(focalLength);};//
(0,_defineProperties.default)(Light.prototype,{onlyShadow:{set:function set(){console.warn('THREE.Light: .onlyShadow has been removed.');}},shadowCameraFov:{set:function set(value){console.warn('THREE.Light: .shadowCameraFov is now .shadow.camera.fov.');this.shadow.camera.fov=value;}},shadowCameraLeft:{set:function set(value){console.warn('THREE.Light: .shadowCameraLeft is now .shadow.camera.left.');this.shadow.camera.left=value;}},shadowCameraRight:{set:function set(value){console.warn('THREE.Light: .shadowCameraRight is now .shadow.camera.right.');this.shadow.camera.right=value;}},shadowCameraTop:{set:function set(value){console.warn('THREE.Light: .shadowCameraTop is now .shadow.camera.top.');this.shadow.camera.top=value;}},shadowCameraBottom:{set:function set(value){console.warn('THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.');this.shadow.camera.bottom=value;}},shadowCameraNear:{set:function set(value){console.warn('THREE.Light: .shadowCameraNear is now .shadow.camera.near.');this.shadow.camera.near=value;}},shadowCameraFar:{set:function set(value){console.warn('THREE.Light: .shadowCameraFar is now .shadow.camera.far.');this.shadow.camera.far=value;}},shadowCameraVisible:{set:function set(){console.warn('THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.');}},shadowBias:{set:function set(value){console.warn('THREE.Light: .shadowBias is now .shadow.bias.');this.shadow.bias=value;}},shadowDarkness:{set:function set(){console.warn('THREE.Light: .shadowDarkness has been removed.');}},shadowMapWidth:{set:function set(value){console.warn('THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.');this.shadow.mapSize.width=value;}},shadowMapHeight:{set:function set(value){console.warn('THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.');this.shadow.mapSize.height=value;}}});//
(0,_defineProperties.default)(BufferAttribute.prototype,{length:{get:function get(){console.warn('THREE.BufferAttribute: .length has been deprecated. Use .count instead.');return this.array.length;}},dynamic:{get:function get(){console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');return this.usage===DynamicDrawUsage;},set:function set()/* value */{console.warn('THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.');this.setUsage(DynamicDrawUsage);}}});(0,_assign.default)(BufferAttribute.prototype,{setDynamic:function setDynamic(value){console.warn('THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.');this.setUsage(value===true?DynamicDrawUsage:StaticDrawUsage);return this;},copyIndicesArray:function copyIndicesArray()/* indices */{console.error('THREE.BufferAttribute: .copyIndicesArray() has been removed.');},setArray:function setArray()/* array */{console.error('THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');}});(0,_assign.default)(BufferGeometry.prototype,{addIndex:function addIndex(index){console.warn('THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().');this.setIndex(index);},addAttribute:function addAttribute(name,attribute){//console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );
if(!(attribute&&attribute.isBufferAttribute)&&!(attribute&&attribute.isInterleavedBufferAttribute)){console.warn('THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).');return this.setAttribute(name,new BufferAttribute(arguments[1],arguments[2]));}if(name==='index'){console.warn('THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.');this.setIndex(attribute);return this;}return this.setAttribute(name,attribute);},addDrawCall:function addDrawCall(start,count,indexOffset){if(indexOffset!==undefined){console.warn('THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.');}console.warn('THREE.BufferGeometry: .addDrawCall() is now .addGroup().');this.addGroup(start,count);},clearDrawCalls:function clearDrawCalls(){console.warn('THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().');this.clearGroups();},computeTangents:function computeTangents(){console.warn('THREE.BufferGeometry: .computeTangents() has been removed.');},computeOffsets:function computeOffsets(){console.warn('THREE.BufferGeometry: .computeOffsets() has been removed.');},removeAttribute:function removeAttribute(name){console.warn('THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().');return this.deleteAttribute(name);},applyMatrix:function applyMatrix(matrix){console.warn('THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().');return this.applyMatrix4(matrix);}});(0,_defineProperties.default)(BufferGeometry.prototype,{drawcalls:{get:function get(){console.error('THREE.BufferGeometry: .drawcalls has been renamed to .groups.');return this.groups;}},offsets:{get:function get(){console.warn('THREE.BufferGeometry: .offsets has been renamed to .groups.');return this.groups;}}});(0,_defineProperties.default)(Raycaster.prototype,{linePrecision:{get:function get(){console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');return this.params.Line.threshold;},set:function set(value){console.warn('THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.');this.params.Line.threshold=value;}}});(0,_defineProperties.default)(InterleavedBuffer.prototype,{dynamic:{get:function get(){console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');return this.usage===DynamicDrawUsage;},set:function set(value){console.warn('THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.');this.setUsage(value);}}});(0,_assign.default)(InterleavedBuffer.prototype,{setDynamic:function setDynamic(value){console.warn('THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.');this.setUsage(value===true?DynamicDrawUsage:StaticDrawUsage);return this;},setArray:function setArray()/* array */{console.error('THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers');}});//
(0,_assign.default)(ExtrudeBufferGeometry.prototype,{getArrays:function getArrays(){console.error('THREE.ExtrudeBufferGeometry: .getArrays() has been removed.');},addShapeList:function addShapeList(){console.error('THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.');},addShape:function addShape(){console.error('THREE.ExtrudeBufferGeometry: .addShape() has been removed.');}});//
(0,_defineProperties.default)(Uniform.prototype,{dynamic:{set:function set(){console.warn('THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.');}},onUpdate:{value:function value(){console.warn('THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.');return this;}}});//
(0,_defineProperties.default)(Material.prototype,{wrapAround:{get:function get(){console.warn('THREE.Material: .wrapAround has been removed.');},set:function set(){console.warn('THREE.Material: .wrapAround has been removed.');}},overdraw:{get:function get(){console.warn('THREE.Material: .overdraw has been removed.');},set:function set(){console.warn('THREE.Material: .overdraw has been removed.');}},wrapRGB:{get:function get(){console.warn('THREE.Material: .wrapRGB has been removed.');return new Color();}},shading:{get:function get(){console.error('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');},set:function set(value){console.warn('THREE.'+this.type+': .shading has been removed. Use the boolean .flatShading instead.');this.flatShading=value===FlatShading;}},stencilMask:{get:function get(){console.warn('THREE.'+this.type+': .stencilMask has been removed. Use .stencilFuncMask instead.');return this.stencilFuncMask;},set:function set(value){console.warn('THREE.'+this.type+': .stencilMask has been removed. Use .stencilFuncMask instead.');this.stencilFuncMask=value;}}});(0,_defineProperties.default)(MeshPhongMaterial.prototype,{metal:{get:function get(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.');return false;},set:function set(){console.warn('THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead');}}});(0,_defineProperties.default)(ShaderMaterial.prototype,{derivatives:{get:function get(){console.warn('THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');return this.extensions.derivatives;},set:function set(value){console.warn('THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.');this.extensions.derivatives=value;}}});//
(0,_assign.default)(WebGLRenderer.prototype,{clearTarget:function clearTarget(renderTarget,color,depth,stencil){console.warn('THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.');this.setRenderTarget(renderTarget);this.clear(color,depth,stencil);},animate:function animate(callback){console.warn('THREE.WebGLRenderer: .animate() is now .setAnimationLoop().');this.setAnimationLoop(callback);},getCurrentRenderTarget:function getCurrentRenderTarget(){console.warn('THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().');return this.getRenderTarget();},getMaxAnisotropy:function getMaxAnisotropy(){console.warn('THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().');return this.capabilities.getMaxAnisotropy();},getPrecision:function getPrecision(){console.warn('THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.');return this.capabilities.precision;},resetGLState:function resetGLState(){console.warn('THREE.WebGLRenderer: .resetGLState() is now .state.reset().');return this.state.reset();},supportsFloatTextures:function supportsFloatTextures(){console.warn('THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).');return this.extensions.get('OES_texture_float');},supportsHalfFloatTextures:function supportsHalfFloatTextures(){console.warn('THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).');return this.extensions.get('OES_texture_half_float');},supportsStandardDerivatives:function supportsStandardDerivatives(){console.warn('THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).');return this.extensions.get('OES_standard_derivatives');},supportsCompressedTextureS3TC:function supportsCompressedTextureS3TC(){console.warn('THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).');return this.extensions.get('WEBGL_compressed_texture_s3tc');},supportsCompressedTexturePVRTC:function supportsCompressedTexturePVRTC(){console.warn('THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).');return this.extensions.get('WEBGL_compressed_texture_pvrtc');},supportsBlendMinMax:function supportsBlendMinMax(){console.warn('THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).');return this.extensions.get('EXT_blend_minmax');},supportsVertexTextures:function supportsVertexTextures(){console.warn('THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.');return this.capabilities.vertexTextures;},supportsInstancedArrays:function supportsInstancedArrays(){console.warn('THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).');return this.extensions.get('ANGLE_instanced_arrays');},enableScissorTest:function enableScissorTest(boolean){console.warn('THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().');this.setScissorTest(boolean);},initMaterial:function initMaterial(){console.warn('THREE.WebGLRenderer: .initMaterial() has been removed.');},addPrePlugin:function addPrePlugin(){console.warn('THREE.WebGLRenderer: .addPrePlugin() has been removed.');},addPostPlugin:function addPostPlugin(){console.warn('THREE.WebGLRenderer: .addPostPlugin() has been removed.');},updateShadowMap:function updateShadowMap(){console.warn('THREE.WebGLRenderer: .updateShadowMap() has been removed.');},setFaceCulling:function setFaceCulling(){console.warn('THREE.WebGLRenderer: .setFaceCulling() has been removed.');},allocTextureUnit:function allocTextureUnit(){console.warn('THREE.WebGLRenderer: .allocTextureUnit() has been removed.');},setTexture:function setTexture(){console.warn('THREE.WebGLRenderer: .setTexture() has been removed.');},setTexture2D:function setTexture2D(){console.warn('THREE.WebGLRenderer: .setTexture2D() has been removed.');},setTextureCube:function setTextureCube(){console.warn('THREE.WebGLRenderer: .setTextureCube() has been removed.');},getActiveMipMapLevel:function getActiveMipMapLevel(){console.warn('THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().');return this.getActiveMipmapLevel();}});(0,_defineProperties.default)(WebGLRenderer.prototype,{shadowMapEnabled:{get:function get(){return this.shadowMap.enabled;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.');this.shadowMap.enabled=value;}},shadowMapType:{get:function get(){return this.shadowMap.type;},set:function set(value){console.warn('THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.');this.shadowMap.type=value;}},shadowMapCullFace:{get:function get(){console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function set()/* value */{console.warn('THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.');}},context:{get:function get(){console.warn('THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.');return this.getContext();}},vr:{get:function get(){console.warn('THREE.WebGLRenderer: .vr has been renamed to .xr');return this.xr;}},gammaInput:{get:function get(){console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');return false;},set:function set(){console.warn('THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.');}},gammaOutput:{get:function get(){console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');return false;},set:function set(value){console.warn('THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.');this.outputEncoding=value===true?sRGBEncoding:LinearEncoding;}}});(0,_defineProperties.default)(WebGLShadowMap.prototype,{cullFace:{get:function get(){console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');return undefined;},set:function set()/* cullFace */{console.warn('THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.');}},renderReverseSided:{get:function get(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function set(){console.warn('THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.');}},renderSingleSided:{get:function get(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');return undefined;},set:function set(){console.warn('THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.');}}});function WebGLRenderTargetCube(width,height,options){console.warn('THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).');return new WebGLCubeRenderTarget(width,options);}//
(0,_defineProperties.default)(WebGLRenderTarget.prototype,{wrapS:{get:function get(){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');return this.texture.wrapS;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.');this.texture.wrapS=value;}},wrapT:{get:function get(){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');return this.texture.wrapT;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.');this.texture.wrapT=value;}},magFilter:{get:function get(){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');return this.texture.magFilter;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.');this.texture.magFilter=value;}},minFilter:{get:function get(){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');return this.texture.minFilter;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.');this.texture.minFilter=value;}},anisotropy:{get:function get(){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');return this.texture.anisotropy;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.');this.texture.anisotropy=value;}},offset:{get:function get(){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');return this.texture.offset;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .offset is now .texture.offset.');this.texture.offset=value;}},repeat:{get:function get(){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');return this.texture.repeat;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .repeat is now .texture.repeat.');this.texture.repeat=value;}},format:{get:function get(){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');return this.texture.format;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .format is now .texture.format.');this.texture.format=value;}},type:{get:function get(){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');return this.texture.type;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .type is now .texture.type.');this.texture.type=value;}},generateMipmaps:{get:function get(){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');return this.texture.generateMipmaps;},set:function set(value){console.warn('THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.');this.texture.generateMipmaps=value;}}});//
(0,_defineProperties.default)(Audio.prototype,{load:{value:function value(file){console.warn('THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.');var scope=this;var audioLoader=new AudioLoader();audioLoader.load(file,function(buffer){scope.setBuffer(buffer);});return this;}},startTime:{set:function set(){console.warn('THREE.Audio: .startTime is now .play( delay ).');}}});AudioAnalyser.prototype.getData=function(){console.warn('THREE.AudioAnalyser: .getData() is now .getFrequencyData().');return this.getFrequencyData();};//
CubeCamera.prototype.updateCubeMap=function(renderer,scene){console.warn('THREE.CubeCamera: .updateCubeMap() is now .update().');return this.update(renderer,scene);};//
var GeometryUtils={merge:function merge(geometry1,geometry2,materialIndexOffset){console.warn('THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.');var matrix;if(geometry2.isMesh){geometry2.matrixAutoUpdate&&geometry2.updateMatrix();matrix=geometry2.matrix;geometry2=geometry2.geometry;}geometry1.merge(geometry2,matrix,materialIndexOffset);},center:function center(geometry){console.warn('THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.');return geometry.center();}};exports.GeometryUtils=GeometryUtils;ImageUtils.crossOrigin=undefined;ImageUtils.loadTexture=function(url,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.');var loader=new TextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(url,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;};ImageUtils.loadTextureCube=function(urls,mapping,onLoad,onError){console.warn('THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.');var loader=new CubeTextureLoader();loader.setCrossOrigin(this.crossOrigin);var texture=loader.load(urls,onLoad,undefined,onError);if(mapping)texture.mapping=mapping;return texture;};ImageUtils.loadCompressedTexture=function(){console.error('THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.');};ImageUtils.loadCompressedTextureCube=function(){console.error('THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.');};//
function CanvasRenderer(){console.error('THREE.CanvasRenderer has been removed');}//
function JSONLoader(){console.error('THREE.JSONLoader has been removed.');}//
var SceneUtils={createMultiMaterialObject:function createMultiMaterialObject()/* geometry, materials */{console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');},detach:function detach()/* child, parent, scene */{console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');},attach:function attach()/* child, scene, parent */{console.error('THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js');}};//
exports.SceneUtils=SceneUtils;function LensFlare(){console.error('THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js');}if(typeof __THREE_DEVTOOLS__!=='undefined'){/* eslint-disable no-undef */__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register',{detail:{revision:REVISION}}));/* eslint-enable no-undef */}

/***/ }),
/* 82 */
/***/ (function(module, exports) {

var core = module.exports = { version: '2.6.11' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef


/***/ }),
/* 83 */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),
/* 84 */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(118);
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(120);
var defined = __webpack_require__(51);
module.exports = function (it) {
  return IObject(defined(it));
};


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(162);
var hiddenKeys = __webpack_require__(122).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(46);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 21.2.5.3 get RegExp.prototype.flags
var anObject = __webpack_require__(30);
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),
/* 90 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(29);
var dPs = __webpack_require__(167);
var enumBugKeys = __webpack_require__(129);
var IE_PROTO = __webpack_require__(127)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(115)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(169).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(123);
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};


/***/ }),
/* 93 */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(77);
var TAG = __webpack_require__(19)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var classof = __webpack_require__(96);
var builtinExec = RegExp.prototype.exec;

 // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }
  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }
  return builtinExec.call(R, S);
};


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(74);
var TAG = __webpack_require__(15)('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(271);
var redefine = __webpack_require__(38);
var hide = __webpack_require__(32);
var fails = __webpack_require__(18);
var defined = __webpack_require__(51);
var wks = __webpack_require__(15);
var regexpExec = __webpack_require__(131);

var SPECIES = wks('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
})();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };
    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }
    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(
      defined,
      SYMBOL,
      ''[KEY],
      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
        if (regexp.exec === regexpExec) {
          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
            // The native String method already delegates to @@method (this
            // polyfilled function), leasing to infinite recursion.
            // We avoid it by directly calling the native @@method method.
            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
          }
          return { done: true, value: nativeMethod.call(str, regexp, arg2) };
        }
        return { done: false };
      }
    );
    var strfn = fns[0];
    var rxfn = fns[1];

    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(62);
var getKeys = __webpack_require__(133);
var redefine = __webpack_require__(38);
var global = __webpack_require__(24);
var hide = __webpack_require__(32);
var Iterators = __webpack_require__(63);
var wks = __webpack_require__(15);
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}


/***/ }),
/* 99 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 100 */
/***/ (function(module, exports) {



/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(43);
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};


/***/ }),
/* 102 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 103 */
/***/ (function(module, exports) {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(337);

/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(22);
var fails = __webpack_require__(18);
var defined = __webpack_require__(51);
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(341);

/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

__webpack_require__(348);
var anObject = __webpack_require__(30);
var $flags = __webpack_require__(89);
var DESCRIPTORS = __webpack_require__(23);
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  __webpack_require__(38)(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (__webpack_require__(18)(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
// const netArea = 'http://console.fengmap.com/api-s/';
var netArea = 'https://console.fengmap.com/api-s/';
var _default = netArea;
exports.default = _default;

/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.netArea = exports.LayerOrder = exports.Prop2Alias = exports.AliasLayerMap = exports.LayerAlias = void 0;

var _map = _interopRequireDefault(__webpack_require__(181));

var _FMExtentLayer = _interopRequireDefault(__webpack_require__(210));

var _FMExternalModelLayer = _interopRequireDefault(__webpack_require__(383));

var _FMModelLayer = _interopRequireDefault(__webpack_require__(384));

var _FMLabelLayer = _interopRequireDefault(__webpack_require__(213));

var _FMFacilityLayer = _interopRequireDefault(__webpack_require__(215));

var _FMImageMarkerLayer = _interopRequireDefault(__webpack_require__(217));

var _FMPolygonMarkerLayer = _interopRequireDefault(__webpack_require__(218));

var _FMGradientPolygonMarkerLayer = _interopRequireDefault(__webpack_require__(219));

var _FMTextMarkerLayer = _interopRequireDefault(__webpack_require__(221));

var _FMStairLayer = _interopRequireDefault(__webpack_require__(389));

var _FMHeatMapLayer = _interopRequireDefault(__webpack_require__(222));

var _FMSymbolLayer = _interopRequireDefault(__webpack_require__(391));

var _FMDomMarkerLayer = _interopRequireDefault(__webpack_require__(224));

var _FMDynamicModelLayer = _interopRequireDefault(__webpack_require__(225));

var _FMWaterMarkerLayer = _interopRequireDefault(__webpack_require__(392));

var _FMDynamicLineMarkerLayer = _interopRequireDefault(__webpack_require__(226));

var _FMExtrudeMarkerLayer = _interopRequireDefault(__webpack_require__(227));

/***
 * 楼层渲染层
 * extent: 地面层
 * model: 地图模型层
 * label: 文字标签层
 * facility:设施层
 * externalModel: 外部模型
 */
var LayerAlias = ['extent', 'model', 'label', 'facility', 'line', 'locationMarker', 'text', 'textMarker', 'polygonMarker', 'gradientPolygonMarker', 'extrudeMarker', 'imageMarker', "stair", 'externalModel', 'heatmap', 'dynmodel', 'symbol', 'domMarker', 'waterMarker', 'flmMarker'];
exports.LayerAlias = LayerAlias;
var AliasLayerMap = new _map.default();
exports.AliasLayerMap = AliasLayerMap;
AliasLayerMap.set('extent', _FMExtentLayer.default);
AliasLayerMap.set('externalModel', _FMExternalModelLayer.default);
AliasLayerMap.set('model', _FMModelLayer.default);
AliasLayerMap.set('label', _FMLabelLayer.default);
AliasLayerMap.set('facility', _FMFacilityLayer.default);
AliasLayerMap.set('imageMarker', _FMImageMarkerLayer.default);
AliasLayerMap.set('polygonMarker', _FMPolygonMarkerLayer.default);
AliasLayerMap.set('gradientPolygonMarker', _FMGradientPolygonMarkerLayer.default);
AliasLayerMap.set('extrudeMarker', _FMExtrudeMarkerLayer.default);
AliasLayerMap.set('textMarker', _FMTextMarkerLayer.default);
AliasLayerMap.set('stair', _FMStairLayer.default);
AliasLayerMap.set('heatmap', _FMHeatMapLayer.default);
AliasLayerMap.set('symbol', _FMSymbolLayer.default);
AliasLayerMap.set('domMarker', _FMDomMarkerLayer.default);
AliasLayerMap.set('dynmodel', _FMDynamicModelLayer.default);
AliasLayerMap.set('waterMarker', _FMWaterMarkerLayer.default);
AliasLayerMap.set('flmMarker', _FMDynamicLineMarkerLayer.default);
var Prop2Alias = {
  "extentLayer": "extent",
  "externalModelLayer": "externalModel",
  "labelLayer": "label",
  "modelLayer": "model",
  "poiLayer": "facility",
  "stairLayer": "stair"
};
exports.Prop2Alias = Prop2Alias;
var LayerOrder = {
  //越小的越先渲染
  "extent": 0,
  "line": 2,
  "model": 2.2,
  "externalModel": 2.2,
  "heatmap": 3,
  "polygonMarker": 3,
  "gradientPolygonMarker": 3,
  "extrudeMarker": 3,
  "location": 4,
  "facility": 3.5,
  "label": 4,
  "imageMarker": 4,
  "textMarker": 4,
  "domMarker": 4,
  "waterMarker": 3,
  "dynmodel": 0.5,
  "flmMarker": 2.1
};
exports.LayerOrder = LayerOrder;
var netArea = 'https://www.fengmap.com/';
exports.netArea = netArea;

/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 * FMGlobal
 * 全局的可以跨模块沟通的runtime对象
 * 保存各模块的一些公用变量
 */
var FMGlobal =
/*#__PURE__*/
function () {
  function FMGlobal() {
    (0, _classCallCheck2.default)(this, FMGlobal);
    this.currentModel = null; //当前点选中的模型

    this.isToggleViewMode = false;
    this.externalLoadingCount = 0;
  }

  (0, _createClass2.default)(FMGlobal, [{
    key: "dispose",
    value: function dispose(uuid) {
      for (var n in this[uuid]) {
        this[uuid][n] = undefined;
      }
    }
  }]);
  return FMGlobal;
}();

var global = new FMGlobal(); // window['FMGlobal'] = global;

var _default = global;
exports.default = _default;

/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var Sprite =
/*#__PURE__*/
function (_fm$Sprite) {
  (0, _inherits2.default)(Sprite, _fm$Sprite);

  function Sprite(material) {
    (0, _classCallCheck2.default)(this, Sprite);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Sprite).call(this, material));
  }

  (0, _createClass2.default)(Sprite, [{
    key: "raycast",
    value: function raycast(raycaster, intersects) {
      var _this = this;

      var intersectPoint = new fm.Vector3();
      var worldScale = new fm.Vector3();
      var mvPosition = new fm.Vector3();
      var alignedPosition = new fm.Vector2();
      var rotatedPosition = new fm.Vector2();
      var viewWorldMatrix = new fm.Matrix4();
      var vA = new fm.Vector3();
      var vB = new fm.Vector3();
      var vC = new fm.Vector3();
      var uvA = new fm.Vector2();
      var uvB = new fm.Vector2();
      var uvC = new fm.Vector2();
      var cameraPos = new fm.Vector4();

      var transformVertex = function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
        // compute position in camera space
        alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

        if (raycaster.perspective && !_this.material.sizeAttenuation) {
          cameraPos.applyMatrix4(_this.modelViewMatrix);
          alignedPosition.multiplyScalar(Math.abs(cameraPos.z));
        } // to check if rotation is not zero


        if (sin !== undefined) {
          rotatedPosition.x = cos * alignedPosition.x - sin * alignedPosition.y;
          rotatedPosition.y = sin * alignedPosition.x + cos * alignedPosition.y;
        } else {
          rotatedPosition.copy(alignedPosition);
        }

        vertexPosition.copy(mvPosition);
        vertexPosition.x += rotatedPosition.x;
        vertexPosition.y += rotatedPosition.y; // transform to world space

        vertexPosition.applyMatrix4(viewWorldMatrix);
      };

      (function (raycaster, intersects) {
        worldScale.setFromMatrixScale(_this.matrixWorld);
        viewWorldMatrix.getInverse(_this.modelViewMatrix).premultiply(_this.matrixWorld);
        mvPosition.setFromMatrixPosition(_this.modelViewMatrix);
        var rotation = _this.material.rotation;
        var sin, cos;

        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }

        var center = _this.center;
        transformVertex(vA.set(-0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
        transformVertex(vB.set(0.5, -0.5, 0), mvPosition, center, worldScale, sin, cos);
        transformVertex(vC.set(0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
        uvA.set(0, 0);
        uvB.set(1, 0);
        uvC.set(1, 1); // check first triangle

        var intersect = raycaster.ray.intersectTriangle(vA, vB, vC, false, intersectPoint);

        if (intersect === null) {
          // check second triangle
          transformVertex(vB.set(-0.5, 0.5, 0), mvPosition, center, worldScale, sin, cos);
          uvB.set(0, 1);
          intersect = raycaster.ray.intersectTriangle(vA, vC, vB, false, intersectPoint);

          if (intersect === null) {
            return;
          }
        }

        var vec3A = vA.clone().project(raycaster.camera); //之前版本的three使用的是raycaster._camera

        var vec3B = vB.clone().project(raycaster.camera);
        var vec3C = vC.clone().project(raycaster.camera);

        if (vec3A.x < -1 || vec3A.x > 1 || vec3A.y < -1 || vec3A.y > 1) {
          if (vec3B.x < -1 || vec3B.x > 1 || vec3B.y < -1 || vec3B.y > 1) {
            if (vec3C.x < -1 || vec3C.x > 1 || vec3C.y < -1 || vec3C.y > 1) {
              return;
            }
          }
        }

        var distance = raycaster.ray.origin.distanceTo(intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
          distance: distance,
          point: intersectPoint.clone(),
          uv: fm.Triangle.getUV(intersectPoint, vA, vB, vC, uvA, uvB, uvC, new fm.Vector2()),
          face: null,
          object: _this
        });
      })(raycaster, intersects);
    }
  }]);
  return Sprite;
}(fm.Sprite);

var _default = Sprite;
exports.default = _default;

/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.2 String.prototype.anchor(name)
__webpack_require__(105)('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _defineProperty2 = _interopRequireDefault(__webpack_require__(186));

var _FMMap = _interopRequireDefault(__webpack_require__(200));

var _NaviService = _interopRequireDefault(__webpack_require__(238));

/**
 * FMMapUtil是工具类 存放通用的一些工具函数
 */
// import FMSearchAnalyser from "../query/FMSearchAnalyser";
// import FMSearchRequest from "../query/FMSearchRequest";
'use strict';

var FMMapUtil =
/*#__PURE__*/
function () {
  function FMMapUtil() {
    (0, _classCallCheck2.default)(this, FMMapUtil);
  }
  /**
   * 根据类型别名获取指定楼层上面的某图层
   * __method getLayerByAlias
   * __param {fengmap.FMMap} map  当前地图对象。
   * __param {int} gid  待设置的楼层ID
   * __param {string} layerAlias  别名，extent, model, label, facility,textMarker,imageMarker
   * __param  {function} callback 查找到后的回调函数
   * __return {array} 包含该类型的图层数组
   * __since v1.2.0
   */


  (0, _createClass2.default)(FMMapUtil, null, [{
    key: "search",
    // /**
    //  * 快捷的按类型的别名得到所有的Object
    //  * 如果采用的是合并这后的Mesh, 得会得到其合并之后的Model
    //  * 并不会返回子物体, 如果想得到合并之后的子物体的数据
    //  * 请使用 getDatasByAlias 方法
    //  * layerAlias: extent, model, label, facility
    //  * __return {array} object array
    //  */
    // static getObjectsByAlias(map, gid, layerAlias, filter) {
    //     let res = [];
    //     this.getLayerByAlias(map, gid, layerAlias, function (layer) {
    //         if (filter != undefined) {
    //             let len = layer.o3d_.children;
    //             for (let i = 0; i < len; i++) {
    //                 if (filter(layer.o3d_.children[i])) {
    //                     res.push(layer.o3d_.children[i]);
    //                 }
    //             }
    //         } else {
    //             res.push.apply(res, layer.o3d_.children);
    //         }
    //     });
    //     return res;
    // };
    // /**
    //  * 按别名得到 fm_ 数据 / 支持得到合并之后的子物体的fm数据
    //  */
    // /**
    //  * 根据类型别名获取指定楼层上面的某类地图对象
    //  * __method getDatasByAlias
    //  * __param {fengmap.FMMap} map  当前地图对象。
    //  * __param {int} gid  待设置的楼层ID
    //  * __param {string} layerAlias  别名，extent, model, label, facility,textMarker,imageMarker
    //  * __return {array} 包含该类型的地图对象数组
    //  * __since v1.2.0
    //  */
    // static getDatasByAlias(map, gid, layerAlias, filter) {
    //     let res = [];
    //     layerAlias = [].concat(layerAlias);
    //     function append(fm) {
    //         if (filter) {
    //             if (filter(fm)) {
    //                 res.push(fm);
    //             }
    //         } else {
    //             res.push(fm);
    //         }
    //     };
    //     if (layerAlias === 'facility') {
    //         layerAlias = 'poi';
    //     }
    //     if (map.options.lazyCreateMode) {
    //         if (!map.groupDatas[gid]) {
    //             map.getGroupData(gid);
    //         }
    //         let gd = map.groupDatas[gid];
    //         layerAlias.forEach(function (alias) {
    //             if (alias === 'facility') {
    //                 alias === 'poi';
    //             }
    //             let ll = gd[alias + 's'];
    //             if (ll) {
    //                 map.groupDatas[gid][alias + 's'].forEach(function (itm) {
    //                     // 如果已经有了实体就直接返回实体，没有就返回数据
    //                     append(itm.entity || itm);
    //                 });
    //             }
    //         })
    //     } else {
    //         this.getLayerByAlias(map, gid, layerAlias, function (layer) {
    //             if (filter != undefined) {
    //                 if (layer._type_ && layer._type_ == fengmap.FMLayerType.EXTERANL_MODEL) {
    //                     let len = layer._elements.length;
    //                     for (let i = 0; i < len; i++) {
    //                         append(layer._elements[i]);
    //                     }
    //                 } else {
    //                     let len = layer.o3d_.children.length;
    //                     for (let i = 0; i < len; i++) {
    //                         let _fm = layer.o3d_.children[i].fm_;
    //                         let bros = _fm.brothers;
    //                         if (bros) {
    //                             bros.forEach(function (itm) {
    //                                 append(itm);
    //                             });
    //                         } else {
    //                             append(_fm);
    //                         }
    //                     }
    //                 }
    //             } else {
    //                 res = layer.o3d_.children.reduce(function (p, c) {
    //                     p.push.apply(p, c.fm_.brothers != undefined ? c.fm_.brothers : [c.fm_]);
    //                     return p;
    //                 }, []);
    //             }
    //         });
    //     }
    //     return res;
    // };
    value: function search(map, groupID, query, callback) {// let res = [];
      // if (!map instanceof FMMap || !groupID || !query) {
      //     return [];
      // }
      // let searchAnalyser = new FMSearchAnalyser(map, map.getCurrDecodeData());
      // // let searchRequest = new FMSearchRequest();
      // if (groupID != null) {
      //     searchRequest.groupID = groupID;
      // }
      // if (query.keyword != '' && query.keyword != null) {
      //     searchRequest.keyword = query.keyword;
      // }
      // if (query.FID != null) {
      //     searchRequest.FID = query.FID;
      // }
      // if (query.typeID != null) {
      //     searchRequest.typeID = typeof query.radius != 'number' ? parseInt(query.typeID) : query.typeID;
      // }
      // if (query.nodeType != null) {
      //     searchRequest.nodeType = query.nodeType ;
      // }
      // if(query.mapCoord != null && query.radius != null){
      //     searchRequest.circle = {
      //         'center':query.mapCoord,
      //         'radius': typeof query.radius != 'number'? parseFloat(query.radius) : query.radius
      //     }
      // }
      // if(query.polygon != null){
      //     searchRequest.polygon = query.polygon;
      // }
      // res = searchAnalyser.query(searchRequest, function (result) {
      //     if (callback) {
      //         callback(result);
      //     }
      // });
      // return res;
    }
  }, {
    key: "drawNaviRoads",
    value: function drawNaviRoads(map) {
      if (!map || !map._currentSceneId || !map.dataManager) {
        return;
      }

      var scene = map.dataManager._sceneDecodeData[map._currentSceneId];

      if (!scene) {
        return;
      }

      var groups = scene.floors;

      if (groups.length == 0) {
        return;
      }

      var naviRoadLineStyles = [{
        lineWidth: 1,
        //设置线的透明度
        alpha: 1.0,
        //设置线的类型
        lineType: fengmap.FMLineType.FULL,
        //设置线的颜色
        color: '#00FFFF'
      }, {
        lineWidth: 1,
        //设置线的透明度
        alpha: 1.0,
        //设置线的类型
        lineType: fengmap.FMLineType.FULL,
        //设置线的颜色
        color: '#00FF00'
      }, {
        lineWidth: 1,
        //设置线的透明度
        alpha: 1.0,
        //设置线的类型
        lineType: fengmap.FMLineType.FULL,
        //设置线的颜色
        color: '#FF00FF'
      }, {
        lineWidth: 1,
        //设置线的透明度
        alpha: 1.0,
        //设置线的类型
        lineType: fengmap.FMLineType.FULL,
        //设置线的颜色
        color: '#FF0000'
      }];
      var naviLineHeight = 1.0;
      var naviLines = [];

      for (var i in groups) {
        var groupId = groups[i].gid;

        if (groupId == undefined) {
          continue;
        }

        var geo = groups[i].geo[0];
        var biz = groups[i].biz[0];
        var nav = groups[i].navi[0];
        var naviService = new _NaviService.default({});
        var navi = naviService.convertToGroup(groupId, geo, biz, nav);

        for (var k in navi.naviSegments) {
          var road = navi.naviSegments[k]; //创建路径线图层

          var line = new fengmap.FMLineMarker(); //创建FMSegment点集，一个点集代表一条折线

          var seg = new fengmap.FMSegment();
          seg.groupId = groupId;
          seg.points = road.geoArr;
          seg.points.forEach(function (point) {
            point.z = naviLineHeight;
          }); //将FMSegment绘制到线图层上

          line.addSegment(seg); //绘制线

          map.drawLineMark(line, naviRoadLineStyles[road.entry]);
          naviLines.push(line);
        }
      }

      return naviLines;
    }
    /**
     * 以center为原点转换坐标
     * @param point {json}
     * @param point.x {number}
     * @param point.y {number}
     * @param point.z {number | undefined}
     * @param center {json}
     * @param center.x {number}
     * @param center.y {number}
     * @param center.z {number | undefined}
     */

  }, {
    key: "convertPointCoordsByCenter",
    value: function convertPointCoordsByCenter(point, center) {
      point.x = point.x - center.x;
      point.y = point.y - center.y;

      if (point.z !== undefined) {
        if (center.z !== undefined) {
          point.z = point.z - center.z;
        }
      }

      return point;
    }
    /**
     * 以center为原点转换坐标
     * @param points {Array}
     * @param points[].x {number}
     * @param points[].y {number}
     * @param points[].z {number | undefined}
     * @param center {json}
     * @param center.x {number}
     * @param center.y {number}
     * @param center.z {number | undefined}
     * @param points
     * @param center
     */

  }, {
    key: "convertPointsCoordsByCenter",
    value: function convertPointsCoordsByCenter(points, center) {
      for (var i = 0; i < points.length; i++) {
        this.convertPointCoordsByCenter(points[i], center);
      }

      return points;
    }
  }]);
  return FMMapUtil;
}();

(0, _defineProperty2.default)(FMMapUtil, "getLayerByAlias", function (map, gid, layerAlias, callback) {
  var group = map.getFMGroup(gid);
  if (!group || !group.layers) return;
  layerAlias = [].concat(layerAlias);
  var res = [];

  for (var i = 0; i < group.layers.length; i++) {
    var layer = group.layers[i];

    if (layer._type_) {
      if (layerAlias.indexOf(layer._type_) > -1) {
        if (callback) {
          if (callback(layer, layer._type_)) {
            i--;
          }
        }

        res.push(layer);
      }
    } else {
      for (var j = 0; j < layerAlias.length; j++) {
        var alias = layerAlias[j];

        if (fengmap.Map.layerAlias[alias] && layer instanceof fengmap.Map.layerAlias[alias]) {
          if (callback) {
            if (callback(layer, alias)) {
              i--;
            }
          }

          res.push(layer);
        }
      }
    }
  }

  return res.length == 0 ? null : res.length == 1 ? res[0] : res;
});
var _default = FMMapUtil;
exports.default = _default;

/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(__webpack_require__(11));

__webpack_require__(25);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 * FMGeometryUtils是Geometry工具类 存放通用的一些工具函数
 */
var FMGeometryUtils =
/*#__PURE__*/
function () {
  /**
   * @constructor
   */
  function FMGeometryUtils() {
    (0, _classCallCheck2.default)(this, FMGeometryUtils);
  }
  /**
   * 创建平面shape
   * @param points
   * @param isClose
   * @returns shape {fm.Shape}
   */


  (0, _createClass2.default)(FMGeometryUtils, null, [{
    key: "createShape",
    value: function createShape(points, isClose) {
      var shape = new fm.Shape();
      shape.moveTo(points[0].x, points[0].y);

      for (var i = 1; i < points.length; i++) {
        shape.lineTo(points[i].x, points[i].y);
      }

      if (isClose) {
        shape.lineTo(points[0].x, points[0].y);
      }

      return shape;
    }
    /**
     * 创建矩形shape
     * @param width 宽度
     * @param height 高度
     * @returns shape {fm.Shape}
     */

  }, {
    key: "createReactShape",
    value: function createReactShape(width, height) {
      var shape = new fm.Shape();
      var halfHeight = height / 2.0;
      var halfWidth = width / 2.0;
      shape.moveTo(-halfWidth, -halfHeight);
      shape.lineTo(-halfWidth, halfHeight);
      shape.lineTo(halfWidth, halfHeight);
      shape.lineTo(halfWidth, -halfHeight);
      return shape;
    }
    /**
     * 创建圆心shape
     * @param radius {number} 半径
     * @param segments{number} 段
     * @returns shape {fm.Shape}
     */

  }, {
    key: "createCircleShape",
    value: function createCircleShape(radius, segments) {
      var shape = new fm.Shape();
      shape.absarc(0, 0, radius, 0, Math.PI * 2, false);
      return shape;
    }
    /**
     * 生成拉伸体
     * @param shape {fm.Shape} 面坐标点
     * @param options {json} 参数
     * @param options.depth {number} 深度
     * @returns {ExtrudeBufferGeometry|ExtrudeBufferGeometry}
     */

  }, {
    key: "createExtrudeBufferGeometry",
    value: function createExtrudeBufferGeometry(shape, options) {
      var extrudeSettings = {
        steps: 1,
        depth: options.depth,
        bevelEnabled: false,
        bevelThickness: 0,
        bevelSize: 0,
        bevelOffset: 0,
        bevelSegments: 1
      };
      return new fm.ExtrudeBufferGeometry(shape, extrudeSettings);
    }
    /**
     * 生成拉伸体
     * @param points {Array} 面坐标点
     * @param points[].x {number}
     * @param points[].y {number}
     * @param options {json} 参数
     * @param options.depth {number} 深度
     * @returns {ExtrudeBufferGeometry|ExtrudeBufferGeometry}
     */

  }, {
    key: "createPointsExtrudeBufferGeometry",
    value: function createPointsExtrudeBufferGeometry(points, options) {
      var shape = FMGeometryUtils.createShape(points, true);
      return this.createExtrudeBufferGeometry(shape, options);
    }
    /**
     * 创建矩形拉伸体
     * @param width 宽度
     * @param height 高度
     * @param options {json} 参数
     * @param options.depth {number} 深度
     */

  }, {
    key: "createReactExtrudeBufferGeometry",
    value: function createReactExtrudeBufferGeometry(width, height, options) {
      var shape = FMGeometryUtils.createReactShape(width, height);
      return this.createExtrudeBufferGeometry(shape, options);
    }
    /**
     * 创建圆心拉伸体
     * @param radius {number} 半径
     * @param segments{number} 段
     * @param options {json} 参数
     * @param options.depth {number} 深度
     */

  }, {
    key: "createCircleExtrudeBufferGeometry",
    value: function createCircleExtrudeBufferGeometry(radius, segments, options) {
      var shape = FMGeometryUtils.createCircleShape(radius, segments);
      return this.createExtrudeBufferGeometry(shape, options);
    }
    /***
     * 创建几何体
     * @param points {Array} 点数据
     * @returns {ShapeBufferGeometry}
     */

  }, {
    key: "createShapeBufferGeometry",
    value: function createShapeBufferGeometry(points) {
      var heartShape = FMGeometryUtils.createShape(points);
      return new fm.ShapeBufferGeometry(heartShape);
    }
    /***
     * 以给定中心点center创建几何体
     * @param points {Array} 点数据
     * @param sceneCenter {Vector2} 中心点
     * @returns {ShapeBufferGeometry}
     */

  }, {
    key: "createShapeBufferGeometryByCenter",
    value: function createShapeBufferGeometryByCenter(points, sceneCenter) {
      var heartShape = new fm.Shape();
      heartShape.moveTo(points[0].x - sceneCenter.x, -points[0].y + sceneCenter.y);

      for (var i = 1; i < points.length; i++) {
        heartShape.lineTo(points[i].x - sceneCenter.x, -points[i].y + sceneCenter.y);
      }

      heartShape.lineTo(points[0].x - sceneCenter.x, -points[0].y + sceneCenter.y);
      return new fm.ShapeBufferGeometry(heartShape);
    }
    /***
     * 添加中心点center，创建几何图形
     * @param points {Array} 点数据
     * @param center {Vector3}
     * @returns {ShapeBufferGeometry}
     */

  }, {
    key: "createCenterBufferGeometry",
    value: function createCenterBufferGeometry(points, center) {
      // 插入顶点
      var tempPoints = [];

      for (var i = 0; i < points.length - 1; i++) {
        for (var j = 2; j < 10; j += 2) {
          tempPoints.push({
            x: points[i].x + (points[i + 1].x - points[i].x) * j * 0.1,
            y: points[i].y + (points[i + 1].y - points[i].y) * j * 0.1,
            z: points[i].z + (points[i + 1].z - points[i].z) * j * 0.1
          });
        }
      }

      tempPoints.push({
        x: tempPoints[0].x,
        y: tempPoints[0].y,
        z: tempPoints[0].z
      });
      var geometry = new fm.BufferGeometry();
      var vertices_arr = [];
      var gradientAlpha = [];

      for (var _i = 0; _i < tempPoints.length - 1; _i++) {
        vertices_arr.push(tempPoints[_i].x);
        vertices_arr.push(tempPoints[_i].y);
        vertices_arr.push(tempPoints[_i].z);
        vertices_arr.push(tempPoints[_i + 1].x);
        vertices_arr.push(tempPoints[_i + 1].y);
        vertices_arr.push(tempPoints[_i + 1].z);
        vertices_arr.push(center.x);
        vertices_arr.push(center.y);
        vertices_arr.push(center.z);
        gradientAlpha.push(0.0, 0.0, 1.0);
      }

      var vertices = new Float32Array(vertices_arr);
      geometry.setAttribute('position', new fm.Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('gradientAlpha', new fm.Float32BufferAttribute(gradientAlpha, 1));
      return geometry;
    }
    /**
     * 基于点center放大points构成的区域
     * @param points {Array} 点的数组
     * @param center {fm.Vector3 | json} 基点
     * @param scale {number} 放大比例
     * @returns {[]}
     */

  }, {
    key: "scalePoints",
    value: function scalePoints(points, center, scale) {
      var targetPoints = [];

      for (var i = 0; i < points.length; i++) {
        var x = points[i].x;
        var y = points[i].y;
        var z = points[i].z;
        targetPoints.push({
          x: x + (x - center.x) * (scale - 1.0),
          y: y + (y - center.y) * (scale - 1.0),
          z: z
        });
      }

      return targetPoints;
    }
    /**
     * 基于点center放大points构成的区域
     * @param points {Array} 点的数组
     * @param center {fm.Vector3 | json} 基点
     * @param scaleValue {number} 放大值
     * @returns {[]}
     */

  }, {
    key: "scaleValuePoints",
    value: function scaleValuePoints(points, center, scaleValue) {
      var targetPoints = [];

      for (var i = 0; i < points.length; i++) {
        var val = {
          x: points[i].x,
          y: points[i].y,
          z: points[i].z
        };

        if (val.x - center.x < 0) {
          val.x -= scaleValue;
        } else {
          val.x += scaleValue;
        }

        if (val.y - center.y < 0) {
          val.y -= scaleValue;
        } else {
          val.y += scaleValue;
        }

        targetPoints.push(val);
      }

      return targetPoints;
    }
    /**
     * 闭合点集
     * @param points {Array<{x:0,y:0}>}
     * @param points[].x {number}
     * @param points[].y {number}
     * @returns {boolean}
     */

  }, {
    key: "closedPoints",
    value: function closedPoints(points) {
      var n = points.length;
      if (n < 3) return false;

      if (points[0].x !== points[n - 1].x || points[0].y !== points[n - 1].y) {
        points[n] = {};
        (0, _assign.default)(points[n], points[0]);
      }

      return true;
    }
  }]);
  return FMGeometryUtils;
}();

var _default = FMGeometryUtils;
exports.default = _default;

/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(17);
var document = __webpack_require__(14).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(17);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(82);
var global = __webpack_require__(24);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(84) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 118 */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(161);
var createDesc = __webpack_require__(83);
var toIObject = __webpack_require__(86);
var toPrimitive = __webpack_require__(72);
var has = __webpack_require__(50);
var IE8_DOM_DEFINE = __webpack_require__(158);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(23) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(74);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(117)('keys');
var uid = __webpack_require__(73);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 122 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 123 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(75);
var $export = __webpack_require__(10);
var redefine = __webpack_require__(125);
var hide = __webpack_require__(43);
var Iterators = __webpack_require__(60);
var $iterCreate = __webpack_require__(265);
var setToStringTag = __webpack_require__(78);
var getPrototypeOf = __webpack_require__(170);
var ITERATOR = __webpack_require__(19)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(43);


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(77);
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(128)('keys');
var uid = __webpack_require__(93);
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(9);
var global = __webpack_require__(14);
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(75) ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),
/* 129 */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(94);
var ITERATOR = __webpack_require__(19)('iterator');
var Iterators = __webpack_require__(60);
module.exports = __webpack_require__(9).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(89);

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(30);
var dPs = __webpack_require__(274);
var enumBugKeys = __webpack_require__(122);
var IE_PROTO = __webpack_require__(121)('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(159)('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  __webpack_require__(275).appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(162);
var enumBugKeys = __webpack_require__(122);

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(33).f;
var has = __webpack_require__(50);
var TAG = __webpack_require__(15)('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(10);
var core = __webpack_require__(9);
var fails = __webpack_require__(44);
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(19);


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(14);
var core = __webpack_require__(9);
var LIBRARY = __webpack_require__(75);
var wksExt = __webpack_require__(136);
var defineProperty = __webpack_require__(28).f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};


/***/ }),
/* 138 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(77);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(36);
var IObject = __webpack_require__(126);
var toObject = __webpack_require__(52);
var toLength = __webpack_require__(92);
var asc = __webpack_require__(293);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var at = __webpack_require__(187)(true);

 // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)

var toObject = __webpack_require__(39);
var toAbsoluteIndex = __webpack_require__(88);
var toLength = __webpack_require__(34);
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 145 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(22);

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(340)
});


/***/ }),
/* 147 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty2 = __webpack_require__(0);

_Object$defineProperty2(exports, "__esModule", {
  value: true
});

exports.ProtoBuf = void 0;

var _stringify = _interopRequireDefault(__webpack_require__(104));

__webpack_require__(98);

__webpack_require__(62);

var _keys = _interopRequireDefault(__webpack_require__(54));

__webpack_require__(13);

var _create = _interopRequireDefault(__webpack_require__(31));

var _isArray = _interopRequireDefault(__webpack_require__(35));

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(48);

__webpack_require__(8);

__webpack_require__(149);

var _typeof2 = _interopRequireDefault(__webpack_require__(47));

__webpack_require__(144);

__webpack_require__(55);

__webpack_require__(107);

__webpack_require__(67);

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

var _defineProperty = _interopRequireDefault(__webpack_require__(0));

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>
 Copyright 2009 The Closure Library Authors. All Rights Reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS-IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license long.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/long.js for details
 */
//(function(global, factory) {
//
//    /* AMD */ if (typeof define === 'function' && define["amd"])
//        define([], factory);
//    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
//        module["exports"] = factory();
//    /* Global */ else
//        (global["dcodeIO"] = global["dcodeIO"] || {})["Long"] = factory();
//
//})(this, function() {
//    "use strict";

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
 * @constructor
 */
function Long(low, high, unsigned) {
  /**
   * The low 32 bits as a signed value.
   * @type {number}
   * @expose
   */
  this.low = low | 0;
  /**
   * The high 32 bits as a signed value.
   * @type {number}
   * @expose
   */

  this.high = high | 0;
  /**
   * Whether unsigned or not.
   * @type {boolean}
   * @expose
   */

  this.unsigned = !!unsigned;
} // The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @expose
 * @private
 */


Long.__isLong__;
(0, _defineProperty.default)(Long.prototype, "__isLong__", {
  value: true,
  enumerable: false,
  configurable: false
});
/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */

function isLong(obj) {
  return (obj && obj["__isLong__"]) === true;
}
/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @expose
 */


Long.isLong = isLong;
/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */

var INT_CACHE = {};
/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */

var UINT_CACHE = {};
/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */

function fromInt(value, unsigned) {
  var obj, cachedObj, cache;

  if (unsigned) {
    value >>>= 0;

    if (cache = 0 <= value && value < 256) {
      cachedObj = UINT_CACHE[value];
      if (cachedObj) return cachedObj;
    }

    obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
    if (cache) UINT_CACHE[value] = obj;
    return obj;
  } else {
    value |= 0;

    if (cache = -128 <= value && value < 128) {
      cachedObj = INT_CACHE[value];
      if (cachedObj) return cachedObj;
    }

    obj = fromBits(value, value < 0 ? -1 : 0, false);
    if (cache) INT_CACHE[value] = obj;
    return obj;
  }
}
/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
 * @returns {!Long} The corresponding Long value
 * @expose
 */


Long.fromInt = fromInt;
/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */

function fromNumber(value, unsigned) {
  if (isNaN(value) || !isFinite(value)) return unsigned ? UZERO : ZERO;

  if (unsigned) {
    if (value < 0) return UZERO;
    if (value >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
  } else {
    if (value <= -TWO_PWR_63_DBL) return MIN_VALUE;
    if (value + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
  }

  if (value < 0) return fromNumber(-value, unsigned).neg();
  return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
}
/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
 * @returns {!Long} The corresponding Long value
 * @expose
 */


Long.fromNumber = fromNumber;
/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */

function fromBits(lowBits, highBits, unsigned) {
  return new Long(lowBits, highBits, unsigned);
}
/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to `false` for signed
 * @returns {!Long} The corresponding Long value
 * @expose
 */


Long.fromBits = fromBits;
/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */

var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */

function fromString(str, unsigned, radix) {
  if (str.length === 0) throw Error('empty string');
  if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return ZERO;
  if (typeof unsigned === 'number') // For goog.math.long compatibility
    radix = unsigned, unsigned = false;
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError('radix');
  var p;
  if ((p = str.indexOf('-')) > 0) throw Error('interior hyphen');else if (p === 0) {
    return fromString(str.substring(1), unsigned, radix).neg();
  } // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.

  var radixToPower = fromNumber(pow_dbl(radix, 8));
  var result = ZERO;

  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i),
        value = (0, _parseInt2.default)(str.substring(i, i + size), radix);

    if (size < 8) {
      var power = fromNumber(pow_dbl(radix, size));
      result = result.mul(power).add(fromNumber(value));
    } else {
      result = result.mul(radixToPower);
      result = result.add(fromNumber(value));
    }
  }

  result.unsigned = unsigned;
  return result;
}
/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to `false` for signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 * @expose
 */


Long.fromString = fromString;
/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @returns {!Long}
 * @inner
 */

function fromValue(val) {
  if (val
  /* is compatible */
  instanceof Long) return val;
  if (typeof val === 'number') return fromNumber(val);
  if (typeof val === 'string') return fromString(val); // Throws for non-objects, converts non-instanceof Long:

  return fromBits(val.low, val.high, val.unsigned);
}
/**
 * Converts the specified value to a Long.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @returns {!Long}
 * @expose
 */


Long.fromValue = fromValue; // NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */

var TWO_PWR_16_DBL = 1 << 16;
/**
 * @type {number}
 * @const
 * @inner
 */

var TWO_PWR_24_DBL = 1 << 24;
/**
 * @type {number}
 * @const
 * @inner
 */

var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
/**
 * @type {number}
 * @const
 * @inner
 */

var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
/**
 * @type {number}
 * @const
 * @inner
 */

var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
/**
 * @type {!Long}
 * @const
 * @inner
 */

var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
/**
 * @type {!Long}
 * @inner
 */

var ZERO = fromInt(0);
/**
 * Signed zero.
 * @type {!Long}
 * @expose
 */

Long.ZERO = ZERO;
/**
 * @type {!Long}
 * @inner
 */

var UZERO = fromInt(0, true);
/**
 * Unsigned zero.
 * @type {!Long}
 * @expose
 */

Long.UZERO = UZERO;
/**
 * @type {!Long}
 * @inner
 */

var ONE = fromInt(1);
/**
 * Signed one.
 * @type {!Long}
 * @expose
 */

Long.ONE = ONE;
/**
 * @type {!Long}
 * @inner
 */

var UONE = fromInt(1, true);
/**
 * Unsigned one.
 * @type {!Long}
 * @expose
 */

Long.UONE = UONE;
/**
 * @type {!Long}
 * @inner
 */

var NEG_ONE = fromInt(-1);
/**
 * Signed negative one.
 * @type {!Long}
 * @expose
 */

Long.NEG_ONE = NEG_ONE;
/**
 * @type {!Long}
 * @inner
 */

var MAX_VALUE = fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0, false);
/**
 * Maximum signed value.
 * @type {!Long}
 * @expose
 */

Long.MAX_VALUE = MAX_VALUE;
/**
 * @type {!Long}
 * @inner
 */

var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF | 0, 0xFFFFFFFF | 0, true);
/**
 * Maximum unsigned value.
 * @type {!Long}
 * @expose
 */

Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
/**
 * @type {!Long}
 * @inner
 */

var MIN_VALUE = fromBits(0, 0x80000000 | 0, false);
/**
 * Minimum signed value.
 * @type {!Long}
 * @expose
 */

Long.MIN_VALUE = MIN_VALUE;
/**
 * @alias Long.prototype
 * @inner
 */

var LongPrototype = Long.prototype;
/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 * @expose
 */

LongPrototype.toInt = function toInt() {
  return this.unsigned ? this.low >>> 0 : this.low;
};
/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 * @expose
 */


LongPrototype.toNumber = function toNumber() {
  if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
  return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};
/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 * @expose
 */


LongPrototype.toString = function toString(radix) {
  radix = radix || 10;
  if (radix < 2 || 36 < radix) throw RangeError('radix');
  if (this.isZero()) return '0';

  if (this.isNegative()) {
    // Unsigned Longs are never negative
    if (this.eq(MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = fromNumber(radix),
          div = this.div(radixLong),
          rem1 = div.mul(radixLong).sub(this);
      return div.toString(radix) + rem1.toInt().toString(radix);
    } else return '-' + this.neg().toString(radix);
  } // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.


  var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
      rem = this;
  var result = '';

  while (true) {
    var remDiv = rem.div(radixToPower),
        intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
        digits = intval.toString(radix);
    rem = remDiv;
    if (rem.isZero()) return digits + result;else {
      while (digits.length < 6) {
        digits = '0' + digits;
      }

      result = '' + digits + result;
    }
  }
};
/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 * @expose
 */


LongPrototype.getHighBits = function getHighBits() {
  return this.high;
};
/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 * @expose
 */


LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
  return this.high >>> 0;
};
/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 * @expose
 */


LongPrototype.getLowBits = function getLowBits() {
  return this.low;
};
/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 * @expose
 */


LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
  return this.low >>> 0;
};
/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 * @expose
 */


LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
  if (this.isNegative()) // Unsigned Longs are never negative
    return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
  var val = this.high != 0 ? this.high : this.low;

  for (var bit = 31; bit > 0; bit--) {
    if ((val & 1 << bit) != 0) break;
  }

  return this.high != 0 ? bit + 33 : bit + 1;
};
/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 * @expose
 */


LongPrototype.isZero = function isZero() {
  return this.high === 0 && this.low === 0;
};
/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 * @expose
 */


LongPrototype.isNegative = function isNegative() {
  return !this.unsigned && this.high < 0;
};
/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 * @expose
 */


LongPrototype.isPositive = function isPositive() {
  return this.unsigned || this.high >= 0;
};
/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 * @expose
 */


LongPrototype.isOdd = function isOdd() {
  return (this.low & 1) === 1;
};
/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 * @expose
 */


LongPrototype.isEven = function isEven() {
  return (this.low & 1) === 0;
};
/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */


LongPrototype.equals = function equals(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
  return this.high === other.high && this.low === other.low;
};
/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */


LongPrototype.eq = LongPrototype.equals;
/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */

LongPrototype.notEquals = function notEquals(other) {
  return !this.eq(
  /* validates */
  other);
};
/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */


LongPrototype.neq = LongPrototype.notEquals;
/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */

LongPrototype.lessThan = function lessThan(other) {
  return this.comp(
  /* validates */
  other) < 0;
};
/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */


LongPrototype.lt = LongPrototype.lessThan;
/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */

LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
  return this.comp(
  /* validates */
  other) <= 0;
};
/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */


LongPrototype.lte = LongPrototype.lessThanOrEqual;
/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */

LongPrototype.greaterThan = function greaterThan(other) {
  return this.comp(
  /* validates */
  other) > 0;
};
/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */


LongPrototype.gt = LongPrototype.greaterThan;
/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */

LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
  return this.comp(
  /* validates */
  other) >= 0;
};
/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 * @expose
 */


LongPrototype.gte = LongPrototype.greaterThanOrEqual;
/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 * @expose
 */

LongPrototype.compare = function compare(other) {
  if (!isLong(other)) other = fromValue(other);
  if (this.eq(other)) return 0;
  var thisNeg = this.isNegative(),
      otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) return -1;
  if (!thisNeg && otherNeg) return 1; // At this point the sign bits are the same

  if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1; // Both are positive if at least one is unsigned

  return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
};
/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 * @expose
 */


LongPrototype.comp = LongPrototype.compare;
/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 * @expose
 */

LongPrototype.negate = function negate() {
  if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
  return this.not().add(ONE);
};
/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 * @expose
 */


LongPrototype.neg = LongPrototype.negate;
/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 * @expose
 */

LongPrototype.add = function add(addend) {
  if (!isLong(addend)) addend = fromValue(addend); // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high >>> 16;
  var a32 = this.high & 0xFFFF;
  var a16 = this.low >>> 16;
  var a00 = this.low & 0xFFFF;
  var b48 = addend.high >>> 16;
  var b32 = addend.high & 0xFFFF;
  var b16 = addend.low >>> 16;
  var b00 = addend.low & 0xFFFF;
  var c48 = 0,
      c32 = 0,
      c16 = 0,
      c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 * @expose
 */


LongPrototype.subtract = function subtract(subtrahend) {
  if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
  return this.add(subtrahend.neg());
};
/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 * @expose
 */


LongPrototype.sub = LongPrototype.subtract;
/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 * @expose
 */

LongPrototype.multiply = function multiply(multiplier) {
  if (this.isZero()) return ZERO;
  if (!isLong(multiplier)) multiplier = fromValue(multiplier);
  if (multiplier.isZero()) return ZERO;
  if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
  if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;

  if (this.isNegative()) {
    if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();
  } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg(); // If both longs are small, use float multiplication


  if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned); // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high >>> 16;
  var a32 = this.high & 0xFFFF;
  var a16 = this.low >>> 16;
  var a00 = this.low & 0xFFFF;
  var b48 = multiplier.high >>> 16;
  var b32 = multiplier.high & 0xFFFF;
  var b16 = multiplier.low >>> 16;
  var b00 = multiplier.low & 0xFFFF;
  var c48 = 0,
      c32 = 0,
      c16 = 0,
      c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
};
/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 * @expose
 */


LongPrototype.mul = LongPrototype.multiply;
/**
 * Returns this Long divided by the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 * @expose
 */

LongPrototype.divide = function divide(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  if (divisor.isZero()) throw Error('division by zero');
  if (this.isZero()) return this.unsigned ? UZERO : ZERO;
  var approx, rem, res;

  if (this.eq(MIN_VALUE)) {
    if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE; // recall that -MIN_VALUE == MIN_VALUE
    else if (divisor.eq(MIN_VALUE)) return ONE;else {
        // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
        var halfThis = this.shr(1);
        approx = halfThis.div(divisor).shl(1);

        if (approx.eq(ZERO)) {
          return divisor.isNegative() ? ONE : NEG_ONE;
        } else {
          rem = this.sub(divisor.mul(approx));
          res = approx.add(rem.div(divisor));
          return res;
        }
      }
  } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;

  if (this.isNegative()) {
    if (divisor.isNegative()) return this.neg().div(divisor.neg());
    return this.neg().div(divisor).neg();
  } else if (divisor.isNegative()) return this.div(divisor.neg()).neg(); // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.


  res = ZERO;
  rem = this;

  while (rem.gte(divisor)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber())); // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.

    var log2 = Math.ceil(Math.log(approx) / Math.LN2),
        delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48),
        // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    approxRes = fromNumber(approx),
        approxRem = approxRes.mul(divisor);

    while (approxRem.isNegative() || approxRem.gt(rem)) {
      approx -= delta;
      approxRes = fromNumber(approx, this.unsigned);
      approxRem = approxRes.mul(divisor);
    } // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.


    if (approxRes.isZero()) approxRes = ONE;
    res = res.add(approxRes);
    rem = rem.sub(approxRem);
  }

  return res;
};
/**
 * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 * @expose
 */


LongPrototype.div = LongPrototype.divide;
/**
 * Returns this Long modulo the specified.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 * @expose
 */

LongPrototype.modulo = function modulo(divisor) {
  if (!isLong(divisor)) divisor = fromValue(divisor);
  return this.sub(this.div(divisor).mul(divisor));
};
/**
 * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.
 * @function
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Remainder
 * @expose
 */


LongPrototype.mod = LongPrototype.modulo;
/**
 * Returns the bitwise NOT of this Long.
 * @returns {!Long}
 * @expose
 */

LongPrototype.not = function not() {
  return fromBits(~this.low, ~this.high, this.unsigned);
};
/**
 * Returns the bitwise AND of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 * @expose
 */


LongPrototype.and = function and(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
};
/**
 * Returns the bitwise OR of this Long and the specified.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 * @expose
 */


LongPrototype.or = function or(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
};
/**
 * Returns the bitwise XOR of this Long and the given one.
 * @param {!Long|number|string} other Other Long
 * @returns {!Long}
 * @expose
 */


LongPrototype.xor = function xor(other) {
  if (!isLong(other)) other = fromValue(other);
  return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
};
/**
 * Returns this Long with bits shifted to the left by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 * @expose
 */


LongPrototype.shiftLeft = function shiftLeft(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return fromBits(0, this.low << numBits - 32, this.unsigned);
};
/**
 * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 * @expose
 */


LongPrototype.shl = LongPrototype.shiftLeft;
/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 * @expose
 */

LongPrototype.shiftRight = function shiftRight(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  if ((numBits &= 63) === 0) return this;else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
};
/**
 * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 * @expose
 */


LongPrototype.shr = LongPrototype.shiftRight;
/**
 * Returns this Long with bits logically shifted to the right by the given amount.
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 * @expose
 */

LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
  if (isLong(numBits)) numBits = numBits.toInt();
  numBits &= 63;
  if (numBits === 0) return this;else {
    var high = this.high;

    if (numBits < 32) {
      var low = this.low;
      return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
    } else if (numBits === 32) return fromBits(high, 0, this.unsigned);else return fromBits(high >>> numBits - 32, 0, this.unsigned);
  }
};
/**
 * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.
 * @function
 * @param {number|!Long} numBits Number of bits
 * @returns {!Long} Shifted Long
 * @expose
 */


LongPrototype.shru = LongPrototype.shiftRightUnsigned;
/**
 * Converts this Long to signed.
 * @returns {!Long} Signed long
 * @expose
 */

LongPrototype.toSigned = function toSigned() {
  if (!this.unsigned) return this;
  return fromBits(this.low, this.high, false);
};
/**
 * Converts this Long to unsigned.
 * @returns {!Long} Unsigned long
 * @expose
 */


LongPrototype.toUnsigned = function toUnsigned() {
  if (this.unsigned) return this;
  return fromBits(this.low, this.high, true);
}; //    return Long;
//});

/*
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/bytebuffer.js for details
 */
//(function(global, factory) {
//
//    /* AMD */ if (typeof define === 'function' && define["amd"])
//        define(["long"], factory);
//    /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
//        module['exports'] = (function() {
//            var Long; try { Long = require("long"); } catch (e) {}
//            return factory(Long);
//        })();
//    /* Global */ else
//        (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);
//
//})(this, function(Long) {
//    "use strict";

/**
 * Constructs a new ByteBuffer.
 * @class The swiss army knife for binary data in JavaScript.
 * @exports ByteBuffer
 * @constructor
 * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
 *  {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
 *  {@link ByteBuffer.DEFAULT_NOASSERT}.
 * @expose
 */


var ByteBuffer = function ByteBuffer(capacity, littleEndian, noAssert) {
  if (typeof capacity === 'undefined') capacity = ByteBuffer.DEFAULT_CAPACITY;
  if (typeof littleEndian === 'undefined') littleEndian = ByteBuffer.DEFAULT_ENDIAN;
  if (typeof noAssert === 'undefined') noAssert = ByteBuffer.DEFAULT_NOASSERT;

  if (!noAssert) {
    capacity = capacity | 0;
    if (capacity < 0) throw RangeError("Illegal capacity");
    littleEndian = !!littleEndian;
    noAssert = !!noAssert;
  }
  /**
   * Backing ArrayBuffer.
   * @type {!ArrayBuffer}
   * @expose
   */


  this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);
  /**
   * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
   * @type {?Uint8Array}
   * @expose
   */

  this.view = capacity === 0 ? null : new Uint8Array(this.buffer);
  /**
   * Absolute read/write offset.
   * @type {number}
   * @expose
   * @see ByteBuffer#flip
   * @see ByteBuffer#clear
   */

  this.offset = 0;
  /**
   * Marked offset.
   * @type {number}
   * @expose
   * @see ByteBuffer#mark
   * @see ByteBuffer#reset
   */

  this.markedOffset = -1;
  /**
   * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.
   * @type {number}
   * @expose
   * @see ByteBuffer#flip
   * @see ByteBuffer#clear
   */

  this.limit = capacity;
  /**
   * Whether to use little endian byte order, defaults to `false` for big endian.
   * @type {boolean}
   * @expose
   */

  this.littleEndian = littleEndian;
  /**
   * Whether to skip assertions of offsets and values, defaults to `false`.
   * @type {boolean}
   * @expose
   */

  this.noAssert = noAssert;
};
/**
 * ByteBuffer version.
 * @type {string}
 * @const
 * @expose
 */


ByteBuffer.VERSION = "5.0.1";
/**
 * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.
 * @type {boolean}
 * @const
 * @expose
 */

ByteBuffer.LITTLE_ENDIAN = true;
/**
 * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.
 * @type {boolean}
 * @const
 * @expose
 */

ByteBuffer.BIG_ENDIAN = false;
/**
 * Default initial capacity of `16`.
 * @type {number}
 * @expose
 */

ByteBuffer.DEFAULT_CAPACITY = 16;
/**
 * Default endianess of `false` for big endian.
 * @type {boolean}
 * @expose
 */

ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;
/**
 * Default no assertions flag of `false`.
 * @type {boolean}
 * @expose
 */

ByteBuffer.DEFAULT_NOASSERT = false;
/**
 * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
 *  and int64 support is not available.
 * @type {?Long}
 * @const
 * @see https://github.com/dcodeIO/long.js
 * @expose
 */

ByteBuffer.Long = Long || null;
/**
 * @alias ByteBuffer.prototype
 * @inner
 */

var ByteBufferPrototype = ByteBuffer.prototype;
/**
 * An indicator used to reliably determine if an object is a ByteBuffer or not.
 * @type {boolean}
 * @const
 * @expose
 * @private
 */

ByteBufferPrototype.__isByteBuffer__;
(0, _defineProperty.default)(ByteBufferPrototype, "__isByteBuffer__", {
  value: true,
  enumerable: false,
  configurable: false
}); // helpers

/**
 * @type {!ArrayBuffer}
 * @inner
 */

var EMPTY_BUFFER = new ArrayBuffer(0);
/**
 * String.fromCharCode reference for compile-time renaming.
 * @type {function(...number):string}
 * @inner
 */

var stringFromCharCode = String.fromCharCode;
/**
 * Creates a source function for a string.
 * @param {string} s String to read from
 * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
 *  no more characters left.
 * @throws {TypeError} If the argument is invalid
 * @inner
 */

function stringSource(s) {
  var i = 0;
  return function () {
    return i < s.length ? s.charCodeAt(i++) : null;
  };
}
/**
 * Creates a destination function for a string.
 * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
 *  Returns the final string when called without arguments.
 * @inner
 */


function stringDestination() {
  var cs = [],
      ps = [];
  return function () {
    if (arguments.length === 0) return ps.join('') + stringFromCharCode.apply(String, cs);
    if (cs.length + arguments.length > 1024) ps.push(stringFromCharCode.apply(String, cs)), cs.length = 0;
    Array.prototype.push.apply(cs, arguments);
  };
}
/**
 * Gets the accessor type.
 * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)
 * @expose
 */


ByteBuffer.accessor = function () {
  return Uint8Array;
};
/**
 * Allocates a new ByteBuffer backed by a buffer of the specified capacity.
 * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
 *  {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
 *  {@link ByteBuffer.DEFAULT_NOASSERT}.
 * @returns {!ByteBuffer}
 * @expose
 */


ByteBuffer.allocate = function (capacity, littleEndian, noAssert) {
  return new ByteBuffer(capacity, littleEndian, noAssert);
};
/**
 * Concatenates multiple ByteBuffers into one.
 * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate
 * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",
 *  defaults to "utf8")
 * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
 *  to {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
 *  {@link ByteBuffer.DEFAULT_NOASSERT}.
 * @returns {!ByteBuffer} Concatenated ByteBuffer
 * @expose
 */


ByteBuffer.concat = function (buffers, encoding, littleEndian, noAssert) {
  if (typeof encoding === 'boolean' || typeof encoding !== 'string') {
    noAssert = littleEndian;
    littleEndian = encoding;
    encoding = undefined;
  }

  var capacity = 0;

  for (var i = 0, k = buffers.length, length; i < k; ++i) {
    if (!ByteBuffer.isByteBuffer(buffers[i])) buffers[i] = ByteBuffer.wrap(buffers[i], encoding);
    length = buffers[i].limit - buffers[i].offset;
    if (length > 0) capacity += length;
  }

  if (capacity === 0) return new ByteBuffer(0, littleEndian, noAssert);
  var bb = new ByteBuffer(capacity, littleEndian, noAssert),
      bi;
  i = 0;

  while (i < k) {
    bi = buffers[i++];
    length = bi.limit - bi.offset;
    if (length <= 0) continue;
    bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);
    bb.offset += length;
  }

  bb.limit = bb.offset;
  bb.offset = 0;
  return bb;
};
/**
 * Tests if the specified type is a ByteBuffer.
 * @param {*} bb ByteBuffer to test
 * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`
 * @expose
 */


ByteBuffer.isByteBuffer = function (bb) {
  return (bb && bb["__isByteBuffer__"]) === true;
};
/**
 * Gets the backing buffer type.
 * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)
 * @expose
 */


ByteBuffer.type = function () {
  return ArrayBuffer;
};
/**
 * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its
 *  {@link ByteBuffer#limit} to the length of the wrapped data.
 * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped
 * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
 *  "utf8")
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
 *  {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
 *  {@link ByteBuffer.DEFAULT_NOASSERT}.
 * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`
 * @expose
 */


ByteBuffer.wrap = function (buffer, encoding, littleEndian, noAssert) {
  if (typeof encoding !== 'string') {
    noAssert = littleEndian;
    littleEndian = encoding;
    encoding = undefined;
  }

  if (typeof buffer === 'string') {
    if (typeof encoding === 'undefined') encoding = "utf8";

    switch (encoding) {
      case "base64":
        return ByteBuffer.fromBase64(buffer, littleEndian);

      case "hex":
        return ByteBuffer.fromHex(buffer, littleEndian);

      case "binary":
        return ByteBuffer.fromBinary(buffer, littleEndian);

      case "utf8":
        return ByteBuffer.fromUTF8(buffer, littleEndian);

      case "debug":
        return ByteBuffer.fromDebug(buffer, littleEndian);

      default:
        throw Error("Unsupported encoding: " + encoding);
    }
  }

  if (buffer === null || (0, _typeof2.default)(buffer) !== 'object') throw TypeError("Illegal buffer");
  var bb;

  if (ByteBuffer.isByteBuffer(buffer)) {
    bb = ByteBufferPrototype.clone.call(buffer);
    bb.markedOffset = -1;
    return bb;
  }

  if (buffer instanceof Uint8Array) {
    // Extract ArrayBuffer from Uint8Array
    bb = new ByteBuffer(0, littleEndian, noAssert);

    if (buffer.length > 0) {
      // Avoid references to more than one EMPTY_BUFFER
      bb.buffer = buffer.buffer;
      bb.offset = buffer.byteOffset;
      bb.limit = buffer.byteOffset + buffer.byteLength;
      bb.view = new Uint8Array(buffer.buffer);
    }
  } else if (buffer instanceof ArrayBuffer) {
    // Reuse ArrayBuffer
    bb = new ByteBuffer(0, littleEndian, noAssert);

    if (buffer.byteLength > 0) {
      bb.buffer = buffer;
      bb.offset = 0;
      bb.limit = buffer.byteLength;
      bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;
    }
  } else if (Object.prototype.toString.call(buffer) === "[object Array]") {
    // Create from octets
    bb = new ByteBuffer(buffer.length, littleEndian, noAssert);
    bb.limit = buffer.length;

    for (var i = 0; i < buffer.length; ++i) {
      bb.view[i] = buffer[i];
    }
  } else throw TypeError("Illegal buffer"); // Otherwise fail


  return bb;
};
/**
 * Writes the array as a bitset.
 * @param {Array<boolean>} value Array of booleans to write
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
 * @returns {!ByteBuffer}
 * @expose
 */


ByteBufferPrototype.writeBitSet = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (!(value instanceof Array)) throw TypeError("Illegal BitSet: Not an array");
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  var start = offset,
      bits = value.length,
      bytes = bits >> 3,
      bit = 0,
      k;
  offset += this.writeVarint32(bits, offset);

  while (bytes--) {
    k = !!value[bit++] & 1 | (!!value[bit++] & 1) << 1 | (!!value[bit++] & 1) << 2 | (!!value[bit++] & 1) << 3 | (!!value[bit++] & 1) << 4 | (!!value[bit++] & 1) << 5 | (!!value[bit++] & 1) << 6 | (!!value[bit++] & 1) << 7;
    this.writeByte(k, offset++);
  }

  if (bit < bits) {
    var m = 0;
    k = 0;

    while (bit < bits) {
      k = k | (!!value[bit++] & 1) << m++;
    }

    this.writeByte(k, offset++);
  }

  if (relative) {
    this.offset = offset;
    return this;
  }

  return offset - start;
};
/**
 * Reads a BitSet as an array of booleans.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
 * @returns {Array<boolean>
 * @expose
 */


ByteBufferPrototype.readBitSet = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;
  var ret = this.readVarint32(offset),
      bits = ret.value,
      bytes = bits >> 3,
      bit = 0,
      value = [],
      k;
  offset += ret.length;

  while (bytes--) {
    k = this.readByte(offset++);
    value[bit++] = !!(k & 0x01);
    value[bit++] = !!(k & 0x02);
    value[bit++] = !!(k & 0x04);
    value[bit++] = !!(k & 0x08);
    value[bit++] = !!(k & 0x10);
    value[bit++] = !!(k & 0x20);
    value[bit++] = !!(k & 0x40);
    value[bit++] = !!(k & 0x80);
  }

  if (bit < bits) {
    var m = 0;
    k = this.readByte(offset++);

    while (bit < bits) {
      value[bit++] = !!(k >> m++ & 1);
    }
  }

  if (relative) {
    this.offset = offset;
  }

  return value;
};
/**
 * Reads the specified number of bytes.
 * @param {number} length Number of bytes to read
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
 * @returns {!ByteBuffer}
 * @expose
 */


ByteBufferPrototype.readBytes = function (length, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + length > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + length + ") <= " + this.buffer.byteLength);
  }

  var slice = this.slice(offset, offset + length);
  if (relative) this.offset += length;
  return slice;
};
/**
 * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.
 * @function
 * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
 *  will be modified according to the performed read operation.
 * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.writeBytes = ByteBufferPrototype.append; // types/ints/int8

/**
 * Writes an 8bit signed integer.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */

ByteBufferPrototype.writeInt8 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
    value |= 0;
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  offset += 1;
  var capacity0 = this.buffer.byteLength;
  if (offset > capacity0) this.resize((capacity0 *= 2) > offset ? capacity0 : offset);
  offset -= 1;
  this.view[offset] = value;
  if (relative) this.offset += 1;
  return this;
};
/**
 * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.
 * @function
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;
/**
 * Reads an 8bit signed integer.
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
 * @returns {number} Value read
 * @expose
 */

ByteBufferPrototype.readInt8 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
  }

  var value = this.view[offset];
  if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed

  if (relative) this.offset += 1;
  return value;
};
/**
 * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.
 * @function
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
 * @returns {number} Value read
 * @expose
 */


ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;
/**
 * Writes an 8bit unsigned integer.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */

ByteBufferPrototype.writeUint8 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
    value >>>= 0;
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  offset += 1;
  var capacity1 = this.buffer.byteLength;
  if (offset > capacity1) this.resize((capacity1 *= 2) > offset ? capacity1 : offset);
  offset -= 1;
  this.view[offset] = value;
  if (relative) this.offset += 1;
  return this;
};
/**
 * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.
 * @function
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;
/**
 * Reads an 8bit unsigned integer.
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
 * @returns {number} Value read
 * @expose
 */

ByteBufferPrototype.readUint8 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
  }

  var value = this.view[offset];
  if (relative) this.offset += 1;
  return value;
};
/**
 * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.
 * @function
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.
 * @returns {number} Value read
 * @expose
 */


ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8; // types/ints/int16

/**
 * Writes a 16bit signed integer.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
 * @throws {TypeError} If `offset` or `value` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @expose
 */

ByteBufferPrototype.writeInt16 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
    value |= 0;
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  offset += 2;
  var capacity2 = this.buffer.byteLength;
  if (offset > capacity2) this.resize((capacity2 *= 2) > offset ? capacity2 : offset);
  offset -= 2;

  if (this.littleEndian) {
    this.view[offset + 1] = (value & 0xFF00) >>> 8;
    this.view[offset] = value & 0x00FF;
  } else {
    this.view[offset] = (value & 0xFF00) >>> 8;
    this.view[offset + 1] = value & 0x00FF;
  }

  if (relative) this.offset += 2;
  return this;
};
/**
 * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.
 * @function
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
 * @throws {TypeError} If `offset` or `value` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @expose
 */


ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;
/**
 * Reads a 16bit signed integer.
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
 * @returns {number} Value read
 * @throws {TypeError} If `offset` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @expose
 */

ByteBufferPrototype.readInt16 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 2 + ") <= " + this.buffer.byteLength);
  }

  var value = 0;

  if (this.littleEndian) {
    value = this.view[offset];
    value |= this.view[offset + 1] << 8;
  } else {
    value = this.view[offset] << 8;
    value |= this.view[offset + 1];
  }

  if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed

  if (relative) this.offset += 2;
  return value;
};
/**
 * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.
 * @function
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
 * @returns {number} Value read
 * @throws {TypeError} If `offset` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @expose
 */


ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;
/**
 * Writes a 16bit unsigned integer.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
 * @throws {TypeError} If `offset` or `value` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @expose
 */

ByteBufferPrototype.writeUint16 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
    value >>>= 0;
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  offset += 2;
  var capacity3 = this.buffer.byteLength;
  if (offset > capacity3) this.resize((capacity3 *= 2) > offset ? capacity3 : offset);
  offset -= 2;

  if (this.littleEndian) {
    this.view[offset + 1] = (value & 0xFF00) >>> 8;
    this.view[offset] = value & 0x00FF;
  } else {
    this.view[offset] = (value & 0xFF00) >>> 8;
    this.view[offset + 1] = value & 0x00FF;
  }

  if (relative) this.offset += 2;
  return this;
};
/**
 * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.
 * @function
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
 * @throws {TypeError} If `offset` or `value` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @expose
 */


ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;
/**
 * Reads a 16bit unsigned integer.
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
 * @returns {number} Value read
 * @throws {TypeError} If `offset` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @expose
 */

ByteBufferPrototype.readUint16 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 2 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 2 + ") <= " + this.buffer.byteLength);
  }

  var value = 0;

  if (this.littleEndian) {
    value = this.view[offset];
    value |= this.view[offset + 1] << 8;
  } else {
    value = this.view[offset] << 8;
    value |= this.view[offset + 1];
  }

  if (relative) this.offset += 2;
  return value;
};
/**
 * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.
 * @function
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.
 * @returns {number} Value read
 * @throws {TypeError} If `offset` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @expose
 */


ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16; // types/ints/int32

/**
 * Writes a 32bit signed integer.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @expose
 */

ByteBufferPrototype.writeInt32 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
    value |= 0;
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  offset += 4;
  var capacity4 = this.buffer.byteLength;
  if (offset > capacity4) this.resize((capacity4 *= 2) > offset ? capacity4 : offset);
  offset -= 4;

  if (this.littleEndian) {
    this.view[offset + 3] = value >>> 24 & 0xFF;
    this.view[offset + 2] = value >>> 16 & 0xFF;
    this.view[offset + 1] = value >>> 8 & 0xFF;
    this.view[offset] = value & 0xFF;
  } else {
    this.view[offset] = value >>> 24 & 0xFF;
    this.view[offset + 1] = value >>> 16 & 0xFF;
    this.view[offset + 2] = value >>> 8 & 0xFF;
    this.view[offset + 3] = value & 0xFF;
  }

  if (relative) this.offset += 4;
  return this;
};
/**
 * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @expose
 */


ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;
/**
 * Reads a 32bit signed integer.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @returns {number} Value read
 * @expose
 */

ByteBufferPrototype.readInt32 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.byteLength);
  }

  var value = 0;

  if (this.littleEndian) {
    value = this.view[offset + 2] << 16;
    value |= this.view[offset + 1] << 8;
    value |= this.view[offset];
    value += this.view[offset + 3] << 24 >>> 0;
  } else {
    value = this.view[offset + 1] << 16;
    value |= this.view[offset + 2] << 8;
    value |= this.view[offset + 3];
    value += this.view[offset] << 24 >>> 0;
  }

  value |= 0; // Cast to signed

  if (relative) this.offset += 4;
  return value;
};
/**
 * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.
 * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.
 * @returns {number} Value read
 * @expose
 */


ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;
/**
 * Writes a 32bit unsigned integer.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @expose
 */

ByteBufferPrototype.writeUint32 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
    value >>>= 0;
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  offset += 4;
  var capacity5 = this.buffer.byteLength;
  if (offset > capacity5) this.resize((capacity5 *= 2) > offset ? capacity5 : offset);
  offset -= 4;

  if (this.littleEndian) {
    this.view[offset + 3] = value >>> 24 & 0xFF;
    this.view[offset + 2] = value >>> 16 & 0xFF;
    this.view[offset + 1] = value >>> 8 & 0xFF;
    this.view[offset] = value & 0xFF;
  } else {
    this.view[offset] = value >>> 24 & 0xFF;
    this.view[offset + 1] = value >>> 16 & 0xFF;
    this.view[offset + 2] = value >>> 8 & 0xFF;
    this.view[offset + 3] = value & 0xFF;
  }

  if (relative) this.offset += 4;
  return this;
};
/**
 * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.
 * @function
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @expose
 */


ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;
/**
 * Reads a 32bit unsigned integer.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @returns {number} Value read
 * @expose
 */

ByteBufferPrototype.readUint32 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.byteLength);
  }

  var value = 0;

  if (this.littleEndian) {
    value = this.view[offset + 2] << 16;
    value |= this.view[offset + 1] << 8;
    value |= this.view[offset];
    value += this.view[offset + 3] << 24 >>> 0;
  } else {
    value = this.view[offset + 1] << 16;
    value |= this.view[offset + 2] << 8;
    value |= this.view[offset + 3];
    value += this.view[offset] << 24 >>> 0;
  }

  if (relative) this.offset += 4;
  return value;
};
/**
 * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.
 * @function
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @returns {number} Value read
 * @expose
 */


ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32; // types/ints/int64

if (Long) {
  /**
   * Writes a 64bit signed integer.
   * @param {number|!Long} value Value to write
   * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
   * @returns {!ByteBuffer} this
   * @expose
   */
  ByteBufferPrototype.writeInt64 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;

    if (!this.noAssert) {
      if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
      if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
      offset >>>= 0;
      if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
    }

    if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);
    offset += 8;
    var capacity6 = this.buffer.byteLength;
    if (offset > capacity6) this.resize((capacity6 *= 2) > offset ? capacity6 : offset);
    offset -= 8;
    var lo = value.low,
        hi = value.high;

    if (this.littleEndian) {
      this.view[offset + 3] = lo >>> 24 & 0xFF;
      this.view[offset + 2] = lo >>> 16 & 0xFF;
      this.view[offset + 1] = lo >>> 8 & 0xFF;
      this.view[offset] = lo & 0xFF;
      offset += 4;
      this.view[offset + 3] = hi >>> 24 & 0xFF;
      this.view[offset + 2] = hi >>> 16 & 0xFF;
      this.view[offset + 1] = hi >>> 8 & 0xFF;
      this.view[offset] = hi & 0xFF;
    } else {
      this.view[offset] = hi >>> 24 & 0xFF;
      this.view[offset + 1] = hi >>> 16 & 0xFF;
      this.view[offset + 2] = hi >>> 8 & 0xFF;
      this.view[offset + 3] = hi & 0xFF;
      offset += 4;
      this.view[offset] = lo >>> 24 & 0xFF;
      this.view[offset + 1] = lo >>> 16 & 0xFF;
      this.view[offset + 2] = lo >>> 8 & 0xFF;
      this.view[offset + 3] = lo & 0xFF;
    }

    if (relative) this.offset += 8;
    return this;
  };
  /**
   * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.
   * @param {number|!Long} value Value to write
   * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
   * @returns {!ByteBuffer} this
   * @expose
   */


  ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;
  /**
   * Reads a 64bit signed integer.
   * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
   * @returns {!Long}
   * @expose
   */

  ByteBufferPrototype.readInt64 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;

    if (!this.noAssert) {
      if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
      offset >>>= 0;
      if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.byteLength);
    }

    var lo = 0,
        hi = 0;

    if (this.littleEndian) {
      lo = this.view[offset + 2] << 16;
      lo |= this.view[offset + 1] << 8;
      lo |= this.view[offset];
      lo += this.view[offset + 3] << 24 >>> 0;
      offset += 4;
      hi = this.view[offset + 2] << 16;
      hi |= this.view[offset + 1] << 8;
      hi |= this.view[offset];
      hi += this.view[offset + 3] << 24 >>> 0;
    } else {
      hi = this.view[offset + 1] << 16;
      hi |= this.view[offset + 2] << 8;
      hi |= this.view[offset + 3];
      hi += this.view[offset] << 24 >>> 0;
      offset += 4;
      lo = this.view[offset + 1] << 16;
      lo |= this.view[offset + 2] << 8;
      lo |= this.view[offset + 3];
      lo += this.view[offset] << 24 >>> 0;
    }

    var value = new Long(lo, hi, false);
    if (relative) this.offset += 8;
    return value;
  };
  /**
   * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.
   * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
   * @returns {!Long}
   * @expose
   */


  ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;
  /**
   * Writes a 64bit unsigned integer.
   * @param {number|!Long} value Value to write
   * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
   * @returns {!ByteBuffer} this
   * @expose
   */

  ByteBufferPrototype.writeUint64 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;

    if (!this.noAssert) {
      if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
      if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
      offset >>>= 0;
      if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
    }

    if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);
    offset += 8;
    var capacity7 = this.buffer.byteLength;
    if (offset > capacity7) this.resize((capacity7 *= 2) > offset ? capacity7 : offset);
    offset -= 8;
    var lo = value.low,
        hi = value.high;

    if (this.littleEndian) {
      this.view[offset + 3] = lo >>> 24 & 0xFF;
      this.view[offset + 2] = lo >>> 16 & 0xFF;
      this.view[offset + 1] = lo >>> 8 & 0xFF;
      this.view[offset] = lo & 0xFF;
      offset += 4;
      this.view[offset + 3] = hi >>> 24 & 0xFF;
      this.view[offset + 2] = hi >>> 16 & 0xFF;
      this.view[offset + 1] = hi >>> 8 & 0xFF;
      this.view[offset] = hi & 0xFF;
    } else {
      this.view[offset] = hi >>> 24 & 0xFF;
      this.view[offset + 1] = hi >>> 16 & 0xFF;
      this.view[offset + 2] = hi >>> 8 & 0xFF;
      this.view[offset + 3] = hi & 0xFF;
      offset += 4;
      this.view[offset] = lo >>> 24 & 0xFF;
      this.view[offset + 1] = lo >>> 16 & 0xFF;
      this.view[offset + 2] = lo >>> 8 & 0xFF;
      this.view[offset + 3] = lo & 0xFF;
    }

    if (relative) this.offset += 8;
    return this;
  };
  /**
   * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.
   * @function
   * @param {number|!Long} value Value to write
   * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
   * @returns {!ByteBuffer} this
   * @expose
   */


  ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;
  /**
   * Reads a 64bit unsigned integer.
   * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
   * @returns {!Long}
   * @expose
   */

  ByteBufferPrototype.readUint64 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;

    if (!this.noAssert) {
      if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
      offset >>>= 0;
      if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.byteLength);
    }

    var lo = 0,
        hi = 0;

    if (this.littleEndian) {
      lo = this.view[offset + 2] << 16;
      lo |= this.view[offset + 1] << 8;
      lo |= this.view[offset];
      lo += this.view[offset + 3] << 24 >>> 0;
      offset += 4;
      hi = this.view[offset + 2] << 16;
      hi |= this.view[offset + 1] << 8;
      hi |= this.view[offset];
      hi += this.view[offset + 3] << 24 >>> 0;
    } else {
      hi = this.view[offset + 1] << 16;
      hi |= this.view[offset + 2] << 8;
      hi |= this.view[offset + 3];
      hi += this.view[offset] << 24 >>> 0;
      offset += 4;
      lo = this.view[offset + 1] << 16;
      lo |= this.view[offset + 2] << 8;
      lo |= this.view[offset + 3];
      lo += this.view[offset] << 24 >>> 0;
    }

    var value = new Long(lo, hi, true);
    if (relative) this.offset += 8;
    return value;
  };
  /**
   * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.
   * @function
   * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
   * @returns {!Long}
   * @expose
   */


  ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;
} // Long
// types/floats/float32

/*
 ieee754 - https://github.com/feross/ieee754
   The MIT License (MIT)
   Copyright (c) Feross Aboukhadijeh
   Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
   The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
*/

/**
 * Reads an IEEE754 float from a byte array.
 * @param {!Array} buffer
 * @param {number} offset
 * @param {boolean} isLE
 * @param {number} mLen
 * @param {number} nBytes
 * @returns {number}
 * @inner
 */


function ieee754_read(buffer, offset, isLE, mLen, nBytes) {
  var e,
      m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? nBytes - 1 : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
}
/**
 * Writes an IEEE754 float to a byte array.
 * @param {!Array} buffer
 * @param {number} value
 * @param {number} offset
 * @param {boolean} isLE
 * @param {number} mLen
 * @param {number} nBytes
 * @inner
 */


function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {
  var e,
      m,
      c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
      i = isLE ? 0 : nBytes - 1,
      d = isLE ? 1 : -1,
      s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}
/**
 * Writes a 32bit float.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.writeFloat32 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number') throw TypeError("Illegal value: " + value + " (not a number)");
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  offset += 4;
  var capacity8 = this.buffer.byteLength;
  if (offset > capacity8) this.resize((capacity8 *= 2) > offset ? capacity8 : offset);
  offset -= 4;
  ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);
  if (relative) this.offset += 4;
  return this;
};
/**
 * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.
 * @function
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;
/**
 * Reads a 32bit float.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @returns {number}
 * @expose
 */

ByteBufferPrototype.readFloat32 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.byteLength);
  }

  var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);
  if (relative) this.offset += 4;
  return value;
};
/**
 * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.
 * @function
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
 * @returns {number}
 * @expose
 */


ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32; // types/floats/float64

/**
 * Writes a 64bit float.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */

ByteBufferPrototype.writeFloat64 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number') throw TypeError("Illegal value: " + value + " (not a number)");
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  offset += 8;
  var capacity9 = this.buffer.byteLength;
  if (offset > capacity9) this.resize((capacity9 *= 2) > offset ? capacity9 : offset);
  offset -= 8;
  ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);
  if (relative) this.offset += 8;
  return this;
};
/**
 * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.
 * @function
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;
/**
 * Reads a 64bit float.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
 * @returns {number}
 * @expose
 */

ByteBufferPrototype.readFloat64 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 8 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 8 + ") <= " + this.buffer.byteLength);
  }

  var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);
  if (relative) this.offset += 8;
  return value;
};
/**
 * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.
 * @function
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
 * @returns {number}
 * @expose
 */


ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64; // types/varints/varint32

/**
 * Maximum number of bytes required to store a 32bit base 128 variable-length integer.
 * @type {number}
 * @const
 * @expose
 */

ByteBuffer.MAX_VARINT32_BYTES = 5;
/**
 * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.
 * @param {number} value Value to encode
 * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}
 * @expose
 */

ByteBuffer.calculateVarint32 = function (value) {
  // ref: src/google/protobuf/io/coded_stream.cc
  value = value >>> 0;
  if (value < 1 << 7) return 1;else if (value < 1 << 14) return 2;else if (value < 1 << 21) return 3;else if (value < 1 << 28) return 4;else return 5;
};
/**
 * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.
 * @param {number} n Signed 32bit integer
 * @returns {number} Unsigned zigzag encoded 32bit integer
 * @expose
 */


ByteBuffer.zigZagEncode32 = function (n) {
  return ((n |= 0) << 1 ^ n >> 31) >>> 0; // ref: src/google/protobuf/wire_format_lite.h
};
/**
 * Decodes a zigzag encoded signed 32bit integer.
 * @param {number} n Unsigned zigzag encoded 32bit integer
 * @returns {number} Signed 32bit integer
 * @expose
 */


ByteBuffer.zigZagDecode32 = function (n) {
  return n >>> 1 ^ -(n & 1) | 0; // // ref: src/google/protobuf/wire_format_lite.h
};
/**
 * Writes a 32bit base 128 variable-length integer.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted.
 * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
 * @expose
 */


ByteBufferPrototype.writeVarint32 = function (value, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
    value |= 0;
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  var size = ByteBuffer.calculateVarint32(value),
      b;
  offset += size;
  var capacity10 = this.buffer.byteLength;
  if (offset > capacity10) this.resize((capacity10 *= 2) > offset ? capacity10 : offset);
  offset -= size;
  value >>>= 0;

  while (value >= 0x80) {
    b = value & 0x7f | 0x80;
    this.view[offset++] = b;
    value >>>= 7;
  }

  this.view[offset++] = value;

  if (relative) {
    this.offset = offset;
    return this;
  }

  return size;
};
/**
 * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.
 * @param {number} value Value to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted.
 * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written
 * @expose
 */


ByteBufferPrototype.writeVarint32ZigZag = function (value, offset) {
  return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);
};
/**
 * Reads a 32bit base 128 variable-length integer.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted.
 * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
 *  and the actual number of bytes read.
 * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
 *  to fully decode the varint.
 * @expose
 */


ByteBufferPrototype.readVarint32 = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
  }

  var c = 0,
      value = 0 >>> 0,
      b;

  do {
    if (!this.noAssert && offset > this.limit) {
      var err = Error("Truncated");
      err['truncated'] = true;
      throw err;
    }

    b = this.view[offset++];
    if (c < 5) value |= (b & 0x7f) << 7 * c;
    ++c;
  } while ((b & 0x80) !== 0);

  value |= 0;

  if (relative) {
    this.offset = offset;
    return value;
  }

  return {
    "value": value,
    "length": c
  };
};
/**
 * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted.
 * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read
 *  and the actual number of bytes read.
 * @throws {Error} If it's not a valid varint
 * @expose
 */


ByteBufferPrototype.readVarint32ZigZag = function (offset) {
  var val = this.readVarint32(offset);
  if ((0, _typeof2.default)(val) === 'object') val["value"] = ByteBuffer.zigZagDecode32(val["value"]);else val = ByteBuffer.zigZagDecode32(val);
  return val;
}; // types/varints/varint64


if (Long) {
  /**
   * Maximum number of bytes required to store a 64bit base 128 variable-length integer.
   * @type {number}
   * @const
   * @expose
   */
  ByteBuffer.MAX_VARINT64_BYTES = 10;
  /**
   * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.
   * @param {number|!Long} value Value to encode
   * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}
   * @expose
   */

  ByteBuffer.calculateVarint64 = function (value) {
    if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value); // ref: src/google/protobuf/io/coded_stream.cc

    var part0 = value.toInt() >>> 0,
        part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
        part2 = value.shiftRightUnsigned(56).toInt() >>> 0;

    if (part2 == 0) {
      if (part1 == 0) {
        if (part0 < 1 << 14) return part0 < 1 << 7 ? 1 : 2;else return part0 < 1 << 21 ? 3 : 4;
      } else {
        if (part1 < 1 << 14) return part1 < 1 << 7 ? 5 : 6;else return part1 < 1 << 21 ? 7 : 8;
      }
    } else return part2 < 1 << 7 ? 9 : 10;
  };
  /**
   * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.
   * @param {number|!Long} value Signed long
   * @returns {!Long} Unsigned zigzag encoded long
   * @expose
   */


  ByteBuffer.zigZagEncode64 = function (value) {
    if (typeof value === 'number') value = Long.fromNumber(value, false);else if (typeof value === 'string') value = Long.fromString(value, false);else if (value.unsigned !== false) value = value.toSigned(); // ref: src/google/protobuf/wire_format_lite.h

    return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();
  };
  /**
   * Decodes a zigzag encoded signed 64bit integer.
   * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number
   * @returns {!Long} Signed long
   * @expose
   */


  ByteBuffer.zigZagDecode64 = function (value) {
    if (typeof value === 'number') value = Long.fromNumber(value, false);else if (typeof value === 'string') value = Long.fromString(value, false);else if (value.unsigned !== false) value = value.toSigned(); // ref: src/google/protobuf/wire_format_lite.h

    return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();
  };
  /**
   * Writes a 64bit base 128 variable-length integer.
   * @param {number|Long} value Value to write
   * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
   *  written if omitted.
   * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
   * @expose
   */


  ByteBufferPrototype.writeVarint64 = function (value, offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;

    if (!this.noAssert) {
      if (typeof value === 'number') value = Long.fromNumber(value);else if (typeof value === 'string') value = Long.fromString(value);else if (!(value && value instanceof Long)) throw TypeError("Illegal value: " + value + " (not an integer or Long)");
      if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
      offset >>>= 0;
      if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
    }

    if (typeof value === 'number') value = Long.fromNumber(value, false);else if (typeof value === 'string') value = Long.fromString(value, false);else if (value.unsigned !== false) value = value.toSigned();
    var size = ByteBuffer.calculateVarint64(value),
        part0 = value.toInt() >>> 0,
        part1 = value.shiftRightUnsigned(28).toInt() >>> 0,
        part2 = value.shiftRightUnsigned(56).toInt() >>> 0;
    offset += size;
    var capacity11 = this.buffer.byteLength;
    if (offset > capacity11) this.resize((capacity11 *= 2) > offset ? capacity11 : offset);
    offset -= size;

    switch (size) {
      case 10:
        this.view[offset + 9] = part2 >>> 7 & 0x01;

      case 9:
        this.view[offset + 8] = size !== 9 ? part2 | 0x80 : part2 & 0x7F;

      case 8:
        this.view[offset + 7] = size !== 8 ? part1 >>> 21 | 0x80 : part1 >>> 21 & 0x7F;

      case 7:
        this.view[offset + 6] = size !== 7 ? part1 >>> 14 | 0x80 : part1 >>> 14 & 0x7F;

      case 6:
        this.view[offset + 5] = size !== 6 ? part1 >>> 7 | 0x80 : part1 >>> 7 & 0x7F;

      case 5:
        this.view[offset + 4] = size !== 5 ? part1 | 0x80 : part1 & 0x7F;

      case 4:
        this.view[offset + 3] = size !== 4 ? part0 >>> 21 | 0x80 : part0 >>> 21 & 0x7F;

      case 3:
        this.view[offset + 2] = size !== 3 ? part0 >>> 14 | 0x80 : part0 >>> 14 & 0x7F;

      case 2:
        this.view[offset + 1] = size !== 2 ? part0 >>> 7 | 0x80 : part0 >>> 7 & 0x7F;

      case 1:
        this.view[offset] = size !== 1 ? part0 | 0x80 : part0 & 0x7F;
    }

    if (relative) {
      this.offset += size;
      return this;
    } else {
      return size;
    }
  };
  /**
   * Writes a zig-zag encoded 64bit base 128 variable-length integer.
   * @param {number|Long} value Value to write
   * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
   *  written if omitted.
   * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.
   * @expose
   */


  ByteBufferPrototype.writeVarint64ZigZag = function (value, offset) {
    return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);
  };
  /**
   * Reads a 64bit base 128 variable-length integer. Requires Long.js.
   * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
   *  read if omitted.
   * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
   *  the actual number of bytes read.
   * @throws {Error} If it's not a valid varint
   * @expose
   */


  ByteBufferPrototype.readVarint64 = function (offset) {
    var relative = typeof offset === 'undefined';
    if (relative) offset = this.offset;

    if (!this.noAssert) {
      if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
      offset >>>= 0;
      if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
    } // ref: src/google/protobuf/io/coded_stream.cc


    var start = offset,
        part0 = 0,
        part1 = 0,
        part2 = 0,
        b = 0;
    b = this.view[offset++];
    part0 = b & 0x7F;

    if (b & 0x80) {
      b = this.view[offset++];
      part0 |= (b & 0x7F) << 7;

      if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
        b = this.view[offset++];
        part0 |= (b & 0x7F) << 14;

        if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
          b = this.view[offset++];
          part0 |= (b & 0x7F) << 21;

          if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
            b = this.view[offset++];
            part1 = b & 0x7F;

            if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
              b = this.view[offset++];
              part1 |= (b & 0x7F) << 7;

              if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                b = this.view[offset++];
                part1 |= (b & 0x7F) << 14;

                if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                  b = this.view[offset++];
                  part1 |= (b & 0x7F) << 21;

                  if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                    b = this.view[offset++];
                    part2 = b & 0x7F;

                    if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                      b = this.view[offset++];
                      part2 |= (b & 0x7F) << 7;

                      if (b & 0x80 || this.noAssert && typeof b === 'undefined') {
                        throw Error("Buffer overrun");
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    var value = Long.fromBits(part0 | part1 << 28, part1 >>> 4 | part2 << 24, false);

    if (relative) {
      this.offset = offset;
      return value;
    } else {
      return {
        'value': value,
        'length': offset - start
      };
    }
  };
  /**
   * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.
   * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
   *  read if omitted.
   * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
   *  the actual number of bytes read.
   * @throws {Error} If it's not a valid varint
   * @expose
   */


  ByteBufferPrototype.readVarint64ZigZag = function (offset) {
    var val = this.readVarint64(offset);
    if (val && val['value'] instanceof Long) val["value"] = ByteBuffer.zigZagDecode64(val["value"]);else val = ByteBuffer.zigZagDecode64(val);
    return val;
  };
} // Long
// types/strings/cstring

/**
 * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL
 *  characters itself.
 * @param {string} str String to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  contained in `str` + 1 if omitted.
 * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written
 * @expose
 */


ByteBufferPrototype.writeCString = function (str, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;
  var i,
      k = str.length;

  if (!this.noAssert) {
    if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");

    for (i = 0; i < k; ++i) {
      if (str.charCodeAt(i) === 0) throw RangeError("Illegal str: Contains NULL-characters");
    }

    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  } // UTF8 strings do not contain zero bytes in between except for the zero character, so:


  k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
  offset += k + 1;
  var capacity12 = this.buffer.byteLength;
  if (offset > capacity12) this.resize((capacity12 *= 2) > offset ? capacity12 : offset);
  offset -= k + 1;
  utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
    this.view[offset++] = b;
  }.bind(this));
  this.view[offset++] = 0;

  if (relative) {
    this.offset = offset;
    return this;
  }

  return k;
};
/**
 * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
 *  itself.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  read if omitted.
 * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 */


ByteBufferPrototype.readCString = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
  }

  var start = offset,
      temp; // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:

  var sd,
      b = -1;
  utfx.decodeUTF8toUTF16(function () {
    if (b === 0) return null;
    if (offset >= this.limit) throw RangeError("Illegal range: Truncated data, " + offset + " < " + this.limit);
    b = this.view[offset++];
    return b === 0 ? null : b;
  }.bind(this), sd = stringDestination(), true);

  if (relative) {
    this.offset = offset;
    return sd();
  } else {
    return {
      "string": sd(),
      "length": offset - start
    };
  }
}; // types/strings/istring

/**
 * Writes a length as uint32 prefixed UTF8 encoded string.
 * @param {string} str String to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted.
 * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
 * @expose
 * @see ByteBuffer#writeVarint32
 */


ByteBufferPrototype.writeIString = function (str, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  var start = offset,
      k;
  k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
  offset += 4 + k;
  var capacity13 = this.buffer.byteLength;
  if (offset > capacity13) this.resize((capacity13 *= 2) > offset ? capacity13 : offset);
  offset -= 4 + k;

  if (this.littleEndian) {
    this.view[offset + 3] = k >>> 24 & 0xFF;
    this.view[offset + 2] = k >>> 16 & 0xFF;
    this.view[offset + 1] = k >>> 8 & 0xFF;
    this.view[offset] = k & 0xFF;
  } else {
    this.view[offset] = k >>> 24 & 0xFF;
    this.view[offset + 1] = k >>> 16 & 0xFF;
    this.view[offset + 2] = k >>> 8 & 0xFF;
    this.view[offset + 3] = k & 0xFF;
  }

  offset += 4;
  utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
    this.view[offset++] = b;
  }.bind(this));
  if (offset !== start + 4 + k) throw RangeError("Illegal range: Truncated data, " + offset + " == " + (offset + 4 + k));

  if (relative) {
    this.offset = offset;
    return this;
  }

  return offset - start;
};
/**
 * Reads a length as uint32 prefixed UTF8 encoded string.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  read if omitted.
 * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 * @see ByteBuffer#readVarint32
 */


ByteBufferPrototype.readIString = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 4 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 4 + ") <= " + this.buffer.byteLength);
  }

  var start = offset;
  var len = this.readUint32(offset);
  var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);
  offset += str['length'];

  if (relative) {
    this.offset = offset;
    return str['string'];
  } else {
    return {
      'string': str['string'],
      'length': offset - start
    };
  }
}; // types/strings/utf8string

/**
 * Metrics representing number of UTF8 characters. Evaluates to `c`.
 * @type {string}
 * @const
 * @expose
 */


ByteBuffer.METRICS_CHARS = 'c';
/**
 * Metrics representing number of bytes. Evaluates to `b`.
 * @type {string}
 * @const
 * @expose
 */

ByteBuffer.METRICS_BYTES = 'b';
/**
 * Writes an UTF8 encoded string.
 * @param {string} str String to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
 * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
 * @expose
 */

ByteBufferPrototype.writeUTF8String = function (str, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  var k;
  var start = offset;
  k = utfx.calculateUTF16asUTF8(stringSource(str))[1];
  offset += k;
  var capacity14 = this.buffer.byteLength;
  if (offset > capacity14) this.resize((capacity14 *= 2) > offset ? capacity14 : offset);
  offset -= k;
  utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
    this.view[offset++] = b;
  }.bind(this));

  if (relative) {
    this.offset = offset;
    return this;
  }

  return offset - start;
};
/**
 * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.
 * @function
 * @param {string} str String to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.
 * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.
 * @expose
 */


ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;
/**
 * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's
 *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.
 * @param {string} str String to calculate
 * @returns {number} Number of UTF8 characters
 * @expose
 */

ByteBuffer.calculateUTF8Chars = function (str) {
  return utfx.calculateUTF16asUTF8(stringSource(str))[0];
};
/**
 * Calculates the number of UTF8 bytes of a string.
 * @param {string} str String to calculate
 * @returns {number} Number of UTF8 bytes
 * @expose
 */


ByteBuffer.calculateUTF8Bytes = function (str) {
  return utfx.calculateUTF16asUTF8(stringSource(str))[1];
};
/**
 * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.
 * @function
 * @param {string} str String to calculate
 * @returns {number} Number of UTF8 bytes
 * @expose
 */


ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;
/**
 * Reads an UTF8 encoded string.
 * @param {number} length Number of characters or bytes to read.
 * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to
 *  {@link ByteBuffer.METRICS_CHARS}.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  read if omitted.
 * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 */

ByteBufferPrototype.readUTF8String = function (length, metrics, offset) {
  if (typeof metrics === 'number') {
    offset = metrics;
    metrics = undefined;
  }

  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;
  if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;

  if (!this.noAssert) {
    if (typeof length !== 'number' || length % 1 !== 0) throw TypeError("Illegal length: " + length + " (not an integer)");
    length |= 0;
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  var i = 0,
      start = offset,
      sd;

  if (metrics === ByteBuffer.METRICS_CHARS) {
    // The same for node and the browser
    sd = stringDestination();
    utfx.decodeUTF8(function () {
      return i < length && offset < this.limit ? this.view[offset++] : null;
    }.bind(this), function (cp) {
      ++i;
      utfx.UTF8toUTF16(cp, sd);
    });
    if (i !== length) throw RangeError("Illegal range: Truncated data, " + i + " == " + length);

    if (relative) {
      this.offset = offset;
      return sd();
    } else {
      return {
        "string": sd(),
        "length": offset - start
      };
    }
  } else if (metrics === ByteBuffer.METRICS_BYTES) {
    if (!this.noAssert) {
      if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
      offset >>>= 0;
      if (offset < 0 || offset + length > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + length + ") <= " + this.buffer.byteLength);
    }

    var k = offset + length;
    utfx.decodeUTF8toUTF16(function () {
      return offset < k ? this.view[offset++] : null;
    }.bind(this), sd = stringDestination(), this.noAssert);
    if (offset !== k) throw RangeError("Illegal range: Truncated data, " + offset + " == " + k);

    if (relative) {
      this.offset = offset;
      return sd();
    } else {
      return {
        'string': sd(),
        'length': offset - start
      };
    }
  } else throw TypeError("Unsupported metrics: " + metrics);
};
/**
 * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.
 * @function
 * @param {number} length Number of characters or bytes to read
 * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to
 *  {@link ByteBuffer.METRICS_CHARS}.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  read if omitted.
 * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 */


ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String; // types/strings/vstring

/**
 * Writes a length as varint32 prefixed UTF8 encoded string.
 * @param {string} str String to write
 * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted.
 * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written
 * @expose
 * @see ByteBuffer#writeVarint32
 */

ByteBufferPrototype.writeVString = function (str, offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  var start = offset,
      k,
      l;
  k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];
  l = ByteBuffer.calculateVarint32(k);
  offset += l + k;
  var capacity15 = this.buffer.byteLength;
  if (offset > capacity15) this.resize((capacity15 *= 2) > offset ? capacity15 : offset);
  offset -= l + k;
  offset += this.writeVarint32(k, offset);
  utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
    this.view[offset++] = b;
  }.bind(this));
  if (offset !== start + k + l) throw RangeError("Illegal range: Truncated data, " + offset + " == " + (offset + k + l));

  if (relative) {
    this.offset = offset;
    return this;
  }

  return offset - start;
};
/**
 * Reads a length as varint32 prefixed UTF8 encoded string.
 * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  read if omitted.
 * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string
 *  read and the actual number of bytes read.
 * @expose
 * @see ByteBuffer#readVarint32
 */


ByteBufferPrototype.readVString = function (offset) {
  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 1 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 1 + ") <= " + this.buffer.byteLength);
  }

  var start = offset;
  var len = this.readVarint32(offset);
  var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);
  offset += str['length'];

  if (relative) {
    this.offset = offset;
    return str['string'];
  } else {
    return {
      'string': str['string'],
      'length': offset - start
    };
  }
};
/**
 * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
 *  data's length.
 * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
 *  will be modified according to the performed read operation.
 * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
 * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`
 * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`
 */


ByteBufferPrototype.append = function (source, encoding, offset) {
  if (typeof encoding === 'number' || typeof encoding !== 'string') {
    offset = encoding;
    encoding = undefined;
  }

  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  if (!(source instanceof ByteBuffer)) source = ByteBuffer.wrap(source, encoding);
  var length = source.limit - source.offset;
  if (length <= 0) return this; // Nothing to append

  offset += length;
  var capacity16 = this.buffer.byteLength;
  if (offset > capacity16) this.resize((capacity16 *= 2) > offset ? capacity16 : offset);
  offset -= length;
  this.view.set(source.view.subarray(source.offset, source.limit), offset);
  source.offset += length;
  if (relative) this.offset += length;
  return this;
};
/**
 * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the
    specified offset up to the length of this ByteBuffer's data.
 * @param {!ByteBuffer} target Target ByteBuffer
 * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  read if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 * @see ByteBuffer#append
 */


ByteBufferPrototype.appendTo = function (target, offset) {
  target.append(this, offset);
  return this;
};
/**
 * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
 *  disable them if your code already makes sure that everything is valid.
 * @param {boolean} assert `true` to enable assertions, otherwise `false`
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.assert = function (assert) {
  this.noAssert = !assert;
  return this;
};
/**
 * Gets the capacity of this ByteBuffer's backing buffer.
 * @returns {number} Capacity of the backing buffer
 * @expose
 */


ByteBufferPrototype.capacity = function () {
  return this.buffer.byteLength;
};
/**
 * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
 *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.clear = function () {
  this.offset = 0;
  this.limit = this.buffer.byteLength;
  this.markedOffset = -1;
  return this;
};
/**
 * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
 *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.
 * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
 * @returns {!ByteBuffer} Cloned instance
 * @expose
 */


ByteBufferPrototype.clone = function (copy) {
  var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);

  if (copy) {
    bb.buffer = new ArrayBuffer(this.buffer.byteLength);
    bb.view = new Uint8Array(bb.buffer);
  } else {
    bb.buffer = this.buffer;
    bb.view = this.view;
  }

  bb.offset = this.offset;
  bb.markedOffset = this.markedOffset;
  bb.limit = this.limit;
  return bb;
};
/**
 * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
 *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
 *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.
 * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
 * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.compact = function (begin, end) {
  if (typeof begin === 'undefined') begin = this.offset;
  if (typeof end === 'undefined') end = this.limit;

  if (!this.noAssert) {
    if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
    begin >>>= 0;
    if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
    end >>>= 0;
    if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
  }

  if (begin === 0 && end === this.buffer.byteLength) return this; // Already compacted

  var len = end - begin;

  if (len === 0) {
    this.buffer = EMPTY_BUFFER;
    this.view = null;
    if (this.markedOffset >= 0) this.markedOffset -= begin;
    this.offset = 0;
    this.limit = 0;
    return this;
  }

  var buffer = new ArrayBuffer(len);
  var view = new Uint8Array(buffer);
  view.set(this.view.subarray(begin, end));
  this.buffer = buffer;
  this.view = view;
  if (this.markedOffset >= 0) this.markedOffset -= begin;
  this.offset = 0;
  this.limit = len;
  return this;
};
/**
 * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and
 *  {@link ByteBuffer#limit}.
 * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
 * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
 * @returns {!ByteBuffer} Copy
 * @expose
 */


ByteBufferPrototype.copy = function (begin, end) {
  if (typeof begin === 'undefined') begin = this.offset;
  if (typeof end === 'undefined') end = this.limit;

  if (!this.noAssert) {
    if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
    begin >>>= 0;
    if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
    end >>>= 0;
    if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
  }

  if (begin === end) return new ByteBuffer(0, this.littleEndian, this.noAssert);
  var capacity = end - begin,
      bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);
  bb.offset = 0;
  bb.limit = capacity;
  if (bb.markedOffset >= 0) bb.markedOffset -= begin;
  this.copyTo(bb, 0, begin, end);
  return bb;
};
/**
 * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
 *  {@link ByteBuffer#limit}.
 * @param {!ByteBuffer} target Target ByteBuffer
 * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}
 *  by the number of bytes copied if omitted.
 * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
 *  number of bytes copied if omitted.
 * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.copyTo = function (target, targetOffset, sourceOffset, sourceLimit) {
  var relative, targetRelative;

  if (!this.noAssert) {
    if (!ByteBuffer.isByteBuffer(target)) throw TypeError("Illegal target: Not a ByteBuffer");
  }

  targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;
  sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;
  sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;
  if (targetOffset < 0 || targetOffset > target.buffer.byteLength) throw RangeError("Illegal target range: 0 <= " + targetOffset + " <= " + target.buffer.byteLength);
  if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength) throw RangeError("Illegal source range: 0 <= " + sourceOffset + " <= " + this.buffer.byteLength);
  var len = sourceLimit - sourceOffset;
  if (len === 0) return target; // Nothing to copy

  target.ensureCapacity(targetOffset + len);
  target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);
  if (relative) this.offset += len;
  if (targetRelative) target.offset += len;
  return this;
};
/**
 * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
 *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
 *  the required capacity will be used instead.
 * @param {number} capacity Required capacity
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.ensureCapacity = function (capacity) {
  var current = this.buffer.byteLength;
  if (current < capacity) return this.resize((current *= 2) > capacity ? current : capacity);
  return this;
};
/**
 * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between
 *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
 * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.
 * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes
 *  written if omitted. defaults to {@link ByteBuffer#offset}.
 * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
 * @returns {!ByteBuffer} this
 * @expose
 * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes
 */


ByteBufferPrototype.fill = function (value, begin, end) {
  var relative = typeof begin === 'undefined';
  if (relative) begin = this.offset;
  if (typeof value === 'string' && value.length > 0) value = value.charCodeAt(0);
  if (typeof begin === 'undefined') begin = this.offset;
  if (typeof end === 'undefined') end = this.limit;

  if (!this.noAssert) {
    if (typeof value !== 'number' || value % 1 !== 0) throw TypeError("Illegal value: " + value + " (not an integer)");
    value |= 0;
    if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
    begin >>>= 0;
    if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
    end >>>= 0;
    if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
  }

  if (begin >= end) return this; // Nothing to fill

  while (begin < end) {
    this.view[begin++] = value;
  }

  if (relative) this.offset = begin;
  return this;
};
/**
 * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and
 *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.flip = function () {
  this.limit = this.offset;
  this.offset = 0;
  return this;
};
/**
 * Marks an offset on this ByteBuffer to be used later.
 * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.
 * @returns {!ByteBuffer} this
 * @throws {TypeError} If `offset` is not a valid number
 * @throws {RangeError} If `offset` is out of bounds
 * @see ByteBuffer#reset
 * @expose
 */


ByteBufferPrototype.mark = function (offset) {
  offset = typeof offset === 'undefined' ? this.offset : offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  this.markedOffset = offset;
  return this;
};
/**
 * Sets the byte order.
 * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.order = function (littleEndian) {
  if (!this.noAssert) {
    if (typeof littleEndian !== 'boolean') throw TypeError("Illegal littleEndian: Not a boolean");
  }

  this.littleEndian = !!littleEndian;
  return this;
};
/**
 * Switches (to) little endian byte order.
 * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.LE = function (littleEndian) {
  this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;
  return this;
};
/**
 * Switches (to) big endian byte order.
 * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.BE = function (bigEndian) {
  this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;
  return this;
};
/**
 * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the
 *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
 *  will be resized and its contents moved accordingly.
 * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
 *  modified according to the performed read operation.
 * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
 * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
 *  prepended if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`
 * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`
 */


ByteBufferPrototype.prepend = function (source, encoding, offset) {
  if (typeof encoding === 'number' || typeof encoding !== 'string') {
    offset = encoding;
    encoding = undefined;
  }

  var relative = typeof offset === 'undefined';
  if (relative) offset = this.offset;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: " + offset + " (not an integer)");
    offset >>>= 0;
    if (offset < 0 || offset + 0 > this.buffer.byteLength) throw RangeError("Illegal offset: 0 <= " + offset + " (+" + 0 + ") <= " + this.buffer.byteLength);
  }

  if (!(source instanceof ByteBuffer)) source = ByteBuffer.wrap(source, encoding);
  var len = source.limit - source.offset;
  if (len <= 0) return this; // Nothing to prepend

  var diff = len - offset;

  if (diff > 0) {
    // Not enough space before offset, so resize + move
    var buffer = new ArrayBuffer(this.buffer.byteLength + diff);
    var view = new Uint8Array(buffer);
    view.set(this.view.subarray(offset, this.buffer.byteLength), len);
    this.buffer = buffer;
    this.view = view;
    this.offset += diff;
    if (this.markedOffset >= 0) this.markedOffset += diff;
    this.limit += diff;
    offset += diff;
  } else {
    var arrayView = new Uint8Array(this.buffer);
  }

  this.view.set(source.view.subarray(source.offset, source.limit), offset - len);
  source.offset = source.limit;
  if (relative) this.offset -= len;
  return this;
};
/**
 * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
 *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
 *  will be resized and its contents moved accordingly.
 * @param {!ByteBuffer} target Target ByteBuffer
 * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
 *  prepended if omitted.
 * @returns {!ByteBuffer} this
 * @expose
 * @see ByteBuffer#prepend
 */


ByteBufferPrototype.prependTo = function (target, offset) {
  target.prepend(this, offset);
  return this;
};
/**
 * Prints debug information about this ByteBuffer's contents.
 * @param {function(string)=} out Output function to call, defaults to console.log
 * @expose
 */


ByteBufferPrototype.printDebug = function (out) {
  if (typeof out !== 'function') out = console.log.bind(console);
  out(this.toString() + "\n" + "-------------------------------------------------------------------\n" + this.toDebug(
  /* columns */
  true));
};
/**
 * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and
 *  {@link ByteBuffer#limit}, so this returns `limit - offset`.
 * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.
 * @expose
 */


ByteBufferPrototype.remaining = function () {
  return this.limit - this.offset;
};
/**
 * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
 *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
 *  marked, sets `offset = 0`.
 * @returns {!ByteBuffer} this
 * @see ByteBuffer#mark
 * @expose
 */


ByteBufferPrototype.reset = function () {
  if (this.markedOffset >= 0) {
    this.offset = this.markedOffset;
    this.markedOffset = -1;
  } else {
    this.offset = 0;
  }

  return this;
};
/**
 * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
 *  large or larger.
 * @param {number} capacity Capacity required
 * @returns {!ByteBuffer} this
 * @throws {TypeError} If `capacity` is not a number
 * @throws {RangeError} If `capacity < 0`
 * @expose
 */


ByteBufferPrototype.resize = function (capacity) {
  if (!this.noAssert) {
    if (typeof capacity !== 'number' || capacity % 1 !== 0) throw TypeError("Illegal capacity: " + capacity + " (not an integer)");
    capacity |= 0;
    if (capacity < 0) throw RangeError("Illegal capacity: 0 <= " + capacity);
  }

  if (this.buffer.byteLength < capacity) {
    var buffer = new ArrayBuffer(capacity);
    var view = new Uint8Array(buffer);
    view.set(this.view);
    this.buffer = buffer;
    this.view = view;
  }

  return this;
};
/**
 * Reverses this ByteBuffer's contents.
 * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}
 * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.reverse = function (begin, end) {
  if (typeof begin === 'undefined') begin = this.offset;
  if (typeof end === 'undefined') end = this.limit;

  if (!this.noAssert) {
    if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
    begin >>>= 0;
    if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
    end >>>= 0;
    if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
  }

  if (begin === end) return this; // Nothing to reverse

  Array.prototype.reverse.call(this.view.subarray(begin, end));
  return this;
};
/**
 * Skips the next `length` bytes. This will just advance
 * @param {number} length Number of bytes to skip. May also be negative to move the offset back.
 * @returns {!ByteBuffer} this
 * @expose
 */


ByteBufferPrototype.skip = function (length) {
  if (!this.noAssert) {
    if (typeof length !== 'number' || length % 1 !== 0) throw TypeError("Illegal length: " + length + " (not an integer)");
    length |= 0;
  }

  var offset = this.offset + length;

  if (!this.noAssert) {
    if (offset < 0 || offset > this.buffer.byteLength) throw RangeError("Illegal length: 0 <= " + this.offset + " + " + length + " <= " + this.buffer.byteLength);
  }

  this.offset = offset;
  return this;
};
/**
 * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.
 * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.
 * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.
 * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
 * @expose
 */


ByteBufferPrototype.slice = function (begin, end) {
  if (typeof begin === 'undefined') begin = this.offset;
  if (typeof end === 'undefined') end = this.limit;

  if (!this.noAssert) {
    if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
    begin >>>= 0;
    if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
    end >>>= 0;
    if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
  }

  var bb = this.clone();
  bb.offset = begin;
  bb.limit = end;
  return bb;
};
/**
 * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between
 *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.
 * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if
 *  possible. Defaults to `false`
 * @returns {!ArrayBuffer} Contents as an ArrayBuffer
 * @expose
 */


ByteBufferPrototype.toBuffer = function (forceCopy) {
  var offset = this.offset,
      limit = this.limit;

  if (!this.noAssert) {
    if (typeof offset !== 'number' || offset % 1 !== 0) throw TypeError("Illegal offset: Not an integer");
    offset >>>= 0;
    if (typeof limit !== 'number' || limit % 1 !== 0) throw TypeError("Illegal limit: Not an integer");
    limit >>>= 0;
    if (offset < 0 || offset > limit || limit > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + offset + " <= " + limit + " <= " + this.buffer.byteLength);
  } // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
  // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:


  if (!forceCopy && offset === 0 && limit === this.buffer.byteLength) return this.buffer;
  if (offset === limit) return EMPTY_BUFFER;
  var buffer = new ArrayBuffer(limit - offset);
  new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);
  return buffer;
};
/**
 * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between
 *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.
 * @function
 * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.
 *  Defaults to `false`
 * @returns {!ArrayBuffer} Contents as an ArrayBuffer
 * @expose
 */


ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;
/**
 * Converts the ByteBuffer's contents to a string.
 * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
 *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with
 *  highlighted offsets.
 * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}
 * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}
 * @returns {string} String representation
 * @throws {Error} If `encoding` is invalid
 * @expose
 */

ByteBufferPrototype.toString = function (encoding, begin, end) {
  if (typeof encoding === 'undefined') return "ByteBufferAB(offset=" + this.offset + ",markedOffset=" + this.markedOffset + ",limit=" + this.limit + ",capacity=" + this.capacity() + ")";
  if (typeof encoding === 'number') encoding = "utf8", begin = encoding, end = begin;

  switch (encoding) {
    case "utf8":
      return this.toUTF8(begin, end);

    case "base64":
      return this.toBase64(begin, end);

    case "hex":
      return this.toHex(begin, end);

    case "binary":
      return this.toBinary(begin, end);

    case "debug":
      return this.toDebug();

    case "columns":
      return this.toColumns();

    default:
      throw Error("Unsupported encoding: " + encoding);
  }
}; // lxiv-embeddable

/**
 * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/lxiv for details
 */


var lxiv = function () {
  "use strict";
  /**
   * lxiv namespace.
   * @type {!Object.<string,*>}
   * @exports lxiv
   */

  var lxiv = {};
  /**
   * Character codes for output.
   * @type {!Array.<number>}
   * @inner
   */

  var aout = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47];
  /**
   * Character codes for input.
   * @type {!Array.<number>}
   * @inner
   */

  var ain = [];

  for (var i = 0, k = aout.length; i < k; ++i) {
    ain[aout[i]] = i;
  }
  /**
   * Encodes bytes to base64 char codes.
   * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
   *  there are no more bytes left.
   * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
   *  code.
   */


  lxiv.encode = function (src, dst) {
    var b, t;

    while ((b = src()) !== null) {
      dst(aout[b >> 2 & 0x3f]);
      t = (b & 0x3) << 4;

      if ((b = src()) !== null) {
        t |= b >> 4 & 0xf;
        dst(aout[(t | b >> 4 & 0xf) & 0x3f]);
        t = (b & 0xf) << 2;
        if ((b = src()) !== null) dst(aout[(t | b >> 6 & 0x3) & 0x3f]), dst(aout[b & 0x3f]);else dst(aout[t & 0x3f]), dst(61);
      } else dst(aout[t & 0x3f]), dst(61), dst(61);
    }
  };
  /**
   * Decodes base64 char codes to bytes.
   * @param {!function():number|null} src Characters source as a function returning the next char code respectively
   *  `null` if there are no more characters left.
   * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
   * @throws {Error} If a character code is invalid
   */


  lxiv.decode = function (src, dst) {
    var c, t1, t2;

    function fail(c) {
      throw Error("Illegal character code: " + c);
    }

    while ((c = src()) !== null) {
      t1 = ain[c];
      if (typeof t1 === 'undefined') fail(c);

      if ((c = src()) !== null) {
        t2 = ain[c];
        if (typeof t2 === 'undefined') fail(c);
        dst(t1 << 2 >>> 0 | (t2 & 0x30) >> 4);

        if ((c = src()) !== null) {
          t1 = ain[c];
          if (typeof t1 === 'undefined') if (c === 61) break;else fail(c);
          dst((t2 & 0xf) << 4 >>> 0 | (t1 & 0x3c) >> 2);

          if ((c = src()) !== null) {
            t2 = ain[c];
            if (typeof t2 === 'undefined') if (c === 61) break;else fail(c);
            dst((t1 & 0x3) << 6 >>> 0 | t2);
          }
        }
      }
    }
  };
  /**
   * Tests if a string is valid base64.
   * @param {string} str String to test
   * @returns {boolean} `true` if valid, otherwise `false`
   */


  lxiv.test = function (str) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);
  };

  return lxiv;
}(); // encodings/base64

/**
 * Encodes this ByteBuffer's contents to a base64 encoded string.
 * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.
 * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.
 * @returns {string} Base64 encoded string
 * @throws {RangeError} If `begin` or `end` is out of bounds
 * @expose
 */


ByteBufferPrototype.toBase64 = function (begin, end) {
  if (typeof begin === 'undefined') begin = this.offset;
  if (typeof end === 'undefined') end = this.limit;
  begin = begin | 0;
  end = end | 0;
  if (begin < 0 || end > this.capacity || begin > end) throw RangeError("begin, end");
  var sd;
  lxiv.encode(function () {
    return begin < end ? this.view[begin++] : null;
  }.bind(this), sd = stringDestination());
  return sd();
};
/**
 * Decodes a base64 encoded string to a ByteBuffer.
 * @param {string} str String to decode
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
 *  {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @returns {!ByteBuffer} ByteBuffer
 * @expose
 */


ByteBuffer.fromBase64 = function (str, littleEndian) {
  if (typeof str !== 'string') throw TypeError("str");
  var bb = new ByteBuffer(str.length / 4 * 3, littleEndian),
      i = 0;
  lxiv.decode(stringSource(str), function (b) {
    bb.view[i++] = b;
  });
  bb.limit = i;
  return bb;
};
/**
 * Encodes a binary string to base64 like `window.btoa` does.
 * @param {string} str Binary string
 * @returns {string} Base64 encoded string
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa
 * @expose
 */


ByteBuffer.btoa = function (str) {
  return ByteBuffer.fromBinary(str).toBase64();
};
/**
 * Decodes a base64 encoded string to binary like `window.atob` does.
 * @param {string} b64 Base64 encoded string
 * @returns {string} Binary string
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob
 * @expose
 */


ByteBuffer.atob = function (b64) {
  return ByteBuffer.fromBase64(b64).toBinary();
}; // encodings/binary

/**
 * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.
 * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
 * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
 * @returns {string} Binary encoded string
 * @throws {RangeError} If `offset > limit`
 * @expose
 */


ByteBufferPrototype.toBinary = function (begin, end) {
  if (typeof begin === 'undefined') begin = this.offset;
  if (typeof end === 'undefined') end = this.limit;
  begin |= 0;
  end |= 0;
  if (begin < 0 || end > this.capacity() || begin > end) throw RangeError("begin, end");
  if (begin === end) return "";
  var chars = [],
      parts = [];

  while (begin < end) {
    chars.push(this.view[begin++]);
    if (chars.length >= 1024) parts.push(String.fromCharCode.apply(String, chars)), chars = [];
  }

  return parts.join('') + String.fromCharCode.apply(String, chars);
};
/**
 * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.
 * @param {string} str String to decode
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
 *  {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @returns {!ByteBuffer} ByteBuffer
 * @expose
 */


ByteBuffer.fromBinary = function (str, littleEndian) {
  if (typeof str !== 'string') throw TypeError("str");
  var i = 0,
      k = str.length,
      charCode,
      bb = new ByteBuffer(k, littleEndian);

  while (i < k) {
    charCode = str.charCodeAt(i);
    if (charCode > 0xff) throw RangeError("illegal char code: " + charCode);
    bb.view[i++] = charCode;
  }

  bb.limit = k;
  return bb;
}; // encodings/debug

/**
 * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:
 * * `<` : offset,
 * * `'` : markedOffset,
 * * `>` : limit,
 * * `|` : offset and limit,
 * * `[` : offset and markedOffset,
 * * `]` : markedOffset and limit,
 * * `!` : offset, markedOffset and limit
 * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`
 * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`
 * @expose
 * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`
 * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`
 * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`
 * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`
 */


ByteBufferPrototype.toDebug = function (columns) {
  var i = -1,
      k = this.buffer.byteLength,
      b,
      hex = "",
      asc = "",
      out = "";

  while (i < k) {
    if (i !== -1) {
      b = this.view[i];
      if (b < 0x10) hex += "0" + b.toString(16).toUpperCase();else hex += b.toString(16).toUpperCase();
      if (columns) asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';
    }

    ++i;

    if (columns) {
      if (i > 0 && i % 16 === 0 && i !== k) {
        while (hex.length < 3 * 16 + 3) {
          hex += " ";
        }

        out += hex + asc + "\n";
        hex = asc = "";
      }
    }

    if (i === this.offset && i === this.limit) hex += i === this.markedOffset ? "!" : "|";else if (i === this.offset) hex += i === this.markedOffset ? "[" : "<";else if (i === this.limit) hex += i === this.markedOffset ? "]" : ">";else hex += i === this.markedOffset ? "'" : columns || i !== 0 && i !== k ? " " : "";
  }

  if (columns && hex !== " ") {
    while (hex.length < 3 * 16 + 3) {
      hex += " ";
    }

    out += hex + asc + "\n";
  }

  return columns ? out : hex;
};
/**
 * Decodes a hex encoded string with marked offsets to a ByteBuffer.
 * @param {string} str Debug string to decode (not be generated with `columns = true`)
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
 *  {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
 *  {@link ByteBuffer.DEFAULT_NOASSERT}.
 * @returns {!ByteBuffer} ByteBuffer
 * @expose
 * @see ByteBuffer#toDebug
 */


ByteBuffer.fromDebug = function (str, littleEndian, noAssert) {
  var k = str.length,
      bb = new ByteBuffer((k + 1) / 3 | 0, littleEndian, noAssert);
  var i = 0,
      j = 0,
      ch,
      b,
      rs = false,
      // Require symbol next
  ho = false,
      hm = false,
      hl = false,
      // Already has offset (ho), markedOffset (hm), limit (hl)?
  fail = false;

  while (i < k) {
    switch (ch = str.charAt(i++)) {
      case '!':
        if (!noAssert) {
          if (ho || hm || hl) {
            fail = true;
            break;
          }

          ho = hm = hl = true;
        }

        bb.offset = bb.markedOffset = bb.limit = j;
        rs = false;
        break;

      case '|':
        if (!noAssert) {
          if (ho || hl) {
            fail = true;
            break;
          }

          ho = hl = true;
        }

        bb.offset = bb.limit = j;
        rs = false;
        break;

      case '[':
        if (!noAssert) {
          if (ho || hm) {
            fail = true;
            break;
          }

          ho = hm = true;
        }

        bb.offset = bb.markedOffset = j;
        rs = false;
        break;

      case '<':
        if (!noAssert) {
          if (ho) {
            fail = true;
            break;
          }

          ho = true;
        }

        bb.offset = j;
        rs = false;
        break;

      case ']':
        if (!noAssert) {
          if (hl || hm) {
            fail = true;
            break;
          }

          hl = hm = true;
        }

        bb.limit = bb.markedOffset = j;
        rs = false;
        break;

      case '>':
        if (!noAssert) {
          if (hl) {
            fail = true;
            break;
          }

          hl = true;
        }

        bb.limit = j;
        rs = false;
        break;

      case "'":
        if (!noAssert) {
          if (hm) {
            fail = true;
            break;
          }

          hm = true;
        }

        bb.markedOffset = j;
        rs = false;
        break;

      case ' ':
        rs = false;
        break;

      default:
        if (!noAssert) {
          if (rs) {
            fail = true;
            break;
          }
        }

        b = (0, _parseInt2.default)(ch + str.charAt(i++), 16);

        if (!noAssert) {
          if (isNaN(b) || b < 0 || b > 255) throw TypeError("Illegal str: Not a debug encoded string");
        }

        bb.view[j++] = b;
        rs = true;
    }

    if (fail) throw TypeError("Illegal str: Invalid symbol at " + i);
  }

  if (!noAssert) {
    if (!ho || !hl) throw TypeError("Illegal str: Missing offset or limit");
    if (j < bb.buffer.byteLength) throw TypeError("Illegal str: Not a debug encoded string (is it hex?) " + j + " < " + k);
  }

  return bb;
}; // encodings/hex

/**
 * Encodes this ByteBuffer's contents to a hex encoded string.
 * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.
 * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.
 * @returns {string} Hex encoded string
 * @expose
 */


ByteBufferPrototype.toHex = function (begin, end) {
  begin = typeof begin === 'undefined' ? this.offset : begin;
  end = typeof end === 'undefined' ? this.limit : end;

  if (!this.noAssert) {
    if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
    begin >>>= 0;
    if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
    end >>>= 0;
    if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
  }

  var out = new Array(end - begin),
      b;

  while (begin < end) {
    b = this.view[begin++];
    if (b < 0x10) out.push("0", b.toString(16));else out.push(b.toString(16));
  }

  return out.join('');
};
/**
 * Decodes a hex encoded string to a ByteBuffer.
 * @param {string} str String to decode
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
 *  {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
 *  {@link ByteBuffer.DEFAULT_NOASSERT}.
 * @returns {!ByteBuffer} ByteBuffer
 * @expose
 */


ByteBuffer.fromHex = function (str, littleEndian, noAssert) {
  if (!noAssert) {
    if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
    if (str.length % 2 !== 0) throw TypeError("Illegal str: Length not a multiple of 2");
  }

  var k = str.length,
      bb = new ByteBuffer(k / 2 | 0, littleEndian),
      b;

  for (var i = 0, j = 0; i < k; i += 2) {
    b = (0, _parseInt2.default)(str.substring(i, i + 2), 16);
    if (!noAssert) if (!isFinite(b) || b < 0 || b > 255) throw TypeError("Illegal str: Contains non-hex characters");
    bb.view[j++] = b;
  }

  bb.limit = j;
  return bb;
}; // utfx-embeddable

/**
 * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/utfx for details
 */


var utfx = function () {
  "use strict";
  /**
   * utfx namespace.
   * @inner
   * @type {!Object.<string,*>}
   */

  var utfx = {};
  /**
   * Maximum valid code point.
   * @type {number}
   * @const
   */

  utfx.MAX_CODEPOINT = 0x10FFFF;
  /**
   * Encodes UTF8 code points to UTF8 bytes.
   * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
   *  respectively `null` if there are no more code points left or a single numeric code point.
   * @param {!function(number)} dst Bytes destination as a function successively called with the next byte
   */

  utfx.encodeUTF8 = function (src, dst) {
    var cp = null;
    if (typeof src === 'number') cp = src, src = function src() {
      return null;
    };

    while (cp !== null || (cp = src()) !== null) {
      if (cp < 0x80) dst(cp & 0x7F);else if (cp < 0x800) dst(cp >> 6 & 0x1F | 0xC0), dst(cp & 0x3F | 0x80);else if (cp < 0x10000) dst(cp >> 12 & 0x0F | 0xE0), dst(cp >> 6 & 0x3F | 0x80), dst(cp & 0x3F | 0x80);else dst(cp >> 18 & 0x07 | 0xF0), dst(cp >> 12 & 0x3F | 0x80), dst(cp >> 6 & 0x3F | 0x80), dst(cp & 0x3F | 0x80);
      cp = null;
    }
  };
  /**
   * Decodes UTF8 bytes to UTF8 code points.
   * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
   *  are no more bytes left.
   * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
   * @throws {RangeError} If a starting byte is invalid in UTF8
   * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the
   *  remaining bytes.
   */


  utfx.decodeUTF8 = function (src, dst) {
    var a,
        b,
        c,
        d,
        fail = function fail(b) {
      b = b.slice(0, b.indexOf(null));
      var err = Error(b.toString());
      err.name = "TruncatedError";
      err['bytes'] = b;
      throw err;
    };

    while ((a = src()) !== null) {
      if ((a & 0x80) === 0) dst(a);else if ((a & 0xE0) === 0xC0) (b = src()) === null && fail([a, b]), dst((a & 0x1F) << 6 | b & 0x3F);else if ((a & 0xF0) === 0xE0) ((b = src()) === null || (c = src()) === null) && fail([a, b, c]), dst((a & 0x0F) << 12 | (b & 0x3F) << 6 | c & 0x3F);else if ((a & 0xF8) === 0xF0) ((b = src()) === null || (c = src()) === null || (d = src()) === null) && fail([a, b, c, d]), dst((a & 0x07) << 18 | (b & 0x3F) << 12 | (c & 0x3F) << 6 | d & 0x3F);else throw RangeError("Illegal starting byte: " + a);
    }
  };
  /**
   * Converts UTF16 characters to UTF8 code points.
   * @param {!function():number|null} src Characters source as a function returning the next char code respectively
   *  `null` if there are no more characters left.
   * @param {!function(number)} dst Code points destination as a function successively called with each converted code
   *  point.
   */


  utfx.UTF16toUTF8 = function (src, dst) {
    var c1,
        c2 = null;

    while (true) {
      if ((c1 = c2 !== null ? c2 : src()) === null) break;

      if (c1 >= 0xD800 && c1 <= 0xDFFF) {
        if ((c2 = src()) !== null) {
          if (c2 >= 0xDC00 && c2 <= 0xDFFF) {
            dst((c1 - 0xD800) * 0x400 + c2 - 0xDC00 + 0x10000);
            c2 = null;
            continue;
          }
        }
      }

      dst(c1);
    }

    if (c2 !== null) dst(c2);
  };
  /**
   * Converts UTF8 code points to UTF16 characters.
   * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
   *  respectively `null` if there are no more code points left or a single numeric code point.
   * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
   * @throws {RangeError} If a code point is out of range
   */


  utfx.UTF8toUTF16 = function (src, dst) {
    var cp = null;
    if (typeof src === 'number') cp = src, src = function src() {
      return null;
    };

    while (cp !== null || (cp = src()) !== null) {
      if (cp <= 0xFFFF) dst(cp);else cp -= 0x10000, dst((cp >> 10) + 0xD800), dst(cp % 0x400 + 0xDC00);
      cp = null;
    }
  };
  /**
   * Converts and encodes UTF16 characters to UTF8 bytes.
   * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
   *  if there are no more characters left.
   * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.
   */


  utfx.encodeUTF16toUTF8 = function (src, dst) {
    utfx.UTF16toUTF8(src, function (cp) {
      utfx.encodeUTF8(cp, dst);
    });
  };
  /**
   * Decodes and converts UTF8 bytes to UTF16 characters.
   * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
   *  are no more bytes left.
   * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
   * @throws {RangeError} If a starting byte is invalid in UTF8
   * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
   */


  utfx.decodeUTF8toUTF16 = function (src, dst) {
    utfx.decodeUTF8(src, function (cp) {
      utfx.UTF8toUTF16(cp, dst);
    });
  };
  /**
   * Calculates the byte length of an UTF8 code point.
   * @param {number} cp UTF8 code point
   * @returns {number} Byte length
   */


  utfx.calculateCodePoint = function (cp) {
    return cp < 0x80 ? 1 : cp < 0x800 ? 2 : cp < 0x10000 ? 3 : 4;
  };
  /**
   * Calculates the number of UTF8 bytes required to store UTF8 code points.
   * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
   *  `null` if there are no more code points left.
   * @returns {number} The number of UTF8 bytes required
   */


  utfx.calculateUTF8 = function (src) {
    var cp,
        l = 0;

    while ((cp = src()) !== null) {
      l += cp < 0x80 ? 1 : cp < 0x800 ? 2 : cp < 0x10000 ? 3 : 4;
    }

    return l;
  };
  /**
   * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.
   * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
   *  `null` if there are no more characters left.
   * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
   */


  utfx.calculateUTF16asUTF8 = function (src) {
    var n = 0,
        l = 0;
    utfx.UTF16toUTF8(src, function (cp) {
      ++n;
      l += cp < 0x80 ? 1 : cp < 0x800 ? 2 : cp < 0x10000 ? 3 : 4;
    });
    return [n, l];
  };

  return utfx;
}(); // encodings/utf8

/**
 * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
 *  string.
 * @returns {string} Hex encoded string
 * @throws {RangeError} If `offset > limit`
 * @expose
 */


ByteBufferPrototype.toUTF8 = function (begin, end) {
  if (typeof begin === 'undefined') begin = this.offset;
  if (typeof end === 'undefined') end = this.limit;

  if (!this.noAssert) {
    if (typeof begin !== 'number' || begin % 1 !== 0) throw TypeError("Illegal begin: Not an integer");
    begin >>>= 0;
    if (typeof end !== 'number' || end % 1 !== 0) throw TypeError("Illegal end: Not an integer");
    end >>>= 0;
    if (begin < 0 || begin > end || end > this.buffer.byteLength) throw RangeError("Illegal range: 0 <= " + begin + " <= " + end + " <= " + this.buffer.byteLength);
  }

  var sd;

  try {
    utfx.decodeUTF8toUTF16(function () {
      return begin < end ? this.view[begin++] : null;
    }.bind(this), sd = stringDestination());
  } catch (e) {
    if (begin !== end) throw RangeError("Illegal range: Truncated data, " + begin + " != " + end);
  }

  return sd();
};
/**
 * Decodes an UTF8 encoded string to a ByteBuffer.
 * @param {string} str String to decode
 * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to
 *  {@link ByteBuffer.DEFAULT_ENDIAN}.
 * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to
 *  {@link ByteBuffer.DEFAULT_NOASSERT}.
 * @returns {!ByteBuffer} ByteBuffer
 * @expose
 */


ByteBuffer.fromUTF8 = function (str, littleEndian, noAssert) {
  if (!noAssert) if (typeof str !== 'string') throw TypeError("Illegal str: Not a string");
  var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),
      i = 0;
  utfx.encodeUTF16toUTF8(stringSource(str), function (b) {
    bb.view[i++] = b;
  });
  bb.limit = i;
  return bb;
}; //    return ByteBuffer;
//});

/*
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

/**
 * @license protobuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
 * Released under the Apache License, Version 2.0
 * see: https://github.com/dcodeIO/protobuf.js for details
 */
//(function(global, factory) {
//
//    /* AMD */ if (typeof define === 'function' && define["amd"])
//        define(["bytebuffer"], factory);
//    /* CommonJS */ else if (typeof require === "function" && typeof module === "object" && module && module["exports"])
//        module["exports"] = factory(require("bytebuffer"), true);
//    /* Global */ else
//        (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = factory(global["dcodeIO"]["ByteBuffer"]);
//
//})(this, function(ByteBuffer, isCommonJS) {
//    "use strict";

/**
 * The ProtoBuf namespace.
 * @exports ProtoBuf
 * @namespace
 * @expose
 */


var ProtoBuf = {};
/**
 * @type {!function(new: ByteBuffer, ...[*])}
 * @expose
 */

exports.ProtoBuf = ProtoBuf;
ProtoBuf.ByteBuffer = ByteBuffer;
/**
 * @type {?function(new: Long, ...[*])}
 * @expose
 */

ProtoBuf.Long = ByteBuffer.Long || null;
/**
 * ProtoBuf.js version.
 * @type {string}
 * @const
 * @expose
 */

ProtoBuf.VERSION = "5.0.1";
/**
 * Wire types.
 * @type {Object.<string,number>}
 * @const
 * @expose
 */

ProtoBuf.WIRE_TYPES = {};
/**
 * Varint wire type.
 * @type {number}
 * @expose
 */

ProtoBuf.WIRE_TYPES.VARINT = 0;
/**
 * Fixed 64 bits wire type.
 * @type {number}
 * @const
 * @expose
 */

ProtoBuf.WIRE_TYPES.BITS64 = 1;
/**
 * Length delimited wire type.
 * @type {number}
 * @const
 * @expose
 */

ProtoBuf.WIRE_TYPES.LDELIM = 2;
/**
 * Start group wire type.
 * @type {number}
 * @const
 * @expose
 */

ProtoBuf.WIRE_TYPES.STARTGROUP = 3;
/**
 * End group wire type.
 * @type {number}
 * @const
 * @expose
 */

ProtoBuf.WIRE_TYPES.ENDGROUP = 4;
/**
 * Fixed 32 bits wire type.
 * @type {number}
 * @const
 * @expose
 */

ProtoBuf.WIRE_TYPES.BITS32 = 5;
/**
 * Packable wire types.
 * @type {!Array.<number>}
 * @const
 * @expose
 */

ProtoBuf.PACKABLE_WIRE_TYPES = [ProtoBuf.WIRE_TYPES.VARINT, ProtoBuf.WIRE_TYPES.BITS64, ProtoBuf.WIRE_TYPES.BITS32];
/**
 * Types.
 * @dict
 * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}
 * @const
 * @expose
 */

ProtoBuf.TYPES = {
  // According to the protobuf spec.
  "int32": {
    name: "int32",
    wireType: ProtoBuf.WIRE_TYPES.VARINT,
    defaultValue: 0
  },
  "uint32": {
    name: "uint32",
    wireType: ProtoBuf.WIRE_TYPES.VARINT,
    defaultValue: 0
  },
  "sint32": {
    name: "sint32",
    wireType: ProtoBuf.WIRE_TYPES.VARINT,
    defaultValue: 0
  },
  "int64": {
    name: "int64",
    wireType: ProtoBuf.WIRE_TYPES.VARINT,
    defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
  },
  "uint64": {
    name: "uint64",
    wireType: ProtoBuf.WIRE_TYPES.VARINT,
    defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
  },
  "sint64": {
    name: "sint64",
    wireType: ProtoBuf.WIRE_TYPES.VARINT,
    defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
  },
  "bool": {
    name: "bool",
    wireType: ProtoBuf.WIRE_TYPES.VARINT,
    defaultValue: false
  },
  "double": {
    name: "double",
    wireType: ProtoBuf.WIRE_TYPES.BITS64,
    defaultValue: 0
  },
  "string": {
    name: "string",
    wireType: ProtoBuf.WIRE_TYPES.LDELIM,
    defaultValue: ""
  },
  "bytes": {
    name: "bytes",
    wireType: ProtoBuf.WIRE_TYPES.LDELIM,
    defaultValue: null // overridden in the code, must be a unique instance

  },
  "fixed32": {
    name: "fixed32",
    wireType: ProtoBuf.WIRE_TYPES.BITS32,
    defaultValue: 0
  },
  "sfixed32": {
    name: "sfixed32",
    wireType: ProtoBuf.WIRE_TYPES.BITS32,
    defaultValue: 0
  },
  "fixed64": {
    name: "fixed64",
    wireType: ProtoBuf.WIRE_TYPES.BITS64,
    defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined
  },
  "sfixed64": {
    name: "sfixed64",
    wireType: ProtoBuf.WIRE_TYPES.BITS64,
    defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined
  },
  "float": {
    name: "float",
    wireType: ProtoBuf.WIRE_TYPES.BITS32,
    defaultValue: 0
  },
  "enum": {
    name: "enum",
    wireType: ProtoBuf.WIRE_TYPES.VARINT,
    defaultValue: 0
  },
  "message": {
    name: "message",
    wireType: ProtoBuf.WIRE_TYPES.LDELIM,
    defaultValue: null
  },
  "group": {
    name: "group",
    wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,
    defaultValue: null
  }
};
/**
 * Valid map key types.
 * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}
 * @const
 * @expose
 */

ProtoBuf.MAP_KEY_TYPES = [ProtoBuf.TYPES["int32"], ProtoBuf.TYPES["sint32"], ProtoBuf.TYPES["sfixed32"], ProtoBuf.TYPES["uint32"], ProtoBuf.TYPES["fixed32"], ProtoBuf.TYPES["int64"], ProtoBuf.TYPES["sint64"], ProtoBuf.TYPES["sfixed64"], ProtoBuf.TYPES["uint64"], ProtoBuf.TYPES["fixed64"], ProtoBuf.TYPES["bool"], ProtoBuf.TYPES["string"], ProtoBuf.TYPES["bytes"]];
/**
 * Minimum field id.
 * @type {number}
 * @const
 * @expose
 */

ProtoBuf.ID_MIN = 1;
/**
 * Maximum field id.
 * @type {number}
 * @const
 * @expose
 */

ProtoBuf.ID_MAX = 0x1FFFFFFF;
/**
 * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.
 *  Must be set prior to parsing.
 * @type {boolean}
 * @expose
 */

ProtoBuf.convertFieldsToCamelCase = false;
/**
 * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by
 *  setting this to `false` prior to building messages.
 * @type {boolean}
 * @expose
 */

ProtoBuf.populateAccessors = true;
/**
 * By default, messages are populated with default values if a field is not present on the wire. To disable
 *  this behavior, set this setting to `false`.
 * @type {boolean}
 * @expose
 */

ProtoBuf.populateDefaults = true;
/**
 * @alias ProtoBuf.Util
 * @expose
 */

ProtoBuf.Util = function () {
  "use strict";
  /**
   * ProtoBuf utilities.
   * @exports ProtoBuf.Util
   * @namespace
   */

  var Util = {};
  /**
   * Flag if running in node or not.
   * @type {boolean}
   * @const
   * @expose
   */

  Util.IS_NODE = !!((typeof process === "undefined" ? "undefined" : (0, _typeof2.default)(process)) === 'object' && process + '' === '[object process]' && !process['browser']);
  /**
   * Constructs a XMLHttpRequest object.
   * @return {XMLHttpRequest}
   * @throws {Error} If XMLHttpRequest is not supported
   * @expose
   */

  Util.XHR = function () {
    // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html
    var XMLHttpFactories = [function () {
      return new XMLHttpRequest();
    }, function () {
      return new ActiveXObject("Msxml2.XMLHTTP");
    }, function () {
      return new ActiveXObject("Msxml3.XMLHTTP");
    }, function () {
      return new ActiveXObject("Microsoft.XMLHTTP");
    }];
    /** @type {?XMLHttpRequest} */

    var xhr = null;

    for (var i = 0; i < XMLHttpFactories.length; i++) {
      try {
        xhr = XMLHttpFactories[i]();
      } catch (e) {
        continue;
      }

      break;
    }

    if (!xhr) throw Error("XMLHttpRequest is not supported");
    return xhr;
  };
  /**
   * Fetches a resource.
   * @param {string} path Resource path
   * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
   *   be fetched synchronously. If the request failed, contents will be null.
   * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
   * @expose
   */


  Util.fetch = function (path, callback) {
    if (callback && typeof callback != 'function') callback = null;

    if (Util.IS_NODE) {
      var fs = __webpack_require__(378);

      if (callback) {
        fs.readFile(path, function (err, data) {
          if (err) callback(null);else callback("" + data);
        });
      } else try {
        return fs.readFileSync(path);
      } catch (e) {
        return null;
      }
    } else {
      var xhr = Util.XHR();
      xhr.open('GET', path, callback ? true : false); // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');

      xhr.setRequestHeader('Accept', 'text/plain');
      if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');

      if (callback) {
        xhr.onreadystatechange = function () {
          if (xhr.readyState != 4) return;
          if (
          /* remote */
          xhr.status == 200 ||
          /* local */
          xhr.status == 0 && typeof xhr.responseText === 'string') callback(xhr.responseText);else callback(null);
        };

        if (xhr.readyState == 4) return;
        xhr.send(null);
      } else {
        xhr.send(null);
        if (
        /* remote */
        xhr.status == 200 ||
        /* local */
        xhr.status == 0 && typeof xhr.responseText === 'string') return xhr.responseText;
        return null;
      }
    }
  };
  /**
   * Converts a string to camel case.
   * @param {string} str
   * @returns {string}
   * @expose
   */


  Util.toCamelCase = function (str) {
    return str.replace(/_([a-zA-Z])/g, function ($0, $1) {
      return $1.toUpperCase();
    });
  };

  return Util;
}();
/**
 * Language expressions.
 * @type {!Object.<string,!RegExp>}
 * @expose
 */


ProtoBuf.Lang = {
  // Characters always ending a statement
  DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,
  // Field rules
  RULE: /^(?:required|optional|repeated|map)$/,
  // Field types
  TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
  // Names
  NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,
  // Type definitions
  TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,
  // Type references
  TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,
  // Fully qualified type references
  FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,
  // All numbers
  NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,
  // Decimal numbers
  NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,
  // Hexadecimal numbers
  NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,
  // Octal numbers
  NUMBER_OCT: /^0[0-7]+$/,
  // Floating point numbers
  NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,
  // Booleans
  BOOL: /^(?:true|false)$/i,
  // Id numbers
  ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
  // Negative id numbers (enum values)
  NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,
  // Whitespaces
  WHITESPACE: /\s/,
  // All strings
  STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,
  // Double quoted strings
  STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,
  // Single quoted strings
  STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g
};
/**
 * @alias ProtoBuf.DotProto
 * @expose
 */

ProtoBuf.DotProto = function (ProtoBuf, Lang) {
  "use strict";
  /**
   * Utilities to parse .proto files.
   * @exports ProtoBuf.DotProto
   * @namespace
   */

  var DotProto = {};
  /**
   * Constructs a new Tokenizer.
   * @exports ProtoBuf.DotProto.Tokenizer
   * @class prototype tokenizer
   * @param {string} proto Proto to tokenize
   * @constructor
   */

  var Tokenizer = function Tokenizer(proto) {
    /**
     * Source to parse.
     * @type {string}
     * @expose
     */
    this.source = proto + "";
    /**
     * Current index.
     * @type {number}
     * @expose
     */

    this.index = 0;
    /**
     * Current line.
     * @type {number}
     * @expose
     */

    this.line = 1;
    /**
     * Token stack.
     * @type {!Array.<string>}
     * @expose
     */

    this.stack = [];
    /**
     * Opening character of the current string read, if any.
     * @type {?string}
     * @private
     */

    this._stringOpen = null;
  };
  /**
   * @alias ProtoBuf.DotProto.Tokenizer.prototype
   * @inner
   */


  var TokenizerPrototype = Tokenizer.prototype;
  /**
   * Reads a string beginning at the current index.
   * @return {string}
   * @private
   */

  TokenizerPrototype._readString = function () {
    var re = this._stringOpen === '"' ? Lang.STRING_DQ : Lang.STRING_SQ;
    re.lastIndex = this.index - 1; // Include the open quote

    var match = re.exec(this.source);
    if (!match) throw Error("unterminated string");
    this.index = re.lastIndex;
    this.stack.push(this._stringOpen);
    this._stringOpen = null;
    return match[1];
  };
  /**
   * Gets the next token and advances by one.
   * @return {?string} Token or `null` on EOF
   * @expose
   */


  TokenizerPrototype.next = function () {
    if (this.stack.length > 0) return this.stack.shift();
    if (this.index >= this.source.length) return null;
    if (this._stringOpen !== null) return this._readString();
    var repeat, prev, next;

    do {
      repeat = false; // Strip white spaces

      while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) {
        if (next === '\n') ++this.line;
        if (++this.index === this.source.length) return null;
      } // Strip comments


      if (this.source.charAt(this.index) === '/') {
        ++this.index;

        if (this.source.charAt(this.index) === '/') {
          // Line
          while (this.source.charAt(++this.index) !== '\n') {
            if (this.index == this.source.length) return null;
          }

          ++this.index;
          ++this.line;
          repeat = true;
        } else if ((next = this.source.charAt(this.index)) === '*') {
          /* Block */
          do {
            if (next === '\n') ++this.line;
            if (++this.index === this.source.length) return null;
            prev = next;
            next = this.source.charAt(this.index);
          } while (prev !== '*' || next !== '/');

          ++this.index;
          repeat = true;
        } else return '/';
      }
    } while (repeat);

    if (this.index === this.source.length) return null; // Read the next token

    var end = this.index;
    Lang.DELIM.lastIndex = 0;
    var delim = Lang.DELIM.test(this.source.charAt(end++));
    if (!delim) while (end < this.source.length && !Lang.DELIM.test(this.source.charAt(end))) {
      ++end;
    }
    var token = this.source.substring(this.index, this.index = end);
    if (token === '"' || token === "'") this._stringOpen = token;
    return token;
  };
  /**
   * Peeks for the next token.
   * @return {?string} Token or `null` on EOF
   * @expose
   */


  TokenizerPrototype.peek = function () {
    if (this.stack.length === 0) {
      var token = this.next();
      if (token === null) return null;
      this.stack.push(token);
    }

    return this.stack[0];
  };
  /**
   * Skips a specific token and throws if it differs.
   * @param {string} expected Expected token
   * @throws {Error} If the actual token differs
   */


  TokenizerPrototype.skip = function (expected) {
    var actual = this.next();
    if (actual !== expected) throw Error("illegal '" + actual + "', '" + expected + "' expected");
  };
  /**
   * Omits an optional token.
   * @param {string} expected Expected optional token
   * @returns {boolean} `true` if the token exists
   */


  TokenizerPrototype.omit = function (expected) {
    if (this.peek() === expected) {
      this.next();
      return true;
    }

    return false;
  };
  /**
   * Returns a string representation of this object.
   * @return {string} String representation as of "Tokenizer(index/length)"
   * @expose
   */


  TokenizerPrototype.toString = function () {
    return "Tokenizer (" + this.index + "/" + this.source.length + " at line " + this.line + ")";
  };
  /**
   * @alias ProtoBuf.DotProto.Tokenizer
   * @expose
   */


  DotProto.Tokenizer = Tokenizer;
  /**
   * Constructs a new Parser.
   * @exports ProtoBuf.DotProto.Parser
   * @class prototype parser
   * @param {string} source Source
   * @constructor
   */

  var Parser = function Parser(source) {
    /**
     * Tokenizer.
     * @type {!ProtoBuf.DotProto.Tokenizer}
     * @expose
     */
    this.tn = new Tokenizer(source);
    /**
     * Whether parsing proto3 or not.
     * @type {boolean}
     */

    this.proto3 = false;
  };
  /**
   * @alias ProtoBuf.DotProto.Parser.prototype
   * @inner
   */


  var ParserPrototype = Parser.prototype;
  /**
   * Parses the source.
   * @returns {!Object}
   * @throws {Error} If the source cannot be parsed
   * @expose
   */

  ParserPrototype.parse = function () {
    var topLevel = {
      "name": "[ROOT]",
      // temporary
      "package": null,
      "messages": [],
      "enums": [],
      "imports": [],
      "options": {},
      "services": [] // "syntax": undefined

    };
    var token,
        head = true,
        weak;

    try {
      while (token = this.tn.next()) {
        switch (token) {
          case 'package':
            if (!head || topLevel["package"] !== null) throw Error("unexpected 'package'");
            token = this.tn.next();
            if (!Lang.TYPEREF.test(token)) throw Error("illegal package name: " + token);
            this.tn.skip(";");
            topLevel["package"] = token;
            break;

          case 'import':
            if (!head) throw Error("unexpected 'import'");
            token = this.tn.peek();
            if (token === "public" || (weak = token === "weak")) // token ignored
              this.tn.next();
            token = this._readString();
            this.tn.skip(";");
            if (!weak) // import ignored
              topLevel["imports"].push(token);
            break;

          case 'syntax':
            if (!head) throw Error("unexpected 'syntax'");
            this.tn.skip("=");
            if ((topLevel["syntax"] = this._readString()) === "proto3") this.proto3 = true;
            this.tn.skip(";");
            break;

          case 'message':
            this._parseMessage(topLevel, null);

            head = false;
            break;

          case 'enum':
            this._parseEnum(topLevel);

            head = false;
            break;

          case 'option':
            this._parseOption(topLevel);

            break;

          case 'service':
            this._parseService(topLevel);

            break;

          case 'extend':
            this._parseExtend(topLevel);

            break;

          default:
            throw Error("unexpected '" + token + "'");
        }
      }
    } catch (e) {
      e.message = "Parse error at line " + this.tn.line + ": " + e.message;
      throw e;
    }

    delete topLevel["name"];
    return topLevel;
  };
  /**
   * Parses the specified source.
   * @returns {!Object}
   * @throws {Error} If the source cannot be parsed
   * @expose
   */


  Parser.parse = function (source) {
    return new Parser(source).parse();
  }; // ----- Conversion ------

  /**
   * Converts a numerical string to an id.
   * @param {string} value
   * @param {boolean=} mayBeNegative
   * @returns {number}
   * @inner
   */


  function mkId(value, mayBeNegative) {
    var id = -1,
        sign = 1;

    if (value.charAt(0) == '-') {
      sign = -1;
      value = value.substring(1);
    }

    if (Lang.NUMBER_DEC.test(value)) id = (0, _parseInt2.default)(value);else if (Lang.NUMBER_HEX.test(value)) id = (0, _parseInt2.default)(value.substring(2), 16);else if (Lang.NUMBER_OCT.test(value)) id = (0, _parseInt2.default)(value.substring(1), 8);else throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
    id = sign * id | 0; // Force to 32bit

    if (!mayBeNegative && id < 0) throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);
    return id;
  }
  /**
   * Converts a numerical string to a number.
   * @param {string} val
   * @returns {number}
   * @inner
   */


  function mkNumber(val) {
    var sign = 1;

    if (val.charAt(0) == '-') {
      sign = -1;
      val = val.substring(1);
    }

    if (Lang.NUMBER_DEC.test(val)) return sign * (0, _parseInt2.default)(val, 10);else if (Lang.NUMBER_HEX.test(val)) return sign * (0, _parseInt2.default)(val.substring(2), 16);else if (Lang.NUMBER_OCT.test(val)) return sign * (0, _parseInt2.default)(val.substring(1), 8);else if (val === 'inf') return sign * Infinity;else if (val === 'nan') return NaN;else if (Lang.NUMBER_FLT.test(val)) return sign * (0, _parseFloat2.default)(val);
    throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);
  } // ----- Reading ------

  /**
   * Reads a string.
   * @returns {string}
   * @private
   */


  ParserPrototype._readString = function () {
    var value = "",
        token,
        delim;

    do {
      delim = this.tn.next();
      if (delim !== "'" && delim !== '"') throw Error("illegal string delimiter: " + delim);
      value += this.tn.next();
      this.tn.skip(delim);
      token = this.tn.peek();
    } while (token === '"' || token === '"'); // multi line?


    return value;
  };
  /**
   * Reads a value.
   * @param {boolean=} mayBeTypeRef
   * @returns {number|boolean|string}
   * @private
   */


  ParserPrototype._readValue = function (mayBeTypeRef) {
    var token = this.tn.peek(),
        value;
    if (token === '"' || token === "'") return this._readString();
    this.tn.next();
    if (Lang.NUMBER.test(token)) return mkNumber(token);
    if (Lang.BOOL.test(token)) return token.toLowerCase() === 'true';
    if (mayBeTypeRef && Lang.TYPEREF.test(token)) return token;
    throw Error("illegal value: " + token);
  }; // ----- Parsing constructs -----

  /**
   * Parses a namespace option.
   * @param {!Object} parent Parent definition
   * @param {boolean=} isList
   * @private
   */


  ParserPrototype._parseOption = function (parent, isList) {
    var token = this.tn.next(),
        custom = false;

    if (token === '(') {
      custom = true;
      token = this.tn.next();
    }

    if (!Lang.TYPEREF.test(token)) // we can allow options of the form google.protobuf.* since they will just get ignored anyways
      // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?
      throw Error("illegal option name: " + token);
    var name = token;

    if (custom) {
      // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar
      this.tn.skip(')');
      name = '(' + name + ')';
      token = this.tn.peek();

      if (Lang.FQTYPEREF.test(token)) {
        name += token;
        this.tn.next();
      }
    }

    this.tn.skip('=');

    this._parseOptionValue(parent, name);

    if (!isList) this.tn.skip(";");
  };
  /**
   * Sets an option on the specified options object.
   * @param {!Object.<string,*>} options
   * @param {string} name
   * @param {string|number|boolean} value
   * @inner
   */


  function setOption(options, name, value) {
    if (typeof options[name] === 'undefined') options[name] = value;else {
      if (!(0, _isArray.default)(options[name])) options[name] = [options[name]];
      options[name].push(value);
    }
  }
  /**
   * Parses an option value.
   * @param {!Object} parent
   * @param {string} name
   * @private
   */


  ParserPrototype._parseOptionValue = function (parent, name) {
    var token = this.tn.peek();

    if (token !== '{') {
      // Plain value
      setOption(parent["options"], name, this._readValue(true));
    } else {
      // Aggregate options
      this.tn.skip("{");

      while ((token = this.tn.next()) !== '}') {
        if (!Lang.NAME.test(token)) throw Error("illegal option name: " + name + "." + token);
        if (this.tn.omit(":")) setOption(parent["options"], name + "." + token, this._readValue(true));else this._parseOptionValue(parent, name + "." + token);
      }
    }
  };
  /**
   * Parses a service definition.
   * @param {!Object} parent Parent definition
   * @private
   */


  ParserPrototype._parseService = function (parent) {
    var token = this.tn.next();
    if (!Lang.NAME.test(token)) throw Error("illegal service name at line " + this.tn.line + ": " + token);
    var name = token;
    var svc = {
      "name": name,
      "rpc": {},
      "options": {}
    };
    this.tn.skip("{");

    while ((token = this.tn.next()) !== '}') {
      if (token === "option") this._parseOption(svc);else if (token === 'rpc') this._parseServiceRPC(svc);else throw Error("illegal service token: " + token);
    }

    this.tn.omit(";");
    parent["services"].push(svc);
  };
  /**
   * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].
   * @param {!Object} svc Service definition
   * @private
   */


  ParserPrototype._parseServiceRPC = function (svc) {
    var type = "rpc",
        token = this.tn.next();
    if (!Lang.NAME.test(token)) throw Error("illegal rpc service method name: " + token);
    var name = token;
    var method = {
      "request": null,
      "response": null,
      "request_stream": false,
      "response_stream": false,
      "options": {}
    };
    this.tn.skip("(");
    token = this.tn.next();

    if (token.toLowerCase() === "stream") {
      method["request_stream"] = true;
      token = this.tn.next();
    }

    if (!Lang.TYPEREF.test(token)) throw Error("illegal rpc service request type: " + token);
    method["request"] = token;
    this.tn.skip(")");
    token = this.tn.next();
    if (token.toLowerCase() !== "returns") throw Error("illegal rpc service request type delimiter: " + token);
    this.tn.skip("(");
    token = this.tn.next();

    if (token.toLowerCase() === "stream") {
      method["response_stream"] = true;
      token = this.tn.next();
    }

    method["response"] = token;
    this.tn.skip(")");
    token = this.tn.peek();

    if (token === '{') {
      this.tn.next();

      while ((token = this.tn.next()) !== '}') {
        if (token === 'option') this._parseOption(method);else throw Error("illegal rpc service token: " + token);
      }

      this.tn.omit(";");
    } else this.tn.skip(";");

    if (typeof svc[type] === 'undefined') svc[type] = {};
    svc[type][name] = method;
  };
  /**
   * Parses a message definition.
   * @param {!Object} parent Parent definition
   * @param {!Object=} fld Field definition if this is a group
   * @returns {!Object}
   * @private
   */


  ParserPrototype._parseMessage = function (parent, fld) {
    var isGroup = !!fld,
        token = this.tn.next();
    var msg = {
      "name": "",
      "fields": [],
      "enums": [],
      "messages": [],
      "options": {},
      "services": [],
      "oneofs": {} // "extensions": undefined

    };
    if (!Lang.NAME.test(token)) throw Error("illegal " + (isGroup ? "group" : "message") + " name: " + token);
    msg["name"] = token;

    if (isGroup) {
      this.tn.skip("=");
      fld["id"] = mkId(this.tn.next());
      msg["isGroup"] = true;
    }

    token = this.tn.peek();
    if (token === '[' && fld) this._parseFieldOptions(fld);
    this.tn.skip("{");

    while ((token = this.tn.next()) !== '}') {
      if (Lang.RULE.test(token)) this._parseMessageField(msg, token);else if (token === "oneof") this._parseMessageOneOf(msg);else if (token === "enum") this._parseEnum(msg);else if (token === "message") this._parseMessage(msg);else if (token === "option") this._parseOption(msg);else if (token === "service") this._parseService(msg);else if (token === "extensions") msg["extensions"] = this._parseExtensionRanges();else if (token === "reserved") this._parseIgnored(); // TODO
      else if (token === "extend") this._parseExtend(msg);else if (Lang.TYPEREF.test(token)) {
          if (!this.proto3) throw Error("illegal field rule: " + token);

          this._parseMessageField(msg, "optional", token);
        } else throw Error("illegal message token: " + token);
    }

    this.tn.omit(";");
    parent["messages"].push(msg);
    return msg;
  };
  /**
   * Parses an ignored statement.
   * @private
   */


  ParserPrototype._parseIgnored = function () {
    while (this.tn.peek() !== ';') {
      this.tn.next();
    }

    this.tn.skip(";");
  };
  /**
   * Parses a message field.
   * @param {!Object} msg Message definition
   * @param {string} rule Field rule
   * @param {string=} type Field type if already known (never known for maps)
   * @returns {!Object} Field descriptor
   * @private
   */


  ParserPrototype._parseMessageField = function (msg, rule, type) {
    if (!Lang.RULE.test(rule)) throw Error("illegal message field rule: " + rule);
    var fld = {
      "rule": rule,
      "type": "",
      "name": "",
      "options": {},
      "id": 0
    };
    var token;

    if (rule === "map") {
      if (type) throw Error("illegal type: " + type);
      this.tn.skip('<');
      token = this.tn.next();
      if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("illegal message field type: " + token);
      fld["keytype"] = token;
      this.tn.skip(',');
      token = this.tn.next();
      if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token)) throw Error("illegal message field: " + token);
      fld["type"] = token;
      this.tn.skip('>');
      token = this.tn.next();
      if (!Lang.NAME.test(token)) throw Error("illegal message field name: " + token);
      fld["name"] = token;
      this.tn.skip("=");
      fld["id"] = mkId(this.tn.next());
      token = this.tn.peek();
      if (token === '[') this._parseFieldOptions(fld);
      this.tn.skip(";");
    } else {
      type = typeof type !== 'undefined' ? type : this.tn.next();

      if (type === "group") {
        // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
        // code, you can treat this message just as if it had a Result type field called result (the latter name is
        // converted to lower-case so that it does not conflict with the former)."
        var grp = this._parseMessage(msg, fld);

        if (!/^[A-Z]/.test(grp["name"])) throw Error('illegal group name: ' + grp["name"]);
        fld["type"] = grp["name"];
        fld["name"] = grp["name"].toLowerCase();
        this.tn.omit(";");
      } else {
        if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type)) throw Error("illegal message field type: " + type);
        fld["type"] = type;
        token = this.tn.next();
        if (!Lang.NAME.test(token)) throw Error("illegal message field name: " + token);
        fld["name"] = token;
        this.tn.skip("=");
        fld["id"] = mkId(this.tn.next());
        token = this.tn.peek();
        if (token === "[") this._parseFieldOptions(fld);
        this.tn.skip(";");
      }
    }

    msg["fields"].push(fld);
    return fld;
  };
  /**
   * Parses a message oneof.
   * @param {!Object} msg Message definition
   * @private
   */


  ParserPrototype._parseMessageOneOf = function (msg) {
    var token = this.tn.next();
    if (!Lang.NAME.test(token)) throw Error("illegal oneof name: " + token);
    var name = token,
        fld;
    var fields = [];
    this.tn.skip("{");

    while ((token = this.tn.next()) !== "}") {
      fld = this._parseMessageField(msg, "optional", token);
      fld["oneof"] = name;
      fields.push(fld["id"]);
    }

    this.tn.omit(";");
    msg["oneofs"][name] = fields;
  };
  /**
   * Parses a set of field option definitions.
   * @param {!Object} fld Field definition
   * @private
   */


  ParserPrototype._parseFieldOptions = function (fld) {
    this.tn.skip("[");
    var token,
        first = true;

    while ((token = this.tn.peek()) !== ']') {
      if (!first) this.tn.skip(",");

      this._parseOption(fld, true);

      first = false;
    }

    this.tn.next();
  };
  /**
   * Parses an enum.
   * @param {!Object} msg Message definition
   * @private
   */


  ParserPrototype._parseEnum = function (msg) {
    var enm = {
      "name": "",
      "values": [],
      "options": {}
    };
    var token = this.tn.next();
    if (!Lang.NAME.test(token)) throw Error("illegal name: " + token);
    enm["name"] = token;
    this.tn.skip("{");

    while ((token = this.tn.next()) !== '}') {
      if (token === "option") this._parseOption(enm);else {
        if (!Lang.NAME.test(token)) throw Error("illegal name: " + token);
        this.tn.skip("=");
        var val = {
          "name": token,
          "id": mkId(this.tn.next(), true)
        };
        token = this.tn.peek();
        if (token === "[") this._parseFieldOptions({
          "options": {}
        });
        this.tn.skip(";");
        enm["values"].push(val);
      }
    }

    this.tn.omit(";");
    msg["enums"].push(enm);
  };
  /**
   * Parses extension / reserved ranges.
   * @returns {!Array.<!Array.<number>>}
   * @private
   */


  ParserPrototype._parseExtensionRanges = function () {
    var ranges = [];
    var token, range, value;

    do {
      range = [];

      while (true) {
        token = this.tn.next();

        switch (token) {
          case "min":
            value = ProtoBuf.ID_MIN;
            break;

          case "max":
            value = ProtoBuf.ID_MAX;
            break;

          default:
            value = mkNumber(token);
            break;
        }

        range.push(value);
        if (range.length === 2) break;

        if (this.tn.peek() !== "to") {
          range.push(value);
          break;
        }

        this.tn.next();
      }

      ranges.push(range);
    } while (this.tn.omit(","));

    this.tn.skip(";");
    return ranges;
  };
  /**
   * Parses an extend block.
   * @param {!Object} parent Parent object
   * @private
   */


  ParserPrototype._parseExtend = function (parent) {
    var token = this.tn.next();
    if (!Lang.TYPEREF.test(token)) throw Error("illegal extend reference: " + token);
    var ext = {
      "ref": token,
      "fields": []
    };
    this.tn.skip("{");

    while ((token = this.tn.next()) !== '}') {
      if (Lang.RULE.test(token)) this._parseMessageField(ext, token);else if (Lang.TYPEREF.test(token)) {
        if (!this.proto3) throw Error("illegal field rule: " + token);

        this._parseMessageField(ext, "optional", token);
      } else throw Error("illegal extend token: " + token);
    }

    this.tn.omit(";");
    parent["messages"].push(ext);
    return ext;
  }; // ----- General -----

  /**
   * Returns a string representation of this parser.
   * @returns {string}
   */


  ParserPrototype.toString = function () {
    return "Parser at line " + this.tn.line;
  };
  /**
   * @alias ProtoBuf.DotProto.Parser
   * @expose
   */


  DotProto.Parser = Parser;
  return DotProto;
}(ProtoBuf, ProtoBuf.Lang);
/**
 * @alias ProtoBuf.Reflect
 * @expose
 */


ProtoBuf.Reflect = function (ProtoBuf) {
  "use strict";
  /**
   * Reflection types.
   * @exports ProtoBuf.Reflect
   * @namespace
   */

  var Reflect = {};
  /**
   * Constructs a Reflect base class.
   * @exports ProtoBuf.Reflect.T
   * @constructor
   * @abstract
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {?ProtoBuf.Reflect.T} parent Parent object
   * @param {string} name Object name
   */

  var T = function T(builder, parent, name) {
    /**
     * Builder reference.
     * @type {!ProtoBuf.Builder}
     * @expose
     */
    this.builder = builder;
    /**
     * Parent object.
     * @type {?ProtoBuf.Reflect.T}
     * @expose
     */

    this.parent = parent;
    /**
     * Object name in namespace.
     * @type {string}
     * @expose
     */

    this.name = name;
    /**
     * Fully qualified class name
     * @type {string}
     * @expose
     */

    this.className;
  };
  /**
   * @alias ProtoBuf.Reflect.T.prototype
   * @inner
   */


  var TPrototype = T.prototype;
  /**
   * Returns the fully qualified name of this object.
   * @returns {string} Fully qualified name as of ".PATH.TO.THIS"
   * @expose
   */

  TPrototype.fqn = function () {
    var name = this.name,
        ptr = this;

    do {
      ptr = ptr.parent;
      if (ptr == null) break;
      name = ptr.name + "." + name;
    } while (true);

    return name;
  };
  /**
   * Returns a string representation of this Reflect object (its fully qualified name).
   * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.
   * @return String representation
   * @expose
   */


  TPrototype.toString = function (includeClass) {
    return (includeClass ? this.className + " " : "") + this.fqn();
  };
  /**
   * Builds this type.
   * @throws {Error} If this type cannot be built directly
   * @expose
   */


  TPrototype.build = function () {
    throw Error(this.toString(true) + " cannot be built directly");
  };
  /**
   * @alias ProtoBuf.Reflect.T
   * @expose
   */


  Reflect.T = T;
  /**
   * Constructs a new Namespace.
   * @exports ProtoBuf.Reflect.Namespace
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent
   * @param {string} name Namespace name
   * @param {Object.<string,*>=} options Namespace options
   * @param {string?} syntax The syntax level of this definition (e.g., proto3)
   * @constructor
   * @extends ProtoBuf.Reflect.T
   */

  var Namespace = function Namespace(builder, parent, name, options, syntax) {
    T.call(this, builder, parent, name);
    /**
     * @override
     */

    this.className = "Namespace";
    /**
     * Children inside the namespace.
     * @type {!Array.<ProtoBuf.Reflect.T>}
     */

    this.children = [];
    /**
     * Options.
     * @type {!Object.<string, *>}
     */

    this.options = options || {};
    /**
     * Syntax level (e.g., proto2 or proto3).
     * @type {!string}
     */

    this.syntax = syntax || "proto2";
  };
  /**
   * @alias ProtoBuf.Reflect.Namespace.prototype
   * @inner
   */


  var NamespacePrototype = Namespace.prototype = (0, _create.default)(T.prototype);
  /**
   * Returns an array of the namespace's children.
   * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
   * @return {Array.<ProtoBuf.Reflect.T>}
   * @expose
   */

  NamespacePrototype.getChildren = function (type) {
    type = type || null;
    if (type == null) return this.children.slice();
    var children = [];

    for (var i = 0, k = this.children.length; i < k; ++i) {
      if (this.children[i] instanceof type) children.push(this.children[i]);
    }

    return children;
  };
  /**
   * Adds a child to the namespace.
   * @param {ProtoBuf.Reflect.T} child Child
   * @throws {Error} If the child cannot be added (duplicate)
   * @expose
   */


  NamespacePrototype.addChild = function (child) {
    var other;

    if (other = this.getChild(child.name)) {
      // Try to revert camelcase transformation on collision
      if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null) other.name = other.originalName; // Revert previous first (effectively keeps both originals)
      else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null) child.name = child.originalName;else throw Error("Duplicate name in namespace " + this.toString(true) + ": " + child.name);
    }

    this.children.push(child);
  };
  /**
   * Gets a child by its name or id.
   * @param {string|number} nameOrId Child name or id
   * @return {?ProtoBuf.Reflect.T} The child or null if not found
   * @expose
   */


  NamespacePrototype.getChild = function (nameOrId) {
    var key = typeof nameOrId === 'number' ? 'id' : 'name';

    for (var i = 0, k = this.children.length; i < k; ++i) {
      if (this.children[i][key] === nameOrId) return this.children[i];
    }

    return null;
  };
  /**
   * Resolves a reflect object inside of this namespace.
   * @param {string|!Array.<string>} qn Qualified name to resolve
   * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`
   * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found
   * @expose
   */


  NamespacePrototype.resolve = function (qn, excludeNonNamespace) {
    var part = typeof qn === 'string' ? qn.split(".") : qn,
        ptr = this,
        i = 0;

    if (part[i] === "") {
      // Fully qualified name, e.g. ".My.Message'
      while (ptr.parent !== null) {
        ptr = ptr.parent;
      }

      i++;
    }

    var child;

    do {
      do {
        if (!(ptr instanceof Reflect.Namespace)) {
          ptr = null;
          break;
        }

        child = ptr.getChild(part[i]);

        if (!child || !(child instanceof Reflect.T) || excludeNonNamespace && !(child instanceof Reflect.Namespace)) {
          ptr = null;
          break;
        }

        ptr = child;
        i++;
      } while (i < part.length);

      if (ptr != null) break; // Found
      // Else search the parent

      if (this.parent !== null) return this.parent.resolve(qn, excludeNonNamespace);
    } while (ptr != null);

    return ptr;
  };
  /**
   * Determines the shortest qualified name of the specified type, if any, relative to this namespace.
   * @param {!ProtoBuf.Reflect.T} t Reflection type
   * @returns {string} The shortest qualified name or, if there is none, the fqn
   * @expose
   */


  NamespacePrototype.qn = function (t) {
    var part = [],
        ptr = t;

    do {
      part.unshift(ptr.name);
      ptr = ptr.parent;
    } while (ptr !== null);

    for (var len = 1; len <= part.length; len++) {
      var qn = part.slice(part.length - len);
      if (t === this.resolve(qn, t instanceof Reflect.Namespace)) return qn.join(".");
    }

    return t.fqn();
  };
  /**
   * Builds the namespace and returns the runtime counterpart.
   * @return {Object.<string,Function|Object>} Runtime namespace
   * @expose
   */


  NamespacePrototype.build = function () {
    /** @dict */
    var ns = {};
    var children = this.children;

    for (var i = 0, k = children.length, child; i < k; ++i) {
      child = children[i];
      if (child instanceof Namespace) ns[child.name] = child.build();
    }

    if (_defineProperty.default) (0, _defineProperty.default)(ns, "$options", {
      "value": this.buildOpt()
    });
    return ns;
  };
  /**
   * Builds the namespace's '$options' property.
   * @return {Object.<string,*>}
   */


  NamespacePrototype.buildOpt = function () {
    var opt = {},
        keys = (0, _keys.default)(this.options);

    for (var i = 0, k = keys.length; i < k; ++i) {
      var key = keys[i],
          val = this.options[keys[i]]; // TODO: Options are not resolved, yet.
      // if (val instanceof Namespace) {
      //     opt[key] = val.build();
      // } else {

      opt[key] = val; // }
    }

    return opt;
  };
  /**
   * Gets the value assigned to the option with the specified name.
   * @param {string=} name Returns the option value if specified, otherwise all options are returned.
   * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option
   */


  NamespacePrototype.getOption = function (name) {
    if (typeof name === 'undefined') return this.options;
    return typeof this.options[name] !== 'undefined' ? this.options[name] : null;
  };
  /**
   * @alias ProtoBuf.Reflect.Namespace
   * @expose
   */


  Reflect.Namespace = Namespace;
  /**
   * Constructs a new Element implementation that checks and converts values for a
   * particular field type, as appropriate.
   *
   * An Element represents a single value: either the value of a singular field,
   * or a value contained in one entry of a repeated field or map field. This
   * class does not implement these higher-level concepts; it only encapsulates
   * the low-level typechecking and conversion.
   *
   * @exports ProtoBuf.Reflect.Element
   * @param {{name: string, wireType: number}} type Resolved data type
   * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant
   * (e.g. submessage field).
   * @param {boolean} isMapKey Is this element a Map key? The value will be
   * converted to string form if so.
   * @param {string} syntax Syntax level of defining message type, e.g.,
   * proto2 or proto3.
   * @constructor
   */

  var Element = function Element(type, resolvedType, isMapKey, syntax) {
    /**
     * Element type, as a string (e.g., int32).
     * @type {{name: string, wireType: number}}
     */
    this.type = type;
    /**
     * Element type reference to submessage or enum definition, if needed.
     * @type {ProtoBuf.Reflect.T|null}
     */

    this.resolvedType = resolvedType;
    /**
     * Element is a map key.
     * @type {boolean}
     */

    this.isMapKey = isMapKey;
    /**
     * Syntax level of defining message type, e.g., proto2 or proto3.
     * @type {string}
     */

    this.syntax = syntax;
    if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0) throw Error("Invalid map key type: " + type.name);
  };

  var ElementPrototype = Element.prototype;
  /**
   * Obtains a (new) default value for the specified type.
   * @param type {string|{name: string, wireType: number}} Field type
   * @returns {*} Default value
   * @inner
   */

  function mkDefault(type) {
    if (typeof type === 'string') type = ProtoBuf.TYPES[type];
    if (typeof type.defaultValue === 'undefined') throw Error("default value for type " + type.name + " is not supported");
    if (type == ProtoBuf.TYPES["bytes"]) return new ByteBuffer(0);
    return type.defaultValue;
  }
  /**
   * Returns the default value for this field in proto3.
   * @function
   * @param type {string|{name: string, wireType: number}} the field type
   * @returns {*} Default value
   */


  Element.defaultFieldValue = mkDefault;
  /**
   * Makes a Long from a value.
   * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value
   * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
   *  strings and numbers
   * @returns {!Long}
   * @throws {Error} If the value cannot be converted to a Long
   * @inner
   */

  function mkLong(value, unsigned) {
    if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean' && value.low === value.low && value.high === value.high) return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
    if (typeof value === 'string') return ProtoBuf.Long.fromString(value, unsigned || false, 10);
    if (typeof value === 'number') return ProtoBuf.Long.fromNumber(value, unsigned || false);
    throw Error("not convertible to Long");
  }
  /**
   * Checks if the given value can be set for an element of this type (singular
   * field or one element of a repeated field or map).
   * @param {*} value Value to check
   * @return {*} Verified, maybe adjusted, value
   * @throws {Error} If the value cannot be verified for this element slot
   * @expose
   */


  ElementPrototype.verifyValue = function (value) {
    var self = this;

    function fail(val, msg) {
      throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
    }

    switch (this.type) {
      // Signed 32bit
      case ProtoBuf.TYPES["int32"]:
      case ProtoBuf.TYPES["sint32"]:
      case ProtoBuf.TYPES["sfixed32"]:
        // Account for !NaN: value === value
        if (typeof value !== 'number' || value === value && value % 1 !== 0) fail((0, _typeof2.default)(value), "not an integer");
        return value > 4294967295 ? value | 0 : value;
      // Unsigned 32bit

      case ProtoBuf.TYPES["uint32"]:
      case ProtoBuf.TYPES["fixed32"]:
        if (typeof value !== 'number' || value === value && value % 1 !== 0) fail((0, _typeof2.default)(value), "not an integer");
        return value < 0 ? value >>> 0 : value;
      // Signed 64bit

      case ProtoBuf.TYPES["int64"]:
      case ProtoBuf.TYPES["sint64"]:
      case ProtoBuf.TYPES["sfixed64"]:
        {
          if (ProtoBuf.Long) try {
            return mkLong(value, false);
          } catch (e) {
            fail((0, _typeof2.default)(value), e.message);
          } else fail((0, _typeof2.default)(value), "requires Long.js");
        }
      // Unsigned 64bit

      case ProtoBuf.TYPES["uint64"]:
      case ProtoBuf.TYPES["fixed64"]:
        {
          if (ProtoBuf.Long) try {
            return mkLong(value, true);
          } catch (e) {
            fail((0, _typeof2.default)(value), e.message);
          } else fail((0, _typeof2.default)(value), "requires Long.js");
        }
      // Bool

      case ProtoBuf.TYPES["bool"]:
        if (typeof value !== 'boolean') fail((0, _typeof2.default)(value), "not a boolean");
        return value;
      // Float

      case ProtoBuf.TYPES["float"]:
      case ProtoBuf.TYPES["double"]:
        if (typeof value !== 'number') fail((0, _typeof2.default)(value), "not a number");
        return value;
      // Length-delimited string

      case ProtoBuf.TYPES["string"]:
        if (typeof value !== 'string' && !(value && value instanceof String)) fail((0, _typeof2.default)(value), "not a string");
        return "" + value;
      // Convert String object to string
      // Length-delimited bytes

      case ProtoBuf.TYPES["bytes"]:
        if (ByteBuffer.isByteBuffer(value)) return value;
        return ByteBuffer.wrap(value, "base64");
      // Constant enum value

      case ProtoBuf.TYPES["enum"]:
        {
          var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);

          for (i = 0; i < values.length; i++) {
            if (values[i].name == value) return values[i].id;else if (values[i].id == value) return values[i].id;
          }

          if (this.syntax === 'proto3') {
            // proto3: just make sure it's an integer.
            if (typeof value !== 'number' || value === value && value % 1 !== 0) fail((0, _typeof2.default)(value), "not an integer");
            if (value > 4294967295 || value < 0) fail((0, _typeof2.default)(value), "not in range for uint32");
            return value;
          } else {
            // proto2 requires enum values to be valid.
            fail(value, "not a valid enum value");
          }
        }
      // Embedded message

      case ProtoBuf.TYPES["group"]:
      case ProtoBuf.TYPES["message"]:
        {
          if (!value || (0, _typeof2.default)(value) !== 'object') fail((0, _typeof2.default)(value), "object expected");
          if (value instanceof this.resolvedType.clazz) return value;

          if (value instanceof ProtoBuf.Builder.Message) {
            // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
            var obj = {};

            for (var i in value) {
              if (value.hasOwnProperty(i)) obj[i] = value[i];
            }

            value = obj;
          } // Else let's try to construct one from a key-value object


          return new this.resolvedType.clazz(value); // May throw for a hundred of reasons
        }
    } // We should never end here


    throw Error("[INTERNAL] Illegal value for " + this.toString(true) + ": " + value + " (undefined type " + this.type + ")");
  };
  /**
   * Calculates the byte length of an element on the wire.
   * @param {number} id Field number
   * @param {*} value Field value
   * @returns {number} Byte length
   * @throws {Error} If the value cannot be calculated
   * @expose
   */


  ElementPrototype.calculateLength = function (id, value) {
    if (value === null) return 0; // Nothing to encode
    // Tag has already been written

    var n;

    switch (this.type) {
      case ProtoBuf.TYPES["int32"]:
        return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);

      case ProtoBuf.TYPES["uint32"]:
        return ByteBuffer.calculateVarint32(value);

      case ProtoBuf.TYPES["sint32"]:
        return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));

      case ProtoBuf.TYPES["fixed32"]:
      case ProtoBuf.TYPES["sfixed32"]:
      case ProtoBuf.TYPES["float"]:
        return 4;

      case ProtoBuf.TYPES["int64"]:
      case ProtoBuf.TYPES["uint64"]:
        return ByteBuffer.calculateVarint64(value);

      case ProtoBuf.TYPES["sint64"]:
        return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));

      case ProtoBuf.TYPES["fixed64"]:
      case ProtoBuf.TYPES["sfixed64"]:
        return 8;

      case ProtoBuf.TYPES["bool"]:
        return 1;

      case ProtoBuf.TYPES["enum"]:
        return ByteBuffer.calculateVarint32(value);

      case ProtoBuf.TYPES["double"]:
        return 8;

      case ProtoBuf.TYPES["string"]:
        n = ByteBuffer.calculateUTF8Bytes(value);
        return ByteBuffer.calculateVarint32(n) + n;

      case ProtoBuf.TYPES["bytes"]:
        if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
        return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();

      case ProtoBuf.TYPES["message"]:
        n = this.resolvedType.calculate(value);
        return ByteBuffer.calculateVarint32(n) + n;

      case ProtoBuf.TYPES["group"]:
        n = this.resolvedType.calculate(value);
        return n + ByteBuffer.calculateVarint32(id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
    } // We should never end here


    throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
  };
  /**
   * Encodes a value to the specified buffer. Does not encode the key.
   * @param {number} id Field number
   * @param {*} value Field value
   * @param {ByteBuffer} buffer ByteBuffer to encode to
   * @return {ByteBuffer} The ByteBuffer for chaining
   * @throws {Error} If the value cannot be encoded
   * @expose
   */


  ElementPrototype.encodeValue = function (id, value, buffer) {
    if (value === null) return buffer; // Nothing to encode
    // Tag has already been written

    switch (this.type) {
      // 32bit signed varint
      case ProtoBuf.TYPES["int32"]:
        // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
        // long – it is, effectively, treated like a very large unsigned integer." (see #122)
        if (value < 0) buffer.writeVarint64(value);else buffer.writeVarint32(value);
        break;
      // 32bit unsigned varint

      case ProtoBuf.TYPES["uint32"]:
        buffer.writeVarint32(value);
        break;
      // 32bit varint zig-zag

      case ProtoBuf.TYPES["sint32"]:
        buffer.writeVarint32ZigZag(value);
        break;
      // Fixed unsigned 32bit

      case ProtoBuf.TYPES["fixed32"]:
        buffer.writeUint32(value);
        break;
      // Fixed signed 32bit

      case ProtoBuf.TYPES["sfixed32"]:
        buffer.writeInt32(value);
        break;
      // 64bit varint as-is

      case ProtoBuf.TYPES["int64"]:
      case ProtoBuf.TYPES["uint64"]:
        buffer.writeVarint64(value); // throws

        break;
      // 64bit varint zig-zag

      case ProtoBuf.TYPES["sint64"]:
        buffer.writeVarint64ZigZag(value); // throws

        break;
      // Fixed unsigned 64bit

      case ProtoBuf.TYPES["fixed64"]:
        buffer.writeUint64(value); // throws

        break;
      // Fixed signed 64bit

      case ProtoBuf.TYPES["sfixed64"]:
        buffer.writeInt64(value); // throws

        break;
      // Bool

      case ProtoBuf.TYPES["bool"]:
        if (typeof value === 'string') buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);else buffer.writeVarint32(value ? 1 : 0);
        break;
      // Constant enum value

      case ProtoBuf.TYPES["enum"]:
        buffer.writeVarint32(value);
        break;
      // 32bit float

      case ProtoBuf.TYPES["float"]:
        buffer.writeFloat32(value);
        break;
      // 64bit float

      case ProtoBuf.TYPES["double"]:
        buffer.writeFloat64(value);
        break;
      // Length-delimited string

      case ProtoBuf.TYPES["string"]:
        buffer.writeVString(value);
        break;
      // Length-delimited bytes

      case ProtoBuf.TYPES["bytes"]:
        if (value.remaining() < 0) throw Error("Illegal value for " + this.toString(true) + ": " + value.remaining() + " bytes remaining");
        var prevOffset = value.offset;
        buffer.writeVarint32(value.remaining());
        buffer.append(value);
        value.offset = prevOffset;
        break;
      // Embedded message

      case ProtoBuf.TYPES["message"]:
        var bb = new ByteBuffer().LE();
        this.resolvedType.encode(value, bb);
        buffer.writeVarint32(bb.offset);
        buffer.append(bb.flip());
        break;
      // Legacy group

      case ProtoBuf.TYPES["group"]:
        this.resolvedType.encode(value, buffer);
        buffer.writeVarint32(id << 3 | ProtoBuf.WIRE_TYPES.ENDGROUP);
        break;

      default:
        // We should never end here
        throw Error("[INTERNAL] Illegal value to encode in " + this.toString(true) + ": " + value + " (unknown type)");
    }

    return buffer;
  };
  /**
   * Decode one element value from the specified buffer.
   * @param {ByteBuffer} buffer ByteBuffer to decode from
   * @param {number} wireType The field wire type
   * @param {number} id The field number
   * @return {*} Decoded value
   * @throws {Error} If the field cannot be decoded
   * @expose
   */


  ElementPrototype.decode = function (buffer, wireType, id) {
    if (wireType != this.type.wireType) throw Error("Unexpected wire type for element");
    var value, nBytes;

    switch (this.type) {
      // 32bit signed varint
      case ProtoBuf.TYPES["int32"]:
        return buffer.readVarint32() | 0;
      // 32bit unsigned varint

      case ProtoBuf.TYPES["uint32"]:
        return buffer.readVarint32() >>> 0;
      // 32bit signed varint zig-zag

      case ProtoBuf.TYPES["sint32"]:
        return buffer.readVarint32ZigZag() | 0;
      // Fixed 32bit unsigned

      case ProtoBuf.TYPES["fixed32"]:
        return buffer.readUint32() >>> 0;

      case ProtoBuf.TYPES["sfixed32"]:
        return buffer.readInt32() | 0;
      // 64bit signed varint

      case ProtoBuf.TYPES["int64"]:
        return buffer.readVarint64();
      // 64bit unsigned varint

      case ProtoBuf.TYPES["uint64"]:
        return buffer.readVarint64().toUnsigned();
      // 64bit signed varint zig-zag

      case ProtoBuf.TYPES["sint64"]:
        return buffer.readVarint64ZigZag();
      // Fixed 64bit unsigned

      case ProtoBuf.TYPES["fixed64"]:
        return buffer.readUint64();
      // Fixed 64bit signed

      case ProtoBuf.TYPES["sfixed64"]:
        return buffer.readInt64();
      // Bool varint

      case ProtoBuf.TYPES["bool"]:
        return !!buffer.readVarint32();
      // Constant enum value (varint)

      case ProtoBuf.TYPES["enum"]:
        // The following Builder.Message#set will already throw
        return buffer.readVarint32();
      // 32bit float

      case ProtoBuf.TYPES["float"]:
        return buffer.readFloat();
      // 64bit float

      case ProtoBuf.TYPES["double"]:
        return buffer.readDouble();
      // Length-delimited string

      case ProtoBuf.TYPES["string"]:
        return buffer.readVString();
      // Length-delimited bytes

      case ProtoBuf.TYPES["bytes"]:
        {
          nBytes = buffer.readVarint32();
          if (buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining());
          value = buffer.clone(); // Offset already set

          value.limit = value.offset + nBytes;
          buffer.offset += nBytes;
          return value;
        }
      // Length-delimited embedded message

      case ProtoBuf.TYPES["message"]:
        {
          nBytes = buffer.readVarint32();
          return this.resolvedType.decode(buffer, nBytes);
        }
      // Legacy group

      case ProtoBuf.TYPES["group"]:
        return this.resolvedType.decode(buffer, -1, id);
    } // We should never end here


    throw Error("[INTERNAL] Illegal decode type");
  };
  /**
   * Converts a value from a string to the canonical element type.
   *
   * Legal only when isMapKey is true.
   *
   * @param {string} str The string value
   * @returns {*} The value
   */


  ElementPrototype.valueFromString = function (str) {
    if (!this.isMapKey) {
      throw Error("valueFromString() called on non-map-key element");
    }

    switch (this.type) {
      case ProtoBuf.TYPES["int32"]:
      case ProtoBuf.TYPES["sint32"]:
      case ProtoBuf.TYPES["sfixed32"]:
      case ProtoBuf.TYPES["uint32"]:
      case ProtoBuf.TYPES["fixed32"]:
        return this.verifyValue((0, _parseInt2.default)(str));

      case ProtoBuf.TYPES["int64"]:
      case ProtoBuf.TYPES["sint64"]:
      case ProtoBuf.TYPES["sfixed64"]:
      case ProtoBuf.TYPES["uint64"]:
      case ProtoBuf.TYPES["fixed64"]:
        // Long-based fields support conversions from string already.
        return this.verifyValue(str);

      case ProtoBuf.TYPES["bool"]:
        return str === "true";

      case ProtoBuf.TYPES["string"]:
        return this.verifyValue(str);

      case ProtoBuf.TYPES["bytes"]:
        return ByteBuffer.fromBinary(str);
    }
  };
  /**
   * Converts a value from the canonical element type to a string.
   *
   * It should be the case that `valueFromString(valueToString(val))` returns
   * a value equivalent to `verifyValue(val)` for every legal value of `val`
   * according to this element type.
   *
   * This may be used when the element must be stored or used as a string,
   * e.g., as a map key on an Object.
   *
   * Legal only when isMapKey is true.
   *
   * @param {*} val The value
   * @returns {string} The string form of the value.
   */


  ElementPrototype.valueToString = function (value) {
    if (!this.isMapKey) {
      throw Error("valueToString() called on non-map-key element");
    }

    if (this.type === ProtoBuf.TYPES["bytes"]) {
      return value.toString("binary");
    } else {
      return value.toString();
    }
  };
  /**
   * @alias ProtoBuf.Reflect.Element
   * @expose
   */


  Reflect.Element = Element;
  /**
   * Constructs a new Message.
   * @exports ProtoBuf.Reflect.Message
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace
   * @param {string} name Message name
   * @param {Object.<string,*>=} options Message options
   * @param {boolean=} isGroup `true` if this is a legacy group
   * @param {string?} syntax The syntax level of this definition (e.g., proto3)
   * @constructor
   * @extends ProtoBuf.Reflect.Namespace
   */

  var Message = function Message(builder, parent, name, options, isGroup, syntax) {
    Namespace.call(this, builder, parent, name, options, syntax);
    /**
     * @override
     */

    this.className = "Message";
    /**
     * Extensions range.
     * @type {!Array.<number>|undefined}
     * @expose
     */

    this.extensions = undefined;
    /**
     * Runtime message class.
     * @type {?function(new:ProtoBuf.Builder.Message)}
     * @expose
     */

    this.clazz = null;
    /**
     * Whether this is a legacy group or not.
     * @type {boolean}
     * @expose
     */

    this.isGroup = !!isGroup; // The following cached collections are used to efficiently iterate over or look up fields when decoding.

    /**
     * Cached fields.
     * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}
     * @private
     */

    this._fields = null;
    /**
     * Cached fields by id.
     * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}
     * @private
     */

    this._fieldsById = null;
    /**
     * Cached fields by name.
     * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}
     * @private
     */

    this._fieldsByName = null;
  };
  /**
   * @alias ProtoBuf.Reflect.Message.prototype
   * @inner
   */


  var MessagePrototype = Message.prototype = (0, _create.default)(Namespace.prototype);
  /**
   * Builds the message and returns the runtime counterpart, which is a fully functional class.
   * @see ProtoBuf.Builder.Message
   * @param {boolean=} rebuild Whether to rebuild or not, defaults to false
   * @return {ProtoBuf.Reflect.Message} Message class
   * @throws {Error} If the message cannot be built
   * @expose
   */

  MessagePrototype.build = function (rebuild) {
    if (this.clazz && !rebuild) return this.clazz; // Create the runtime Message class in its own scope

    var clazz = function (ProtoBuf, T) {
      var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),
          oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);
      /**
       * Constructs a new runtime Message.
       * @name ProtoBuf.Builder.Message
       * @class Barebone of all runtime messages.
       * @param {!Object.<string,*>|string} values Preset values
       * @param {...string} var_args
       * @constructor
       * @throws {Error} If the message cannot be created
       */

      var Message = function Message(values, var_args) {
        ProtoBuf.Builder.Message.call(this); // Create virtual oneof properties

        for (var i = 0, k = oneofs.length; i < k; ++i) {
          this[oneofs[i].name] = null;
        } // Create fields and set default values


        for (i = 0, k = fields.length; i < k; ++i) {
          var field = fields[i];
          this[field.name] = field.repeated ? [] : field.map ? new ProtoBuf.Map(field) : null;
          if ((field.required || T.syntax === 'proto3') && field.defaultValue !== null) this[field.name] = field.defaultValue;
        }

        if (arguments.length > 0) {
          var value; // Set field values from a values object

          if (arguments.length === 1 && values !== null && (0, _typeof2.default)(values) === 'object' && (
          /* not _another_ Message */
          typeof values.encode !== 'function' || values instanceof Message) &&
          /* not a repeated field */
          !(0, _isArray.default)(values) &&
          /* not a Map */
          !(values instanceof ProtoBuf.Map) &&
          /* not a ByteBuffer */
          !ByteBuffer.isByteBuffer(values) &&
          /* not an ArrayBuffer */
          !(values instanceof ArrayBuffer) &&
          /* not a Long */
          !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {
            this.$set(values);
          } else // Set field values from arguments, in declaration order
            for (i = 0, k = arguments.length; i < k; ++i) {
              if (typeof (value = arguments[i]) !== 'undefined') this.$set(fields[i].name, value);
            } // May throw

        }
      };
      /**
       * @alias ProtoBuf.Builder.Message.prototype
       * @inner
       */


      var MessagePrototype = Message.prototype = (0, _create.default)(ProtoBuf.Builder.Message.prototype);
      /**
       * Adds a value to a repeated field.
       * @name ProtoBuf.Builder.Message#add
       * @function
       * @param {string} key Field name
       * @param {*} value Value to add
       * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
       * @returns {!ProtoBuf.Builder.Message} this
       * @throws {Error} If the value cannot be added
       * @expose
       */

      MessagePrototype.add = function (key, value, noAssert) {
        var field = T._fieldsByName[key];

        if (!noAssert) {
          if (!field) throw Error(this + "#" + key + " is undefined");
          if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(true)); // May throw if it's an enum or embedded message

          if (!field.repeated) throw Error(this + "#" + key + " is not a repeated field");
          value = field.verifyValue(value, true);
        }

        if (this[key] === null) this[key] = [];
        this[key].push(value);
        return this;
      };
      /**
       * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.
       * @name ProtoBuf.Builder.Message#$add
       * @function
       * @param {string} key Field name
       * @param {*} value Value to add
       * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)
       * @returns {!ProtoBuf.Builder.Message} this
       * @throws {Error} If the value cannot be added
       * @expose
       */


      MessagePrototype.$add = MessagePrototype.add;
      /**
       * Sets a field's value.
       * @name ProtoBuf.Builder.Message#set
       * @function
       * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
       * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
       * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
       * @returns {!ProtoBuf.Builder.Message} this
       * @throws {Error} If the value cannot be set
       * @expose
       */

      MessagePrototype.set = function (keyOrObj, value, noAssert) {
        if (keyOrObj && (0, _typeof2.default)(keyOrObj) === 'object') {
          noAssert = value;

          for (var ikey in keyOrObj) {
            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined') this.$set(ikey, value, noAssert);
          }

          return this;
        }

        var field = T._fieldsByName[keyOrObj];

        if (!noAssert) {
          if (!field) throw Error(this + "#" + keyOrObj + " is not a field: undefined");
          if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + keyOrObj + " is not a field: " + field.toString(true));
          this[field.name] = value = field.verifyValue(value); // May throw
        } else this[keyOrObj] = value;

        if (field && field.oneof) {
          // Field is part of an OneOf (not a virtual OneOf field)
          var currentField = this[field.oneof.name]; // Virtual field references currently set field

          if (value !== null) {
            if (currentField !== null && currentField !== field.name) this[currentField] = null; // Clear currently set field

            this[field.oneof.name] = field.name; // Point virtual field at this field
          } else if (
          /* value === null && */
          currentField === keyOrObj) this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)

        }

        return this;
      };
      /**
       * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.
       * @name ProtoBuf.Builder.Message#$set
       * @function
       * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values
       * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted
       * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
       * @throws {Error} If the value cannot be set
       * @expose
       */


      MessagePrototype.$set = MessagePrototype.set;
      /**
       * Gets a field's value.
       * @name ProtoBuf.Builder.Message#get
       * @function
       * @param {string} key Key
       * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`
       * @return {*} Value
       * @throws {Error} If there is no such field
       * @expose
       */

      MessagePrototype.get = function (key, noAssert) {
        if (noAssert) return this[key];
        var field = T._fieldsByName[key];
        if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: undefined");
        if (!(field instanceof ProtoBuf.Reflect.Message.Field)) throw Error(this + "#" + key + " is not a field: " + field.toString(true));
        return this[field.name];
      };
      /**
       * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.
       * @name ProtoBuf.Builder.Message#$get
       * @function
       * @param {string} key Key
       * @return {*} Value
       * @throws {Error} If there is no such field
       * @expose
       */


      MessagePrototype.$get = MessagePrototype.get; // Getters and setters

      for (var i = 0; i < fields.length; i++) {
        var field = fields[i]; // no setters for extension fields as these are named by their fqn

        if (field instanceof ProtoBuf.Reflect.Message.ExtensionField) continue;
        if (T.builder.options['populateAccessors']) (function (field) {
          // set/get[SomeValue]
          var Name = field.originalName.replace(/(_[a-zA-Z])/g, function (match) {
            return match.toUpperCase().replace('_', '');
          });
          Name = Name.substring(0, 1).toUpperCase() + Name.substring(1); // set/get_[some_value] FIXME: Do we really need these?

          var name = field.originalName.replace(/([A-Z])/g, function (match) {
            return "_" + match;
          });
          /**
           * The current field's unbound setter function.
           * @function
           * @param {*} value
           * @param {boolean=} noAssert
           * @returns {!ProtoBuf.Builder.Message}
           * @inner
           */

          var setter = function setter(value, noAssert) {
            this[field.name] = noAssert ? value : field.verifyValue(value);
            return this;
          };
          /**
           * The current field's unbound getter function.
           * @function
           * @returns {*}
           * @inner
           */


          var getter = function getter() {
            return this[field.name];
          };

          if (T.getChild("set" + Name) === null)
            /**
             * Sets a value. This method is present for each field, but only if there is no name conflict with
             *  another field.
             * @name ProtoBuf.Builder.Message#set[SomeField]
             * @function
             * @param {*} value Value to set
             * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
             * @returns {!ProtoBuf.Builder.Message} this
             * @abstract
             * @throws {Error} If the value cannot be set
             */
            MessagePrototype["set" + Name] = setter;
          if (T.getChild("set_" + name) === null)
            /**
             * Sets a value. This method is present for each field, but only if there is no name conflict with
             *  another field.
             * @name ProtoBuf.Builder.Message#set_[some_field]
             * @function
             * @param {*} value Value to set
             * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`
             * @returns {!ProtoBuf.Builder.Message} this
             * @abstract
             * @throws {Error} If the value cannot be set
             */
            MessagePrototype["set_" + name] = setter;
          if (T.getChild("get" + Name) === null)
            /**
             * Gets a value. This method is present for each field, but only if there is no name conflict with
             *  another field.
             * @name ProtoBuf.Builder.Message#get[SomeField]
             * @function
             * @abstract
             * @return {*} The value
             */
            MessagePrototype["get" + Name] = getter;
          if (T.getChild("get_" + name) === null)
            /**
             * Gets a value. This method is present for each field, but only if there is no name conflict with
             *  another field.
             * @name ProtoBuf.Builder.Message#get_[some_field]
             * @function
             * @return {*} The value
             * @abstract
             */
            MessagePrototype["get_" + name] = getter;
        })(field);
      } // En-/decoding

      /**
       * Encodes the message.
       * @name ProtoBuf.Builder.Message#$encode
       * @function
       * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
       * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
       * @return {!ByteBuffer} Encoded message as a ByteBuffer
       * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
       *  returns the encoded ByteBuffer in the `encoded` property on the error.
       * @expose
       * @see ProtoBuf.Builder.Message#encode64
       * @see ProtoBuf.Builder.Message#encodeHex
       * @see ProtoBuf.Builder.Message#encodeAB
       */


      MessagePrototype.encode = function (buffer, noVerify) {
        if (typeof buffer === 'boolean') noVerify = buffer, buffer = undefined;
        var isNew = false;
        if (!buffer) buffer = new ByteBuffer(), isNew = true;
        var le = buffer.littleEndian;

        try {
          T.encode(this, buffer.LE(), noVerify);
          return (isNew ? buffer.flip() : buffer).LE(le);
        } catch (e) {
          buffer.LE(le);
          throw e;
        }
      };
      /**
       * Encodes a message using the specified data payload.
       * @param {!Object.<string,*>} data Data payload
       * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
       * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
       * @return {!ByteBuffer} Encoded message as a ByteBuffer
       * @expose
       */


      Message.encode = function (data, buffer, noVerify) {
        return new Message(data).encode(buffer, noVerify);
      };
      /**
       * Calculates the byte length of the message.
       * @name ProtoBuf.Builder.Message#calculate
       * @function
       * @returns {number} Byte length
       * @throws {Error} If the message cannot be calculated or if required fields are missing.
       * @expose
       */


      MessagePrototype.calculate = function () {
        return T.calculate(this);
      };
      /**
       * Encodes the varint32 length-delimited message.
       * @name ProtoBuf.Builder.Message#encodeDelimited
       * @function
       * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
       * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
       * @return {!ByteBuffer} Encoded message as a ByteBuffer
       * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
       *  returns the encoded ByteBuffer in the `encoded` property on the error.
       * @expose
       */


      MessagePrototype.encodeDelimited = function (buffer, noVerify) {
        var isNew = false;
        if (!buffer) buffer = new ByteBuffer(), isNew = true;
        var enc = new ByteBuffer().LE();
        T.encode(this, enc, noVerify).flip();
        buffer.writeVarint32(enc.remaining());
        buffer.append(enc);
        return isNew ? buffer.flip() : buffer;
      };
      /**
       * Directly encodes the message to an ArrayBuffer.
       * @name ProtoBuf.Builder.Message#encodeAB
       * @function
       * @return {ArrayBuffer} Encoded message as ArrayBuffer
       * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
       *  returns the encoded ArrayBuffer in the `encoded` property on the error.
       * @expose
       */


      MessagePrototype.encodeAB = function () {
        try {
          return this.encode().toArrayBuffer();
        } catch (e) {
          if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();
          throw e;
        }
      };
      /**
       * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
       * @name ProtoBuf.Builder.Message#toArrayBuffer
       * @function
       * @return {ArrayBuffer} Encoded message as ArrayBuffer
       * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
       *  returns the encoded ArrayBuffer in the `encoded` property on the error.
       * @expose
       */


      MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;
      /**
       * Directly encodes the message to a node Buffer.
       * @name ProtoBuf.Builder.Message#encodeNB
       * @function
       * @return {!Buffer}
       * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
       *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.
       * @expose
       */

      MessagePrototype.encodeNB = function () {
        try {
          return this.encode().toBuffer();
        } catch (e) {
          if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();
          throw e;
        }
      };
      /**
       * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
       * @name ProtoBuf.Builder.Message#toBuffer
       * @function
       * @return {!Buffer}
       * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
       *  returns the encoded node Buffer in the `encoded` property on the error.
       * @expose
       */


      MessagePrototype.toBuffer = MessagePrototype.encodeNB;
      /**
       * Directly encodes the message to a base64 encoded string.
       * @name ProtoBuf.Builder.Message#encode64
       * @function
       * @return {string} Base64 encoded string
       * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
       *  still returns the encoded base64 string in the `encoded` property on the error.
       * @expose
       */

      MessagePrototype.encode64 = function () {
        try {
          return this.encode().toBase64();
        } catch (e) {
          if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();
          throw e;
        }
      };
      /**
       * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
       * @name ProtoBuf.Builder.Message#toBase64
       * @function
       * @return {string} Base64 encoded string
       * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
       *  returns the encoded base64 string in the `encoded` property on the error.
       * @expose
       */


      MessagePrototype.toBase64 = MessagePrototype.encode64;
      /**
       * Directly encodes the message to a hex encoded string.
       * @name ProtoBuf.Builder.Message#encodeHex
       * @function
       * @return {string} Hex encoded string
       * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
       *  still returns the encoded hex string in the `encoded` property on the error.
       * @expose
       */

      MessagePrototype.encodeHex = function () {
        try {
          return this.encode().toHex();
        } catch (e) {
          if (e["encoded"]) e["encoded"] = e["encoded"].toHex();
          throw e;
        }
      };
      /**
       * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
       * @name ProtoBuf.Builder.Message#toHex
       * @function
       * @return {string} Hex encoded string
       * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
       *  returns the encoded hex string in the `encoded` property on the error.
       * @expose
       */


      MessagePrototype.toHex = MessagePrototype.encodeHex;
      /**
       * Clones a message object or field value to a raw object.
       * @param {*} obj Object to clone
       * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
       * @param {boolean} longsAsStrings Whether to encode longs as strings
       * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field
       * @returns {*} Cloned object
       * @inner
       */

      function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {
        if (obj === null || (0, _typeof2.default)(obj) !== 'object') {
          // Convert enum values to their respective names
          if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {
            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);
            if (name !== null) return name;
          } // Pass-through string, number, boolean, null...


          return obj;
        } // Convert ByteBuffers to raw buffer or strings


        if (ByteBuffer.isByteBuffer(obj)) return binaryAsBase64 ? obj.toBase64() : obj.toBuffer(); // Convert Longs to proper objects or strings

        if (ProtoBuf.Long.isLong(obj)) return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);
        var clone; // Clone arrays

        if ((0, _isArray.default)(obj)) {
          clone = [];
          obj.forEach(function (v, k) {
            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);
          });
          return clone;
        }

        clone = {}; // Convert maps to objects

        if (obj instanceof ProtoBuf.Map) {
          var it = obj.entries();

          for (var e = it.next(); !e.done; e = it.next()) {
            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
          }

          return clone;
        } // Everything else is a non-null object


        var type = obj.$type,
            field = undefined;

        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            if (type && (field = type.getChild(i))) clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);else clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);
          }
        }

        return clone;
      }
      /**
       * Returns the message's raw payload.
       * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
       * @param {boolean} longsAsStrings Whether to encode longs as strings
       * @returns {Object.<string,*>} Raw payload
       * @expose
       */


      MessagePrototype.toRaw = function (binaryAsBase64, longsAsStrings) {
        return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);
      };
      /**
       * Encodes a message to JSON.
       * @returns {string} JSON string
       * @expose
       */


      MessagePrototype.encodeJSON = function () {
        return (0, _stringify.default)(cloneRaw(this,
        /* binary-as-base64 */
        true,
        /* longs-as-strings */
        true, this.$type));
      };
      /**
       * Decodes a message from the specified buffer or string.
       * @name ProtoBuf.Builder.Message.decode
       * @function
       * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
       * @param {(number|string)=} length Message length. Defaults to decode all the remainig data.
       * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
       * @return {!ProtoBuf.Builder.Message} Decoded message
       * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
       *  returns the decoded message with missing fields in the `decoded` property on the error.
       * @expose
       * @see ProtoBuf.Builder.Message.decode64
       * @see ProtoBuf.Builder.Message.decodeHex
       */


      Message.decode = function (buffer, length, enc) {
        if (typeof length === 'string') enc = length, length = -1;
        if (typeof buffer === 'string') buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
        buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw

        var le = buffer.littleEndian;

        try {
          var msg = T.decode(buffer.LE());
          buffer.LE(le);
          return msg;
        } catch (e) {
          buffer.LE(le);
          throw e;
        }
      };
      /**
       * Decodes a varint32 length-delimited message from the specified buffer or string.
       * @name ProtoBuf.Builder.Message.decodeDelimited
       * @function
       * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from
       * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
       * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet
       * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
       *  returns the decoded message with missing fields in the `decoded` property on the error.
       * @expose
       */


      Message.decodeDelimited = function (buffer, enc) {
        if (typeof buffer === 'string') buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");
        buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw

        if (buffer.remaining() < 1) return null;
        var off = buffer.offset,
            len = buffer.readVarint32();

        if (buffer.remaining() < len) {
          buffer.offset = off;
          return null;
        }

        try {
          var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());
          buffer.offset += len;
          return msg;
        } catch (err) {
          buffer.offset += len;
          throw err;
        }
      };
      /**
       * Decodes the message from the specified base64 encoded string.
       * @name ProtoBuf.Builder.Message.decode64
       * @function
       * @param {string} str String to decode from
       * @return {!ProtoBuf.Builder.Message} Decoded message
       * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
       *  returns the decoded message with missing fields in the `decoded` property on the error.
       * @expose
       */


      Message.decode64 = function (str) {
        return Message.decode(str, "base64");
      };
      /**
       * Decodes the message from the specified hex encoded string.
       * @name ProtoBuf.Builder.Message.decodeHex
       * @function
       * @param {string} str String to decode from
       * @return {!ProtoBuf.Builder.Message} Decoded message
       * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
       *  returns the decoded message with missing fields in the `decoded` property on the error.
       * @expose
       */


      Message.decodeHex = function (str) {
        return Message.decode(str, "hex");
      };
      /**
       * Decodes the message from a JSON string.
       * @name ProtoBuf.Builder.Message.decodeJSON
       * @function
       * @param {string} str String to decode from
       * @return {!ProtoBuf.Builder.Message} Decoded message
       * @throws {Error} If the message cannot be decoded or if required fields are
       * missing.
       * @expose
       */


      Message.decodeJSON = function (str) {
        return new Message(JSON.parse(str));
      }; // Utility

      /**
       * Returns a string representation of this Message.
       * @name ProtoBuf.Builder.Message#toString
       * @function
       * @return {string} String representation as of ".Fully.Qualified.MessageName"
       * @expose
       */


      MessagePrototype.toString = function () {
        return T.toString();
      }; // Properties

      /**
       * Message options.
       * @name ProtoBuf.Builder.Message.$options
       * @type {Object.<string,*>}
       * @expose
       */


      var $optionsS; // cc needs this

      /**
       * Message options.
       * @name ProtoBuf.Builder.Message#$options
       * @type {Object.<string,*>}
       * @expose
       */

      var $options;
      /**
       * Reflection type.
       * @name ProtoBuf.Builder.Message.$type
       * @type {!ProtoBuf.Reflect.Message}
       * @expose
       */

      var $typeS;
      /**
       * Reflection type.
       * @name ProtoBuf.Builder.Message#$type
       * @type {!ProtoBuf.Reflect.Message}
       * @expose
       */

      var $type;
      if (_defineProperty.default) (0, _defineProperty.default)(Message, '$options', {
        "value": T.buildOpt()
      }), (0, _defineProperty.default)(MessagePrototype, "$options", {
        "value": Message["$options"]
      }), (0, _defineProperty.default)(Message, "$type", {
        "value": T
      }), (0, _defineProperty.default)(MessagePrototype, "$type", {
        "value": T
      });
      return Message;
    }(ProtoBuf, this); // Static enums and prototyped sub-messages / cached collections


    this._fields = [];
    this._fieldsById = {};
    this._fieldsByName = {};

    for (var i = 0, k = this.children.length, child; i < k; i++) {
      child = this.children[i];

      if (child instanceof Enum || child instanceof Message || child instanceof Service) {
        if (clazz.hasOwnProperty(child.name)) throw Error("Illegal reflect child of " + this.toString(true) + ": " + child.toString(true) + " cannot override static property '" + child.name + "'");
        clazz[child.name] = child.build();
      } else if (child instanceof Message.Field) child.build(), this._fields.push(child), this._fieldsById[child.id] = child, this._fieldsByName[child.name] = child;else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built
        throw Error("Illegal reflect child of " + this.toString(true) + ": " + this.children[i].toString(true));
    }

    return this.clazz = clazz;
  };
  /**
   * Encodes a runtime message's contents to the specified buffer.
   * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
   * @param {ByteBuffer} buffer ByteBuffer to write to
   * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`
   * @return {ByteBuffer} The ByteBuffer for chaining
   * @throws {Error} If required fields are missing or the message cannot be encoded for another reason
   * @expose
   */


  MessagePrototype.encode = function (message, buffer, noVerify) {
    var fieldMissing = null,
        field;

    for (var i = 0, k = this._fields.length, val; i < k; ++i) {
      field = this._fields[i];
      val = message[field.name];

      if (field.required && val === null) {
        if (fieldMissing === null) fieldMissing = field;
      } else field.encode(noVerify ? val : field.verifyValue(val), buffer, message);
    }

    if (fieldMissing !== null) {
      var err = Error("Missing at least one required field for " + this.toString(true) + ": " + fieldMissing);
      err["encoded"] = buffer; // Still expose what we got

      throw err;
    }

    return buffer;
  };
  /**
   * Calculates a runtime message's byte length.
   * @param {!ProtoBuf.Builder.Message} message Runtime message to encode
   * @returns {number} Byte length
   * @throws {Error} If required fields are missing or the message cannot be calculated for another reason
   * @expose
   */


  MessagePrototype.calculate = function (message) {
    for (var n = 0, i = 0, k = this._fields.length, field, val; i < k; ++i) {
      field = this._fields[i];
      val = message[field.name];
      if (field.required && val === null) throw Error("Missing at least one required field for " + this.toString(true) + ": " + field);else n += field.calculate(val, message);
    }

    return n;
  };
  /**
   * Skips all data until the end of the specified group has been reached.
   * @param {number} expectedId Expected GROUPEND id
   * @param {!ByteBuffer} buf ByteBuffer
   * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached
   * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)
   * @inner
   */


  function skipTillGroupEnd(expectedId, buf) {
    var tag = buf.readVarint32(),
        // Throws on OOB
    wireType = tag & 0x07,
        id = tag >>> 3;

    switch (wireType) {
      case ProtoBuf.WIRE_TYPES.VARINT:
        do {
          tag = buf.readUint8();
        } while ((tag & 0x80) === 0x80);

        break;

      case ProtoBuf.WIRE_TYPES.BITS64:
        buf.offset += 8;
        break;

      case ProtoBuf.WIRE_TYPES.LDELIM:
        tag = buf.readVarint32(); // reads the varint

        buf.offset += tag; // skips n bytes

        break;

      case ProtoBuf.WIRE_TYPES.STARTGROUP:
        skipTillGroupEnd(id, buf);
        break;

      case ProtoBuf.WIRE_TYPES.ENDGROUP:
        if (id === expectedId) return false;else throw Error("Illegal GROUPEND after unknown group: " + id + " (" + expectedId + " expected)");

      case ProtoBuf.WIRE_TYPES.BITS32:
        buf.offset += 4;
        break;

      default:
        throw Error("Illegal wire type in unknown group " + expectedId + ": " + wireType);
    }

    return true;
  }
  /**
   * Decodes an encoded message and returns the decoded message.
   * @param {ByteBuffer} buffer ByteBuffer to decode from
   * @param {number=} length Message length. Defaults to decode all remaining data.
   * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group
   * @return {ProtoBuf.Builder.Message} Decoded message
   * @throws {Error} If the message cannot be decoded
   * @expose
   */


  MessagePrototype.decode = function (buffer, length, expectedGroupEndId) {
    length = typeof length === 'number' ? length : -1;
    var start = buffer.offset,
        msg = new this.clazz(),
        tag,
        wireType,
        id,
        field;

    while (buffer.offset < start + length || length === -1 && buffer.remaining() > 0) {
      tag = buffer.readVarint32();
      wireType = tag & 0x07;
      id = tag >>> 3;

      if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {
        if (id !== expectedGroupEndId) throw Error("Illegal group end indicator for " + this.toString(true) + ": " + id + " (" + (expectedGroupEndId ? expectedGroupEndId + " expected" : "not a group") + ")");
        break;
      }

      if (!(field = this._fieldsById[id])) {
        // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
        switch (wireType) {
          case ProtoBuf.WIRE_TYPES.VARINT:
            buffer.readVarint32();
            break;

          case ProtoBuf.WIRE_TYPES.BITS32:
            buffer.offset += 4;
            break;

          case ProtoBuf.WIRE_TYPES.BITS64:
            buffer.offset += 8;
            break;

          case ProtoBuf.WIRE_TYPES.LDELIM:
            var len = buffer.readVarint32();
            buffer.offset += len;
            break;

          case ProtoBuf.WIRE_TYPES.STARTGROUP:
            while (skipTillGroupEnd(id, buffer)) {}

            break;

          default:
            throw Error("Illegal wire type for unknown field " + id + " in " + this.toString(true) + "#decode: " + wireType);
        }

        continue;
      }

      if (field.repeated && !field.options["packed"]) {
        msg[field.name].push(field.decode(wireType, buffer));
      } else if (field.map) {
        var keyval = field.decode(wireType, buffer);
        msg[field.name].set(keyval[0], keyval[1]);
      } else {
        msg[field.name] = field.decode(wireType, buffer);

        if (field.oneof) {
          // Field is part of an OneOf (not a virtual OneOf field)
          var currentField = msg[field.oneof.name]; // Virtual field references currently set field

          if (currentField !== null && currentField !== field.name) msg[currentField] = null; // Clear currently set field

          msg[field.oneof.name] = field.name; // Point virtual field at this field
        }
      }
    } // Check if all required fields are present and set default values for optional fields that are not


    for (var i = 0, k = this._fields.length; i < k; ++i) {
      field = this._fields[i];

      if (msg[field.name] === null) {
        if (this.syntax === "proto3") {
          // Proto3 sets default values by specification
          msg[field.name] = field.defaultValue;
        } else if (field.required) {
          var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
          err["decoded"] = msg; // Still expose what we got

          throw err;
        } else if (ProtoBuf.populateDefaults && field.defaultValue !== null) msg[field.name] = field.defaultValue;
      }
    }

    return msg;
  };
  /**
   * @alias ProtoBuf.Reflect.Message
   * @expose
   */


  Reflect.Message = Message;
  /**
   * Constructs a new Message Field.
   * @exports ProtoBuf.Reflect.Message.Field
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.Message} message Message reference
   * @param {string} rule Rule, one of requried, optional, repeated
   * @param {string?} keytype Key data type, if any.
   * @param {string} type Data type, e.g. int32
   * @param {string} name Field name
   * @param {number} id Unique field id
   * @param {Object.<string,*>=} options Options
   * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf
   * @param {string?} syntax The syntax level of this definition (e.g., proto3)
   * @constructor
   * @extends ProtoBuf.Reflect.T
   */

  var Field = function Field(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {
    T.call(this, builder, message, name);
    /**
     * @override
     */

    this.className = "Message.Field";
    /**
     * Message field required flag.
     * @type {boolean}
     * @expose
     */

    this.required = rule === "required";
    /**
     * Message field repeated flag.
     * @type {boolean}
     * @expose
     */

    this.repeated = rule === "repeated";
    /**
     * Message field map flag.
     * @type {boolean}
     * @expose
     */

    this.map = rule === "map";
    /**
     * Message field key type. Type reference string if unresolved, protobuf
     * type if resolved. Valid only if this.map === true, null otherwise.
     * @type {string|{name: string, wireType: number}|null}
     * @expose
     */

    this.keyType = keytype || null;
    /**
     * Message field type. Type reference string if unresolved, protobuf type if
     * resolved. In a map field, this is the value type.
     * @type {string|{name: string, wireType: number}}
     * @expose
     */

    this.type = type;
    /**
     * Resolved type reference inside the global namespace.
     * @type {ProtoBuf.Reflect.T|null}
     * @expose
     */

    this.resolvedType = null;
    /**
     * Unique message field id.
     * @type {number}
     * @expose
     */

    this.id = id;
    /**
     * Message field options.
     * @type {!Object.<string,*>}
     * @dict
     * @expose
     */

    this.options = options || {};
    /**
     * Default value.
     * @type {*}
     * @expose
     */

    this.defaultValue = null;
    /**
     * Enclosing OneOf.
     * @type {?ProtoBuf.Reflect.Message.OneOf}
     * @expose
     */

    this.oneof = oneof || null;
    /**
     * Syntax level of this definition (e.g., proto3).
     * @type {string}
     * @expose
     */

    this.syntax = syntax || 'proto2';
    /**
     * Original field name.
     * @type {string}
     * @expose
     */

    this.originalName = this.name; // Used to revert camelcase transformation on naming collisions

    /**
     * Element implementation. Created in build() after types are resolved.
     * @type {ProtoBuf.Element}
     * @expose
     */

    this.element = null;
    /**
     * Key element implementation, for map fields. Created in build() after
     * types are resolved.
     * @type {ProtoBuf.Element}
     * @expose
     */

    this.keyElement = null; // Convert field names to camel case notation if the override is set

    if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField)) this.name = ProtoBuf.Util.toCamelCase(this.name);
  };
  /**
   * @alias ProtoBuf.Reflect.Message.Field.prototype
   * @inner
   */


  var FieldPrototype = Field.prototype = (0, _create.default)(T.prototype);
  /**
   * Builds the field.
   * @override
   * @expose
   */

  FieldPrototype.build = function () {
    this.element = new Element(this.type, this.resolvedType, false, this.syntax);
    if (this.map) this.keyElement = new Element(this.keyType, undefined, true, this.syntax); // In proto3, fields do not have field presence, and every field is set to
    // its type's default value ("", 0, 0.0, or false).

    if (this.syntax === 'proto3' && !this.repeated && !this.map) this.defaultValue = Element.defaultFieldValue(this.type); // Otherwise, default values are present when explicitly specified
    else if (typeof this.options['default'] !== 'undefined') this.defaultValue = this.verifyValue(this.options['default']);
  };
  /**
   * Checks if the given value can be set for this field.
   * @param {*} value Value to check
   * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.
   * @return {*} Verified, maybe adjusted, value
   * @throws {Error} If the value cannot be set for this field
   * @expose
   */


  FieldPrototype.verifyValue = function (value, skipRepeated) {
    skipRepeated = skipRepeated || false;
    var self = this;

    function fail(val, msg) {
      throw Error("Illegal value for " + self.toString(true) + " of type " + self.type.name + ": " + val + " (" + msg + ")");
    }

    if (value === null) {
      // NULL values for optional fields
      if (this.required) fail((0, _typeof2.default)(value), "required");
      if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES["message"]) fail((0, _typeof2.default)(value), "proto3 field without field presence cannot be null");
      return null;
    }

    var i;

    if (this.repeated && !skipRepeated) {
      // Repeated values as arrays
      if (!(0, _isArray.default)(value)) value = [value];
      var res = [];

      for (i = 0; i < value.length; i++) {
        res.push(this.element.verifyValue(value[i]));
      }

      return res;
    }

    if (this.map && !skipRepeated) {
      // Map values as objects
      if (!(value instanceof ProtoBuf.Map)) {
        // If not already a Map, attempt to convert.
        if (!(value instanceof Object)) {
          fail((0, _typeof2.default)(value), "expected ProtoBuf.Map or raw object for map field");
        }

        return new ProtoBuf.Map(this, value);
      } else {
        return value;
      }
    } // All non-repeated fields expect no array


    if (!this.repeated && (0, _isArray.default)(value)) fail((0, _typeof2.default)(value), "no array expected");
    return this.element.verifyValue(value);
  };
  /**
   * Determines whether the field will have a presence on the wire given its
   * value.
   * @param {*} value Verified field value
   * @param {!ProtoBuf.Builder.Message} message Runtime message
   * @return {boolean} Whether the field will be present on the wire
   */


  FieldPrototype.hasWirePresence = function (value, message) {
    if (this.syntax !== 'proto3') return value !== null;
    if (this.oneof && message[this.oneof.name] === this.name) return true;

    switch (this.type) {
      case ProtoBuf.TYPES["int32"]:
      case ProtoBuf.TYPES["sint32"]:
      case ProtoBuf.TYPES["sfixed32"]:
      case ProtoBuf.TYPES["uint32"]:
      case ProtoBuf.TYPES["fixed32"]:
        return value !== 0;

      case ProtoBuf.TYPES["int64"]:
      case ProtoBuf.TYPES["sint64"]:
      case ProtoBuf.TYPES["sfixed64"]:
      case ProtoBuf.TYPES["uint64"]:
      case ProtoBuf.TYPES["fixed64"]:
        return value.low !== 0 || value.high !== 0;

      case ProtoBuf.TYPES["bool"]:
        return value;

      case ProtoBuf.TYPES["float"]:
      case ProtoBuf.TYPES["double"]:
        return value !== 0.0;

      case ProtoBuf.TYPES["string"]:
        return value.length > 0;

      case ProtoBuf.TYPES["bytes"]:
        return value.remaining() > 0;

      case ProtoBuf.TYPES["enum"]:
        return value !== 0;

      case ProtoBuf.TYPES["message"]:
        return value !== null;

      default:
        return true;
    }
  };
  /**
   * Encodes the specified field value to the specified buffer.
   * @param {*} value Verified field value
   * @param {ByteBuffer} buffer ByteBuffer to encode to
   * @param {!ProtoBuf.Builder.Message} message Runtime message
   * @return {ByteBuffer} The ByteBuffer for chaining
   * @throws {Error} If the field cannot be encoded
   * @expose
   */


  FieldPrototype.encode = function (value, buffer, message) {
    if (this.type === null || (0, _typeof2.default)(this.type) !== 'object') throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
    if (value === null || this.repeated && value.length == 0) return buffer; // Optional omitted

    try {
      if (this.repeated) {
        var i; // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
        // types) can be declared 'packed'."

        if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
          // "All of the elements of the field are packed into a single key-value pair with wire type 2
          // (length-delimited). Each element is encoded the same way it would be normally, except without a
          // tag preceding it."
          buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
          buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1

          var start = buffer.offset; // Remember where the contents begin

          for (i = 0; i < value.length; i++) {
            this.element.encodeValue(this.id, value[i], buffer);
          }

          var len = buffer.offset - start,
              varintLen = ByteBuffer.calculateVarint32(len);

          if (varintLen > 1) {
            // We need to move the contents
            var contents = buffer.slice(start, buffer.offset);
            start += varintLen - 1;
            buffer.offset = start;
            buffer.append(contents);
          }

          buffer.writeVarint32(len, start - varintLen);
        } else {
          // "If your message definition has repeated elements (without the [packed=true] option), the encoded
          // message has zero or more key-value pairs with the same tag number"
          for (i = 0; i < value.length; i++) {
            buffer.writeVarint32(this.id << 3 | this.type.wireType), this.element.encodeValue(this.id, value[i], buffer);
          }
        }
      } else if (this.map) {
        // Write out each map entry as a submessage.
        value.forEach(function (val, key, m) {
          // Compute the length of the submessage (key, val) pair.
          var length = ByteBuffer.calculateVarint32(1 << 3 | this.keyType.wireType) + this.keyElement.calculateLength(1, key) + ByteBuffer.calculateVarint32(2 << 3 | this.type.wireType) + this.element.calculateLength(2, val); // Submessage with wire type of length-delimited.

          buffer.writeVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
          buffer.writeVarint32(length); // Write out the key and val.

          buffer.writeVarint32(1 << 3 | this.keyType.wireType);
          this.keyElement.encodeValue(1, key, buffer);
          buffer.writeVarint32(2 << 3 | this.type.wireType);
          this.element.encodeValue(2, val, buffer);
        }, this);
      } else {
        if (this.hasWirePresence(value, message)) {
          buffer.writeVarint32(this.id << 3 | this.type.wireType);
          this.element.encodeValue(this.id, value, buffer);
        }
      }
    } catch (e) {
      throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
    }

    return buffer;
  };
  /**
   * Calculates the length of this field's value on the network level.
   * @param {*} value Field value
   * @param {!ProtoBuf.Builder.Message} message Runtime message
   * @returns {number} Byte length
   * @expose
   */


  FieldPrototype.calculate = function (value, message) {
    value = this.verifyValue(value); // May throw

    if (this.type === null || (0, _typeof2.default)(this.type) !== 'object') throw Error("[INTERNAL] Unresolved type in " + this.toString(true) + ": " + this.type);
    if (value === null || this.repeated && value.length == 0) return 0; // Optional omitted

    var n = 0;

    try {
      if (this.repeated) {
        var i, ni;

        if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
          n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
          ni = 0;

          for (i = 0; i < value.length; i++) {
            ni += this.element.calculateLength(this.id, value[i]);
          }

          n += ByteBuffer.calculateVarint32(ni);
          n += ni;
        } else {
          for (i = 0; i < value.length; i++) {
            n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType), n += this.element.calculateLength(this.id, value[i]);
          }
        }
      } else if (this.map) {
        // Each map entry becomes a submessage.
        value.forEach(function (val, key, m) {
          // Compute the length of the submessage (key, val) pair.
          var length = ByteBuffer.calculateVarint32(1 << 3 | this.keyType.wireType) + this.keyElement.calculateLength(1, key) + ByteBuffer.calculateVarint32(2 << 3 | this.type.wireType) + this.element.calculateLength(2, val);
          n += ByteBuffer.calculateVarint32(this.id << 3 | ProtoBuf.WIRE_TYPES.LDELIM);
          n += ByteBuffer.calculateVarint32(length);
          n += length;
        }, this);
      } else {
        if (this.hasWirePresence(value, message)) {
          n += ByteBuffer.calculateVarint32(this.id << 3 | this.type.wireType);
          n += this.element.calculateLength(this.id, value);
        }
      }
    } catch (e) {
      throw Error("Illegal value for " + this.toString(true) + ": " + value + " (" + e + ")");
    }

    return n;
  };
  /**
   * Decode the field value from the specified buffer.
   * @param {number} wireType Leading wire type
   * @param {ByteBuffer} buffer ByteBuffer to decode from
   * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.
   * @return {*} Decoded value: array for packed repeated fields, [key, value] for
   *             map fields, or an individual value otherwise.
   * @throws {Error} If the field cannot be decoded
   * @expose
   */


  FieldPrototype.decode = function (wireType, buffer, skipRepeated) {
    var value, nBytes; // We expect wireType to match the underlying type's wireType unless we see
    // a packed repeated field, or unless this is a map field.

    var wireTypeOK = !this.map && wireType == this.type.wireType || !skipRepeated && this.repeated && this.options["packed"] && wireType == ProtoBuf.WIRE_TYPES.LDELIM || this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM;
    if (!wireTypeOK) throw Error("Illegal wire type for field " + this.toString(true) + ": " + wireType + " (" + this.type.wireType + " expected)"); // Handle packed repeated fields.

    if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
      if (!skipRepeated) {
        nBytes = buffer.readVarint32();
        nBytes = buffer.offset + nBytes; // Limit

        var values = [];

        while (buffer.offset < nBytes) {
          values.push(this.decode(this.type.wireType, buffer, true));
        }

        return values;
      } // Read the next value otherwise...

    } // Handle maps.


    if (this.map) {
      // Read one (key, value) submessage, and return [key, value]
      var key = Element.defaultFieldValue(this.keyType);
      value = Element.defaultFieldValue(this.type); // Read the length

      nBytes = buffer.readVarint32();
      if (buffer.remaining() < nBytes) throw Error("Illegal number of bytes for " + this.toString(true) + ": " + nBytes + " required but got only " + buffer.remaining()); // Get a sub-buffer of this key/value submessage

      var msgbuf = buffer.clone();
      msgbuf.limit = msgbuf.offset + nBytes;
      buffer.offset += nBytes;

      while (msgbuf.remaining() > 0) {
        var tag = msgbuf.readVarint32();
        wireType = tag & 0x07;
        var id = tag >>> 3;

        if (id === 1) {
          key = this.keyElement.decode(msgbuf, wireType, id);
        } else if (id === 2) {
          value = this.element.decode(msgbuf, wireType, id);
        } else {
          throw Error("Unexpected tag in map field key/value submessage");
        }
      }

      return [key, value];
    } // Handle singular and non-packed repeated field values.


    return this.element.decode(buffer, wireType, this.id);
  };
  /**
   * @alias ProtoBuf.Reflect.Message.Field
   * @expose
   */


  Reflect.Message.Field = Field;
  /**
   * Constructs a new Message ExtensionField.
   * @exports ProtoBuf.Reflect.Message.ExtensionField
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.Message} message Message reference
   * @param {string} rule Rule, one of requried, optional, repeated
   * @param {string} type Data type, e.g. int32
   * @param {string} name Field name
   * @param {number} id Unique field id
   * @param {!Object.<string,*>=} options Options
   * @constructor
   * @extends ProtoBuf.Reflect.Message.Field
   */

  var ExtensionField = function ExtensionField(builder, message, rule, type, name, id, options) {
    Field.call(this, builder, message, rule,
    /* keytype = */
    null, type, name, id, options);
    /**
     * Extension reference.
     * @type {!ProtoBuf.Reflect.Extension}
     * @expose
     */

    this.extension;
  }; // Extends Field


  ExtensionField.prototype = (0, _create.default)(Field.prototype);
  /**
   * @alias ProtoBuf.Reflect.Message.ExtensionField
   * @expose
   */

  Reflect.Message.ExtensionField = ExtensionField;
  /**
   * Constructs a new Message OneOf.
   * @exports ProtoBuf.Reflect.Message.OneOf
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.Message} message Message reference
   * @param {string} name OneOf name
   * @constructor
   * @extends ProtoBuf.Reflect.T
   */

  var OneOf = function OneOf(builder, message, name) {
    T.call(this, builder, message, name);
    /**
     * Enclosed fields.
     * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}
     * @expose
     */

    this.fields = [];
  };
  /**
   * @alias ProtoBuf.Reflect.Message.OneOf
   * @expose
   */


  Reflect.Message.OneOf = OneOf;
  /**
   * Constructs a new Enum.
   * @exports ProtoBuf.Reflect.Enum
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object
   * @param {string} name Enum name
   * @param {Object.<string,*>=} options Enum options
   * @param {string?} syntax The syntax level (e.g., proto3)
   * @constructor
   * @extends ProtoBuf.Reflect.Namespace
   */

  var Enum = function Enum(builder, parent, name, options, syntax) {
    Namespace.call(this, builder, parent, name, options, syntax);
    /**
     * @override
     */

    this.className = "Enum";
    /**
     * Runtime enum object.
     * @type {Object.<string,number>|null}
     * @expose
     */

    this.object = null;
  };
  /**
   * Gets the string name of an enum value.
   * @param {!ProtoBuf.Builder.Enum} enm Runtime enum
   * @param {number} value Enum value
   * @returns {?string} Name or `null` if not present
   * @expose
   */


  Enum.getName = function (enm, value) {
    var keys = (0, _keys.default)(enm);

    for (var i = 0, key; i < keys.length; ++i) {
      if (enm[key = keys[i]] === value) return key;
    }

    return null;
  };
  /**
   * @alias ProtoBuf.Reflect.Enum.prototype
   * @inner
   */


  var EnumPrototype = Enum.prototype = (0, _create.default)(Namespace.prototype);
  /**
   * Builds this enum and returns the runtime counterpart.
   * @param {boolean} rebuild Whether to rebuild or not, defaults to false
   * @returns {!Object.<string,number>}
   * @expose
   */

  EnumPrototype.build = function (rebuild) {
    if (this.object && !rebuild) return this.object;
    var enm = new ProtoBuf.Builder.Enum(),
        values = this.getChildren(Enum.Value);

    for (var i = 0, k = values.length; i < k; ++i) {
      enm[values[i]['name']] = values[i]['id'];
    }

    if (_defineProperty.default) (0, _defineProperty.default)(enm, '$options', {
      "value": this.buildOpt(),
      "enumerable": false
    });
    return this.object = enm;
  };
  /**
   * @alias ProtoBuf.Reflect.Enum
   * @expose
   */


  Reflect.Enum = Enum;
  /**
   * Constructs a new Enum Value.
   * @exports ProtoBuf.Reflect.Enum.Value
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.Enum} enm Enum reference
   * @param {string} name Field name
   * @param {number} id Unique field id
   * @constructor
   * @extends ProtoBuf.Reflect.T
   */

  var Value = function Value(builder, enm, name, id) {
    T.call(this, builder, enm, name);
    /**
     * @override
     */

    this.className = "Enum.Value";
    /**
     * Unique enum value id.
     * @type {number}
     * @expose
     */

    this.id = id;
  }; // Extends T


  Value.prototype = (0, _create.default)(T.prototype);
  /**
   * @alias ProtoBuf.Reflect.Enum.Value
   * @expose
   */

  Reflect.Enum.Value = Value;
  /**
   * An extension (field).
   * @exports ProtoBuf.Reflect.Extension
   * @constructor
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.T} parent Parent object
   * @param {string} name Object name
   * @param {!ProtoBuf.Reflect.Message.Field} field Extension field
   */

  var Extension = function Extension(builder, parent, name, field) {
    T.call(this, builder, parent, name);
    /**
     * Extended message field.
     * @type {!ProtoBuf.Reflect.Message.Field}
     * @expose
     */

    this.field = field;
  }; // Extends T


  Extension.prototype = (0, _create.default)(T.prototype);
  /**
   * @alias ProtoBuf.Reflect.Extension
   * @expose
   */

  Reflect.Extension = Extension;
  /**
   * Constructs a new Service.
   * @exports ProtoBuf.Reflect.Service
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.Namespace} root Root
   * @param {string} name Service name
   * @param {Object.<string,*>=} options Options
   * @constructor
   * @extends ProtoBuf.Reflect.Namespace
   */

  var Service = function Service(builder, root, name, options) {
    Namespace.call(this, builder, root, name, options);
    /**
     * @override
     */

    this.className = "Service";
    /**
     * Built runtime service class.
     * @type {?function(new:ProtoBuf.Builder.Service)}
     */

    this.clazz = null;
  };
  /**
   * @alias ProtoBuf.Reflect.Service.prototype
   * @inner
   */


  var ServicePrototype = Service.prototype = (0, _create.default)(Namespace.prototype);
  /**
   * Builds the service and returns the runtime counterpart, which is a fully functional class.
   * @see ProtoBuf.Builder.Service
   * @param {boolean=} rebuild Whether to rebuild or not
   * @return {Function} Service class
   * @throws {Error} If the message cannot be built
   * @expose
   */

  ServicePrototype.build = function (rebuild) {
    if (this.clazz && !rebuild) return this.clazz; // Create the runtime Service class in its own scope

    return this.clazz = function (ProtoBuf, T) {
      /**
       * Constructs a new runtime Service.
       * @name ProtoBuf.Builder.Service
       * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
       * @class Barebone of all runtime services.
       * @constructor
       * @throws {Error} If the service cannot be created
       */
      var Service = function Service(rpcImpl) {
        ProtoBuf.Builder.Service.call(this);
        /**
         * Service implementation.
         * @name ProtoBuf.Builder.Service#rpcImpl
         * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
         * @expose
         */

        this.rpcImpl = rpcImpl || function (name, msg, callback) {
          // This is what a user has to implement: A function receiving the method name, the actual message to
          // send (type checked) and the callback that's either provided with the error as its first
          // argument or null and the actual response message.
          setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
        };
      };
      /**
       * @alias ProtoBuf.Builder.Service.prototype
       * @inner
       */


      var ServicePrototype = Service.prototype = (0, _create.default)(ProtoBuf.Builder.Service.prototype);
      /**
       * Asynchronously performs an RPC call using the given RPC implementation.
       * @name ProtoBuf.Builder.Service.[Method]
       * @function
       * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
       * @param {ProtoBuf.Builder.Message} req Request
       * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
       *  the error if any and the response either as a pre-parsed message or as its raw bytes
       * @abstract
       */

      /**
       * Asynchronously performs an RPC call using the instance's RPC implementation.
       * @name ProtoBuf.Builder.Service#[Method]
       * @function
       * @param {ProtoBuf.Builder.Message} req Request
       * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
       *  the error if any and the response either as a pre-parsed message or as its raw bytes
       * @abstract
       */

      var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);

      for (var i = 0; i < rpc.length; i++) {
        (function (method) {
          // service#Method(message, callback)
          ServicePrototype[method.name] = function (req, callback) {
            try {
              try {
                // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
                req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));
              } catch (err) {
                if (!(err instanceof TypeError)) throw err;
              }

              if (req === null || (0, _typeof2.default)(req) !== 'object') throw Error("Illegal arguments");
              if (!(req instanceof method.resolvedRequestType.clazz)) req = new method.resolvedRequestType.clazz(req);
              this.rpcImpl(method.fqn(), req, function (err, res) {
                // Assumes that this is properly async
                if (err) {
                  callback(err);
                  return;
                } // Coalesce to empty string when service response has empty content


                if (res === null) res = '';

                try {
                  res = method.resolvedResponseType.clazz.decode(res);
                } catch (notABuffer) {}

                if (!res || !(res instanceof method.resolvedResponseType.clazz)) {
                  callback(Error("Illegal response type received in service method " + T.name + "#" + method.name));
                  return;
                }

                callback(null, res);
              });
            } catch (err) {
              setTimeout(callback.bind(this, err), 0);
            }
          }; // Service.Method(rpcImpl, message, callback)


          Service[method.name] = function (rpcImpl, req, callback) {
            new Service(rpcImpl)[method.name](req, callback);
          };

          if (_defineProperty.default) (0, _defineProperty.default)(Service[method.name], "$options", {
            "value": method.buildOpt()
          }), (0, _defineProperty.default)(ServicePrototype[method.name], "$options", {
            "value": Service[method.name]["$options"]
          });
        })(rpc[i]);
      } // Properties

      /**
       * Service options.
       * @name ProtoBuf.Builder.Service.$options
       * @type {Object.<string,*>}
       * @expose
       */


      var $optionsS; // cc needs this

      /**
       * Service options.
       * @name ProtoBuf.Builder.Service#$options
       * @type {Object.<string,*>}
       * @expose
       */

      var $options;
      /**
       * Reflection type.
       * @name ProtoBuf.Builder.Service.$type
       * @type {!ProtoBuf.Reflect.Service}
       * @expose
       */

      var $typeS;
      /**
       * Reflection type.
       * @name ProtoBuf.Builder.Service#$type
       * @type {!ProtoBuf.Reflect.Service}
       * @expose
       */

      var $type;
      if (_defineProperty.default) (0, _defineProperty.default)(Service, "$options", {
        "value": T.buildOpt()
      }), (0, _defineProperty.default)(ServicePrototype, "$options", {
        "value": Service["$options"]
      }), (0, _defineProperty.default)(Service, "$type", {
        "value": T
      }), (0, _defineProperty.default)(ServicePrototype, "$type", {
        "value": T
      });
      return Service;
    }(ProtoBuf, this);
  };
  /**
   * @alias ProtoBuf.Reflect.Service
   * @expose
   */


  Reflect.Service = Service;
  /**
   * Abstract service method.
   * @exports ProtoBuf.Reflect.Service.Method
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.Service} svc Service
   * @param {string} name Method name
   * @param {Object.<string,*>=} options Options
   * @constructor
   * @extends ProtoBuf.Reflect.T
   */

  var Method = function Method(builder, svc, name, options) {
    T.call(this, builder, svc, name);
    /**
     * @override
     */

    this.className = "Service.Method";
    /**
     * Options.
     * @type {Object.<string, *>}
     * @expose
     */

    this.options = options || {};
  };
  /**
   * @alias ProtoBuf.Reflect.Service.Method.prototype
   * @inner
   */


  var MethodPrototype = Method.prototype = (0, _create.default)(T.prototype);
  /**
   * Builds the method's '$options' property.
   * @name ProtoBuf.Reflect.Service.Method#buildOpt
   * @function
   * @return {Object.<string,*>}
   */

  MethodPrototype.buildOpt = NamespacePrototype.buildOpt;
  /**
   * @alias ProtoBuf.Reflect.Service.Method
   * @expose
   */

  Reflect.Service.Method = Method;
  /**
   * RPC service method.
   * @exports ProtoBuf.Reflect.Service.RPCMethod
   * @param {!ProtoBuf.Builder} builder Builder reference
   * @param {!ProtoBuf.Reflect.Service} svc Service
   * @param {string} name Method name
   * @param {string} request Request message name
   * @param {string} response Response message name
   * @param {boolean} request_stream Whether requests are streamed
   * @param {boolean} response_stream Whether responses are streamed
   * @param {Object.<string,*>=} options Options
   * @constructor
   * @extends ProtoBuf.Reflect.Service.Method
   */

  var RPCMethod = function RPCMethod(builder, svc, name, request, response, request_stream, response_stream, options) {
    Method.call(this, builder, svc, name, options);
    /**
     * @override
     */

    this.className = "Service.RPCMethod";
    /**
     * Request message name.
     * @type {string}
     * @expose
     */

    this.requestName = request;
    /**
     * Response message name.
     * @type {string}
     * @expose
     */

    this.responseName = response;
    /**
     * Whether requests are streamed
     * @type {bool}
     * @expose
     */

    this.requestStream = request_stream;
    /**
     * Whether responses are streamed
     * @type {bool}
     * @expose
     */

    this.responseStream = response_stream;
    /**
     * Resolved request message type.
     * @type {ProtoBuf.Reflect.Message}
     * @expose
     */

    this.resolvedRequestType = null;
    /**
     * Resolved response message type.
     * @type {ProtoBuf.Reflect.Message}
     * @expose
     */

    this.resolvedResponseType = null;
  }; // Extends Method


  RPCMethod.prototype = (0, _create.default)(Method.prototype);
  /**
   * @alias ProtoBuf.Reflect.Service.RPCMethod
   * @expose
   */

  Reflect.Service.RPCMethod = RPCMethod;
  return Reflect;
}(ProtoBuf);
/**
 * @alias ProtoBuf.Builder
 * @expose
 */


ProtoBuf.Builder = function (ProtoBuf, Lang, Reflect) {
  "use strict";
  /**
   * Constructs a new Builder.
   * @exports ProtoBuf.Builder
   * @class Provides the functionality to build protocol messages.
   * @param {Object.<string,*>=} options Options
   * @constructor
   */

  var Builder = function Builder(options) {
    /**
     * Namespace.
     * @type {ProtoBuf.Reflect.Namespace}
     * @expose
     */
    this.ns = new Reflect.Namespace(this, null, ""); // Global namespace

    /**
     * Namespace pointer.
     * @type {ProtoBuf.Reflect.T}
     * @expose
     */

    this.ptr = this.ns;
    /**
     * Resolved flag.
     * @type {boolean}
     * @expose
     */

    this.resolved = false;
    /**
     * The current building result.
     * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}
     * @expose
     */

    this.result = null;
    /**
     * Imported files.
     * @type {Array.<string>}
     * @expose
     */

    this.files = {};
    /**
     * Import root override.
     * @type {?string}
     * @expose
     */

    this.importRoot = null;
    /**
     * Options.
     * @type {!Object.<string, *>}
     * @expose
     */

    this.options = options || {};
  };
  /**
   * @alias ProtoBuf.Builder.prototype
   * @inner
   */


  var BuilderPrototype = Builder.prototype; // ----- Definition tests -----

  /**
   * Tests if a definition most likely describes a message.
   * @param {!Object} def
   * @returns {boolean}
   * @expose
   */

  Builder.isMessage = function (def) {
    // Messages require a string name
    if (typeof def["name"] !== 'string') return false; // Messages do not contain values (enum) or rpc methods (service)

    if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined') return false;
    return true;
  };
  /**
   * Tests if a definition most likely describes a message field.
   * @param {!Object} def
   * @returns {boolean}
   * @expose
   */


  Builder.isMessageField = function (def) {
    // Message fields require a string rule, name and type and an id
    if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined') return false;
    return true;
  };
  /**
   * Tests if a definition most likely describes an enum.
   * @param {!Object} def
   * @returns {boolean}
   * @expose
   */


  Builder.isEnum = function (def) {
    // Enums require a string name
    if (typeof def["name"] !== 'string') return false; // Enums require at least one value

    if (typeof def["values"] === 'undefined' || !(0, _isArray.default)(def["values"]) || def["values"].length === 0) return false;
    return true;
  };
  /**
   * Tests if a definition most likely describes a service.
   * @param {!Object} def
   * @returns {boolean}
   * @expose
   */


  Builder.isService = function (def) {
    // Services require a string name and an rpc object
    if (typeof def["name"] !== 'string' || (0, _typeof2.default)(def["rpc"]) !== 'object' || !def["rpc"]) return false;
    return true;
  };
  /**
   * Tests if a definition most likely describes an extended message
   * @param {!Object} def
   * @returns {boolean}
   * @expose
   */


  Builder.isExtend = function (def) {
    // Extends rquire a string ref
    if (typeof def["ref"] !== 'string') return false;
    return true;
  }; // ----- Building -----

  /**
   * Resets the pointer to the root namespace.
   * @returns {!ProtoBuf.Builder} this
   * @expose
   */


  BuilderPrototype.reset = function () {
    this.ptr = this.ns;
    return this;
  };
  /**
   * Defines a namespace on top of the current pointer position and places the pointer on it.
   * @param {string} namespace
   * @return {!ProtoBuf.Builder} this
   * @expose
   */


  BuilderPrototype.define = function (namespace) {
    if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace)) throw Error("illegal namespace: " + namespace);
    namespace.split(".").forEach(function (part) {
      var ns = this.ptr.getChild(part);
      if (ns === null) // Keep existing
        this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));
      this.ptr = ns;
    }, this);
    return this;
  };
  /**
   * Creates the specified definitions at the current pointer position.
   * @param {!Array.<!Object>} defs Messages, enums or services to create
   * @returns {!ProtoBuf.Builder} this
   * @throws {Error} If a message definition is invalid
   * @expose
   */


  BuilderPrototype.create = function (defs) {
    if (!defs) return this; // Nothing to create

    if (!(0, _isArray.default)(defs)) defs = [defs];else {
      if (defs.length === 0) return this;
      defs = defs.slice();
    } // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.

    var stack = [defs];

    while (stack.length > 0) {
      defs = stack.pop();
      if (!(0, _isArray.default)(defs)) // Stack always contains entire namespaces
        throw Error("not a valid namespace: " + (0, _stringify.default)(defs));

      while (defs.length > 0) {
        var def = defs.shift(); // Namespaces always contain an array of messages, enums and services

        if (Builder.isMessage(def)) {
          var obj = new Reflect.Message(this, this.ptr, def["name"], def["options"], def["isGroup"], def["syntax"]); // Create OneOfs

          var oneofs = {};
          if (def["oneofs"]) (0, _keys.default)(def["oneofs"]).forEach(function (name) {
            obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));
          }, this); // Create fields

          if (def["fields"]) def["fields"].forEach(function (fld) {
            if (obj.getChild(fld["id"] | 0) !== null) throw Error("duplicate or invalid field id in " + obj.name + ": " + fld['id']);
            if (fld["options"] && (0, _typeof2.default)(fld["options"]) !== 'object') throw Error("illegal field options in " + obj.name + "#" + fld["name"]);
            var oneof = null;
            if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]])) throw Error("illegal oneof in " + obj.name + "#" + fld["name"] + ": " + fld["oneof"]);
            fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
            if (oneof) oneof.fields.push(fld);
            obj.addChild(fld);
          }, this); // Push children to stack

          var subObj = [];
          if (def["enums"]) def["enums"].forEach(function (enm) {
            subObj.push(enm);
          });
          if (def["messages"]) def["messages"].forEach(function (msg) {
            subObj.push(msg);
          });
          if (def["services"]) def["services"].forEach(function (svc) {
            subObj.push(svc);
          }); // Set extension ranges

          if (def["extensions"]) {
            if (typeof def["extensions"][0] === 'number') // pre 5.0.1
              obj.extensions = [def["extensions"]];else obj.extensions = def["extensions"];
          } // Create on top of current namespace


          this.ptr.addChild(obj);

          if (subObj.length > 0) {
            stack.push(defs); // Push the current level back

            defs = subObj; // Continue processing sub level

            subObj = null;
            this.ptr = obj; // And move the pointer to this namespace

            obj = null;
            continue;
          }

          subObj = null;
        } else if (Builder.isEnum(def)) {
          obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);
          def["values"].forEach(function (val) {
            obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));
          }, this);
          this.ptr.addChild(obj);
        } else if (Builder.isService(def)) {
          obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);
          (0, _keys.default)(def["rpc"]).forEach(function (name) {
            var mtd = def["rpc"][name];
            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
          }, this);
          this.ptr.addChild(obj);
        } else if (Builder.isExtend(def)) {
          obj = this.ptr.resolve(def["ref"], true);

          if (obj) {
            def["fields"].forEach(function (fld) {
              if (obj.getChild(fld['id'] | 0) !== null) throw Error("duplicate extended field id in " + obj.name + ": " + fld['id']); // Check if field id is allowed to be extended

              if (obj.extensions) {
                var valid = false;
                obj.extensions.forEach(function (range) {
                  if (fld["id"] >= range[0] && fld["id"] <= range[1]) valid = true;
                });
                if (!valid) throw Error("illegal extended field id in " + obj.name + ": " + fld['id'] + " (not within valid ranges)");
              } // Convert extension field names to camel case notation if the override is set


              var name = fld["name"];
              if (this.options['convertFieldsToCamelCase']) name = ProtoBuf.Util.toCamelCase(name); // see #161: Extensions use their fully qualified name as their runtime key and...

              var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn() + '.' + name, fld["id"], fld["options"]); // ...are added on top of the current namespace as an extension which is used for
              // resolving their type later on (the extension always keeps the original name to
              // prevent naming collisions)

              var ext = new Reflect.Extension(this, this.ptr, fld["name"], field);
              field.extension = ext;
              this.ptr.addChild(ext);
              obj.addChild(field);
            }, this);
          } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions
            throw Error("extended message " + def["ref"] + " is not defined");
        } else throw Error("not a valid definition: " + (0, _stringify.default)(def));

        def = null;
        obj = null;
      } // Break goes here


      defs = null;
      this.ptr = this.ptr.parent; // Namespace done, continue at parent
    }

    this.resolved = false; // Require re-resolve

    this.result = null; // Require re-build

    return this;
  };
  /**
   * Propagates syntax to all children.
   * @param {!Object} parent
   * @inner
   */


  function propagateSyntax(parent) {
    if (parent['messages']) {
      parent['messages'].forEach(function (child) {
        child["syntax"] = parent["syntax"];
        propagateSyntax(child);
      });
    }

    if (parent['enums']) {
      parent['enums'].forEach(function (child) {
        child["syntax"] = parent["syntax"];
      });
    }
  }
  /**
   * Imports another definition into this builder.
   * @param {Object.<string,*>} json Parsed import
   * @param {(string|{root: string, file: string})=} filename Imported file name
   * @returns {!ProtoBuf.Builder} this
   * @throws {Error} If the definition or file cannot be imported
   * @expose
   */


  BuilderPrototype["import"] = function (json, filename) {
    var delim = '/'; // Make sure to skip duplicate imports

    if (typeof filename === 'string') {
      if (ProtoBuf.Util.IS_NODE) filename = __webpack_require__(204)['resolve'](filename);
      if (this.files[filename] === true) return this.reset();
      this.files[filename] = true;
    } else if ((0, _typeof2.default)(filename) === 'object') {
      // Object with root, file.
      var root = filename.root;
      if (ProtoBuf.Util.IS_NODE) root = __webpack_require__(204)['resolve'](root);
      if (root.indexOf("\\") >= 0 || filename.file.indexOf("\\") >= 0) delim = '\\';
      var fname = root + delim + filename.file;
      if (this.files[fname] === true) return this.reset();
      this.files[fname] = true;
    } // Import imports


    if (json['imports'] && json['imports'].length > 0) {
      var importRoot,
          resetRoot = false;

      if ((0, _typeof2.default)(filename) === 'object') {
        // If an import root is specified, override
        this.importRoot = filename["root"];
        resetRoot = true; // ... and reset afterwards

        importRoot = this.importRoot;
        filename = filename["file"];
        if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0) delim = '\\';
      } else if (typeof filename === 'string') {
        if (this.importRoot) // If import root is overridden, use it
          importRoot = this.importRoot;else {
          // Otherwise compute from filename
          if (filename.indexOf("/") >= 0) {
            // Unix
            importRoot = filename.replace(/\/[^\/]*$/, "");
            if (
            /* /file.proto */
            importRoot === "") importRoot = "/";
          } else if (filename.indexOf("\\") >= 0) {
            // Windows
            importRoot = filename.replace(/\\[^\\]*$/, "");
            delim = '\\';
          } else importRoot = ".";
        }
      } else importRoot = null;

      for (var i = 0; i < json['imports'].length; i++) {
        if (typeof json['imports'][i] === 'string') {
          // Import file
          if (!importRoot) throw Error("cannot determine import root");
          var importFilename = json['imports'][i];
          if (importFilename === "google/protobuf/descriptor.proto") continue; // Not needed and therefore not used

          importFilename = importRoot + delim + importFilename;
          if (this.files[importFilename] === true) continue; // Already imported

          if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto) // If this is a light build
            importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file

          var contents = ProtoBuf.Util.fetch(importFilename);
          if (contents === null) throw Error("failed to import '" + importFilename + "' in '" + filename + "': file not found");
          if (/\.json$/i.test(importFilename)) // Always possible
            this["import"](JSON.parse(contents + ""), importFilename); // May throw
          else this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw
        } else // Import structure
          if (!filename) this["import"](json['imports'][i]);else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function ($0, $1, $2) {
              return $1 + "_import" + i + "." + $2;
            }));else // Without extension: Append _importN to make it unique
            this["import"](json['imports'][i], filename + "_import" + i);
      }

      if (resetRoot) // Reset import root override when all imports are done
        this.importRoot = null;
    } // Import structures


    if (json['package']) this.define(json['package']);
    if (json['syntax']) propagateSyntax(json);
    var base = this.ptr;
    if (json['options']) (0, _keys.default)(json['options']).forEach(function (key) {
      base.options[key] = json['options'][key];
    });
    if (json['messages']) this.create(json['messages']), this.ptr = base;
    if (json['enums']) this.create(json['enums']), this.ptr = base;
    if (json['services']) this.create(json['services']), this.ptr = base;
    if (json['extends']) this.create(json['extends']);
    return this.reset();
  };
  /**
   * Resolves all namespace objects.
   * @throws {Error} If a type cannot be resolved
   * @returns {!ProtoBuf.Builder} this
   * @expose
   */


  BuilderPrototype.resolveAll = function () {
    // Resolve all reflected objects
    var res;
    if (this.ptr == null || (0, _typeof2.default)(this.ptr.type) === 'object') return this; // Done (already resolved)

    if (this.ptr instanceof Reflect.Namespace) {
      // Resolve children
      this.ptr.children.forEach(function (child) {
        this.ptr = child;
        this.resolveAll();
      }, this);
    } else if (this.ptr instanceof Reflect.Message.Field) {
      // Resolve type
      if (!Lang.TYPE.test(this.ptr.type)) {
        if (!Lang.TYPEREF.test(this.ptr.type)) throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
        res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
        if (!res) throw Error("unresolvable type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
        this.ptr.resolvedType = res;

        if (res instanceof Reflect.Enum) {
          this.ptr.type = ProtoBuf.TYPES["enum"];
          if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3') throw Error("proto3 message cannot reference proto2 enum");
        } else if (res instanceof Reflect.Message) this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];else throw Error("illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.type);
      } else this.ptr.type = ProtoBuf.TYPES[this.ptr.type]; // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type
      // (i.e., no enums or messages), so we don't need to resolve against the current namespace.


      if (this.ptr.map) {
        if (!Lang.TYPE.test(this.ptr.keyType)) throw Error("illegal key type for map field in " + this.ptr.toString(true) + ": " + this.ptr.keyType);
        this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];
      }
    } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {
      if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {
        res = this.ptr.parent.resolve(this.ptr.requestName, true);
        if (!res || !(res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.requestName);
        this.ptr.resolvedRequestType = res;
        res = this.ptr.parent.resolve(this.ptr.responseName, true);
        if (!res || !(res instanceof ProtoBuf.Reflect.Message)) throw Error("Illegal type reference in " + this.ptr.toString(true) + ": " + this.ptr.responseName);
        this.ptr.resolvedResponseType = res;
      } else // Should not happen as nothing else is implemented
        throw Error("illegal service type in " + this.ptr.toString(true));
    } else if (!(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built
    !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built
    !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum
    ) throw Error("illegal object in namespace: " + (0, _typeof2.default)(this.ptr) + ": " + this.ptr);

    return this.reset();
  };
  /**
   * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,
   * return the built package.
   * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.
   * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}
   * @throws {Error} If a type could not be resolved
   * @expose
   */


  BuilderPrototype.build = function (path) {
    this.reset();
    if (!this.resolved) this.resolveAll(), this.resolved = true, this.result = null; // Require re-build

    if (this.result === null) // (Re-)Build
      this.result = this.ns.build();
    if (!path) return this.result;
    var part = typeof path === 'string' ? path.split(".") : path,
        ptr = this.result; // Build namespace pointer (no hasChild etc.)

    for (var i = 0; i < part.length; i++) {
      if (ptr[part[i]]) ptr = ptr[part[i]];else {
        ptr = null;
        break;
      }
    }

    return ptr;
  };
  /**
   * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.
   * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.
   * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`
   * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found
   */


  BuilderPrototype.lookup = function (path, excludeNonNamespace) {
    return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;
  };
  /**
   * Returns a string representation of this object.
   * @return {string} String representation as of "Builder"
   * @expose
   */


  BuilderPrototype.toString = function () {
    return "Builder";
  }; // ----- Base classes -----
  // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.

  /**
   * @alias ProtoBuf.Builder.Message
   */


  Builder.Message = function () {};
  /**
   * @alias ProtoBuf.Builder.Enum
   */


  Builder.Enum = function () {};
  /**
   * @alias ProtoBuf.Builder.Message
   */


  Builder.Service = function () {};

  return Builder;
}(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);
/**
 * @alias ProtoBuf.Map
 * @expose
 */


ProtoBuf.Map = function (ProtoBuf, Reflect) {
  "use strict";
  /**
   * Constructs a new Map. A Map is a container that is used to implement map
   * fields on message objects. It closely follows the ES6 Map API; however,
   * it is distinct because we do not want to depend on external polyfills or
   * on ES6 itself.
   *
   * @exports ProtoBuf.Map
   * @param {!ProtoBuf.Reflect.Field} field Map field
   * @param {Object.<string,*>=} contents Initial contents
   * @constructor
   */

  var Map = function Map(field, contents) {
    if (!field.map) throw Error("field is not a map");
    /**
     * The field corresponding to this map.
     * @type {!ProtoBuf.Reflect.Field}
     */

    this.field = field;
    /**
     * Element instance corresponding to key type.
     * @type {!ProtoBuf.Reflect.Element}
     */

    this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);
    /**
     * Element instance corresponding to value type.
     * @type {!ProtoBuf.Reflect.Element}
     */

    this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);
    /**
     * Internal map: stores mapping of (string form of key) -> (key, value)
     * pair.
     *
     * We provide map semantics for arbitrary key types, but we build on top
     * of an Object, which has only string keys. In order to avoid the need
     * to convert a string key back to its native type in many situations,
     * we store the native key value alongside the value. Thus, we only need
     * a one-way mapping from a key type to its string form that guarantees
     * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1
     * === K2).
     *
     * @type {!Object<string, {key: *, value: *}>}
     */

    this.map = {};
    /**
     * Returns the number of elements in the map.
     */

    (0, _defineProperty.default)(this, "size", {
      get: function get() {
        return (0, _keys.default)(this.map).length;
      }
    }); // Fill initial contents from a raw object.

    if (contents) {
      var keys = (0, _keys.default)(contents);

      for (var i = 0; i < keys.length; i++) {
        var key = this.keyElem.valueFromString(keys[i]);
        var val = this.valueElem.verifyValue(contents[keys[i]]);
        this.map[this.keyElem.valueToString(key)] = {
          key: key,
          value: val
        };
      }
    }
  };

  var MapPrototype = Map.prototype;
  /**
   * Helper: return an iterator over an array.
   * @param {!Array<*>} arr the array
   * @returns {!Object} an iterator
   * @inner
   */

  function arrayIterator(arr) {
    var idx = 0;
    return {
      next: function next() {
        if (idx < arr.length) return {
          done: false,
          value: arr[idx++]
        };
        return {
          done: true
        };
      }
    };
  }
  /**
   * Clears the map.
   */


  MapPrototype.clear = function () {
    this.map = {};
  };
  /**
   * Deletes a particular key from the map.
   * @returns {boolean} Whether any entry with this key was deleted.
   */


  MapPrototype["delete"] = function (key) {
    var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
    var hadKey = keyValue in this.map;
    delete this.map[keyValue];
    return hadKey;
  };
  /**
   * Returns an iterator over [key, value] pairs in the map.
   * @returns {Object} The iterator
   */


  MapPrototype.entries = function () {
    var entries = [];
    var strKeys = (0, _keys.default)(this.map);

    for (var i = 0, entry; i < strKeys.length; i++) {
      entries.push([(entry = this.map[strKeys[i]]).key, entry.value]);
    }

    return arrayIterator(entries);
  };
  /**
   * Returns an iterator over keys in the map.
   * @returns {Object} The iterator
   */


  MapPrototype.keys = function () {
    var keys = [];
    var strKeys = (0, _keys.default)(this.map);

    for (var i = 0; i < strKeys.length; i++) {
      keys.push(this.map[strKeys[i]].key);
    }

    return arrayIterator(keys);
  };
  /**
   * Returns an iterator over values in the map.
   * @returns {!Object} The iterator
   */


  MapPrototype.values = function () {
    var values = [];
    var strKeys = (0, _keys.default)(this.map);

    for (var i = 0; i < strKeys.length; i++) {
      values.push(this.map[strKeys[i]].value);
    }

    return arrayIterator(values);
  };
  /**
   * Iterates over entries in the map, calling a function on each.
   * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.
   * @param {Object=} thisArg The `this` value for the callback
   */


  MapPrototype.forEach = function (cb, thisArg) {
    var strKeys = (0, _keys.default)(this.map);

    for (var i = 0, entry; i < strKeys.length; i++) {
      cb.call(thisArg, (entry = this.map[strKeys[i]]).value, entry.key, this);
    }
  };
  /**
   * Sets a key in the map to the given value.
   * @param {*} key The key
   * @param {*} value The value
   * @returns {!ProtoBuf.Map} The map instance
   */


  MapPrototype.set = function (key, value) {
    var keyValue = this.keyElem.verifyValue(key);
    var valValue = this.valueElem.verifyValue(value);
    this.map[this.keyElem.valueToString(keyValue)] = {
      key: keyValue,
      value: valValue
    };
    return this;
  };
  /**
   * Gets the value corresponding to a key in the map.
   * @param {*} key The key
   * @returns {*|undefined} The value, or `undefined` if key not present
   */


  MapPrototype.get = function (key) {
    var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
    if (!(keyValue in this.map)) return undefined;
    return this.map[keyValue].value;
  };
  /**
   * Determines whether the given key is present in the map.
   * @param {*} key The key
   * @returns {boolean} `true` if the key is present
   */


  MapPrototype.has = function (key) {
    var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));
    return keyValue in this.map;
  };

  return Map;
}(ProtoBuf, ProtoBuf.Reflect);
/**
 * Loads a .proto string and returns the Builder.
 * @param {string} proto .proto file contents
 * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
 * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
 * @return {ProtoBuf.Builder} Builder to create new messages
 * @throws {Error} If the definition cannot be parsed or built
 * @expose
 */


ProtoBuf.loadProto = function (proto, builder, filename) {
  if (typeof builder === 'string' || builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string') filename = builder, builder = undefined;
  return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);
};
/**
 * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.
 * @function
 * @param {string} proto .proto file contents
 * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.
 * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
 * @return {ProtoBuf.Builder} Builder to create new messages
 * @throws {Error} If the definition cannot be parsed or built
 * @expose
 */


ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy

/**
 * Loads a .proto file and returns the Builder.
 * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
 *  an overridden 'root' path for all imported files.
 * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
 *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
 *  file will be read synchronously and this function will return the Builder.
 * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
 * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
 *   request has failed), else undefined
 * @expose
 */

ProtoBuf.loadProtoFile = function (filename, callback, builder) {
  if (callback && (0, _typeof2.default)(callback) === 'object') builder = callback, callback = null;else if (!callback || typeof callback !== 'function') callback = null;
  if (callback) return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
    if (contents === null) {
      callback(Error("Failed to fetch file"));
      return;
    }

    try {
      callback(null, ProtoBuf.loadProto(contents, builder, filename));
    } catch (e) {
      callback(e);
    }
  });
  var contents = ProtoBuf.Util.fetch((0, _typeof2.default)(filename) === 'object' ? filename["root"] + "/" + filename["file"] : filename);
  return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);
};
/**
 * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.
 * @function
 * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with
 *  an overridden 'root' path for all imported files.
 * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
 *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
 *  file will be read synchronously and this function will return the Builder.
 * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
 * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
 *   request has failed), else undefined
 * @expose
 */


ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy

/**
 * Constructs a new empty Builder.
 * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf
 * @return {!ProtoBuf.Builder} Builder
 * @expose
 */

ProtoBuf.newBuilder = function (options) {
  options = options || {};
  if (typeof options['convertFieldsToCamelCase'] === 'undefined') options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;
  if (typeof options['populateAccessors'] === 'undefined') options['populateAccessors'] = ProtoBuf.populateAccessors;
  return new ProtoBuf.Builder(options);
};
/**
 * Loads a .json definition and returns the Builder.
 * @param {!*|string} json JSON definition
 * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
 * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
 * @return {ProtoBuf.Builder} Builder to create new messages
 * @throws {Error} If the definition cannot be parsed or built
 * @expose
 */


ProtoBuf.loadJson = function (json, builder, filename) {
  if (typeof builder === 'string' || builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string') filename = builder, builder = null;
  if (!builder || (0, _typeof2.default)(builder) !== 'object') builder = ProtoBuf.newBuilder();
  if (typeof json === 'string') json = JSON.parse(json);
  builder["import"](json, filename);
  builder.resolveAll();
  return builder;
};
/**
 * Loads a .json file and returns the Builder.
 * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with
 *  an overridden 'root' path for all imported files.
 * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and
 *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the
 *  file will be read synchronously and this function will return the Builder.
 * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.
 * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the
 *   request has failed), else undefined
 * @expose
 */


ProtoBuf.loadJsonFile = function (filename, callback, builder) {
  if (callback && (0, _typeof2.default)(callback) === 'object') builder = callback, callback = null;else if (!callback || typeof callback !== 'function') callback = null;
  if (callback) return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"] + "/" + filename["file"], function (contents) {
    if (contents === null) {
      callback(Error("Failed to fetch file"));
      return;
    }

    try {
      callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));
    } catch (e) {
      callback(e);
    }
  });
  var contents = ProtoBuf.Util.fetch((0, _typeof2.default)(filename) === 'object' ? filename["root"] + "/" + filename["file"] : filename);
  return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);
}; // window["ProtoBuf"] = ProtoBuf;
//    return ProtoBuf;
//});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(147)))

/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(22);

$export($export.P, 'Array', { fill: __webpack_require__(142) });

__webpack_require__(175)('fill');


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

__webpack_require__(53);

__webpack_require__(13);

__webpack_require__(8);

var _assign = _interopRequireDefault(__webpack_require__(11));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMLanguageType = _interopRequireDefault(__webpack_require__(80));

var _FMGroup = _interopRequireDefault(__webpack_require__(209));

/**
 *	FMScene 是对地图Scene元素进行数据管理 
 *  
 * 	@class FMScene
 *	@constructor
 * 	@module FMScene
 */
var FMScene =
/*#__PURE__*/
function () {
  function FMScene(id, data, nm) {
    (0, _classCallCheck2.default)(this, FMScene);
    this.groups = {};
    this._id = id;
    this._center = new fm.Vector2();
    this._mapcenter = new fm.Vector2(data.scene.x, data.scene.y);
    this._theme = null;
    this.parent = nm;
    this.layerGroups = data.scene.layerGroups;
    this._bbox = {
      max: new fm.Vector2(-Infinity, -Infinity),
      min: new fm.Vector2(Infinity, Infinity)
    };
    this._bboxTh = {
      max: new fm.Vector2(-Infinity, -Infinity),
      min: new fm.Vector2(Infinity, Infinity)
    };
    this._bbox.max.x = data.scene.maxX;
    this._bbox.max.y = data.scene.maxY;
    this._bbox.min.x = data.scene.minX;
    this._bbox.min.y = data.scene.minY;
    this._bboxTh.max.x = data.scene.maxX - data.scene.x;
    this._bboxTh.max.y = data.scene.maxY - data.scene.y;
    this._bboxTh.min.x = data.scene.minX - data.scene.x;
    this._bboxTh.min.y = data.scene.minY - data.scene.y;
    this._groupIds = [];
    this.initGroupByData(data);
    this._spcace = (0, _parseInt2.default)(data.scene.layerGroups[0].height);
  }

  (0, _createClass2.default)(FMScene, [{
    key: "getNeedLoadGroup",
    value: function getNeedLoadGroup(gids, opposite) {
      var loadGroup = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this.layerGroups), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var gdata = _step.value;
          var pass = gids.indexOf(gdata.gid) > -1;

          if (opposite) {
            pass = !pass;
          }

          if (!gdata.loaded && pass) {
            //
            loadGroup.push({
              gid: gdata.gid,
              url: this.getGroupLoadUrl(gdata.gname, gdata.gid),
              layerData: gdata
            });
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return loadGroup;
    }
  }, {
    key: "getGroupLoadUrl",
    value: function getGroupLoadUrl(gname, id) {
      // let type = gname.substring(0,1);
      return "floor." + gname; // switch(type) {
      //    case "g" :
      //         // return "floor." + this.getLastAndNextName(gname, id);
      //    case "m" :
      //         // return "floor." + this.getLastAndNextName(gname, id);
      //    case "f" :
      //    case "b" : 
      //         return "floor." + gname;
      // }
    }
  }, {
    key: "getLastAndNextName",
    value: function getLastAndNextName(gname, gid) {
      var name = "" + gname;
      var last, next;
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator2.default)(this.layerGroups), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var layer = _step2.value;

          if (layer.gid === gid - 1) {
            last = "_" + layer.gname;
          }

          if (layer.gid === gid + 1) {
            next = "_" + layer.gname;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (!last) {
        last = "_no";
      }

      if (!next) {
        next = "_no";
      }

      name += last + next;
      return name;
    }
    /**
     * 初始化group 
     * @param {*} data 
     */

  }, {
    key: "initGroupByData",
    value: function initGroupByData(data) {
      var floors = data.floors;
      this._groupLength = floors.length;

      for (var i = 0; i < floors.length; i++) {
        this.addGroup(floors[i].gid, floors[i], data.scene.layerGroups[i]);
      }
    }
  }, {
    key: "addGroup",
    value: function addGroup(id, floor, groupdata) {
      this._groupIds.push(id);

      var group = new _FMGroup.default(id, floor, groupdata);
      group.hideWithFree = this.parent.map.MapOptions.autoDispose;
      group.parent = this;
      var floornum = (0, _parseInt2.default)(id);
      group.height = this._space * floornum;

      if (this.parent.map.visibleGroupIDs.indexOf(id) > -1) {
        group.visible = true;
      } else {
        group.visible = false;
      }

      this.groups[id + ""] = group;
    }
  }, {
    key: "changeTheme",
    value: function changeTheme(themeManager, materialManager) {
      var _this = this;

      this._theme = themeManager;
      var alias = ['extent', 'model', 'label', 'facility'];
      var ntheme;

      var _loop = function _loop(g) {
        _this.groups[g].traverseByAlias(alias, function (node, alias) {
          switch (alias) {
            case 'extent':
              ntheme = themeManager;
              break;

            case 'model':
              if (_this.parent.map.MapOptions.useStoreApply) {
                ntheme = themeManager.getStoreApplyTheme(node.bdata.fid);
              } else {
                ntheme = undefined;
              }

              !ntheme && (ntheme = themeManager.getModelTheme(node.bdata));
              ntheme = (0, _assign.default)(ntheme, {
                logoPath: themeManager.data.logoPath
              });
              break;

            case 'label':
              ntheme = themeManager.getLabelTheme(node.bdata);
              break;

            case 'facility':
              ntheme = themeManager.getPoiTheme(node.bdata);
              break;
          }

          if (node.renderNodeInited) {
            node.setByTheme(ntheme);

            _this.parent.checkMaterialAlpha(node.renderNode, (0, _parseInt2.default)(g));

            if (alias == "model") {
              _this.parent.checkMaterialAlpha(node.line, (0, _parseInt2.default)(g));
            }
          }
        });
      };

      for (var g in this.groups) {
        _loop(g);
      }
    }
  }, {
    key: "getAllGroupLayerByAlias",
    value: function getAllGroupLayerByAlias(alias, back) {
      for (var g in this.groups) {
        var layers = this.groups[g].layers[alias];
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _getIterator2.default)(layers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var layer = _step3.value;
            back(layer);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    }
    /**
     * 获得标注层
     * @param {*} gids 
     * @param {*} filter 
     */

  }, {
    key: "getFacilityByFilter",
    value: function getFacilityByFilter(gids, filter) {
      var facilitys = [];
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(gids), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var gid = _step4.value;
          var group = this.groups[gid];

          if (!group) {
            continue;
          }

          var alias = ['imageMarker', 'textMarker', 'facility'];

          for (var _i = 0, _alias = alias; _i < _alias.length; _i++) {
            var alia = _alias[_i];
            var layers = group.getLayers(alia);
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = (0, _getIterator2.default)(layers), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var layer = _step5.value;

                for (var _i2 = 0; _i2 < layer.scene.children.length; _i2++) {
                  if (filter) {
                    filter(layer.scene.children[_i2]) && facilitys.push(layer.scene.children[_i2]);
                  } else {
                    facilitys.push(layer.scene.children[_i2]);
                  }
                }
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
          }

          var locations = group._locationScene.children;

          for (var i = 0; i < locations.length; i++) {
            if (filter) {
              filter(locations[i]) && facilitys.push(locations[i]);
            } else {
              facilitys.push(locations[i]);
            }
          } // let label = group.getOrCreateLayer("label");
          // for (let i = 0; i < label.scene.children.length; i++) {
          //     if (filter) {
          //         filter(label.scene.children[i]) && facilitys.push(label.scene.children[i]);
          //     } else {
          //         facilitys.push(label.scene.children[i]);
          //     }
          // }

        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      return facilitys;
    }
  }, {
    key: "getSpriteInfo",
    value: function getSpriteInfo(target, isText, camera, height) {
      target.updateMatrixWorld(true);
      var position = new fm.Vector3().setFromMatrixPosition(target.matrixWorld);
      var cameraSpacePos = position.applyMatrix4(camera.matrixWorldInverse);
      var ndcPos = cameraSpacePos.applyMatrix4(camera.projectionMatrix);
      var size = target.mapNode.size / height * 2; // console.log(size);

      var widthSize;

      if (isText) {
        var mname = this.parent._map.labelLanguage == _FMLanguageType.default.ZH ? target.mapNode.name : target.mapNode.ename;

        if (mname) {
          var length = mname.split("%rn%").length;
          size *= length;
        }

        widthSize = size / target.material.userData.scaleRatio;
      } else {
        widthSize = size;
      }

      if (camera.type == "PerspectiveCamera") {
        ndcPos.x *= camera.aspect;
      }

      var leftTop = {
        x: ndcPos.x - widthSize / 2,
        y: ndcPos.y + size / 2
      };
      var rightDown = {
        x: ndcPos.x + widthSize / 2,
        y: ndcPos.y - size / 2
      }; // console.log('lt',leftTop);
      // console.log('rd',rightDown);
      // console.log('tar',target.mapNode._text);

      return {
        target: target,
        z: target.mapNode.eid,
        position: ndcPos,
        leftTop: leftTop,
        rightDown: rightDown
      };
    }
  }, {
    key: "getMarkers",
    value: function getMarkers(gid, camera, clientHeight) {
      var markers = []; // function 

      var group = this.groups[gid];

      if (!group) {
        return markers;
      }

      var layers = group.getLayers("facility");
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = (0, _getIterator2.default)(layers), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var layer = _step6.value;
          if (!layer.needAvoid) continue;

          for (var i = 0; i < layer.scene.children.length; i++) {
            var target = layer.scene.children[i];
            if (!target.mapNode.needAvoid) continue;

            if (target.mapNode.show) {
              var spriteInfo = this.getSpriteInfo(target, false, camera, clientHeight);
              markers.push(spriteInfo);
            }
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      var labels = group.getLayers("label");
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = (0, _getIterator2.default)(labels), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var label = _step7.value;

          // if (!label.needAvoid) continue;
          for (var _i3 = 0; _i3 < label.scene.children.length; _i3++) {
            var _target = label.scene.children[_i3];
            _target.mapNode.renderNode.visible = true;
            if (!_target.mapNode.needAvoid || !label.needAvoid) continue;

            if (_target.mapNode.show) {
              var _spriteInfo = this.getSpriteInfo(_target, true, camera, clientHeight);

              markers.push(_spriteInfo);
            }
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      markers.sort(function (item1, item2) {
        return item1.z - item2.z;
      });
      return markers;
    }
  }, {
    key: "getAllImageMarker",
    value: function getAllImageMarker(gid) {
      var markers = [];
      var group = this.groups[gid];

      if (!group) {
        return markers;
      } //console.log(353,group);


      var imageMarkers = group.layers["imageMarker"];

      for (var i = 0; i < imageMarkers.length; i++) {
        for (var j = 0; j < imageMarkers[i].scene.children.length; j++) {
          var target = imageMarkers[i].scene.children[j]; //console.log(358,target);

          markers.push(target);
        }
      }

      return markers;
    }
  }, {
    key: "getUserMarkers",
    value: function getUserMarkers(gid, camera, clientHeight) {
      var markers = [];
      var group = this.groups[gid];

      if (!group) {
        return markers;
      }

      var imageMarkers = group.layers["imageMarker"];

      for (var i = 0; i < imageMarkers.length; i++) {
        var imagemarks = [];
        if (!imageMarkers[i].needAvoid) continue;

        for (var j = 0; j < imageMarkers[i].scene.children.length; j++) {
          var target = imageMarkers[i].scene.children[j];
          if (!target.mapNode.needAvoid) continue;

          if (target.mapNode.show) {
            var spriteInfo = this.getSpriteInfo(target, false, camera, clientHeight);
            imagemarks.push(spriteInfo);
          }
        }

        markers.push(imagemarks);
      }

      var textMarkers = group.layers["textMarker"];

      for (var _i4 = 0; _i4 < textMarkers.length; _i4++) {
        var textmarks = [];
        if (!textMarkers[_i4].needAvoid) continue;

        for (var _j = 0; _j < textMarkers[_i4].scene.children.length; _j++) {
          var _target2 = textMarkers[_i4].scene.children[_j];
          if (!_target2.mapNode.needAvoid) continue;

          if (_target2.mapNode.show) {
            var _spriteInfo2 = this.getSpriteInfo(_target2, true, camera, clientHeight);

            textmarks.push(_spriteInfo2);
          }
        }

        markers.push(textmarks);
      }

      return markers;
    }
  }, {
    key: "getNodesExceptFacility",
    value: function getNodesExceptFacility(gids, filter) {
      var nodes = [];
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = (0, _getIterator2.default)(gids), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var gid = _step8.value;
          var group = this.groups[gid];

          if (!group) {
            continue;
          }

          group.everyLayers(['facility', 'label', 'imageMarker', 'textMarker', 'dynmodel'], function (scene) {
            for (var i = 0; i < scene.children.length; i++) {
              if (filter) {
                filter(scene.children[i]) && nodes.push(scene.children[i]);
              } else {
                nodes.push(scene.children[i]);
              }
            }
          });
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return nodes;
    }
  }, {
    key: "getDynnodes",
    value: function getDynnodes(filter, gids) {
      var nodes = [];
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = (0, _getIterator2.default)(gids), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var gid = _step9.value;
          var group = this.groups[gid];

          if (!group) {
            continue;
          }

          group.getDynmodel(function (scene) {
            for (var i = 0; i < scene.children.length; i++) {
              if (filter) {
                filter(scene.children[i]) && nodes.push(scene.children[i]);
              } else {
                nodes.push(scene.children[i]);
              }
            }
          });
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }

      return nodes;
    }
    /**
     * 获取多楼层所有models
     * @param {*} gids 
     */

  }, {
    key: "getGroupsModels",
    value: function getGroupsModels(gids) {
      var models = [];
      var _iteratorNormalCompletion10 = true;
      var _didIteratorError10 = false;
      var _iteratorError10 = undefined;

      try {
        for (var _iterator10 = (0, _getIterator2.default)(gids), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
          var gid = _step10.value;
          var group = this.groups[gid];

          if (!group) {
            continue;
          }

          var layers = group.getLayers("model");
          var _iteratorNormalCompletion11 = true;
          var _didIteratorError11 = false;
          var _iteratorError11 = undefined;

          try {
            for (var _iterator11 = (0, _getIterator2.default)(layers), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
              var layer = _step11.value;
              layer.checkSceneNode();
              models = models.concat(layer.scene.children);
            }
          } catch (err) {
            _didIteratorError11 = true;
            _iteratorError11 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
                _iterator11.return();
              }
            } finally {
              if (_didIteratorError11) {
                throw _iteratorError11;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError10 = true;
        _iteratorError10 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
            _iterator10.return();
          }
        } finally {
          if (_didIteratorError10) {
            throw _iteratorError10;
          }
        }
      }

      return models;
    }
    /**
     * 获取多楼层所有externalmodels
     * @param {*} gids 
     */

  }, {
    key: "getGroupsExternalModels",
    value: function getGroupsExternalModels(gids) {
      var models = [];
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = (0, _getIterator2.default)(gids), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var gid = _step12.value;
          var group = this.groups[gid];

          if (!group) {
            continue;
          }

          var layers = group.getLayers("externalModel");
          var _iteratorNormalCompletion13 = true;
          var _didIteratorError13 = false;
          var _iteratorError13 = undefined;

          try {
            for (var _iterator13 = (0, _getIterator2.default)(layers), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
              var layer = _step13.value;
              layer.checkSceneNode(); // models.push(); = models.concat(layer.scene.children);

              for (var i = 0; i < layer.scene.children.length; i++) {
                layer.scene.children[i].traverse(function (mesh) {
                  if (mesh instanceof fm.Mesh) {
                    models.push(mesh);
                  }
                });
              }
            }
          } catch (err) {
            _didIteratorError13 = true;
            _iteratorError13 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
                _iterator13.return();
              }
            } finally {
              if (_didIteratorError13) {
                throw _iteratorError13;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }

      return models;
    }
    /**
     * 通过过滤器获取多楼层所有models
     * @param {*} gids 
     */

  }, {
    key: "getGroupsNodelsByFilter",
    value: function getGroupsNodelsByFilter(gids, lalias, filter) {
      var nodes = [];
      var _iteratorNormalCompletion14 = true;
      var _didIteratorError14 = false;
      var _iteratorError14 = undefined;

      try {
        for (var _iterator14 = (0, _getIterator2.default)(gids), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
          var gid = _step14.value;
          var group = this.groups[gid];

          for (var alias in group.layers) {
            if (lalias === alias) {
              var layers = group.layers[alias];
              var _iteratorNormalCompletion15 = true;
              var _didIteratorError15 = false;
              var _iteratorError15 = undefined;

              try {
                for (var _iterator15 = (0, _getIterator2.default)(layers), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
                  var layer = _step15.value;
                  layer.traverse(function (node) {
                    if (filter(node)) {
                      nodes.push({
                        nodeType: node.nodeType,
                        typeID: node.bdata && node.bdata.type,
                        data: node.bdata,
                        target: node
                      });
                    }
                  });
                }
              } catch (err) {
                _didIteratorError15 = true;
                _iteratorError15 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
                    _iterator15.return();
                  }
                } finally {
                  if (_didIteratorError15) {
                    throw _iteratorError15;
                  }
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError14 = true;
        _iteratorError14 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
            _iterator14.return();
          }
        } finally {
          if (_didIteratorError14) {
            throw _iteratorError14;
          }
        }
      }

      return nodes;
    }
    /**
     * 获取除extent之外其他的
     * @param {*} gids 
     */

  }, {
    key: "getNodesExpectExtent",
    value: function getNodesExpectExtent(gids) {
      var nodes = [];
      var _iteratorNormalCompletion16 = true;
      var _didIteratorError16 = false;
      var _iteratorError16 = undefined;

      try {
        for (var _iterator16 = (0, _getIterator2.default)(gids), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
          var gid = _step16.value;
          var group = this.groups[gid];
          group.everyLayers(["extent"], function (scene) {
            nodes.push.apply(nodes, (0, _toConsumableArray2.default)(scene.children));
          });
        }
      } catch (err) {
        _didIteratorError16 = true;
        _iteratorError16 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
            _iterator16.return();
          }
        } finally {
          if (_didIteratorError16) {
            throw _iteratorError16;
          }
        }
      }

      return nodes;
    }
    /**
     * 获取当前显示的group
     */

  }, {
    key: "getRenderGroup",
    value: function getRenderGroup() {
      var groups = [];

      for (var g in this.groups) {
        if (this.groups[g].visible) {
          groups.push(this.groups[g]);
        }
      }

      return groups.sort(function (g1, g2) {
        return g1.getHeight() - g2.getHeight();
      });
    }
  }, {
    key: "getLastRenderArray",
    value: function getLastRenderArray() {
      var arr = [];

      for (var g in this.groups) {
        arr.push.apply(arr, (0, _toConsumableArray2.default)(this.groups[g].alwaysShowMarkers));
      }

      return arr;
    }
  }, {
    key: "getHeight",
    value: function getHeight(gid) {
      var height;

      if (this.groups["" + gid]) {
        height = this.groups["" + gid].getHeight();
      } else {
        height = this._space * gid;
      }

      return height;
    }
  }, {
    key: "setLabelLanguage",
    value: function setLabelLanguage(type) {
      for (var g in this.groups) {
        this.groups[g].traverseByAlias(["label"], function (label) {
          label.setByLanguage(type);
        });
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var g in this.groups) {
        this.groups[g].dispose();
        this.groups[g].parent = undefined;
        this.groups[g] = undefined;
      }

      this.groups = undefined;

      if (this._theme) {
        this._theme.dispose();

        this._theme = undefined;
      }
    }
  }, {
    key: "mapcenter",
    get: function get() {
      return new fm.Vector2().copy(this._mapcenter);
    }
  }, {
    key: "groupLength",
    get: function get() {
      return this._groupIds.length;
    }
  }, {
    key: "groupIds",
    get: function get() {
      return this._groupIds;
    }
  }, {
    key: "center",
    get: function get() {
      return new fm.Vector2().copy(this._center);
    },
    set: function set(c) {
      // console.error(c);
      this._center = c;
    }
  }, {
    key: "theme",
    set: function set(theme) {
      this._theme = theme;
    },
    get: function get() {
      return this._theme;
    }
  }, {
    key: "bbox",
    get: function get() {
      return this._bbox;
    }
  }, {
    key: "bboxTh",
    get: function get() {
      return this._bboxTh;
    }
  }, {
    key: "space",
    get: function get() {
      return this._space;
    },
    set: function set(s) {
      this._space = s; // let offset = this._space - this.groups[1 + ""].height;

      for (var gid in this.groups) {
        var floor = (0, _parseInt2.default)(gid);
        this.groups[gid].height = s * floor;
      }
    }
  }]);
  return FMScene;
}();

var _default = FMScene;
exports.default = _default;

/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 25.4.1.5 NewPromiseCapability(C)
var aFunction = __webpack_require__(70);

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

/***
 * @class FMEdgesLinesType 地图中的常量
 * @memberof fengmap
 * @hideconstructor true
 */
var FMEdgesLinesType = {
  /*
   * 边缘线类型
   * @property {number} ALL_LINES_TYPE 40
   * @final
   */
  "ALL_LINES_TYPE": 40,

  /*
   * 边缘线顶线类型
   * @property {number} TOP_LINES_TYPE 41
   * @final
   */
  "TOP_LINES_TYPE": 41
};
var _default = FMEdgesLinesType;
exports.default = _default;

/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

/**
*	FMMarkerAnchor 锚点枚举类
* 	@class
* 	@memberof fengmap
*   @hideconstructor true
*/
var FMMarkerAnchor = {
  /**
   * 右中
   * @property {number} RIGHT -1
   * @final
   */
  RIGHT: 1,

  /**
  * 左中
  * @property {number} LEFT -2
  * @final
  */
  LEFT: 2,

  /**
  * 下中
  * @property {number} BOTTOM -3
  * @final
  */
  BOTTOM: 3,

  /**
  * 上中
  * @property {number} TOP -4
  * @final
  */
  TOP: 4,

  /**
  * 右下
  * @property {number} RIGHT_BOTTOM -5
  * @final
  */
  RIGHT_BOTTOM: 5,

  /**
  * 左下
  * @property {number} LEFT_BOTTOM -6
  * @final
  */
  LEFT_BOTTOM: 6,

  /**
  * 右上
  * @property {number} RIGHT_TOP -7
  * @final
  */
  RIGHT_TOP: 7,

  /**
  * 左上
  * @property {number} LEFT_TOP -8
  * @final
  */
  LEFT_TOP: 8,

  /**
  * 居中
  * @property {number} CENTER -9
  * @final
  */
  CENTER: 9
};
var _default = FMMarkerAnchor;
exports.default = _default;

/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.LineMaterial = void 0;

var _create = _interopRequireDefault(__webpack_require__(31));

var _defineProperties = _interopRequireDefault(__webpack_require__(106));

var _three = __webpack_require__(81);

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  linewidth: <float>,
 *  dashed: <boolean>,
 *  dashScale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *  resolution: <Vector2>, // to be set by renderer
 * }
 */
_three.UniformsLib.line2 = {
  linewidth: {
    value: 1
  },
  resolution: {
    value: new _three.Vector2(1, 1)
  },
  dashScale: {
    value: 1
  },
  dashSize: {
    value: 1
  },
  gapSize: {
    value: 1
  } // todo FIX - maybe change to totalSize

};
_three.ShaderLib['line2'] = {
  uniforms: _three.UniformsUtils.merge([_three.UniformsLib.common, _three.UniformsLib.fog, _three.UniformsLib.line2]),
  vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
  fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t"
};

var LineMaterial = function LineMaterial(parameters) {
  _three.ShaderMaterial.call(this, {
    type: 'LineMaterial',
    uniforms: _three.UniformsUtils.clone(_three.ShaderLib['line2'].uniforms),
    vertexShader: _three.ShaderLib['line2'].vertexShader,
    fragmentShader: _three.ShaderLib['line2'].fragmentShader,
    clipping: true // required for clipping support

  });

  this.dashed = false;
  (0, _defineProperties.default)(this, {
    color: {
      enumerable: true,
      get: function get() {
        return this.uniforms.diffuse.value;
      },
      set: function set(value) {
        this.uniforms.diffuse.value = value;
      }
    },
    lineWidth: {
      enumerable: true,
      get: function get() {
        return this.uniforms.linewidth.value;
      },
      set: function set(value) {
        this.uniforms.linewidth.value = value;
      }
    },
    dashScale: {
      enumerable: true,
      get: function get() {
        return this.uniforms.dashScale.value;
      },
      set: function set(value) {
        this.uniforms.dashScale.value = value;
      }
    },
    dashSize: {
      enumerable: true,
      get: function get() {
        return this.uniforms.dashSize.value;
      },
      set: function set(value) {
        this.uniforms.dashSize.value = value;
      }
    },
    gapSize: {
      enumerable: true,
      get: function get() {
        return this.uniforms.gapSize.value;
      },
      set: function set(value) {
        this.uniforms.gapSize.value = value;
      }
    },
    resolution: {
      enumerable: true,
      get: function get() {
        return this.uniforms.resolution.value;
      },
      set: function set(value) {
        this.uniforms.resolution.value.copy(value);
      }
    }
  });
  this.setValues(parameters);
};

exports.LineMaterial = LineMaterial;
LineMaterial.prototype = (0, _create.default)(_three.ShaderMaterial.prototype);
LineMaterial.prototype.constructor = LineMaterial;
LineMaterial.prototype.isLineMaterial = true;

/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(146);

var _assign = _interopRequireDefault(__webpack_require__(11));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

__webpack_require__(244);

var _LineGeometry = _interopRequireDefault(__webpack_require__(245));

var _Line = _interopRequireDefault(__webpack_require__(430));

var _FMSegment = _interopRequireDefault(__webpack_require__(247));

var _FMLineType = _interopRequireDefault(__webpack_require__(243));

var _warnMessage = __webpack_require__(69);

var lineAnimate = function lineAnimate(e) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator2.default)(this._lineNodes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var l = _step.value;
      l.line.material.uniforms.offset.value.y -= 0.001 * e.delTime;

      if (this.passed) {
        if (l.gid !== this._passedGid) continue;
        l.line.material.uniforms.miny.value = this.specific;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};
/**
 * FMLineMarker 自定义线标注对象，为自定义图层。
 * @class
 * @memberof fengmap
 */


var FMLineMarker =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMLineMarker, _FMNode);

  function FMLineMarker() {
    var _this;

    (0, _classCallCheck2.default)(this, FMLineMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMLineMarker).call(this));
    _this._renderNode = null;
    _this._segment = [];
    _this._noAnimate = true;
    _this._lineDis = [];
    _this._lineNodes = [];
    _this._style = null;
    _this._secLen = 60;
    _this._hwProp = 10;
    _this._passed = true;
    _this._passedColor = '#aeaeae';
    _this._specific = 0;
    return _this;
  }
  /**
   * 新增一段线段segement
   * @param {fengmap.FMSegment} seg  路段
   */


  (0, _createClass2.default)(FMLineMarker, [{
    key: "addSegment",
    value: function addSegment(seg) {
      this._segment.push(seg);
    }
  }, {
    key: "convertPointByCenter",
    value: function convertPointByCenter(p, center) {
      return [p.x - center.x, p.z, -p.y + center.y];
    }
  }, {
    key: "segPointsToLinePnts",
    value: function segPointsToLinePnts(center) {
      var line = [];

      for (var i = 0; i < this._segment.points.length; i++) {
        if (i > 0 && i < this._segment.points.length - 1) {
          var start = this._segment.points[i - 1];
        }

        line.push.apply(line, (0, _toConsumableArray2.default)(this.convertPointByCenter(this._segment.points[i], center)));

        if (i !== 0) {
          var posPrev = new fm.Vector3(this._segment.points[i].x, this._segment.points[i].y, this._segment.points[i].z);
          var posLast = new fm.Vector3(this._segment.points[i - 1].x, this._segment.points[i - 1].y, this._segment.points[i - 1].z);

          this._lineDis.push(posPrev.distanceTo(posLast));
        }
      }

      return line;
    }
  }, {
    key: "getIndexDis",
    value: function getIndexDis(index) {
      var d = 0;

      for (var i = 0; i < this._lineDis.length; i++) {
        if (i < index) {
          d += this._lineDis[i];
        }
      }

      return d;
    }
  }, {
    key: "computerUVY",
    value: function computerUVY() {
      var uvys = [];
      var allDistance = this.getIndexDis(this._lineDis.length);

      for (var i = 0; i < this._segment.points.length; i++) {
        if (i === 0) {
          uvys.push(0);
        } else if (i === this._segment.points.length - 1) {
          uvys.push(1);
        } else {
          var uvy = this.getIndexDis(i) / allDistance;
          uvys.push(uvy);
          uvys.push(uvy);
        }
      }

      return uvys;
    }
  }, {
    key: "initLine",
    value: function initLine(center, style, map) {
      this._style = style;
      var texparams = this.getLineTextureParams(style.lineType, style.lineWidth, style.godColor, style.godEdgeColor, style.color);

      if (!style.mapUrl) {
        style.useMap = texparams.useMap;
        style.map = map.nodeManager.materialManager[texparams.txtureCommand](texparams);
        style.map.minFilter = fm.LinearFilter;
        style.map.generateMipmaps = false;
        style.map.anisotropy = 4;
      } else {
        style.useMap = true;
      } // 


      for (var i = this._segment.length - 1; i > -1; i--) {
        var line = this.createLine(this._segment[i], center, style, map);
        var group = map.getFMGroup(this._segment[i].groupId);

        if (!group) {
          console.warn(_warnMessage.tileMessage.noGroup);
          continue;
        }

        this._lineNodes.push({
          line: line,
          gid: this._segment[i].groupId,
          seg: this._segment[i],
          isCross: false
        });

        group.addLine(line);

        if (i - 1 > -1) {
          if (this._segment[i].groupId != this._segment[i - 1].groupId) {
            var _group = map.getFMGroup(this._segment[i - 1].groupId);

            if (!_group) {
              console.warn(_warnMessage.tileMessage.noGroup);
              continue;
            }

            var height = _group.height + _group.offsetHeight;
            var p1 = (0, _assign.default)({}, this._segment[i - 1].points[this._segment[i - 1].points.length - 1]);
            var p2 = (0, _assign.default)({}, this._segment[i].points[0]);
            var groupn = map.getFMGroup(this._segment[i].groupId);

            if (!groupn) {
              console.warn(_warnMessage.tileMessage.noGroup);
              continue;
            }

            p1.z = height - groupn.height - groupn.offsetHeight + p1.z - p2.z;
            var crossSeg = new _FMSegment.default([p1, p2]);
            crossSeg.groupId = this._segment[i].groupId;
            var cline = this.createLine(crossSeg, center, style, map);

            this._lineNodes.push({
              line: cline,
              gid: this._segment[i - 1].groupId,
              gidAn: this._segment[i].groupId,
              seg: crossSeg,
              isCross: true
            });

            _group.addLine(cline);
          }
        }
      }

      this._noAnimate = style.noAnimate;

      if (!this._noAnimate) {
        map.on("frameLoop", lineAnimate.bind(this));
      } // this._renderNode.rotation.set(Math.PI / 2, 0, 0, 'XYZ');

    }
  }, {
    key: "conputeMaterialRepeat",
    value: function conputeMaterialRepeat(material, seg, map, secLen) {
      var allDistance = seg.allLength;
      var pxdis = allDistance * map.getPixelTo3DdisByGid(seg.groupId);
      var sections = Math.floor(pxdis * window.devicePixelRatio / secLen);
      material.uniforms.repeat.value.y = sections;
    }
  }, {
    key: "resetRepeat",
    value: function resetRepeat(map) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator2.default)(this._lineNodes), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var l = _step2.value;
          this.conputeMaterialRepeat(l.line.material, l.seg, map, this._secLen);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "rebuildLine",
    value: function rebuildLine(center, map, gids, maxGid) {
      this.removeByMap(map);
      var style = this._style;

      for (var i = this._segment.length - 1; i > -1; i--) {
        var line = this.createLine(this._segment[i], center, style, map);
        var group = map.getFMGroup(this._segment[i].groupId);

        this._lineNodes.push({
          line: line,
          gid: this._segment[i].groupId,
          seg: this._segment[i],
          isCross: false
        });

        group.addLine(line);

        if (i - 1 > -1) {
          if (this._segment[i].groupId != this._segment[i - 1].groupId) {
            var _group2 = map.getFMGroup(this._segment[i - 1].groupId);

            ;
            var height = _group2.height + _group2.offsetHeight;
            var p1 = (0, _assign.default)({}, this._segment[i].points[this._segment[i].points.length - 1]);
            var p2 = (0, _assign.default)({}, this._segment[i - 1].points[0]);
            var groupn = map.getFMGroup(this._segment[i].groupId);
            p1.z = height - groupn.height - groupn.offsetHeight + p1.z - p2.z;
            var crossSeg = new _FMSegment.default([p1, p2]);
            crossSeg.groupId = this._segment[i].groupId;
            var cline = this.createLine(crossSeg, center, style, map);

            this._lineNodes.push({
              line: cline,
              gid: this._segment[i - 1].groupId,
              gidAn: this._segment[i].groupId,
              seg: crossSeg,
              isCross: true
            });

            _group2.addLine(cline);
          }
        }
      }

      this.hideOrShowBy(gids, maxGid);
    }
  }, {
    key: "removeByMap",
    value: function removeByMap(map, removeAnimate) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator2.default)(this._lineNodes), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var l = _step3.value;
          l.line.material.dispose();
          l.line.geometry.dispose();
          var group = map.getFMGroup(l.gid);
          group.removeLine(l.line);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (removeAnimate) {
        map.off("frameLoop", lineAnimate);
      }

      this._lineNodes.length = 0;
    }
  }, {
    key: "dispose",
    value: function dispose(map) {
      this.removeByMap(map, true);
    }
  }, {
    key: "hideOrShowBy",
    value: function hideOrShowBy(gids, maxGid) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(this._lineNodes), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var l = _step4.value;

          if (!l.isCross) {
            if (gids.indexOf(l.gid) > -1) {
              l.line.visible = true;
            } else {
              l.line.visible = false;
            }
          } else {
            if (gids.indexOf(l.gid) < 0 || gids.indexOf(l.gidAn) < 0) {
              l.line.visible = false;
            } else {
              l.line.visible = true;
            }
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: "createLine",
    value: function createLine(segment, center, style, map) {
      var group = map.getFMGroup(segment.groupId);
      var height = group.height + group.offsetHeight;
      var linePos = new fm.Vector3(0, height, 0);
      var meshLine = new _LineGeometry.default();
      segment.needSmooth = style.smooth === false ? false : true;
      segment.initSegement(center, style.radius);
      var linePoints = []; //console.log(segment.linePoints.length,295);
      //linePoints.push(...segment.linePoints);

      for (var i = 0; i < segment.linePoints.length; i++) {
        linePoints.push(segment.linePoints[i]);
      }

      var uvys = segment.uvys;
      meshLine.setPositions(linePoints);
      meshLine.setUvys(uvys);
      var material = new fm.LineMaterial({
        color: style.color,
        linewidth: 5,
        // in pixels
        vertexColors: fm.VertexColors,
        dashed: false,
        transparent: true
      });
      material.resolution.set(style.resolution.x, style.resolution.y);
      material.linewidth = style.lineWidth;

      if (style.useMap) {
        material.defines["USE_MMAP"] = true;

        if (style.mapUrl) {
          style.useMap = true;
          map.nodeManager.materialManager.loadTexture(style.mapUrl, function (t) {
            material.uniforms.mmap.value = t;
            t.minFilter = fm.LinearFilter;
            t.generateMipmaps = false;
            t.anisotropy = 4;
            t.wrapS = fm.RepeatWrapping;
            t.wrapT = fm.RepeatWrapping;
            material.needsUpdate = true;
          });
        } else {
          material.uniforms.mmap.value = style.map;
          style.map.wrapS = fm.RepeatWrapping;
          style.map.wrapT = fm.RepeatWrapping;
        }

        this.conputeMaterialRepeat(material, segment, map, this._secLen);
        material.needsUpdate = true;
      }

      var renderNode = new _Line.default(meshLine, material);
      renderNode.computeLineDistances();
      renderNode.position.set(linePos.x, linePos.y, linePos.z);
      return renderNode;
    }
  }, {
    key: "initLinePoints",
    value: function initLinePoints(points, style) {
      var meshLine = new _LineGeometry.default();
      meshLine.setPositions(points); //set geometry后才能用

      var material = new fm.LineMaterial({
        color: style.color,
        linewidth: style.lineWidth,
        //5, // in pixels
        vertexColors: fm.VertexColors,
        dashed: false,
        transparent: true
      });
      material.lineWidth = style.lineWidth;
      material.resolution.set(style.resolution.x, style.resolution.y); // material.map = style.map;

      this._renderNode = new _Line.default(meshLine, material);

      this._renderNode.computeLineDistances();
    }
  }, {
    key: "moveUv",
    value: function moveUv(x) {
      if (this._noAnimate) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = (0, _getIterator2.default)(this._lineNodes), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var l = _step5.value;
            l.line.material.uniforms.offset.value.y -= x;
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      }
    }
  }, {
    key: "getLineTextureParams",
    value: function getLineTextureParams(lineType, width, gcolor, gecolor, color) {
      if (!width) {
        width = 6;
      }

      var height = width * this._hwProp;
      this._secLen = height;
      var params = {
        type: 'normal',
        width: 128,
        height: 128,
        color: '#ff0000',
        arrowHeightPercent: .6,
        arrowWidthPercent: 1,
        arrowPercent: .1,
        lineType: null,
        dashArray: [2, 1],
        txtureCommand: "createNormalLineTexture",
        // god arrow property
        godHeightPercent: 1,
        godEdgePercent: 0.2,
        godArrowPercent: .15,
        arrawWidth: 20,
        godColor: '#33cc61',
        godEdgeColor: '#4a82d2',
        godArrowColor: '#F4FEFB',
        godArrowXScale: 4,
        godArrowWidthPercent: 0.9
      };

      if (gcolor) {
        params.godColor = gcolor;
      }

      if (gecolor) {
        params.godEdgeColor = gecolor;
      }

      if (color) {
        params.color = color;
      }

      switch (lineType) {
        case _FMLineType.default.FULL:
          params.useMap = false;
          break;

        case _FMLineType.default.DOTTED:
          params.dashArray = [1, 1];
          params.useMap = true;
          break;

        case _FMLineType.default.DOT_DASH:
          params.dashArray = [2.5, 1, .5, 1];
          params.useMap = true;
          break;

        case _FMLineType.default.CENTER:
          params.dashArray = [3, 1, 1.5, 1];
          params.useMap = true;
          break;

        case _FMLineType.default.DASH:
          params.dashArray = [2, 1];
          params.useMap = true;
          break;

        case _FMLineType.default.DOUBLE_DOT_DASH:
          params.dashArray = [2.5, .5, .5, .5, .5, .5];
          params.useMap = true;
          break;

        case _FMLineType.default.TRI_DOT_DASH:
          params.dashArray = [2.5, .5, .5, .5, .5, .5, .5, .5];
          params.useMap = true;
          break;

        case _FMLineType.default.ARROW:
          params.dashArray = [5, 0];
          params.useMap = true;
          params.txtureCommand = "createArrowLineTexture";
          break;

        case _FMLineType.default.FMARROW:
          params.width = width * 5;
          params.height = height * 5;
          params.arrawWidth = params.height / 12;
          params.dashArray = [7, 0];
          params.useMap = true;
          params.txtureCommand = "createArrowWidthBackTexture";
          break;

        default:
          params.useMap = false;
          break;
      }

      return params;
    }
  }, {
    key: "setPassed",
    value: function setPassed(gid, value) {
      var distance = 0;
      var passage = 0;
      var points = [];

      for (var i = 0; i < this._segment.length; i++) {
        if (this._segment[i].groupId === gid) {
          points = this._segment[i]._points;
          break;
        }
      }

      for (var _i = 0; _i < points.length; _i++) {
        if (_i !== 0) {
          if (_i > value) passage += Math.abs(Math.sqrt(Math.pow(points[_i].y - points[_i - 1].y, 2) + Math.pow(points[_i].x - points[_i - 1].x, 2)));
          distance += Math.abs(Math.sqrt(Math.pow(points[_i].y - points[_i - 1].y, 2) + Math.pow(points[_i].x - points[_i - 1].x, 2)));
        }
      }

      this._specific = passage / distance;
      this._passedGid = gid;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    }
  }, {
    key: "segment",
    get: function get() {
      return this._segment;
    }
  }, {
    key: "passed",
    get: function get() {
      return this._passed;
    },
    set: function set(bool) {
      this._passed = bool;
    }
  }, {
    key: "passedColor",
    get: function get() {
      return this._passedColor;
    },
    set: function set(bool) {
      this._passedColor = bool;
    }
  }, {
    key: "specific",
    get: function get() {
      return this._specific;
    },
    set: function set(value) {
      this._specific = value;
    }
  }]);
  return FMLineMarker;
}(_FMNode2.default);

var FMLineMarker2 = FMLineMarker;
var _default = FMLineMarker2;
exports.default = _default;

/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(26) && !__webpack_require__(44)(function () {
  return Object.defineProperty(__webpack_require__(115)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 157 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(23) && !__webpack_require__(18)(function () {
  return Object.defineProperty(__webpack_require__(159)('div'), 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(37);
var document = __webpack_require__(24).document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(37);
var setPrototypeOf = __webpack_require__(262).set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};


/***/ }),
/* 161 */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(50);
var toIObject = __webpack_require__(86);
var arrayIndexOf = __webpack_require__(163)(false);
var IE_PROTO = __webpack_require__(121)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(86);
var toLength = __webpack_require__(34);
var toAbsoluteIndex = __webpack_require__(88);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(37);
var cof = __webpack_require__(74);
var MATCH = __webpack_require__(15)('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(24);
var dP = __webpack_require__(33);
var DESCRIPTORS = __webpack_require__(23);
var SPECIES = __webpack_require__(15)('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(263);

/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(28);
var anObject = __webpack_require__(29);
var getKeys = __webpack_require__(76);

module.exports = __webpack_require__(26) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(45);
var toIObject = __webpack_require__(61);
var arrayIndexOf = __webpack_require__(266)(false);
var IE_PROTO = __webpack_require__(127)('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(14).document;
module.exports = document && document.documentElement;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(45);
var toObject = __webpack_require__(52);
var IE_PROTO = __webpack_require__(127)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(29);
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(60);
var ITERATOR = __webpack_require__(19)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(19)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(30);
var sameValue = __webpack_require__(270);
var regExpExec = __webpack_require__(95);

// @@search logic
__webpack_require__(97)('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[SEARCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative($search, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(15)('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(32)(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(84);
var $export = __webpack_require__(22);
var redefine = __webpack_require__(38);
var hide = __webpack_require__(32);
var Iterators = __webpack_require__(63);
var $iterCreate = __webpack_require__(273);
var setToStringTag = __webpack_require__(134);
var getPrototypeOf = __webpack_require__(177);
var ITERATOR = __webpack_require__(15)('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(50);
var toObject = __webpack_require__(39);
var IE_PROTO = __webpack_require__(121)('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};


/***/ }),
/* 178 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(168);
var hiddenKeys = __webpack_require__(129).concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(99);
var createDesc = __webpack_require__(71);
var toIObject = __webpack_require__(61);
var toPrimitive = __webpack_require__(116);
var has = __webpack_require__(45);
var IE8_DOM_DEFINE = __webpack_require__(156);
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = __webpack_require__(26) ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(290);

/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(14);
var core = __webpack_require__(9);
var dP = __webpack_require__(28);
var DESCRIPTORS = __webpack_require__(26);
var SPECIES = __webpack_require__(19)('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(14);
var $export = __webpack_require__(10);
var meta = __webpack_require__(64);
var fails = __webpack_require__(44);
var hide = __webpack_require__(43);
var redefineAll = __webpack_require__(101);
var forOf = __webpack_require__(66);
var anInstance = __webpack_require__(102);
var isObject = __webpack_require__(17);
var setToStringTag = __webpack_require__(78);
var dP = __webpack_require__(28).f;
var each = __webpack_require__(140)(0);
var DESCRIPTORS = __webpack_require__(26);

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(10);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};


/***/ }),
/* 185 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://tc39.github.io/proposal-setmap-offrom/
var $export = __webpack_require__(10);
var aFunction = __webpack_require__(70);
var ctx = __webpack_require__(36);
var forOf = __webpack_require__(66);

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};


/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

var _Object$defineProperty = __webpack_require__(0);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    _Object$defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),
/* 187 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(46);
var defined = __webpack_require__(51);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 188 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(30);
var aFunction = __webpack_require__(118);
var SPECIES = __webpack_require__(15)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(26);
var getKeys = __webpack_require__(76);
var gOPS = __webpack_require__(138);
var pIE = __webpack_require__(99);
var toObject = __webpack_require__(52);
var IObject = __webpack_require__(126);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(44)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),
/* 190 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(309);

/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(24);
var hide = __webpack_require__(32);
var uid = __webpack_require__(73);
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};


/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(38);
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};


/***/ }),
/* 193 */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(46);
var toLength = __webpack_require__(34);
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};


/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(10);
var defined = __webpack_require__(90);
var fails = __webpack_require__(44);
var spaces = __webpack_require__(145);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(30);
var toLength = __webpack_require__(34);
var advanceStringIndex = __webpack_require__(141);
var regExpExec = __webpack_require__(95);

// @@match logic
__webpack_require__(97)('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = defined(this);
      var fn = regexp == undefined ? undefined : regexp[MATCH];
      return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative($match, regexp, this);
      if (res.done) return res.value;
      var rx = anObject(regexp);
      var S = String(this);
      if (!rx.global) return regExpExec(rx, S);
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

__webpack_require__(13);

var _typeof2 = _interopRequireDefault(__webpack_require__(47));

__webpack_require__(55);

var _keys = _interopRequireDefault(__webpack_require__(54));

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

var _isArray = _interopRequireDefault(__webpack_require__(35));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

__webpack_require__(8);

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(174);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(103));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

__webpack_require__(48);

var _stringify = _interopRequireDefault(__webpack_require__(104));

var _FMServer = _interopRequireDefault(__webpack_require__(201));

var _MapOptions = _interopRequireDefault(__webpack_require__(375));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _ThemeManager = _interopRequireDefault(__webpack_require__(414));

var _Animater = _interopRequireDefault(__webpack_require__(58));

var _FMGlobal = _interopRequireDefault(__webpack_require__(110));

var _FMUtil = _interopRequireDefault(__webpack_require__(57));

var _FMVersion = _interopRequireDefault(__webpack_require__(234));

var _EventDispatcher2 = _interopRequireDefault(__webpack_require__(235));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _FMDynamicModel = _interopRequireDefault(__webpack_require__(236));

var _Graphics = _interopRequireDefault(__webpack_require__(49));

var _stats = _interopRequireDefault(__webpack_require__(416));

var _warnMessage = __webpack_require__(69);

var _NetArea = _interopRequireDefault(__webpack_require__(108));

var _Cerity = _interopRequireDefault(__webpack_require__(205));

var _FMMapGestureEnableController = _interopRequireDefault(__webpack_require__(237));

var _FMMapUtil = _interopRequireDefault(__webpack_require__(113));

var _warnMessage2 = __webpack_require__(69);

var _FMRenderer = _interopRequireDefault(__webpack_require__(239));

var _VideoMemoryManager = _interopRequireDefault(__webpack_require__(419));

var _Enum = __webpack_require__(109);

var openFailBack;

function openMap(id) {
  //匿名 防止被绕过
  var themeUrl = this.MapOptions.mapThemeURL + '/' + this.MapOptions.defaultThemeName + '/' + this.MapOptions.defaultThemeName + '.theme';
  var me = this;
  this.fmServer.getTheme(themeUrl, function (themeData) {
    // console.log(themeData);
    me.initTheme(me.MapOptions.defaultThemeName, themeData, function (theme) {
      var sendData = null;
      var url = me.MapOptions.mapServerURL;
      var method = "GET";

      if (me.MapOptions.mapServerURL === "fengmap") {
        url = _NetArea.default + "sdk/auth/downMaps";

        if (me.obtainMapRoute) {
          url = _NetArea.default + "sdk/auth/obtainMapRoute";
        }

        if (me.MapOptions.tile) {
          url = _NetArea.default + "sdk/authLayered/downMaps";

          if (me.obtainMapRoute) {
            //https://console.fengmap.club/api-s/sdk/authLayered/obtainMapRoute/{fname:.+}
            url = _NetArea.default + "sdk/authLayered/obtainMapRoute";
          }
        }

        var data = _Cerity.default.getCerityData(me.MapOptions.key, me.MapOptions.appName, id);

        var sendObject = {
          newFlag: '2',
          mapId: data.mapId,
          keyValue: data.appKey,
          appName: data.appName,
          webUrl: data.webURL,
          keyType: 3,
          // web platform flag
          isSeparate: me.MapOptions.tile
        };
        sendData = (0, _stringify.default)(sendObject);
        method = "POST";
      } else {
        me.obtainMapRoute = false;
      }

      if (!me.obtainMapRoute) {
        me.fmServer.getScene(url, id, me.MapOptions.tile, sendData, method, function (data, sceneId) {
          me.dataExcute(theme, data, sceneId, sendData);
        }, function (errorText) {
          openFailBack && openFailBack(errorText);
        });
      } else {
        me.fmServer.getUrl(url, id, me.MapOptions.tile, sendData, method, function (myurl, sceneId) {
          myurl = myurl.replace('"', '').replace('"', '');
          me.fmServer.getScene(myurl, null, me.MapOptions.tile, null, 'GET', function (data2, sceneId2) {
            me.dataExcute(theme, data2, sceneId, sendData);
          }, function (errorText) {
            openFailBack && openFailBack(errorText);
          });
        }, function (errorText) {
          openFailBack && openFailBack(errorText);
        });
      }

      me._currentSceneId = id;
    });
  });
}
/**
 * @class 地图类
 * @constructor
 * @memberof fengmap
 * @param {json} options
 *             @param {HTMLElement} options.container  加载地图html容器,必填。
 *             @param {string} options.appName 必填,可通过蜂鸟云平台-》我的应用-》创建应用
 *             @param {string} options.key 必填,key可通过蜂鸟云平台-》我的应用-》创建应用-》添加key添加
 *             @param {string} options.mapServerURL 设置地图数据的路径，如不设置，则从蜂鸟视图服务器上获取在线地图
 *             @param {string}  options.mapThemeURL 设置主题数据的路径，如不设置，则从蜂鸟视图服务器上获取在线主题
 *             @param {string}  options.defaultThemeName 设置默认主题名称，默认为‘2001’，设置后主题对应文件夹路径为：options.mapThemeURL+options.defaultThemeName。
 *             @param {boolean} options.useStoreApply 开启支持主题中模型的自定义样式，默认为true。
 *             @param {array}  options.defaultVisibleGroups 初始显示楼层ID数组，默认值为[1]
 *             @param {int}  options.defaultFocusGroup 初始聚焦楼层ID，默认值为1，设置非1时请同步设置defaultVisibleGroups。
 *             @param {json} options.defaultViewCenter 初始化地图中心点坐标。如：{x:12961580.734922647,y:4861883.567717729}
 *             @param {boolean}  options.modelSelectedEffect 支持单击模型高亮，false为单击时模型不高亮
 *             @param {boolean}  options.modelHoverEffect 支持悬停模型高亮或拾取，false为悬停时模型不高亮。默认值：false
 *             @param {boolean}  options.modelHoverTime 悬停时间触发时间，默认1000,参数数值表示毫秒时长。
 *             @param {boolean} options.focusAlphaMode 是否对不聚焦图层启用透明设置 默认为true
 *             @param {float} options.focusAlpha 对不聚焦图层启用透明设置 默认为0.1。值范围为 0-1。此属性只有当options.focusAlphaMode = ture是有效
 *             @param {boolean} options.focusAnimateMode 是否开启聚焦图层切换的动画显示。默认true
 *             @param {fengmap.FMViewMode} options.defaultViewMode 初始二维还是三维状态，fengmap.FMViewMode.MODE_2D|fengmap.FMViewMode.MODE_3D ,默认3维显示。
 *             @param {boolean} options.viewModeAnimateMode 是否启用2D，3D模式切换时的动画效果。默认true
 *             @param {boolean} options.moveToAnimateMode  是否启用拾取地图物体时相机的移动动画效果。 默认true。
 *             @param {boolean} options.scaleToAnimateMode  是否启用地图物缩放的动画效果。 默认true。
 *             @param {number} options.defaultMapScaleLevel  设置地图初始显示比例尺级别。范围为1-29之间的整数值。如29级的比例尺为1:1厘米。
 *             @param {array} options.mapScaleLevelRange  设置比例尺级别可缩放范围， 通常室内地图使用到的范围为16级到23级。即：[16,23]。
 *             @param {number} options.defaultMapScale  设置地图初始显示自定义比例尺级别。如设置1000，为1:1000（厘米）的显示状态。defaultMapScale的优先级比defaultMapScaleLevel的优先级高。
 *             @param {array} options.mapScaleRange  设置自定义比例尺范围，单位（厘米），如[200,4000]。
 *             @param {array} options.compassOffset  设置初始指南针的偏移量，默认为[28, 20],左：28px,上：20px。
 *             @param {number} options.compassSize  设置指南针大小,默认50px。
 *             @param {number} options.defaultGroupSpace  设置初始地图的楼层间距,默认50。
 *             @param {boolean} options.enabledPanRange 是否开启平移地图范围限制,默认为false
 *             @param {boolean} options.tile 是否访问分层数据,默认为false。
 *             @param {int|string} options.defaultBackgroundColor 默认背景颜色: 0xff00ff, '#00ff00'
 *             @param {int} options.defaultBackgroundAlpha 默认背景透明度: 0 ~ 1
 *             @param {number} options.defaultControlsPose 地图默认旋转角度，默认为-15度。
 *             @param {fengmap.FMLanguageType} options.defaultLabelLanguage 默认label的语言类型，显示英文或者中文
 * @see https://www.fengmap.com/fmAPI/help-fmdemo.html#FMMapBasic
 */


var FMMap =
/*#__PURE__*/
function (_EventDispatcher) {
  (0, _inherits2.default)(FMMap, _EventDispatcher);

  /**
   * FMMap 是加载场景、显示模型、遍历模型等的主类，一个页面中必须且至少包含一个FMMap对象
   */
  function FMMap(options) {
    var _this;

    (0, _classCallCheck2.default)(this, FMMap);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMMap).call(this));
    _this.uuid = fm.Math.generateUUID();
    _FMGlobal.default[_this.uuid] = {};
    _this.MapOptions = new _MapOptions.default(options);
    _this.fmServer = new _FMServer.default();
    _this.dataManager = new _DataManager.default();
    _this.nodeManager = new _NodeManager.default(_this.MapOptions, (0, _assertThisInitialized2.default)(_this));
    _this.isMarkerTip = false;

    if (options.isMarkerTip) {
      _this.isMarkerTip = true;
    }

    _this.isMarkerMove = false;

    if (options.isMarkerMove) {
      _this.isMarkerMove = true;
    }

    _this.render = null;

    _this.getRenderOption();

    if (options.lightEffects) {
      _FMGlobal.default["light"] = true;
      _this.renderer = new _FMRenderer.default(_this.MapOptions, (0, _assertThisInitialized2.default)(_this));
    } else {
      _FMGlobal.default["light"] = false;
      _this.renderer = new _FMRenderer.default(_this.MapOptions, (0, _assertThisInitialized2.default)(_this));
    } // this.renderer = new EffectRenderer(this.MapOptions, this);
    // alert(window.devicePixelRatio)


    _this.controls = new fm.OrbitControls(_this.MapOptions.defaultViewMode === "3d" ? _this.renderer.perspectiveCamera : _this.renderer.orthographicCamera, _this.renderer.canvas, (0, _assertThisInitialized2.default)(_this));
    _this.mapScaleLevels = [295829355.45, 147914677.73, 73957338.86, 36978669.43, 18489334.72, 9244667.36, 4622333.68, 2311166.84, 1155583.42, 577791.71, 288895.85, 144447.93, 72223.96, 36111.98, 18056, 9028, 4514, 2257, 1128, 564, 282, 141, 70, 35, 17, 8, 4, 2, 1];
    _this._mapScaleLevel = 20;
    _this._mapScale = 564;
    _this._minScale = 1;
    _this._maxScale = 295829355.45;
    _this._minScaleLevel = 1;
    _this._maxScaleLevel = 29;
    _this._animaters = [];
    _this._windowPops = []; //地图弹出框对象

    _this._currentSceneId = "10347";
    _this._currentFocusGroup = _this.MapOptions.defaultFocusGroup;
    _this._visibleGroups = _this.MapOptions.defaultVisibleGroups;
    _this._viewMode = _this.MapOptions.defaultViewMode;
    _this.renderer.viewMode = _this.MapOptions.defaultViewMode;
    _this._currentTime = new Date().getTime();
    _this._showAllGroup = false;
    _this._lineMarkers = [];
    _this._lastMoveEvent = null;
    _this._mouseHoverTime = 0;
    _this._mouseHoverStart = true;
    _this._compassBG = _this.MapOptions.compassBg;
    _this._compassFG = _this.MapOptions.compassFg;

    _this.getMapScaleInfo();

    _this.scaleLevelInit();

    _this.controlEventInit();

    _this._loopHander = requestAnimationFrame(_this.update.bind((0, _assertThisInitialized2.default)(_this)));
    _this.allowRender = true;
    _this._sweep = {};
    _this.isOneShot = true;
    /**
     * 过滤设置可点击拾取函数。可通过过滤设置模型的可点击拾取和不可点击拾取。
     * @property {function} pickFilterFunction 该方法返回true表示支持点击拾取，false表示不可点击拾取
     * @example
     *  //过滤不允许点击的地图元素，设置为true为允许点击，设置为false为不允许点击
     *   map.pickFilterFunction = function(event) {
     *       //如设置点击墙模型时不高亮
     *       if(event.nodeType == fengmap.FMNodeType.MODEL &&
     *           event.typeID == "300000") {
     *               return false;
     *       }
     *       return true;
     *   };
     */

    _this.pickFilterFunction = null;
    _this.animationMixers = [];
    /**
     * 过滤设置可悬停拾取函数。可通过过滤设置模型的可悬停拾取和不可悬停拾取。
     * @property {function} hoverFilterFunction 该方法返回true表示支持悬停拾取，false表示不可悬停拾取
     * @example
     *   map.hoverFilterFunction = function (event) {
     *       if (event.nodeType === fengmap.FMNodeType.MODEL &&
     *               event.typeID === 300000) {
     *           return false; //不支持悬停
     *      }
     *      if (event.nodeType === fengmap.FMNodeType.FLOOR) {
     *           return false; //不支持悬停
     *       }
     *       return true; //支持悬停
     *  };
     */

    _this.hoverFilterFunction = null;
    _this._eventId = 0;
    _this._modelSelectColor = {
      r: 0.97,
      g: 0.388,
      b: 0.196,
      a: 1
    };
    _this._fullScreen = false;
    _this._enterControl = new _FMMapGestureEnableController.default();
    _this._enterControl.enableMapHover = _this.MapOptions.modelHoverEffect;
    _this._allowfps = 60;
    _this._renderTime = 0;

    _this.controls.setEnterCtrl(_this._enterControl);

    _this.otherFocus = [];
    _this.autoRotateBymodel = false;
    _this.autoRotateBymodelSpeed = 1;
    _this.autoRotateBymodelPause = false;
    _this.tileLoading = false;
    _this.letUpdate = false;
    _this.selectedObjects = []; //添加FPS显示功能，doublechang

    _this.isFpsDisplay = false;
    _this.stats = null;

    if (options.isFpsDisplay) {
      _this.isFpsDisplay = options.isFpsDisplay;
    }

    if (_this.isFpsDisplay) {
      _this.stats = new _stats.default();

      _this.stats.showPanel(0);

      document.body.appendChild(_this.stats.dom);
    }

    _this.obtainMapRoute = true; //options.obtainMapRoute;

    _this.videoMemory = new _VideoMemoryManager.default((0, _assertThisInitialized2.default)(_this));

    _this.getStation();

    _this.animaModels = [];
    /**
     * layer渲染顺序等级。等级越高越后渲染，显示在上方（在深度检测开启后无效。一般作用于覆盖物layer之间的显示顺序）
     */

    _this.layerRenderOrder = _Enum.LayerOrder;
    return _this;
  }

  (0, _createClass2.default)(FMMap, [{
    key: "getRenderOption",
    value: function getRenderOption() {
      try {
        if (this.MapOptions.logarithmicDepthBuffer) {
          this.render = new fm.WebGLRenderer({
            antialias: true,
            alpha: true,
            logarithmicDepthBuffer: true
          });
        } else {
          this.render = new fm.WebGLRenderer({
            antialias: true,
            alpha: true
          });
        }
      } catch (ex) {
        console.error('WebGLRenderer ERROR: ', ex);
        new fengmap.MapError().noWebGL(this.renderOption.container);
        return false;
      }

      this.canvas = this.render.domElement;
      var w = this.MapOptions.container.clientWidth;
      var h = this.MapOptions.container.clientHeight;
      this.perspectiveCamera = new fm.PerspectiveCamera(35, w / h, 2, 100000);
      this.orthographicCamera = new fm.OrthographicCamera(-w / 2, w / 2, h / 2, -h / 2, 1, 100000);
      return true;
    }
  }, {
    key: "isOnLine",
    value: function isOnLine(success, failed) {
      // 使用百度Logo判断
      var img = new Image();

      img.onload = function () {
        if (success) {
          success();
        }
      };

      img.onerror = function () {
        if (failed) {
          failed();
        }
      };

      img.style.display = 'none';
      img.src = 'http://www.baidu.com/img/baidu_sylogo1.gif?' + ('' + Math.random()).slice(-6); // 使用xhr HEAD 请求判断
      // TODO:
    }
    /**
     * 通过sceneId加载地图。
     * @param {number} sceneId 场景Id
     * @param {function} failed 失败返回函数
     */

  }, {
    key: "openMapById",
    value: function openMapById(bid, failed) {
      openFailBack = failed;

      if (!bid) {
        console.warn(decodeURIComponent(_warnMessage.cerityMessage.warn_nomapid));
        return;
      }

      if (!this.MapOptions.key) {
        console.warn(decodeURIComponent(_warnMessage.cerityMessage.warn_nokey));
        return;
      } // check key's format


      var reg = /^[a-zA-z\d]{32}$/;

      if (!reg.test(this.MapOptions.key)) {
        console.warn(decodeURIComponent(_warnMessage.cerityMessage.warn_keynotright));
        return;
      }

      if (!this.MapOptions.appName) {
        console.warn(decodeURIComponent(_warnMessage.cerityMessage.warn_noappname));
        return;
      }
      /*
       * 为了防止有人绕过调用 openMapById
       * 而直接调用openMap 或 openMap_
       * 所以设置一个变量累加做为标识
       */


      this._zopStep_ = 1;
      var me = this; // 在线处理方法

      function onLine() {
        if (me.MapOptions.mapServerURL !== "fengmap") {
          openMap.call(me, bid);
          return;
        }

        _Cerity.default.checkIsOnLine(function () {
          _Cerity.default.checkOnLine(me.MapOptions.key, me.MapOptions.appName, bid, function (res) {
            // 成功
            openMap.call(me, bid, true);
          }, function (res) {
            if (res) {
              // 在线验证返回 success: false
              // 说明在线认证没有通过
              // 不打开地图文件
              // {"error_code":2009,"error_message":"错误的请求"}
              console.warn(res.error_code, res.error_message);

              if (failed) {
                failed({
                  msg: '线上验证失败!',
                  data: res
                });
              }
            } else {
              console.warn('offLine 2'); // ** 测试使用 ** 在线上验证不通过的情况下
              // 及打开地图

              openMap.call(me, bid);
            }
          }, "POST"); // }, 1000);   // 1s timeout

        }, function () {
          console.warn('offLine 1');
          openMap.call(me, bid);
        }, 1000);
      } // 离线处理方法


      function offLine() {
        // 无网,直接打开本地数据
        // 进行本地验证
        openMap.call(me, bid);
      } // 这里添加一个设置
      // 主要是为了避免不同的浏览器在navigator.onLine判断是否在线时
      // 有时不能正确的返回结果
      // 所以默认的情况下我们使用navigator.onLine来判断
      // 用户也可以设置另一个兼容一些的onLine判断


      if (this.MapOptions.useCompatibleOnLineCheck) {
        this.isOnLine(onLine, offLine);
      } else {
        if (navigator.onLine) {
          onLine();
        } else {
          offLine();
        }
      } //

    } //旧版本兼容

  }, {
    key: "search",
    value: function search(groupID, query, callback) {
      return _FMMapUtil.default.search(this, groupID, query, callback);
    }
    /*
     * 切换聚焦层 {gid : 1,duration : 0.5,callback :function ,undate:function}
     */

  }, {
    key: "changeFocusToGroup",
    value: function changeFocusToGroup(params) {
      var _this2 = this;

      // if (!this._showAllGroup && this._visibleGroups.indexOf(gid) < 0) return;
      // let srcHeight = this.nodeManager.getHeight(this._currentSceneId,this.currentFocusGroup );
      var center = this.nodeManager.getSceneCenter(this._currentSceneId);
      var srcHeight = this.controls.target.y;
      this.currentFocusGroup = params.gid;
      var destHeight = this.nodeManager.getHeight(this._currentSceneId, this.currentFocusGroup) + center.y; //不用animation

      if (!this.MapOptions.focusAnimateMode) {
        this.controls.panUp(destHeight - srcHeight);
        this.controls.update();
        params.callback && params.callback();
        this.setRenderList();
        return;
      }

      if (_FMGlobal.default[this.uuid]['currentGroupChangeAnimater']) {
        _FMGlobal.default[this.uuid]['currentGroupChangeAnimater'].stop();

        this.removeAnimater(_FMGlobal.default[this.uuid]['currentGroupChangeAnimater']);
      }

      var animater = new _Animater.default({
        h: srcHeight
      }, {
        h: destHeight
      }, params.duration ? params.duration * 1000 : 800, function () {
        _this2.removeAnimater(animater);

        _FMGlobal.default[_this2.uuid]['currentGroupChangeAnimater'] = null;
        params.callback && params.callback();
      }, function (heighter, dheighter) {
        _this2.controls.panUp(dheighter.h); // this.controls.update();


        params.update && params.update();
      }).start();
      _FMGlobal.default[this.uuid]['currentGroupChangeAnimater'] = animater;

      this._animaters.push(animater);
    }
    /**
     * 外部模型加载完成事件
     * @event fengmap.FMMap#gltfLoaded
     */

    /**
     * 地图加载完成事件
     * @event fengmap.FMMap#loadComplete
     */

    /**
     * 开启分层加载时，显示楼层加载完成事件
     * @event fengmap.FMMap#visibleGroupLoaded
     */
    //
    // 地图数据处理。
    // @method dataExcute
    // @param  data  原生数据
    // @param  id  sceneId
    // @param  theme  主题管理器
    //

  }, {
    key: "dataExcute",
    value: function dataExcute(theme, data, id, sendData) {
      var _this3 = this;

      if (!this || !this.MapOptions) {
        return;
      }

      var color = new fm.Color(theme.selectedColor);
      this._modelSelectColor.r = color.r;
      this._modelSelectColor.g = color.g;
      this._modelSelectColor.b = color.b;

      if (this.MapOptions.defaultBackgroundColor === 0) {
        this.MapOptions.defaultBackgroundColor = 0;
      } else {
        !this.MapOptions.defaultBackgroundColor && (this.MapOptions.defaultBackgroundColor = _FMUtil.default.toColor(theme.data.viewtheme.clearcolor));
      }

      if (this.MapOptions.defaultBackgroundAlpha === null) {
        this.MapOptions.defaultBackgroundAlpha = (0, _parseFloat2.default)(theme.data.viewtheme.clearalpha);
      }

      this.renderer.setClearColor(this.MapOptions.defaultBackgroundColor, this.MapOptions.defaultBackgroundAlpha);
      this.dataManager.putRawScene(data, id);
      console.log(this.obtainMapRoute);
      var decodeData = this.dataManager.parseScene(id, this.MapOptions.tile, this.MapOptions.license, this.obtainMapRoute);

      if (!decodeData) {
        return;
      }

      var checked = !decodeData.scene.key ? true : _Cerity.default.checkOffLine(this.MapOptions.key, this.MapOptions.appName, "", decodeData.scene.key);

      if (!checked) {
        console.warn(decodeURIComponent(_warnMessage.cerityMessage.warn_offline));
        openFailBack && openFailBack({
          message: decodeURIComponent(_warnMessage.cerityMessage.warn_local)
        });
        return;
      }

      this.dataManager.putDecodeScene(decodeData, id);
      console.log(decodeData);
      this.nodeManager.conformatScene(decodeData, id, theme);
      this.groupSpace = this.MapOptions.defaultGroupSpace; //数据获取后 初始化相机位置 便于接下来视锥剔除

      this.initCameraPosition();
      var pos = this.renderer.perspectiveCamera.position;
      var frustum = this.renderer.getFrustumByViewMode(this._viewMode);
      var visibleGroups = this.getVisibleGroups();

      if (this.MapOptions.tile) {
        var scene = this.nodeManager.getSceneById(this._currentSceneId);
        scene.sdata = sendData;
        var floors = scene.getNeedLoadGroup(visibleGroups);

        var tileLoader = function tileLoader() {
          var loadOthers = function loadOthers() {
            var orthers = scene.getNeedLoadGroup(visibleGroups, true);

            if (orthers.length < 1) {
              _this3.dispatchEvent({
                type: "loadComplete"
              });

              return;
            }

            _this3.loadAndExcuteData(orthers, scene, 0, false, function (index) {
              _this3.tileLoading = false;

              if (index === orthers.length - 1) {
                _this3.dispatchEvent({
                  type: "loadComplete"
                });
              }
            });
          };

          if (floors.length < 1) {
            _this3.dispatchEvent({
              type: "visibleGroupLoaded"
            });

            loadOthers();
            return;
          }

          _this3.loadAndExcuteData(floors, scene, 0, false, function (index) {
            _this3.nodeManager.checkNodeByFrustum(_this3.dataManager.getDecodeScene(_this3._currentSceneId), _this3.renderer.getFrustumByViewMode(_this3._viewMode), _this3.getVisibleGroups(), _this3.mapScaleLevel, id);

            _this3.setRenderList();

            _this3.avoidMarkers();

            if (index === floors.length - 1) {
              _this3.dispatchEvent({
                type: "visibleGroupLoaded"
              });

              loadOthers();
            }
          });
        };

        this.tileLoading = true; //加载聚焦层

        var groupIndex = -1;

        for (var i = 0; i < floors.length; i++) {
          if (floors[i].gid && floors[i].gid == this._currentFocusGroup) {
            groupIndex = i;
            break;
          }
        }

        if (groupIndex < 0) {
          console.error(_warnMessage2.tileMessage.noFocus);
          return;
        }

        this.loadAndExcuteData(floors, scene, groupIndex, true, function (index) {
          _this3.nodeManager.checkNodeByFrustum(_this3.dataManager.getDecodeScene(_this3._currentSceneId), _this3.renderer.getFrustumByViewMode(_this3._viewMode), _this3.getVisibleGroups(), _this3.mapScaleLevel, id);

          _this3.setRenderList();

          _this3.avoidMarkers();

          floors.splice(groupIndex, 1);
          tileLoader();
        }); // this.on("visibleGroupIDsChanged" ,tileLoader);
      } else {
        this.nodeManager.checkNodeByFrustum(decodeData, frustum, visibleGroups, this.mapScaleLevel, id);
        this.setRenderList();
        this.avoidMarkers();
        this.dispatchEvent({
          type: "visibleGroupLoaded"
        });
        this.dispatchEvent({
          type: "loadComplete"
        });
        this.renderer.setClearColor(this.MapOptions.defaultBackgroundColor, this.MapOptions.defaultBackgroundAlpha);
      }

      this.letUpdate = true;
      setTimeout(function () {
        _this3.animationPlay();

        _this3.renderer.renderer.getContext().canvas.addEventListener("webglcontextlost", function () {// window.location.reload();
          // setTimeout(()=>{
          // 	this.renderer.renderer.forceContextRestore();
          // },5000);
        });
      }, 3000);
    }
  }, {
    key: "animationPlay",
    value: function animationPlay() {
      for (var i = 0; i < this.animaModels.length; i++) {
        var animations = this.animaModels[i].animations;
        var model = this.animaModels[i].model;
        var mixer = new fm.AnimationMixer(model);
        var actions = {};

        for (var ii = 0; ii < animations.length; ii++) {
          var clip = animations[ii];
          var action = mixer.clipAction(clip);
          actions[clip.name] = action;
        }

        this.addAnimationMixer(mixer);
        actions[animations[0].name].clampWhenFinished = true; // console.log(animations[0].name);

        actions[animations[0].name].reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(0.2).play();
      }
    }
  }, {
    key: "loadAndExcuteData",
    value: function loadAndExcuteData(floors, scene, index, single, back) {
      var _this4 = this;

      var lfloor = floors[index];
      this.fmServer.getFloor(this.MapOptions.mapServerURL, lfloor.url, this._currentSceneId, lfloor.gid, function (gdata, bdata, ndata, fid) {
        var datas = _this4.dataManager.parseFloor(gdata, bdata, ndata);

        var floor = {
          geo: [datas[0]],
          biz: [datas[1]],
          navi: [datas[2]],
          gid: fid
        };

        _this4.dataManager.getDecodeScene(_this4._currentSceneId).floors.push(floor);

        lfloor.layerData.loaded = true; // console.log(fid);

        scene.addGroup(fid, floor, lfloor.layerData);
        back && back(index);

        if (single) {
          return;
        }

        index++;

        if (index < floors.length) {
          _this4.loadAndExcuteData(floors, scene, index, false, back);
        }
      }, scene.sdata, this.obtainMapRoute);
    }
  }, {
    key: "moveLinesUv",
    value: function moveLinesUv(x) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this._lineMarkers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var line = _step.value;
          line.moveUv(x);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "resetLineRepeat",
    value: function resetLineRepeat() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator2.default)(this._lineMarkers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var line = _step2.value;
          line.resetRepeat(this);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "hideOrShowLine",
    value: function hideOrShowLine() {
      var maxid = this.groupIDs[this.groupIDs.length - 1];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator2.default)(this._lineMarkers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var marker = _step3.value;
          marker.hideOrShowBy(this._visibleGroups, maxid);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
    /**
     * 显示楼层获取。返回楼层数组
     */

  }, {
    key: "getVisibleGroups",
    value: function getVisibleGroups() {
      return this._visibleGroups; // // 1 ,2 ,3,, 5,6,7,8,9,10,11,12,13,14,15,16,17,18
    }
    /**
     *
     * 设置显示楼层，楼层id数组
     */

  }, {
    key: "setVisibleGroups",
    value: function setVisibleGroups(v) {
      this._visibleGroups = v;
      this.checkNode();
      this.setRenderList();
      this.dispatchEvent({
        type: "visibleGroupIDsChanged",
        gids: v
      });
    } // camera初始化

  }, {
    key: "initCameraPosition",
    value: function initCameraPosition() {
      var cameraDis = this.getCameraDistanceByScale(this.mapScale);
      var center = this.MapOptions.defaultViewCenter;

      try {
        if (!center) {
          center = this.nodeManager.getSceneById(this._currentSceneId).center;
        } else {
          var sceneCenter = this.nodeManager.getSceneById(this._currentSceneId).mapcenter;
          center.x -= sceneCenter.x;
          center.y -= sceneCenter.y;
          center.z = -center.y;
          center.y = 0;
        }

        var cheight = this.nodeManager.getHeight(this._currentSceneId, this._currentFocusGroup);
        center.z = 0;
        center.y += cheight;
        this.controls.target = new fm.Vector3().copy(center);
      } catch (e) {
        console.error(_warnMessage2.mapOptionMessage.defaultViewCenterError);
      }

      if (this._viewMode === "3d") {
        this.controls.minPolarAngle = (90 - this.MapOptions.defaultMaxTiltAngle) * fm.Math.DEG2RAD;
        this.controls.maxPolarAngle = (90 - this.MapOptions.defaultMinTiltAngle) * fm.Math.DEG2RAD; // console.log("dddcenter" , center);

        var defaultAngle = (90 - this.MapOptions.defaultTiltAngle) * fm.Math.DEG2RAD;
        var y = cameraDis * Math.cos(defaultAngle);
        var z = cameraDis * Math.sin(defaultAngle);
        var pos = new fm.Vector3(0, y, z); // pos.applyAxisAngle(new fm.Vector3(0 ,1 ,0) ,15* fm.Math.DEG2RAD);

        this.controls.object.position.set(center.x + pos.x, center.y + pos.y, center.z + pos.z);
        this.controls.object.lookAt(center);
        this.renderer.orthographicCamera.position.set(center.x + pos.x, center.y + pos.y, center.z + pos.z);
        this.renderer.orthographicCamera.lookAt(center);
      } else {
        var zoom = this.getCameraScaleByScale(this.mapScale);
        this.controls.minPolarAngle = 0;
        this.controls.maxPolarAngle = 0;
        this.controls.object.position.set(center.x, center.y + cameraDis, center.z);
        this.controls.object.zoom = 1 / zoom;
        this.controls.object.lookAt(center);
        this.renderer.orthographicCamera.updateProjectionMatrix(); // this.renderer.orthographicCamera.updateMatrix();
      }

      var defualtPorlyAngle = this.MapOptions.computePoseToAngle();
      this.controls.rotateLeft(defualtPorlyAngle * fm.Math.DEG2RAD);

      this._changePanrange(cameraDis, center);

      this.controls.update();
    }
  }, {
    key: "_changePanrange",
    value: function _changePanrange(cameraDis, center) {
      if (this.MapOptions.enabledPanRange) {
        var rati = 0.5;
        var tbox = this.nodeManager.getSceneById(this._currentSceneId).bboxTh;
        this.controls.viewBox = new fm.Box3(new fm.Vector3(tbox.min.x, 0, tbox.min.y), new fm.Vector3(tbox.max.x, this.getGroupHeight(this.groupIDs[this.groupIDs.length - 1]) + this.groupSpace, tbox.max.y));
        this.controls.viewBox.min.multiplyScalar(rati);
        this.controls.viewBox.max.multiplyScalar(rati); // let mpa;
        // if (this.controls.maxPolarAngle > Math.PI / 2) {
        //   mpa = Math.PI / 2;
        // } else if (this.controls.maxPolarAngle <= 0.61) {
        //   mpa = 0.6;
        // } else {
        //   mpa = this.controls.maxPolarAngle;
        // }
        // let radius = cameraDis  / 5;
        // if(center) {
        //   this.controls.rangeCenter = new fm.Vector2();
        //   this.controls.rangeCenter.x = center.x;
        //   this.controls.rangeCenter.y = center.z;
        // }
        // this.controls.rangeRadius = radius;

        this.controls.useRange = true;
      }
    } //scale level相关

  }, {
    key: "scaleLevelInit",
    value: function scaleLevelInit() {
      if (this.MapOptions.mapScaleLevelRange) {
        this.setMapScaleLevelRange(this.MapOptions.mapScaleLevelRange);
      }

      if (this.MapOptions.mapScaleRange) {
        this.setMapScaleRange(this.MapOptions.mapScaleRange);
      }

      if (this.MapOptions.defaultMapScaleLevel) {
        var level = this.MapOptions.defaultMapScaleLevel;
        this._mapScaleLevel = level;
        this._mapScale = this.levelToScale(level); // this.mapScaleLevel = ;
      }

      if (this.MapOptions.defaultMapScale) {
        this.mapScale = this.MapOptions.defaultMapScale;
      }
    }
    /**
     * 地图缩放比例范围设置
     * @param {number} min 最小比例
     * @param {number} max 最大比例
     */

  }, {
    key: "setMapScaleRange",
    value: function setMapScaleRange(min, max) {
      if ((0, _isArray.default)(min)) {
        this.minScale = min[0];
        this.maxScale = min[1];
      } else {
        this.minScale = min;
        this.maxScale = max;
      }
    }
    /**
     * 设置地图比例尺 级别 范围
     * @param {number} min 最小等级
     * @param {number} max 最大等级
     */

  }, {
    key: "setMapScaleLevelRange",
    value: function setMapScaleLevelRange(min, max) {
      if ((0, _isArray.default)(min)) {
        this.minScaleLevel = min[0];
        this.maxScaleLevel = min[1];
      } else {
        this.minScaleLevel = min;
        this.maxScaleLevel = max;
      }
    }
    /*
     * 是否显示所有楼层
     * @param {bool} all true为显示所有楼层
     */

  }, {
    key: "showSingerOrMultiGroup",
    value: function showSingerOrMultiGroup(all) {
      this._showAllGroup = all;

      if (all) {
        this.visibleGroupIDs = this.getCurrGroupIds().slice(0);
      } else {
        this.visibleGroupIDs = [this._currentFocusGroup];
      }
    } // 从动画队列中删除

  }, {
    key: "removeAnimater",
    value: function removeAnimater(animater) {
      var rindex = this._animaters.indexOf(animater);

      if (rindex > -1) {
        this._animaters.splice(rindex, 1);
      }
    }
    /*
     *
     * 地图动画缩小
     */

  }, {
    key: "dollyOut",
    value: function dollyOut() {
      var _this5 = this;

      var temp = 1;
      var animater = new _Animater.default({
        scale: 1
      }, {
        scale: 2
      }, 500, function () {
        _this5.removeAnimater(animater);
      }, function (scaler) {
        var scale = scaler.scale / temp;
        temp = scaler.scale;

        _this5.controls.dollyOut(scale); // this.controls.update();

      }).start();

      this._animaters.push(animater);
    }
    /*
     *  地图动画放大
     *
     */

  }, {
    key: "dollyIn",
    value: function dollyIn() {
      var _this6 = this;

      var temp = 1;
      var animater = new _Animater.default({
        scale: 1
      }, {
        scale: 2
      }, 500, function () {
        _this6.removeAnimater(animater);
      }, function (scaler) {
        var scale = scaler.scale / temp;
        temp = scaler.scale;

        _this6.controls.dollyIn(scale); // this.controls.update();

      }).start();

      this._animaters.push(animater);
    }
    /**
     * 地图动画放大
     */

  }, {
    key: "zoomIn",
    value: function zoomIn() {
      this.dollyIn();
    }
    /**
     * 地图动画缩小
     */

  }, {
    key: "zoomOut",
    value: function zoomOut() {
      this.dollyOut();
    }
  }, {
    key: "checkNode",
    value: function checkNode() {
      if (!this.renderer) {
        return;
      }

      var frustum = this.renderer.getFrustumByViewMode(this._viewMode);
      var id = this._currentSceneId;
      var decodeData = this.dataManager.getDecodeScene(id);
      var scale;

      if (this._viewMode === "top") {
        scale = this.getScaleByCameraScale();
      } else {
        scale = this.getScaleByCameraDistance();
      }

      var level = this.scaleTolevel(scale);
      this.nodeManager.checkNodeByFrustum(decodeData, frustum, this.getVisibleGroups(), level, id);
    }
  }, {
    key: "getCurrDecodeData",
    value: function getCurrDecodeData() {
      var id = this._currentSceneId;
      var decodeData = this.dataManager.getDecodeScene(id);
      return decodeData;
    }
    /**
     * 背景色与透明度设置
     * @param {string|int} color 颜色值0xFF0000 | '#FF0000'
     * @param {number} alpha 透明度，取值范围：0.0 - 1.0
     */

  }, {
    key: "setBackgroundColor",
    value: function setBackgroundColor(color, alpha) {
      var _this7 = this;

      if (typeof color === "string") {
        color = (0, _parseInt2.default)(color.replace("#", "0x")); // color = parseInt(color.slice(1),16);
      }

      setTimeout(function () {
        _this7.renderer.setClearColor(color, alpha);
      }, 500);
    }
  }, {
    key: "setBackground",
    value: function setBackground(url) {
      this.renderer.setClearColor(0, 0);
      this.renderer.setBackground(url);
    }
  }, {
    key: "addAnimationMixer",
    value: function addAnimationMixer(mixer) {
      this.animationMixers.push(mixer);
    }
  }, {
    key: "setRenderList",
    value: function setRenderList() {
      var _this8 = this;

      if (!this.nodeManager) {
        return;
      }

      if (this.visibleGroupIDs.length > 1) {
        var rotationY = this.nodeManager._scenes[this._currentSceneId].groups[this.focusGroupID]._layers.extent[0]._scene.rotation.y;

        for (var i = 0; i < this.visibleGroupIDs.length; i++) {
          if (this.visibleGroupIDs[i] !== this.focusGroupID) {
            (function () {
              //this.nodeManager._scenes[this._currentSceneId].groups[this.visibleGroupIDs[i]]._layers.extent[0]._scene.rotation.y = rotationY;
              var layers = _this8.nodeManager._scenes[_this8._currentSceneId].groups[_this8.visibleGroupIDs[i]]._layers;
              (0, _keys.default)(layers).forEach(function (key) {
                if (key !== 'domMarker') {
                  var layer = layers[key];

                  if (layer.length > 0) {
                    layer[0]._scene.rotation.y = rotationY;
                  }
                }
              });
            })();
          }
        }
      }

      var rl = this.nodeManager.getRenderList();
      this.renderer.renderList = rl;
      this.renderer.resetSpriteSize();
    }
  }, {
    key: "rushRenderNode",
    value: function rushRenderNode() {
      this.setRenderList();
      this.renderer.resetSpriteSize();
    }
    /**
     * 地图比例尺级别变化时的回调。
     * @event fengmap.FMMap#scaleLevelChanged
     * @type {json}
     * @property {string} type "scaleLevelChanged"
     * @property {number} scale 改变后的比例尺级别。
     */

    /**
     * 地图级别变化时的回调。
     * @event fengmap.FMMap#mapScaleLevelChanged
     * @type {json}
     * @property {string} type "mapScaleLevelChanged"
     * @property {number} scale 改变后的比例尺级别。
     */
    //主控制器事件监听

  }, {
    key: "controlEventInit",
    value: function controlEventInit() {
      var _this9 = this;

      this.controls.addEventListener("change", function () {
        // let time1 = new Date().getTime();
        _this9.checkNode();

        _this9.setRenderList();

        _this9.avoidMarkers(); // let time2 = new Date().getTime();
        // console.log("rt1",time2 - time1);
        // console.log(1);


        if (_this9.renderer.compassNode) {
          _this9.renderer.compassNode.material.uniforms["rotation"].value = -_this9.controls.getAzimuthalAngle();
        }

        var scale;

        if (_this9._viewMode === "top") {
          scale = _this9.getScaleByCameraScale();
        } else {
          scale = _this9.getScaleByCameraDistance();
        }

        _this9.dispatchEvent({
          type: "mapViewChanged"
        });

        if (Math.abs(scale - _this9._mapScale) > 0.5) {
          _this9.dispatchEvent({
            type: "scaleLevelChanged",
            scale: scale
          });
        }

        _this9._mapScale = scale;

        var level = _this9.scaleTolevel(scale);

        if (level !== _this9._mapScaleLevel) {
          _this9._mapScaleLevel = level;

          _this9.dispatchEvent({
            type: "mapScaleLevelChanged",
            mapScale: level
          });
        } // let dis = this.getCameraDistanceByScale(scale);
        // let center = this.nodeManager.getSceneCenter(this._currentSceneId);
        // this._changePanrange(dis);


        _this9._mapScaleLevel = level;

        _this9.renderer.resetSpriteSize();

        _this9.moveLinesUv(0.01);

        _this9.resetLineRepeat();

        _this9.renderer.resetLocationsSize(); // let time3 = new Date().getTime();
        // console.log("rt2",time3 - time2);

      });
      var timeStart = 0;
      var timeEnd = 0;
      var time = null;
      var marker = null;
      var changeflag = true;
      var oldscale = null;

      if (this.isMarkerMove) {
        this.MapOptions.container.addEventListener("mousedown", function (e) {
          var coord = {
            x: e.offsetX * 2 / _this9.MapOptions.container.clientWidth - 1,
            y: 1 - e.offsetY * 2 / _this9.MapOptions.container.clientHeight
          };
          timeStart = new Date().getTime(); // if(markers.length!==0){
          // 	marker=markers[0].object;
          // oldscale={
          // 	x:marker.scale.x,
          // 	y:marker.scale.y,
          // 	z:marker.scale.z
          // };

          time = setInterval(function () {
            timeEnd = new Date().getTime();

            if (timeEnd - timeStart > 500) {
              var markers = _this9.nodeManager.getFacility(_this9._currentSceneId, _this9.getVisibleGroups(), coord, _this9.renderer.getCameraByViewMode(_this9._viewMode));

              if (markers.length > 0) {
                _this9.dispatchEvent({
                  type: "press",
                  target: markers[0].object.mapNode
                });
              }

              clearInterval(time);
            }
          }, 250); //}
        });
      }

      this.controls.addEventListener("mouseup", function (e) {
        var mousePoint = e.mousePoint;
        var coord = {
          x: mousePoint.x * 2 / mousePoint.w - 1,
          y: 1 - mousePoint.y * 2 / mousePoint.h
        }; //

        _this9._eventId++;

        var clickEvent = _this9.dispatchClickEvent(coord, e.event);

        if (e.mouseButton === fm.MOUSE.LEFT) {
          if (clickEvent && clickEvent.target != null) {
            if (clickEvent.target._nodeType != 4) {
              _this9.modelFire(coord);
            } else {
              _this9.selectNull();
            }
          }
        }

        _this9.checkCompassClick(coord);

        if (time !== null) {
          clearInterval(time);
          time = null; // if(marker!==null){
          // 	marker.scale.x=oldscale.x;
          // 	marker.scale.y=oldscale.y;
          //     marker.scale.z=oldscale.z;
          // 	marker=null
          // }
        }

        _this9.dispatchEvent({
          type: "pressover"
        });
      });
      this.controls.addEventListener("mousemove", function (e) {
        //this.MapOptions.container.focus();
        if (_this9.isMarkerTip || _this9.isMarkerMove) {
          _this9.mouseIntoInfo(e);
        }

        _this9._lastMoveEvent = e;
        _this9._mouseHoverTime = 0;
        _this9._mouseHoverStart = true;

        if (time !== null) {
          clearInterval(time);
          time = null; // if(marker!==null){
          // 	marker.scale.x=oldscale.x;
          // 	marker.scale.y=oldscale.y;
          //     marker.scale.z=oldscale.z;
          // 	marker=null
          // }
        }
      });
    }
  }, {
    key: "mouseIntoInfo",
    value: function mouseIntoInfo(e) {
      var mousePoint = e.mousePoint;
      var coord = {
        x: mousePoint.x * 2 / mousePoint.w - 1,
        y: 1 - mousePoint.y * 2 / mousePoint.h
      }; // document.body.style.cursor='pointer';
      //console.log(markers[0].object.markername);

      if (!this.isMarkerTip) {
        var markers = this.nodeManager.getFacility(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode));

        if (markers.length !== 0) {
          this.dispatchEvent({
            type: "hover",
            target: markers[0].object.mapNode
          });
        } else {
          this.dispatchEvent({
            type: "mouseleave"
          }); // document.body.style.cursor='default';
          // if(document.getElementById('infodiv')!==null){
          // 	document.body.removeChild(document.getElementById('infodiv'));
          // }
        }

        return;
      } // if(document.getElementById('infodiv')!==null){
      // 	document.body.removeChild(document.getElementById('infodiv'));
      // }
      // var infodiv=document.createElement('div');
      // infodiv.id='infodiv';
      // infodiv.style.cssText='position:absolute;color:#FFFFFF;opacity:0.8;top:'+(e.event.clientY-80)+'px;left:'+(e.event.clientX-90)+'px;border-radius:10px;z-index:1000;margin-top: 10px; width:180px; height:35px; background: #666; border- radius: 8px; text-align:center; padding: 15px 1px 0px 1px;';
      // var div1=document.createElement('div');
      // div1.innerHTML=markers[0].object.markername;
      // infodiv.appendChild(div1);
      // var div2=document.createElement('div');
      // div2.style.cssText='width: 0; height: 0; border-style:solid; border-width:10px; border-color:#666 transparent transparent transparent; margin: 14px auto 0 auto;';
      // infodiv.appendChild(div2);
      // document.body.appendChild(infodiv);
      // infodiv.onmouseover=function(e2){
      // 	document.body.removeChild(infodiv);
      // }

    }
  }, {
    key: "checkCompassClick",
    value: function checkCompassClick(coord) {
      if (!this.renderer) {
        return;
      }

      if (!this.renderer.compassNode || !this.showCompass) return;
      var userData = this.renderer.compassNode.userData;

      if (_Graphics.default.pointIsInRect(coord, userData.coord, userData.width, userData.width)) {
        this.dispatchEvent({
          type: "mapClickCompass",
          target: this.renderer.compassNode
        });
      }
    }
    /**
     * 地图点击事件。默认所有地图元素均可点击拾取，可通过fengmap.FMMap属性pickFilterFunction设置某些地图元素的不可点击拾取属性。
     * @event fengmap.FMMap#mapClickNode
     * @type {json}
     * @property {string} type "mapClickNode"
     * @property {fengmap.FMNode} target 当前点击拾取到的fengmap.FMNode对象。当nodeType !== 0时，target 包含FMNode对象的属性。如下：
     * @property {string} target.FID 模型的唯一编码
     * @property {number} target.groupID 当前楼层
     * @property {number} target.height FMNode对象的高度
     * @property {number} target.typeID FMNode对象的类型ID
     * @property {json} target.mapCoord 当前对象对应的中心点坐标
     * @property {boolean} target.show  是否显示
     * @property {number} target.minlevel 最小显示级别
     * @property {number} target.maxlevel 最大显示级别
     * @property {number} target.x   x坐标
     * @property {number} target.y   y坐标
     * @property {number} target.z   z坐标
     * @property {MouseEvent} domEvent 当前触发点击的鼠标或触摸事件，包含点击位置的屏幕坐标，domElement等信息。
     * @property {json} eventInfo 封装根据当前触发点击事件计算后的一些属性。
     * @property {MouseEvent} eventInfo.domEvent 当前触发点击的鼠标或触摸事件，包含点击位置的屏幕坐标，domElement等信息。
     * @property {json} eventInfo.coord 点击位置的地图坐标。
     * @property {fengmap.FMNodeType} nodeType 当前触发点击事件拾取到的结点类型。
     *
     */

  }, {
    key: "dispatchClickEvent",
    value: function dispatchClickEvent(coord, e) {
      if (!this._enterControl.enableMapSingleTap) {
        return;
      }

      var nodes = this.nodeManager.getNode(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode)); // let nodes = [];

      var facilitys = this.nodeManager.getFacility(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode)); //外部模型

      var externalmodels = this.nodeManager.getExternalModels(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode)); //console.log(1229,externalmodels);

      var clickEvent;
      var nullEvent = {
        type: 'mapClickNode',
        target: null,
        mouse: e.mouse,
        domEvent: e,
        // 并装原始的dom事件体,回传
        eventInfo: {
          domEvent: e,
          coord: null,
          eventID: this._eventId
        },
        nodeType: null
      };

      if (nodes.length < 1 && facilitys.length < 1 && externalmodels.length < 1) {
        this.dispatchEvent(nullEvent);
        clickEvent = {};
        clickEvent.target = true;
        return clickEvent;
      } else {
        if (facilitys.length >= 1) {
          var fickFilterFlag = 0;

          if (this.pickFilterFunction) {
            var filter = this.pickFilterFunction({
              nodeType: facilitys[0].object.mapNode.nodeType,
              typeID: facilitys[0].object.mapNode.bdata && facilitys[0].object.mapNode.bdata.type,
              data: facilitys[0].object.mapNode.bdata
            });

            if (!filter) {
              // this.dispatchEvent(nullEvent);
              fickFilterFlag = 1;
            }
          }

          clickEvent = {
            type: 'mapClickNode',
            target: facilitys[0].object.mapNode,
            mouse: e.mouse,
            domEvent: e,
            // 并装原始的dom事件体,回传
            eventInfo: {
              domEvent: e,
              // 并装原始的dom事件体,回传
              coord: {
                x: facilitys[0].object.mapNode.x,
                y: facilitys[0].object.mapNode.y
              },
              eventID: this._eventId
            },
            mapCoord: {
              x: facilitys[0].object.mapNode.x,
              y: facilitys[0].object.mapNode.y
            },
            nodeType: facilitys[0].object.mapNode.nodeType
          };

          if (fickFilterFlag === 1) {
            this.dispatchEvent(nullEvent);
          } else {
            this.dispatchEvent(clickEvent);
          }
        }

        if (nodes.length >= 1) {
          var _fickFilterFlag = 0;

          if (this.pickFilterFunction) {
            var _filter = this.pickFilterFunction({
              nodeType: nodes[0].object.mapNode.nodeType,
              typeID: nodes[0].object.mapNode.bdata && nodes[0].object.mapNode.bdata.type,
              data: nodes[0].object.mapNode.bdata
            });

            if (!_filter) {
              // this.dispatchEvent(nullEvent);
              _fickFilterFlag = 1;
            }
          }

          var _coord = new fm.Vector3().copy(nodes[0].point);

          clickEvent = {
            type: 'mapClickNode',
            target: nodes[0].object.mapNode,
            mouse: e.mouse,
            domEvent: e,
            // 并装原始的dom事件体,回传
            eventInfo: {
              domEvent: e,
              // 并装原始的dom事件体,回传
              threeCoord: _coord,
              coord: {
                x: _coord.x + this.center.x,
                y: this.center.y - _coord.z
              },
              eventID: this._eventId
            },
            mapCoord: {
              x: _coord.x + this.center.x,
              y: this.center.y - _coord.z
            },
            nodeType: nodes[0].object.mapNode.nodeType
          }; // 用于某个版本两个顶面贴图通过点击事件决定顺序的代码片段
          // if (clickEvent.target._nodeType ===5) {
          //     for(let i in clickEvent.target.parent._models){
          //       if (clickEvent.target.parent._models["" + i]._renderNode && clickEvent.target.parent._models["" + i]._renderNode.children.length > 1) {
          //         clickEvent.target.parent._models[""+i]._renderNode.children[1].renderOrder = 10;
          //       }
          //     }
          //     if (clickEvent.target._renderNode.children.length > 1) {
          //       clickEvent.target._renderNode.children[1].renderOrder = 11;
          //     }
          // }

          if (_fickFilterFlag === 1) {
            this.dispatchEvent(nullEvent);
            return nullEvent;
          } else {
            this.dispatchEvent(clickEvent);
            return clickEvent;
          }
        }

        if (externalmodels.length >= 1) {
          //console.log(externalmodels[0]);
          var _coord2 = new fm.Vector3().copy(externalmodels[0].point);

          clickEvent = {
            type: 'mapClickNode',
            target: externalmodels[0].object,
            mouse: e.mouse,
            domEvent: e,
            // 并装原始的dom事件体,回传
            eventInfo: {
              domEvent: e,
              // 并装原始的dom事件体,回传
              threeCoord: _coord2,
              coord: {
                x: _coord2.x + this.center.x,
                y: this.center.y - _coord2.z
              },
              eventID: this._eventId
            },
            mapCoord: {
              x: _coord2.x + this.center.x,
              y: this.center.y - _coord2.z
            },
            nodeType: 35
          };
          this.dispatchEvent(clickEvent);
          return clickEvent;
        }
      }
    }
    /**
     * 根据类型别名获取指定楼层上面的某图层数据
     * @param {number} gid 楼层id
     * @param {string} alias 别名，供设置的值有：'extent' | 'model' | 'label' | 'facility' | 'textMarker' | 'imageMarker' | 'externalModel'
     * @param {function} filter 过滤函数
     * @return {array} 地图元素数据
     */

  }, {
    key: "getDatasByAlias",
    value: function getDatasByAlias(gid, alias, filter) {
      if (!filter) {
        filter = function filter() {
          return true;
        };
      }

      var scene = this.nodeManager.getSceneById(this._currentSceneId);
      return scene.getGroupsNodelsByFilter([gid], alias, filter);
    }
    /**
     * 地图hover事件，默认不开启，可通过fengmap.MapOptions中的modelHoverEffect:true开启、或通过map.hoverFilterFunction方法针对不同的模型开启hover事件。mapHoverClickNode事件的返回值和mapClickNode相同。
     * @event fengmap.FMMap#mapHoverNode
     * @type {json}
     */

  }, {
    key: "mouseHoverEventFire",
    value: function mouseHoverEventFire(delTime) {
      if (this._mouseHoverStart) {
        if (this._mouseHoverTime > this.MapOptions.modelHoverTime) {
          if (!this._enterControl.enableMapHover) {
            return;
          }

          if (!this._lastMoveEvent) return;
          var e = this._lastMoveEvent;
          var mousePoint = e.mousePoint;
          var coord = {
            x: mousePoint.x * 2 / mousePoint.w - 1,
            y: 1 - mousePoint.y * 2 / mousePoint.h
          };
          var nodes = this.nodeManager.getNode(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode));
          var facilitys = this.nodeManager.getFacility(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode));
          if (nodes.length < 1 && facilitys.length < 1) return;

          if (nodes[0]) {
            var coord2 = new fm.Vector3().copy(nodes[0].point);
            var resultevent = {
              type: "mapHoverNode",
              target: nodes[0].object.mapNode,
              mouse: mousePoint,
              eventInfo: {
                domEvent: e.event,
                // 并装原始的dom事件体,回传
                threeCoord: nodes[0].point,
                eventID: e.eventID,
                coord: {
                  x: coord2.x + this.center.x,
                  y: nodes[0].object.mapNode.y - coord2.z
                }
              },
              groupID: nodes[0].object.mapNode.groupID,
              nodeType: nodes[0].object.mapNode.nodeType
            };

            if (this.hoverFilterFunction) {
              var filter = this.hoverFilterFunction({
                nodeType: nodes[0].object.mapNode.nodeType,
                typeID: nodes[0].object.mapNode.bdata && nodes[0].object.mapNode.bdata.type,
                data: nodes[0].object.mapNode.bdata
              });

              if (!filter) {} else {
                if (nodes[0].object.mapNode.nodeType === _FMNodeType.default.MODEL) {
                  if (this.MapOptions.modelHoverEffect) {
                    this.storeSelect(nodes[0].object);
                  }
                }

                this.dispatchEvent(resultevent);
              }
            } else {
              if (nodes[0].object.mapNode.nodeType === _FMNodeType.default.MODEL) {
                if (this.MapOptions.modelHoverEffect) {
                  this.storeSelect(nodes[0].object);
                }
              }

              this.dispatchEvent(resultevent);
            }
          }

          if (facilitys[0]) {
            var _coord3 = new fm.Vector3().copy(facilitys[0].point);

            var _resultevent = {
              type: "mapHoverNode",
              target: facilitys[0].object.mapNode,
              mouse: mousePoint,
              eventInfo: {
                domEvent: e.event,
                // 并装原始的dom事件体,回传
                threeCoord: facilitys[0].point,
                eventID: e.eventID,
                coord: {
                  x: _coord3.x + this.center.x,
                  y: facilitys[0].object.mapNode.y - _coord3.z
                }
              },
              groupID: facilitys[0].object.mapNode.groupID,
              nodeType: facilitys[0].object.mapNode.nodeType
            };

            if (this.hoverFilterFunction) {
              var _filter2 = this.hoverFilterFunction({
                nodeType: facilitys[0].object.mapNode.nodeType,
                typeID: facilitys[0].object.mapNode.bdata && facilitys[0].object.mapNode.bdata.type,
                data: facilitys[0].object.mapNode.bdata
              });

              if (!_filter2) {} else {
                this.dispatchEvent(_resultevent);
              }
            } else {
              this.dispatchEvent(_resultevent);
            }
          }

          this._mouseHoverStart = false;
          this._mouseHoverTime = 0;
        } else {
          this._mouseHoverTime += delTime;
        }
      }
    }
    /*
     * 取消模型高亮
     *
     */

  }, {
    key: "selectNull",
    value: function selectNull() {
      if (_FMGlobal.default[this.uuid].currentModel) {
        if (_FMGlobal.default[this.uuid].currentAnimater) {
          _FMGlobal.default[this.uuid].currentAnimater.stop();

          _FMGlobal.default[this.uuid].currentAnimater = undefined;
        }

        var currentModel = _FMGlobal.default[this.uuid].currentModel;

        if (typeof _FMGlobal.default[this.uuid].currentModel.material.length === "undefined") {
          currentModel.material.color = _FMGlobal.default[this.uuid].currentModel.material.userData.color;
          currentModel.material.opacity = _FMGlobal.default[this.uuid].currentModel.material.userData.opacity;
          currentModel.material.userData.opacity = undefined;
          currentModel.material.userData.color = undefined;
          currentModel.material.update = true;
          _FMGlobal.default[this.uuid].currentModel = undefined;
        } else {
          for (var i = 0; i < _FMGlobal.default[this.uuid].currentModel.material.length; i++) {
            currentModel.material[i].color = _FMGlobal.default[this.uuid].currentModel.material[i].userData.color;
            currentModel.material[i].opacity = _FMGlobal.default[this.uuid].currentModel.material[i].userData.opacity;
            currentModel.material[i].userData.opacity = undefined;
            currentModel.material[i].userData.color = undefined;
            currentModel.material[i].update = true;
          }

          _FMGlobal.default[this.uuid].currentModel = undefined;
        }
      }
    }
    /**
     * 根据别名遍历对应layer
     * @param {string} alias 别名，供设置的值有：'extent' | 'model' | 'label' | 'facility' | 'textMarker' | 'imageMarker' | 'externalModel'
     * @param {fucntion} back 回调函数
     * @param {object} back.layer 回调返回参数，查询到的某一楼层的图层
     */

  }, {
    key: "callAllLayersByAlias",
    value: function callAllLayersByAlias(alias, back) {
      this.nodeManager.getSceneById(this._currentSceneId).getAllGroupLayerByAlias(alias, back);
    }
    /*
     * 高亮store模型，只高亮当前模型。
     * @param {fengmap.FMModel} model store模型对象，可通过点击拾取或搜索获取某模型对象。
     */

  }, {
    key: "storeSelect",
    value: function storeSelect(model) {
      var _this10 = this;

      var mmodel = model;

      if (model.nodeType && model.nodeType === _FMNodeType.default.MODEL) {
        if (!model.renderNodeInited) {
          return;
        }

        mmodel = model.renderNode;
      }

      if (_FMGlobal.default[this.uuid].currentModel && _FMGlobal.default[this.uuid].currentModel !== mmodel) {
        if (_FMGlobal.default[this.uuid].currentAnimater) {
          _FMGlobal.default[this.uuid].currentAnimater.stop();

          _FMGlobal.default[this.uuid].currentAnimater = undefined;
        }

        if (typeof _FMGlobal.default[this.uuid].currentModel.material.length === "undefined") {
          _FMGlobal.default[this.uuid].currentModel.material.color = _FMGlobal.default[this.uuid].currentModel.material.userData.color;
          _FMGlobal.default[this.uuid].currentModel.material.opacity = _FMGlobal.default[this.uuid].currentModel.material.userData.opacity;
          _FMGlobal.default[this.uuid].currentModel.material.update = true;
        } else {
          for (var i = 0; i < _FMGlobal.default[this.uuid].currentModel.material.length; i++) {
            _FMGlobal.default[this.uuid].currentModel.material[i].color = _FMGlobal.default[this.uuid].currentModel.material[i].userData.color;
            _FMGlobal.default[this.uuid].currentModel.material[i].opacity = _FMGlobal.default[this.uuid].currentModel.material[i].userData.opacity;
            _FMGlobal.default[this.uuid].currentModel.material[i].update = true;
          }
        }
      }

      _FMGlobal.default[this.uuid].currentModel = mmodel;

      if (typeof mmodel.material.length === "undefined") {
        //currentModel.material.userData.opacity = undefined;
        //currentModel.material.userData.color = undefined;
        if (!mmodel.material.userData.color) {
          mmodel.material.userData.color = mmodel.material.color;
          mmodel.material.userData.opacity = mmodel.material.opacity;
        }
      } else {
        for (var _i = 0; _i < mmodel.material.length; _i++) {
          if (!mmodel.material[_i].userData.color) {
            mmodel.material[_i].userData.color = mmodel.material[_i].color;
            mmodel.material[_i].userData.opacity = mmodel.material[_i].opacity;
          }
        }
      }

      if (!_FMGlobal.default[this.uuid].currentAnimater) {
        var color_a = this._modelSelectColor.a;

        if (color_a === 0) {
          color_a = 1;
        }

        var animater = new _Animater.default({
          r: this._modelSelectColor.r / 2,
          g: this._modelSelectColor.g / 2,
          b: this._modelSelectColor.b / 2,
          a: color_a / 2
        }, this._modelSelectColor, 500, function () {
          _this10.removeAnimater(animater);

          _FMGlobal.default[_this10.uuid].currentAnimater = null;
        }, function (color) {
          if (typeof mmodel.material.length === "undefined") {
            if (mmodel.material.userData.color) {
              mmodel.material.color = new fm.Color(color.r, color.g, color.b);
              mmodel.material.opacity = color_a;
              mmodel.material.update = true;
            }
          } else {
            for (var _i2 = 0; _i2 < mmodel.material.length; _i2++) {
              if (mmodel.material[_i2].userData.color) {
                mmodel.material[_i2].color = new fm.Color(color.r, color.g, color.b);
                mmodel.material[_i2].opacity = color_a;
                mmodel.material[_i2].update = true;
              }
            }
          }
        });
        _FMGlobal.default[this.uuid].currentAnimater = animater;
        animater.start();

        this._animaters.push(animater);
      }
    }
  }, {
    key: "modelFire",
    value: function modelFire(coord) {
      // let models = this.nodeManager.getModel(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode));
      var models = [];
      var models1 = [];

      if (!this.MapOptions) {
        return;
      }

      if (!this.MapOptions.lightEffects) {
        models = this.nodeManager.getModelExternal(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode)); // let models = this.nodeManager.getModelExternal(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode));

        if (models.length < 1) {
          this.selectNull();
          return;
        }

        if (!this.MapOptions.modelSelectedEffect) return;
        this.storeSelect(models[0].object);
      } else {
        models = this.nodeManager.getExternalModels(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode));
        models1 = this.nodeManager.getModel(this._currentSceneId, this.getVisibleGroups(), coord, this.renderer.getCameraByViewMode(this._viewMode));
        var models0 = models.concat(models1);

        if (models0.length < 1) {
          this.selectNull();
          return;
        }

        if (!this.MapOptions.modelSelectedEffect) return;
        this.storeSelect(models0[0].object); // this.renderer.outlinePass.selectedObjects = models[0].object;
        // models[0].object.name = "luminance";
      }
    }
    /**
     * 设置模型拾取颜色
     * @param {string|number} color 十六进制颜色值或CSS颜色样式: 0xFF0000 | '#FF0000'
     * @param {number} alpha 透明度。在0 ~ 1之间取值。
     */

  }, {
    key: "setModelSelectColor",
    value: function setModelSelectColor(color, alpha) {
      var selectColor = new fm.Color();
      selectColor.set(color);
      this._modelSelectColor = {
        r: selectColor.r,
        g: selectColor.g,
        b: selectColor.b,
        a: alpha
      };
    }
    /*
     * 文字避让
     */

  }, {
    key: "checkMarkerAvoid",
    value: function checkMarkerAvoid(markers) {
      // console.log(markers.length);
      if (markers.length < 1) {
        return;
      } // console.log(markers.length);


      var marker = markers[0]; // console.log(marker.target.mapNode._text);

      var remarkers = [];

      for (var i = 1; i < markers.length; i++) {
        if (_Graphics.default.isRectCross(marker.leftTop, marker.rightDown, markers[i].leftTop, markers[i].rightDown)) {
          markers[i].target.visible = false;
        } else {
          markers[i].target.visible = true;
          remarkers.push(markers[i]);
        }
      }

      if (remarkers.length > 1) {
        remarkers.reverse();
        this.checkMarkerAvoid(remarkers);
      }
    }
  }, {
    key: "avoidMarkers",
    value: function avoidMarkers() {
      var scene = this.nodeManager.getSceneById(this._currentSceneId);
      if (!scene) return;
      var camera = this.renderer.getCameraByViewMode(this._viewMode);

      for (var i = 0; i < this._visibleGroups.length; i++) {
        var markers = scene.getMarkers(this._visibleGroups[i], camera, this.renderer.domElementHeight);
        this.checkMarkerAvoid(markers);
        var userMarkers = scene.getUserMarkers(this._visibleGroups[i], camera, this.renderer.domElementHeight);

        for (var j = 0; j < userMarkers.length; j++) {
          this.checkMarkerAvoid(userMarkers[j]);
        }
      }
    }
    /*
     * 新增动画对象
     * @param {*} animater
     */

  }, {
    key: "addAnimater",
    value: function addAnimater(animater) {
      this._animaters.push(animater);
    }
    /*
     * theme数据处理
     */

  }, {
    key: "initTheme",
    value: function initTheme(themeName, themeData, success) {
      var type = this.MapOptions.themeFileType || themeData['filetype'] || themeData['fileType'] || themeData['image'];
      var me = this;
      var themeManager = new _ThemeManager.default(this.MapOptions.mapThemeURL, themeName);
      themeManager.clearColor = this.MapOptions.defaultBackgroundColor;
      themeManager.clearAlpha = this.MapOptions.defaultBackgroundAlpha;
      themeManager.version = this.MapOptions.themeVersion;

      if (type == 'rtheme') {
        var themeUrl = this.MapOptions.mapThemeURL + '/' + this.MapOptions.themeName + '/' + themeName + '.rtheme';
        this.fmServer.getTheme(themeUrl, function (rtheme) {
          themeManager.rtheme = rtheme;
          themeManager.data = themeData;

          if (success) {
            themeManager.fileType = type;
            success(themeManager);
          }
        }, function () {
          themeManager.rtheme = null;
          console.warn('以 rtheme 格式加入资源失败!');
        });
      } else {
        // 以原始的fmi图片形式
        themeManager.rtheme = null;
        themeManager.data = themeData;

        if (success) {
          success(themeManager);
        }
      }

      this._modelSelectColor = themeManager.getModelSelectColor();
    }
    /*
     * 缩放等级转成缩放比例
     * @param {*} level
     */

  }, {
    key: "levelToScale",
    value: function levelToScale(level) {
      return this.mapScaleLevels[level - 1];
    }
    /*
     * 缩放比例转成缩放等级
     * @param {*} level
     */

  }, {
    key: "scaleTolevel",
    value: function scaleTolevel(scale) {
      if (scale > this.mapScaleLevels[0]) {
        return 1;
      }

      if (scale < this.mapScaleLevels[this.mapScaleLevels.length - 1]) {
        return this.mapScaleLevels.length;
      }

      for (var i = 0; i < this.mapScaleLevels.length - 1; i++) {
        if (scale >= this.mapScaleLevels[i + 1] && scale <= this.mapScaleLevels[i]) {
          var toLeft = scale - this.mapScaleLevels[i + 1];
          var toRight = this.mapScaleLevels[i] - scale;
          return toLeft < toRight ? i + 2 : i + 1;
        }
      }
    }
    /*
     * 计算像素与物理尺寸比 （厘米）
     */

  }, {
    key: "getMapScaleInfo",
    value: function getMapScaleInfo() {
      var dpi;

      for (var i = 56; i < 2000; i++) {
        if (matchMedia("(max-resolution: " + i + "dpi)").matches === true) {
          dpi = i / window.devicePixelRatio;
        }
      }

      if (window.screen.deviceXDPI) {
        dpi = window.screen.deviceXDPI;
      } else {
        var tmpNode = document.createElement("DIV");
        tmpNode.style.cssText = "width:1in;height:1in;position:absolute;left:0px;top:0px;z-index:99;visibility:hidden";
        document.body.appendChild(tmpNode);
        dpi = (0, _parseInt2.default)(tmpNode.offsetWidth);
        tmpNode.parentNode.removeChild(tmpNode);
      }

      this._pixelsPerCentimeter = dpi / 2.54; //1cm代表像素长度
    }
    /*
     *
     * @param {*} cameraP
     * @param {*} controls
     * @param {*} distance
     */

  }, {
    key: "getOrthoCameraSizeByPerspectiveCamera",
    value: function getOrthoCameraSizeByPerspectiveCamera(cameraP, controls, distance) {
      if (cameraP instanceof FMMap) {
        distance = controls;
        controls = cameraP.controls;
        cameraP = cameraP.mapView.camera;
      }

      var fov = cameraP.fov;
      var aspect = cameraP.aspect;
      var hyperfocus = distance != undefined ? distance : controls.target.distanceTo(cameraP.position);
      var halfHeight = Math.tan(fov * fm.Math.DEG2RAD / 2) * hyperfocus;
      var planeHeight = 2 * halfHeight;
      var planeWidth = planeHeight * aspect;
      var halfWidth = planeWidth / 2;
      return {
        top: halfHeight || 1,
        right: halfWidth
      };
    }
    /*
     * 利用缩放值求相机到中心点的距离
     * perspective
     * @param {*} scale
     */

  }, {
    key: "getCameraDistanceByScale",
    value: function getCameraDistanceByScale(scale) {
      var fov = this.renderer.perspectiveCamera.fov; //屏幕上一厘米转换为三维空间近截面高度

      var dis = scale / 100 * (this.renderer.domElementHeight / this._pixelsPerCentimeter) / 2 / Math.tan(fov / 2 * fm.Math.DEG2RAD);
      return dis;
    }
    /*
     * 利用机到中心点的距离求缩放值
     * perspective
     */

  }, {
    key: "getScaleByCameraDistance",
    value: function getScaleByCameraDistance() {
      var fov = this.renderer.perspectiveCamera.fov;
      var d = new fm.Vector3().copy(this.controls.object.position).sub(this.controls.target).length();

      var cmAtNear = 100 * Math.tan(fov / 2 * fm.Math.DEG2RAD) * 2 / (this.renderer.domElementHeight / this._pixelsPerCentimeter);

      return d * cmAtNear;
    }
    /*
     * 利用缩放值求相机scale
     * orth
     * @param {*} scale
     */

  }, {
    key: "getCameraScaleByScale",
    value: function getCameraScaleByScale(scale) {
      var top = this.renderer.orthographicCamera.top;
      var bottom = this.renderer.orthographicCamera.bottom; //屏幕上一厘米转换为三维空间近截面高度

      var cmAtNear = Math.abs(top - bottom) * this._pixelsPerCentimeter * 100 / this.renderer.domElementHeight;
      return scale / cmAtNear;
    }
    /*
     * 利用相机scale求缩放值
     * orth
     */

  }, {
    key: "getScaleByCameraScale",
    value: function getScaleByCameraScale() {
      var top = this.renderer.orthographicCamera.top;
      var bottom = this.renderer.orthographicCamera.bottom; //屏幕上一厘米转换为三维空间近截面高度

      var cmAtNear = Math.abs(top - bottom) * this._pixelsPerCentimeter * 100 / this.renderer.domElementHeight;
      return cmAtNear / this.renderer.orthographicCamera.zoom;
    }
    /**
     * 获取对应楼层别名为alias的layer
     *
     * @param {number} gid 楼层id
     * @param {string} alias 图层别名,供设置的值有：'extent' | 'model' | 'label' | 'facility' | 'textMarker' | 'imageMarker' | 'externalModel'
     * @param {function} back 回调函数
     * @returns {array} layers
     */

  }, {
    key: "getLayerByAlias",
    value: function getLayerByAlias(gid, alias, back) {
      var result = [];
      var group = this.getFMGroup(gid);
      group.traverseByAlias([alias], function (layer, alias) {
        result.push(layer);
        back && back(layer);
      }, true); // let layer = group.getOrCreateLayer(alias);

      return result;
    }
    /**
     * 地图中心移动到指定点，如果groupID和当前聚焦层不一致，会自动切换至groupID楼层，此时不要和focusGroupID组合调用。
     * @param  {json} opts
     *         @param {float} opts.x  地图坐标x值。
     *         @param {float} opts.y  地图坐标y值。
     *         @param {float} opts.z  地图坐标z值。
     *         @param {int} opts.groupID  楼层id,跳转到指定位置，并聚焦该楼层。
     *         @param {int} opts.time 目标层不是聚焦层时跳转的动画时间间隔。
     *         @param {function} opts.callback  完成moveTo事件后的回调，返回目标层gid。
     */

  }, {
    key: "moveTo",
    value: function moveTo(options) {
      return this._moveTo(options, false);
    }
  }, {
    key: "_moveTo",
    value: function _moveTo(options, forceAnimation) {
      var _this11 = this;

      var center = this.center;
      var threex = options.x - center.x;
      var threez = -options.y + center.y;
      var srcx = this.controls.target.x;
      var srcz = this.controls.target.z;
      var gid = options.groupID;
      var destHeight, srcHeight;

      if (gid) {
        srcHeight = this.controls.target.y;
        this.currentFocusGroup = gid;
        destHeight = this.nodeManager.getHeight(this._currentSceneId, this.currentFocusGroup);
      } else {
        srcHeight = 0;
        destHeight = 0;
      }

      if (!this.MapOptions.moveToAnimateMode && !forceAnimation) {
        gid && this.controls.panUp(destHeight - srcHeight);
        this.controls.panAdd({
          x: threex - srcx,
          z: threez - srcz,
          y: 0
        });
        this.controls.update();
        return null;
      }

      if (_FMGlobal.default[this.uuid].currentMoveMapAnimater) {
        _FMGlobal.default[this.uuid].currentMoveMapAnimater.stop();

        this.removeAnimater(_FMGlobal.default[this.uuid].currentMoveMapAnimater);
      }

      var animater = new _Animater.default({
        h: srcHeight,
        x: srcx,
        z: srcz
      }, {
        h: destHeight,
        x: threex,
        z: threez
      }, options.time ? options.time * 1000 : 500, function () {
        _this11.removeAnimater(animater);

        _FMGlobal.default[_this11.uuid].currentMoveMapAnimater = null;
        options.callback && options.callback();
      }, function (heighter, dheighter) {
        gid && _this11.controls.panUp(dheighter.h);

        _this11.controls.panAdd({
          x: dheighter.x,
          z: dheighter.z,
          y: 0
        });

        _this11.controls.update();

        options.update && options.update();
      }).start();
      _FMGlobal.default[this.uuid].currentMoveMapAnimater = animater;

      this._animaters.push(animater);

      return animater;
    }
    /**
     * 移动地图至楼层的中心点
     * @param {int} gid 目标楼层id。
     */

  }, {
    key: "moveToCenter",
    value: function moveToCenter(gid) {
      if ((0, _typeof2.default)(gid) === "object") {
        this.moveTo(gid);
        return;
      }

      var center = this.center;
      this.moveTo({
        x: center.x,
        y: center.y,
        groupID: gid ? gid : this.focusGroupID
      });
    }
    /**
     * 旋转到对应角度
     * @param {json} param {to: 45, duration: 1, callback: function() {}}
     * @param {number} param.to 转至角度
     * @param {number} param.duration 动画时间
     * @param {function} param.callback 回调函数
     */

  }, {
    key: "rotateTo",
    value: function rotateTo(param) {
      var _this12 = this;

      var srcTheta = this.controls.getAzimuthalAngle(); // 当前角度

      var destTheta = -(param.to % 360) * fm.Math.DEG2RAD; // 目的角度

      var temp = destTheta;
      var dtheta = 0; // 实际需要旋转角度

      if (destTheta - srcTheta !== 0) {
        dtheta = Math.sin(destTheta - srcTheta) / Math.abs(Math.sin(destTheta - srcTheta)) * Math.acos(Math.cos(destTheta - srcTheta));
      }

      destTheta = srcTheta + dtheta;

      if (_FMGlobal.default[this.uuid].currentRotateAnimater) {
        _FMGlobal.default[this.uuid].currentRotateAnimater.stop();

        this.removeAnimater(_FMGlobal.default[this.uuid].currentRotateAnimater);
      }

      var animater = new _Animater.default({
        theta: srcTheta
      }, {
        theta: destTheta
      }, param.duration ? param.duration * 1000 : 500, function () {
        _this12.removeAnimater(animater);

        _this12.controls.setUpdate(undefined, undefined, undefined, temp);

        param.callback && param.callback();
      }, function (heighter, dheighter) {
        _this12.controls.setUpdate(undefined, dheighter.theta);

        param.update && param.update();
      }).start();
      _FMGlobal.default[this.uuid].currentRotateAnimater = animater;

      this._animaters.push(animater);

      return animater;
    }
    /**
     * 缩放到对应值
     * @param {json} params
     *         @param {float} params.duration 动画时间
     *         @param {float} params.scale  缩放值
     *         @param {float} params.update  动画执行时回掉。
     *         @param {function} opts.callback  完成moveTo事件后的回调，返回目标层gid。
     */

  }, {
    key: "scaleTo",
    value: function scaleTo(params, forceAnimation) {
      var _this13 = this;

      if (!params.scale) return;
      var scale = params.scale;
      var currScale = this.mapScale;
      var dis = this.getCameraDistanceByScale(scale);
      var currDis = this.controls.object.position.distanceTo(this.controls.target);
      var normal = new fm.Vector3().copy(this.controls.object.position).sub(this.controls.target).normalize();

      if (!this.MapOptions.scaleToAnimateMode && !forceAnimation) {
        var offset = new fm.Vector3().copy(normal).multiplyScalar(dis - currDis);
        this.controls.setUpdate(0, 0, offset);
        var zoom = this.getCameraScaleByScale(scale);
        this.renderer.orthographicCamera.zoom = 1 / zoom;
        this.renderer.orthographicCamera.updateProjectionMatrix();
        this.renderer.resetSpriteSize();
        return null;
      }

      var animater = new _Animater.default({
        phi: currDis,
        scale: currScale
      }, {
        phi: dis,
        scale: scale
      }, params.duration ? params.duration * 1000 : 500, function (o) {
        _this13.removeAnimater(animater);

        params.callback && params.callback();

        _this13.renderer.resetSpriteSize();
      }, function (o, dereult) {
        var offset = new fm.Vector3().copy(normal).multiplyScalar(dereult.phi);

        _this13.controls.setUpdate(0, 0, offset);

        params.update && params.update();

        var zoom = _this13.getCameraScaleByScale(o.scale);

        _this13.renderer.orthographicCamera.zoom = 1 / zoom;

        _this13.renderer.orthographicCamera.updateProjectionMatrix();
      }).start();

      this._animaters.push(animater);

      return animater;
    }
    /**
     * scalelevel等级降低
     *
     */

  }, {
    key: "scaleLevelIn",
    value: function scaleLevelIn() {
      var level = this.scaleLevel;
      level--;
      this.scaleLevelTo({
        level: level
      });
    }
    /**
     * scalelevel等级提高
     *
     */

  }, {
    key: "scaleLevelOut",
    value: function scaleLevelOut() {
      var level = this.scaleLevel;
      level++;
      this.scaleLevelTo({
        level: level
      });
    }
    /**
     * 定位到某个级别
     * @param {json} params
     *         @param {float} params.duration 动画时间
     *         @param {float} params.level  缩放级别
     *         @param {float} params.update  动画执行时回掉。
     *         @param {function} opts.callback  完成moveTo事件后的回调，返回目标层gid。
     */

  }, {
    key: "scaleLevelTo",
    value: function scaleLevelTo(params) {
      var _this14 = this;

      if (!params.level) return;
      var scale = this.levelToScale(params.level);
      var currScale = this.mapScale;
      var dis = this.getCameraDistanceByScale(scale);
      var currDis = this.controls.object.position.distanceTo(this.controls.target);
      var normal = new fm.Vector3().copy(this.controls.object.position).sub(this.controls.target).normalize();

      if (!params.duration) {
        var offset = new fm.Vector3().copy(normal).multiplyScalar(dis - currDis);
        this.controls.setUpdate(0, 0, offset);
        var zoom = this.getCameraScaleByScale(scale);
        this.renderer.orthographicCamera.zoom = 1 / zoom;
        this.renderer.orthographicCamera.updateProjectionMatrix();
        this.controls.update();
        return;
      }

      var animater = new _Animater.default({
        phi: currDis,
        scale: currScale
      }, {
        phi: dis,
        scale: scale
      }, params.duration ? params.duration * 1000 : 500, function (o) {
        _this14.removeAnimater(animater);

        params.callback && params.callback();

        _this14.renderer.resetSpriteSize();
      }, function (o, dereult) {
        var offset = new fm.Vector3().copy(normal).multiplyScalar(dereult.phi); // console.log(offset);

        _this14.controls.setUpdate(0, 0, offset);

        params.update && params.update(); // let scale = this.getScaleByCameraDistance();

        var zoom = _this14.getCameraScaleByScale(o.scale);

        _this14.renderer.orthographicCamera.zoom = 1 / zoom;

        _this14.renderer.orthographicCamera.updateProjectionMatrix();
      }).start();

      this._animaters.push(animater);

      return animater;
    }
    /**
     * 倾斜到对应角度
     * @param {json} params {to: 45, duration: 1, callback: function() {}}
     * @param {number} params.to 移动到的角度值
     * @param {number} params.duration 动画时间
     * @param {function} params.callback 回调函数
     *
     */

  }, {
    key: "tiltTo",
    value: function tiltTo(params) {
      var _this15 = this;

      if (params.to === 0 || !params.to) return;
      var curPolarAngle = this.controls.getPolarAngle();
      var destPhi = (90 - params.to) * fm.Math.DEG2RAD;
      var animater = new _Animater.default({
        phi: curPolarAngle
      }, {
        phi: destPhi
      }, params.duration ? params.duration * 1000 : 500, function (o) {
        _this15.removeAnimater(animater);

        params.callback && params.callback();

        _this15.renderer.resetSpriteSize();
      }, function (o, dereult) {
        _this15.controls.setUpdate(dereult.phi);

        params.update && params.update(o);
      }).start();

      this._animaters.push(animater);

      return animater;
    }
    /**
     * 检查浏览器能否全屏
     *
     * @returns {bool} ture表示支持全屏
     */

  }, {
    key: "fullScreenAvaliable",
    value: function fullScreenAvaliable() {
      return !!(document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled);
    }
    /**
     * 地图坐标转屏幕坐标
     * @param {number} x 地图坐标x
     * @param {number} y 地图坐标y
     * @param {number} z 高度z
     */

  }, {
    key: "coordMapToScreen",
    value: function coordMapToScreen(x, y, z) {
      var center = this.threeCenter;
      var mcenter = this.center;
      var camera = this.controls.object;
      var pos2 = this.getRotationCoord(x, y, true);
      var pos = new fm.Vector3(pos2.x - mcenter.x, center.y + z, -pos2.y + center.y + mcenter.y);
      pos.project(camera);
      var width = this.renderer.container.clientWidth;
      var height = this.renderer.container.clientHeight;
      var screenx = width / 2 * pos.x + width / 2;
      var screeny = -height / 2 * pos.y + height / 2;
      return {
        x: screenx,
        y: screeny
      };
    }
    /**
     * 获取正确坐标的方法，当设置地图绕中点旋转设置之后，通过mapClickNode事件获取坐标需要调用此方法
     * @param {number} x 地图坐标x
     * @param {number} y 地图坐标y
     * @returns {json} 返回旋转后的地图坐标
     */

  }, {
    key: "getRotationCoord",
    value: function getRotationCoord(x, y, isgetcoord) {
      var x2 = x - this.center.x;
      var y2 = y - this.center.y;
      var param = 1;

      if (isgetcoord) {
        param = -1;
      }

      var angle = this.nodeManager._scenes[this._currentSceneId].groups[this.focusGroupID]._layers.extent[0]._scene.rotation.y;
      var x3 = Math.sin(param * angle) * y2 + Math.cos(param * angle) * x2;
      var y3 = Math.cos(param * angle) * y2 - Math.sin(param * angle) * x2;
      var dis_x = x3 - x2;
      var dis_y = y3 - y2;
      return {
        x: x + dis_x,
        y: y + dis_y
      };
    }
    /**
     * 屏幕坐标转地图坐标
     *
     * @param {number} x 屏幕x值
     * @param {number} y 屏幕y值
     * @param {number} z 地图高度
     * @param {bool} isFloat 是否使用屏幕像素坐标系 默认false
     * @param {bool} giveMeRaw 是否返回三维空间坐标 默认false
     * @returns {json} 返回对应的地图坐标
     */

  }, {
    key: "coordScreenToMap",
    value: function coordScreenToMap(x, y, z, isFloat, giveMeRaw) {
      var camera = this.controls.object;
      var EPS = 0.0001;
      var center = this.center;
      var threeCenter = this.threeCenter; // z 值的默认值,当前层的高度

      var gh = this.getFMGroup(this._currentFocusGroup).height; // 如果此层尚示加入

      if (gh == undefined) {
        return;
      }

      z = z === undefined ? gh + this.MapOptions.pickCoordHeight : z;
      var coords = null;

      if (isFloat) {
        // 小数 比例值 -1 ~ 1
        coords = new fm.Vector3(x, y, z);
      } else {
        // 鼠标的x,y坐标
        coords = new fm.Vector3(x / this.renderer.domElementWidth * 2 - 1, 1 - y / this.renderer.domElementHeight * 2, .5);
      }

      var origin = new fm.Vector3(),
          direction = new fm.Vector3();

      if (camera && camera.isPerspectiveCamera) {
        origin.setFromMatrixPosition(camera.matrixWorld);
        direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(origin).normalize();
      } else if (camera && camera.isOrthographicCamera) {
        origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera

        direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
      }

      var planeNormal = new fm.Vector3(0, 1, 0);
      var hasCrossPnt = planeNormal.dot(direction);
      if (Math.abs(hasCrossPnt) < EPS) return;
      var dy = -origin.y + z + threeCenter.y;
      var c = dy / direction.y;
      var dest = new fm.Vector3().copy(origin).add(new fm.Vector3().copy(direction).multiplyScalar(c));

      if (giveMeRaw) {
        return dest;
      } else {
        return {
          x: dest.x + center.x,
          y: center.y - dest.z,
          z: z
        };
      }
    } //

    /**
     * 根据矩形左下角坐标和右上角坐标获取地图当前的显示级别
     *
     *
     * @param {json} startPnt 左下角坐标
     * @param {json} endPnt 右上角坐标
     * @returns {number} level
     *
     */

  }, {
    key: "getScalelevelValueByVectics",
    value: function getScalelevelValueByVectics(startPnt, endPnt) {
      return this.scaleTolevel(this.getScaleValueByVectics(startPnt, endPnt));
    }
    /**
     * 根据矩形左下角坐标和右上角坐标获取地图当前的显示比例尺
     *
     *
     * @param {json} startPnt 左下角坐标
     * @param {json} endPnt 右上角坐标
     * @returns {number} 比例尺
     *
     */

  }, {
    key: "getScaleValueByVectics",
    value: function getScaleValueByVectics(startPnt, endPnt) {
      // 按照canvas宽高比计算比例
      var w = Math.abs(endPnt.x - startPnt.x);
      var h = Math.abs(endPnt.y - startPnt.y);
      var height = this.renderer.domElementHeight;
      var width = this.renderer.domElementWidth;
      var scale = null;

      if (height >= width) {
        if (width / height >= w / h) {
          var cmLength = height / (this._pixelsPerCentimeter * 1.0);
          scale = h * 100 / cmLength;
        } else {
          var _cmLength = width / (this._pixelsPerCentimeter * 1.0);

          scale = w * 100 / _cmLength;
        }
      } else {
        if (width / height >= w / h) {
          var _cmLength2 = height / (this._pixelsPerCentimeter * 1.0);

          scale = h * 100 / _cmLength2;
        } else {
          var _cmLength3 = width / (this._pixelsPerCentimeter * 1.0);

          scale = w * 100 / _cmLength3;
        }
      }

      return scale; // 按照canvas对角线计算比例
      // let center = this.center;
      // let begin = new fm.Vector2(center.x - startPnt.x, center.y - startPnt.y);
      // let end = new fm.Vector2(center.x - endPnt.x, center.y - endPnt.y);
      // let dis = begin.distanceTo(end);
      // let height = this.renderer.domElementHeight;
      // let width = this.renderer.domElementWidth;
      // let pixlength = Math.sqrt(height * height + width * width);
      // let cmLength = pixlength / this._pixelsPerCentimeter;
      // let scale = dis * 100 / cmLength;
      // return scale;
    }
    /*
     * 2d /3d切换
     * @param {*} back
     * @param {*} time
     */

  }, {
    key: "toggleToTop",
    value: function toggleToTop(back) {
      var _this16 = this;

      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      this.controls.minPolarAngle = 0;
      this.controls.update();
      var curPolarAngle = this.controls.getPolarAngle();
      _FMGlobal.default[this.uuid].curPolarAngle = curPolarAngle;

      if (!this.MapOptions.viewModeAnimateMode) {
        time = 0.001;
      }

      var animater = new _Animater.default({
        phi: curPolarAngle
      }, {
        phi: 0
      }, time, function (o) {
        _this16.removeAnimater(animater); // console.log("yy");


        _this16.controls.maxPolarAngle = 0;

        var scale = _this16.getScaleByCameraDistance();

        var zoom = _this16.getCameraScaleByScale(scale);

        _this16.renderer.orthographicCamera.zoom = 1 / zoom;

        _this16.renderer.orthographicCamera.quaternion.copy(_this16.controls.object.quaternion);

        _this16.renderer.orthographicCamera.position.copy(_this16.controls.object.position);

        _this16.renderer.orthographicCamera.updateProjectionMatrix();

        _this16.controls.object = _this16.renderer.orthographicCamera;
        back && back();

        _this16.renderer.resetSpriteSize();

        _FMGlobal.default[_this16.uuid].isToggleViewMode = false;
      }, function (o, dereult) {
        _this16.controls.setUpdate(dereult.phi);
      }).start();
      _FMGlobal.default[this.uuid].isToggleViewMode = true;

      this._animaters.push(animater);
    }
  }, {
    key: "toggleTo3D",
    value: function toggleTo3D(back) {
      var _this17 = this;

      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;
      this.controls.maxPolarAngle = (90 - this.MapOptions.defaultMinTiltAngle) * fm.Math.DEG2RAD;
      var scale = this.getScaleByCameraScale();
      var distance = this.getCameraDistanceByScale(scale);
      this.renderer.perspectiveCamera.quaternion.copy(this.controls.object.quaternion);
      this.renderer.perspectiveCamera.position.copy(this.controls.object.position);
      this.renderer.perspectiveCamera.position.setY(this.controls.target.y + distance);
      this.renderer.perspectiveCamera.updateMatrix();
      this.controls.object = this.renderer.perspectiveCamera;
      this.renderer.resetSpriteSize();
      var destPolarAngle = _FMGlobal.default[this.uuid].curPolarAngle ? _FMGlobal.default[this.uuid].curPolarAngle : (90 - this.MapOptions.defaultTiltAngle) * fm.Math.DEG2RAD;

      if (!this.MapOptions.viewModeAnimateMode) {
        time = 0.001;
      }

      var animater = new _Animater.default({
        phi: 0
      }, {
        phi: destPolarAngle
      }, time, function (o) {
        back && back();

        _this17.removeAnimater(animater);

        _FMGlobal.default[_this17.uuid].isToggleViewMode = false;

        _this17.renderer.resetSpriteSize();
      }, function (o, dereult) {
        _this17.controls.setUpdate(dereult.phi);
      }).start();
      _FMGlobal.default[this.uuid].isToggleViewMode = true;

      this._animaters.push(animater);
    }
  }, {
    key: "getPixelTo3DdisByGid",
    value: function getPixelTo3DdisByGid(gid) {
      var center = new fm.Vector3().copy(this.controls.target);
      var sceneCenter = this.nodeManager.getSceneCenter(this._currentSceneId);
      center.y = this.getFMGroup(gid).height + this.getFMGroup(gid).offsetHeight + sceneCenter.y;
      var tenpxAtNear;
      var tenpxAtCenter;

      if (this._viewMode === "top") {
        var top = this.renderer.orthographicCamera.top;
        var bottom = this.renderer.orthographicCamera.bottom; //屏幕上px转换为三维空间近截面高度

        tenpxAtCenter = 10 * Math.abs(top - bottom) / this.renderer.domElementHeight / this.renderer.orthographicCamera.zoom;
      } else {
        var near = this.renderer.perspectiveCamera.near;
        var fov = this.renderer.perspectiveCamera.fov;
        var distance = this.controls.object.position.distanceTo(center); //屏幕上一厘米转换为三维空间近截面高度

        tenpxAtNear = 10 * near * Math.tan(fov / 2 * fm.Math.DEG2RAD) * 2 / this.renderer.domElementHeight;
        tenpxAtCenter = tenpxAtNear * distance / near;
      }

      return 10 / tenpxAtCenter;
    }
    /**
     * 释放内存
     */

  }, {
    key: "dispose",
    value: function dispose() {
      //
      cancelAnimationFrame(this._loopHander);
      this.dispatchEvent({
        type: "dispose"
      });
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(this._lineMarkers), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var line = _step4.value;
          line.dispose(this);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this.nodeManager.dispose();
      this.dataManager.dispose();
      this.controls.dispose();
      this.renderer.dispose();

      _FMGlobal.default.dispose(this.uuid);

      this._lineMarkers.length = 0;
      this._windowPops.length = 0;
      this.nodeManager = undefined;
      this.dataManager = undefined;
      this.controls = undefined;
      this.renderer = undefined;
      this.fmServer = undefined;
      this.MapOptions = undefined;
    }
  }, {
    key: "disposeById",
    value: function disposeById(id) {
      this.nodeManager.disposeById(id);
      this.dataManager.disposeById(id);
    }
    /**
     *
     * 添加locationMarker
     *
     * @param {fengmap.FMLocationMarker} marker locationMarker实例
     */

  }, {
    key: "addLocationMarker",
    value: function addLocationMarker(marker) {
      marker.map = this;
      marker.scene = this.nodeManager.getSceneById(this._currentSceneId);
      marker.initSprite(this.nodeManager);
      this.addLocationToGroup(marker, this._currentSceneId, marker.groupID);
      marker.renderNode.updateMatrixWorld(true);
      this.renderer.setLocationSize(marker.renderNode, marker.size);
    }
  }, {
    key: "addLocationToGroup",
    value: function addLocationToGroup(marker, id, gid) {
      var group = this.nodeManager.getGroup(id, gid);
      group.addLocation(marker);
    }
    /**
     * 删除locationMarker
     *
     * @param {fengmap.FMLocationMarker} marker locationMarker实例
     */

  }, {
    key: "removeLocationMarker",
    value: function removeLocationMarker(marker) {
      this.removeLocationByGroup(marker, this._currentSceneId, marker.groupID);
      marker.dispose();
    }
  }, {
    key: "removeLocationByGroup",
    value: function removeLocationByGroup(marker, id, gid) {
      var group = this.nodeManager.getGroup(id, gid);
      group.removeLocation(marker);
    }
    /*
     * 新增一个lineMarker
     * @param {*} marker
     * @param {*} style
     */

  }, {
    key: "addLineMarker",
    value: function addLineMarker(marker, style) {
      var center = this.center;
      marker.initLine(center, style, this);

      this._lineMarkers.push(marker);

      marker.hideOrShowBy(this.visibleGroupIDs); // this.renderer.lineMarkerScene.add(marker.renderNode);
      // marker
    }
    /**
     * 清除某条路径线
     * @param  {fengmap.FMLineMarker} marker 移除当前的某条线FMLineMarker。
     */

  }, {
    key: "removeLineMarker",
    value: function removeLineMarker(marker) {
      var index = this._lineMarkers.indexOf(marker);

      if (index > -1) {
        this._lineMarkers.splice(index, 1);
      } // this.renderer.lineMarkerScene.remove(marker.renderNode);


      marker.removeByMap(this);
    }
  }, {
    key: "removeAllMarkers",
    value: function removeAllMarkers() {
      for (var i = this._lineMarkers.length - 1; i > -1; i--) {
        this._lineMarkers[i].removeByMap(this);
      }

      this._lineMarkers.length = 0;
    }
    /**
     * 清除路径线
     * @param  {undefined|array<fengmap.FMLineMarker>} marker 可选。如不传该参数表示移除所有FMLineMarker,如果为数组则移除数组内的FMLineMarker。
     */

  }, {
    key: "clearLineMark",
    value: function clearLineMark(marker) {
      if (!marker) {
        this.removeAllMarkers();
      } else {
        if ((0, _isArray.default)(marker)) {
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = undefined;

          try {
            for (var _iterator5 = (0, _getIterator2.default)(marker), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var line = _step5.value;
              this.removeLineMarker(line);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
        } else {
          this.removeLineMarker(marker);
        }
      }
    }
    /**
     * 画出线
     *
     * @param {fengmap.FMLineMarker} line FMLineMarker对象
     * @param {json} style 线形的样式
     * @param  {fengmap.FMLineType} style.lineType 线型
     * @param  {string} style.color 只支持修改非FMARROW线型的线的颜色。
     * @param  {boolean} style.smooth 是否开启平滑线功能
     * @param  {number} style.lineWidth 设置线宽
     * @param  {string} style.mapUrl 线贴图路径
     * @param  {string} style.godColor 设置FMARROW线型线的颜色，十六进制颜色值。如：'#FF0000'。
     * @param  {boolean} style.godEdgeColor 设置FMARROW线型线边线的颜色,十六进制颜色值。如：'#FF0000'
     * @param  {boolean} style.noAnimate 设置导航线的动画。【 true 】启用关闭动画，【 false 】启用动画。
     * @param  {*} back 回调函数
     * @example
     * let _linestyle = {color: 0xff0000,lineWidth: 8,alpha: 0.8,dash: {size: 1,gap: 1}}
     */

  }, {
    key: "drawLineMark",
    value: function drawLineMark(line, style, back) {
      style.resolution = new fm.Vector2(this.renderer.container.clientWidth, this.renderer.container.clientHeight);
      var camera = this.renderer.getCameraByViewMode(this._viewMode);
      style.near = camera.near;
      style.far = camera.far;

      if (style.url) {
        style.map = this.nodeManager.materialManager.loadTexture(style.url, function (t) {});
        style.map.wrapS = fm.RepeatWrapping;
        style.map.wrapT = fm.RepeatWrapping; // style.map.anisotropy = 4;
      }

      this.addLineMarker(line, style);

      if (back) {
        back();
      }
    }
  }, {
    key: "setLastRender",
    value: function setLastRender() {
      var scene = this.nodeManager.getSceneById(this._currentSceneId);

      if (!scene) {
        return;
      }

      var lastThings = scene.getLastRenderArray();
      this.renderer.setBackRender(lastThings);
    }
  }, {
    key: "update",
    value: function update() {
      this._loopHander = requestAnimationFrame(this.update.bind(this));
      if (!this.letUpdate) return;

      if (this.isFpsDisplay) {
        this.stats.begin();
      }

      var time = new Date().getTime();
      var delTime = time - this._currentTime;
      this._currentTime = time;
      this.mouseHoverEventFire(delTime);
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = (0, _getIterator2.default)(this._animaters), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var animater = _step6.value;
          animater.enable && animater.run(delTime);
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = (0, _getIterator2.default)(this.animationMixers), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var mixer = _step7.value;
          mixer.update(delTime / 1000);
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      this.dispatchEvent({
        type: "frameLoop",
        delTime: delTime
      });
      this.controls.update();
      var fpsRender = false;
      this._renderTime += delTime;
      var renderTime;

      if (1000 / this._allowfps < this._renderTime) {
        renderTime = this._renderTime;
        this._renderTime = 0;
        fpsRender = true;
      }

      if (this.renderer && fpsRender) {
        // let time2 = new Date().getTime();
        this.updatePopsPosition();

        if (this.allowRender) {
          this.setLastRender();
          this.renderer.update(this._viewMode);
        } // let time3 = new Date().getTime();
        // console.log(time3 - time2);


        this.dispatchEvent({
          type: "update",
          fps: 1000 / renderTime
        });
      }

      if (this.isFpsDisplay) {
        this.stats.end();
      }
    }
    /**
     * 地图事件注册
     * @param {*} type 事件类型
     * @param {*} back 回调函数
     */

  }, {
    key: "on",
    value: function on(type, back) {
      this.addEventListener(type, back);
    }
    /**
     * 地图事件移除
     * @param {*} type 事件类型
     * @param {*} back 回调函数
     */

  }, {
    key: "off",
    value: function off(type, back) {
      this.removeEventListener(type, back);
    }
    /*
     * 弹出框注册到地图
     * @param {*} pop
     */

  }, {
    key: "registeredPop",
    value: function registeredPop(pop) {
      this._windowPops.push(pop);
    }
    /*
     * 弹出框登出地图
     *
     * @param {*} pop
     */

  }, {
    key: "logoutPop",
    value: function logoutPop(pop) {
      var index = this._windowPops.indexOf(pop);

      if (index > -1) {
        this._windowPops.splice(index, 1);
      }
    }
  }, {
    key: "updatePopsPosition",
    value: function updatePopsPosition() {
      var camera = this.renderer.getCameraByViewMode(this._viewMode);
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = (0, _getIterator2.default)(this._windowPops), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var pop = _step8.value;
          this.updatePopPosition(pop, camera);
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
    }
  }, {
    key: "updatePopPosition",
    value: function updatePopPosition(pop, camera) {
      if (!camera) {
        camera = this.renderer.getCameraByViewMode(this._viewMode);
      }

      var position = new fm.Vector3();

      if (pop.threeCoord) {
        position.copy(pop.threeCoord);
      } else if (pop.marker) {
        if (pop.marker instanceof _FMDynamicModel.default) {
          if (pop.marker._meshes.length > 0) {
            pop.marker._meshes[0].updateMatrixWorld();

            pop.marker._meshes[0].updateMatrixWorld(true);

            position = new fm.Vector3().setFromMatrixPosition(pop.marker._meshes[0].matrixWorld);
          }
        } else {
          pop.marker.renderNode.parent.updateMatrixWorld();
          pop.marker.renderNode.updateMatrixWorld(true);
          position = new fm.Vector3().setFromMatrixPosition(pop.marker.renderNode.matrixWorld);
        }
      } else {
        var center = this.center;
        position = position.set(pop.coord.x - center.x, this.getFMGroup(pop.coord.groupID).getHeight() + pop.coord.height, -pop.coord.y + center.y);
      }

      var screenCoord = position.project(camera);
      var left = (screenCoord.x + 1) / 2 * this.renderer.container.clientWidth;
      var top = (1 - screenCoord.y) / 2 * this.renderer.container.clientHeight;
      pop.updateCoord(left, top);
    }
    /**
     * 通过id获取对应楼层对象
     * @param {number} gid 楼层id
     * @returns {fengmap.FMGroup}
     */

  }, {
    key: "getFMGroup",
    value: function getFMGroup(gid) {
      return this.nodeManager.getGroup(this._currentSceneId, gid);
    }
  }, {
    key: "getGroupHeight",
    value: function getGroupHeight(id) {
      var height = 50;

      if (this.getFMGroup(id)) {
        height = this.getFMGroup(id).getHeight();
      }

      return height;
    }
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.renderer.container;
    }
  }, {
    key: "getCurrGroupLength",
    value: function getCurrGroupLength() {
      this.nodeManager.getGroupLength(this._currentSceneId);
    }
  }, {
    key: "getCurrGroupIds",
    value: function getCurrGroupIds() {
      return this.nodeManager.getGroupIds(this._currentSceneId);
    }
    /**
     * 地图打印功能
     * @param {function} callback 回调函数，参数为截图blob数据
     */

  }, {
    key: "Printing",
    value: function Printing(callback) {
      var _this18 = this;

      this.isOneShot = true; // 更新初次截图flag
      // 显示所有的textMarker

      if (this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["textMarker"][0]) {
        for (var i = 0; i < this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["textMarker"][0].textMarkers.length; i++) {
          if (this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["textMarker"][0].textMarkers[i]._renderNode) {
            this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["textMarker"][0].textMarkers[i]._renderNode.visible = true;
          }
        }
      } // 显示所有的facility


      for (var _i3 in this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["facility"][0]._facility) {
        if (this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["facility"][0]._facility["" + _i3]._renderNode) {
          this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["facility"][0]._facility["" + _i3]._renderNode.visible = true;
        }
      } // 显示所有的label


      for (var _i4 in this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["label"][0]._labels) {
        if (this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["label"][0]._labels["" + _i4]._renderNode) {
          this.nodeManager._scenes["" + this._currentSceneId].groups["" + this._currentFocusGroup]._layers["label"][0]._labels["" + _i4]._renderNode.visible = true;
        }
      }

      var scaleLevel = this.mapScaleLevel; // 保存当前的地图等级，用于在截图完成之后恢复

      var param = {};
      param.level = 21;
      this.scaleLevelTo(param); // 更新地图等级到21级
      // 将地图居中显示

      var srcx = this.controls.target.x;
      var srcz = this.controls.target.z;
      this.controls.panAdd({
        x: -srcx,
        z: -srcz,
        y: 0
      });
      var width0 = this.renderer.renderer.domElement.width;
      var height0 = this.renderer.renderer.domElement.height;
      var tiltAngle = this.tiltAngle;
      var rotateAngle = this.rotateAngle;
      this.tiltAngle = 90;
      this.rotateAngle = 0;

      if (this._viewMode === "3d") {
        var zoom0 = this.renderer.orthographicCamera.zoom; // 保存相机的zoom，用于在截图完成之后恢复

        this.viewMode = "top";
        this.on('viewModeChange', function () {
          var canvas = document.createElement('canvas');
          canvas.width = width0 * 6;
          canvas.height = height0 * 6;
          var cxt = canvas.getContext("2d");
          var index = 0;
          var viewMode = "3d"; // 调用截图方法

          _this18._shot(canvas, cxt, index, zoom0, srcx, srcz, scaleLevel, viewMode, tiltAngle, rotateAngle, callback);
        });
      } else {
        var _zoom = this.renderer.orthographicCamera.zoom;
        var canvas = document.createElement('canvas');
        canvas.width = width0 * 6;
        canvas.height = height0 * 6;
        var cxt = canvas.getContext("2d");
        var index = 0;
        var viewMode = "top";

        this._shot(canvas, cxt, index, _zoom, srcx, srcz, scaleLevel, viewMode, tiltAngle, rotateAngle, callback);
      }
    }
  }, {
    key: "_shot",
    value: function _shot(canvas, cxt, index, zoom0, srcx, srcz, scaleLevel, viewMode, tiltAngle, rotateAngle, callback) {
      if (!this.isOneShot) return;

      if (index < 6 * 6) {
        var rows = null;
        var columns = null;

        if (index < 6 * 1) {
          rows = 0;
          columns = index - 6 * 0;
        } else if (index < 6 * 2) {
          rows = 1;
          columns = index - 6 * 1;
        } else if (index < 6 * 3) {
          rows = 2;
          columns = index - 6 * 2;
        } else if (index < 6 * 4) {
          rows = 3;
          columns = index - 6 * 3;
        } else if (index < 6 * 5) {
          rows = 4;
          columns = index - 6 * 4;
        } else if (index < 6 * 6) {
          rows = 5;
          columns = index - 6 * 5;
        }

        var scope = this;
        var fullWidth = this.renderer.renderer.domElement.width;
        var fullHeight = this.renderer.renderer.domElement.height;
        this.renderer.orthographicCamera.setViewOffset(fullWidth, fullHeight, -fullWidth * 2.5 + fullWidth * rows, -fullHeight * 2.5 + fullHeight * columns, fullWidth, fullHeight);
        this.renderer.orthographicCamera.updateProjectionMatrix();
        var img = new Image();
        img.indexI = rows;
        img.indexJ = columns;
        var param = {};
        param.level = scaleLevel;

        img.onload = function (e) {
          scope._shotIndex++;
          cxt.drawImage(e.path[0], fullWidth * e.path[0].indexI, fullHeight * e.path[0].indexJ);

          if (scope._shotIndex === 6 * 6) {
            canvas.toBlob(function (blob) {
              callback(blob);
              scope.renderer.orthographicCamera.zoom = zoom0 * 6;
              scope.renderer.orthographicCamera.updateProjectionMatrix();
              scope.viewMode = viewMode;
              scope.renderer.orthographicCamera.clearViewOffset();
              scope.checkNode();
              scope.setRenderList();
              scope.controls.panAdd({
                x: srcx,
                z: srcz,
                y: 0
              });
              scope.tiltAngle = tiltAngle;
              scope.rotateAngle = rotateAngle;
              scope.scaleLevelTo(param);
              scope.renderer.resetSpriteSize();
              scope.controls.update();
              scope.renderer.update();
              scope.isOneShot = false;
            }); // let ba = canvas.toDataURL();
            // callback(ba);

            scope._shotIndex = 0;
          }
        };

        this.checkNode();
        this.setRenderList();
        this.renderer.resetSpriteSize();
        this.controls.update();
        this.renderer.update();
        img.src = this.renderer.renderer.domElement.toDataURL();
        index++;
        return this._shot(canvas, cxt, index, zoom0, srcx, srcz, scaleLevel, viewMode, tiltAngle, rotateAngle, callback);
      }
    }
    /**
     * 打印截图
     * @param {number} pos1 选框左上角点坐标
     * @param {number} pos3 选框右下角点坐标
     * @param {bool} direction 打印纸张方向，【true】：纵向打印，【false】：横向打印。缺省为根据打印截图的宽高自动判断
     * @param {int} rank 打印等级，等级越高，质量越高(1-5) 通常这个值应设置为3
     * @param {function} callback 截图成功后回调函数，第1(base64),2(bolb)个参数为打印截图。第3(base64),4(bolb)个参数为框选截图
     */

  }, {
    key: "screenshot",
    value: function screenshot(pos1, pos3, direction, rank, callback) {
      var shotWidth = pos3.x - pos1.x;
      var shotHeight = pos3.y - pos1.y;
      var center = {
        x: 0,
        y: 0
      };
      center.x = (pos3.x + pos1.x) / 2;
      center.y = (pos3.y + pos1.y) / 2;
      var canvasWidths = this.renderer.container.getElementsByTagName('canvas')[0].style.width;
      var canvasHeights = this.renderer.container.getElementsByTagName('canvas')[0].style.height;
      var canvasWidth = canvasWidths.split("p")[0];
      var canvasHeight = canvasHeights.split("p")[0];
      var scale = null;

      if ((pos3.x - pos1.x) / (pos3.y - pos1.y) > canvasWidth / canvasHeight) {
        scale = canvasWidth / (pos3.x - pos1.x);
      } else {
        scale = canvasHeight / (pos3.y - pos1.y);
      }

      var cX = center.x - canvasWidth / 2;
      var cY = center.y - canvasHeight / 2;
      var canvas = document.getElementsByTagName('canvas')[0];
      var canvas0 = document.createElement('canvas');
      var canvas1 = document.createElement('canvas');
      var canvas2 = document.createElement('canvas');
      var pixeRatio = window.devicePixelRatio;
      var img0 = new Image();

      if (this.viewMode === '3d') {
        this.renderer.perspectiveCamera.setViewOffset(canvasWidth * scale, canvasHeight * scale, canvasWidth * (scale - 1) / 2 + cX * scale, canvasHeight * (scale - 1) / 2 + cY * scale, canvasWidth, canvasHeight);
      } else {
        this.renderer.orthographicCamera.setViewOffset(canvasWidth * scale, canvasHeight * scale, canvasWidth * (scale - 1) / 2 + cX * scale, canvasHeight * (scale - 1) / 2 + cY * scale, canvasWidth, canvasHeight);
      }

      this.renderer.update();
      canvas0.width = shotWidth * scale * pixeRatio;
      canvas0.height = shotHeight * scale * pixeRatio;
      canvas0.style.width = shotWidth * scale * pixeRatio + "px";
      canvas0.style.height = shotHeight * scale * pixeRatio + "px";

      if (direction) {
        canvas1.width = 1240 * Math.pow(1.414, rank - 1);
        canvas1.height = 1754 * Math.pow(1.414, rank - 1);
        canvas1.style.width = 1240 * Math.pow(1.414, rank - 1) + "px";
        canvas1.style.height = 1754 * Math.pow(1.414, rank - 1) + "px";
      } else {
        canvas1.height = 1240 * Math.pow(1.414, rank - 1);
        canvas1.width = 1754 * Math.pow(1.414, rank - 1);
        canvas1.style.height = 1240 * Math.pow(1.414, rank - 1) + "px";
        canvas1.style.width = 1754 * Math.pow(1.414, rank - 1) + "px";
      }

      canvas2.height = shotHeight * Math.pow(1.414, rank - 1);
      canvas2.width = shotWidth * Math.pow(1.414, rank - 1);
      canvas2.style.height = shotHeight * Math.pow(1.414, rank - 1) + "px";
      canvas2.style.width = shotWidth * Math.pow(1.414, rank - 1) + "px";
      img0.src = canvas.toDataURL("image/png");

      if (this.viewMode === '3d') {
        this.renderer.perspectiveCamera.clearViewOffset();
      } else {
        this.renderer.orthographicCamera.clearViewOffset();
      }

      var ctx0 = canvas0.getContext('2d');
      var ctx1 = canvas1.getContext('2d');
      var ctx2 = canvas2.getContext('2d');
      var me = this;

      img0.onload = function () {
        if (me.viewMode === '3d') {
          ctx0.drawImage(img0, -(canvasWidth * pixeRatio - shotWidth * scale * pixeRatio) / 2, -(canvasHeight * pixeRatio - shotHeight * scale * pixeRatio) / 2);
        } else {
          ctx0.drawImage(img0, -(canvasWidth * pixeRatio - shotWidth * scale * pixeRatio) / 2, -(canvasHeight * pixeRatio - shotHeight * scale * pixeRatio) / 2); // ctx0.drawImage(img0, -(canvas.width - shotWidth * scale) / 2, -(canvas.height - shotHeight * scale) / 2);
        }

        var img1 = new Image();
        img1.src = canvas0.toDataURL("image/png");

        img1.onload = function () {
          var ratio = Math.min(1240 * Math.pow(1.414, rank - 1) / (shotWidth * scale), 1754 * Math.pow(1.414, rank - 1) / (shotHeight * scale));
          var leftBias = (canvas1.width - shotWidth * scale * ratio) / 2;
          var topBias = (canvas1.height - shotHeight * scale * ratio) / 2;
          ctx1.drawImage(img1, leftBias, topBias, shotWidth * scale * ratio, shotHeight * scale * ratio);
          ctx2.drawImage(img1, 0, 0, shotWidth * Math.pow(1.414, rank - 1), shotHeight * Math.pow(1.414, rank - 1));
          var base64_1 = canvas1.toDataURL("image/png");
          var base64_2 = canvas2.toDataURL("image/png");

          if (navigator.userAgent.indexOf("Edge") > -1 || navigator.userAgent.indexOf(".NET4.0C") > -1) {
            var blob_1 = null;
            var blob_2 = null; // console.log(base64);

            callback(base64_1, blob_1, base64_2, blob_2);
          } else {
            canvas1.toBlob(function (blob_1) {
              canvas2.toBlob(function (blob_2) {
                callback(base64_1, blob_1, base64_2, blob_2);
              });
            });
          }
        };
      };
    }
  }, {
    key: "enableKeys",
    value: function enableKeys(flag) {
      this.controls.enableKeys = flag;
    }
    /**
     * 返回根据搜索结果查询到的对象
     * @param {Array} results 搜索结果数组
     */

  }, {
    key: "getSearchObjects",
    value: function getSearchObjects(results) {
      var objects = [];

      for (var i = 0; i < results.length; i++) {
        var type = null;

        if (results[i].nodeType === 5) {
          type = "model";
        } else if (results[i].nodeType === 4) {
          type = "extent";
        } else if (results[i].nodeType === 12) {
          type = "label";
        } else if (results[i].nodeType === 11) {
          type = "facility";
        } else if (results[i].nodeType === 35) {
          type = "externalModel";
        }

        objects.push(this.getFMGroup(results[i].groupID).getNodeByLayerId(type, results[i].ID));
      }

      return objects;
    }
    /**
     * 获得EffectRenderer
     * @returns {fengmap.FMEffectRenderer}
     */

  }, {
    key: "getEffectRenderer",
    value: function getEffectRenderer() {
      var er = new EffectRenderer(this.MapOptions, this);
      this.renderer = er;
      return er;
    }
  }, {
    key: "getCompassOffset",
    value: function getCompassOffset() {
      return {
        left: this.MapOptions.compassOffset[0],
        top: this.MapOptions.compassOffset[1]
      };
    }
  }, {
    key: "setCompassOffset",
    value: function setCompassOffset(top, left) {
      this.MapOptions.compassOffset[0] = left;
      this.MapOptions.compassOffset[1] = top;
      this.renderer.resetCompass();
    }
  }, {
    key: "getCompassScale",
    value: function getCompassScale() {
      return this.MapOptions.compassSize;
    }
  }, {
    key: "setCompassScale",
    value: function setCompassScale(size) {
      this.MapOptions.compassSize = size;
      this.renderer.resetCompass();
    }
  }, {
    key: "getStation",
    value: function getStation() {
      var station = {}; //判断是否Opera浏览器

      if (navigator.userAgent.indexOf("Opera") > -1) {
        station.userAgent = "Opera";
      } //判断是否Firefox浏览器


      if (navigator.userAgent.indexOf("Firefox") > -1) {
        station.userAgent = "FF";
      } //判断是否chorme浏览器


      if (navigator.userAgent.indexOf("Chrome") > -1) {
        station.userAgent = "Chrome";
      } //判断是否Safari浏览器


      if (navigator.userAgent.indexOf("Safari") > -1 && navigator.userAgent.indexOf("Chrome") === 0) {
        station.userAgent = "Safari";
      } //判断是否IE浏览器


      if (navigator.userAgent.indexOf("compatible") > -1 && navigator.userAgent.indexOf("MSIE") > -1 && !isOpera) {
        station.userAgent = "IE";
      } //判断是否Edge浏览器


      if (navigator.userAgent.indexOf("Trident") > -1) {
        station.userAgent = "Edge";
      } //获取sdk版本号


      station.sdkVersion = _FMVersion.default.VERSION + "." + _FMVersion.default.BUILD; //获取appName

      station.appName = this.MapOptions.appName; //获取设备显卡型号

      var canvas = document.createElement('canvas'),
          gl = canvas.getContext('experimental-webgl'),
          debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
      station.gpu = debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : null; //获取设备操作系统

      station.os = navigator.platform; //判断设备是否是pc端

      var isPC = true;
      var userAgentInfo = navigator.userAgent;
      var Agents = new Array("Android", "iPhone", "SymbianOS", "Windows Phone", "iPad", "iPod");

      for (var v = 0; v < Agents.length; v++) {
        if (userAgentInfo.indexOf(Agents[v]) > 0) {
          isPC = false;
          break;
        }
      }

      if (isPC) {
        station.device = "pc";
      } else {}

      var date2 = new Date();
      station.time = date2.getFullYear() + '-' + (date2.getMonth() + 1) + '-' + date2.getDate() + ' ' + date2.getHours() + ':' + date2.getMinutes();
      var data = (0, _stringify.default)(station);
      console.log(data);
      var xhr = new XMLHttpRequest();
      xhr.open('POST', _NetArea.default + 'sdk/collect', true);
      xhr.setRequestHeader("Content-type", "application/json");
      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");

      xhr.onreadystatechange = function (p) {
        if (xhr.readyState === 4 && xhr.status === 200) {
          console.log(p);
        }
      };

      xhr.send(data);
      return station;
    }
  }, {
    key: "getVideoMemoryAmount",
    value: function getVideoMemoryAmount(scenesId) {
      var videoMemotyAmount = null;
      videoMemotyAmount = this.videoMemory.getVideoMemoryAmount(scenesId);
      return videoMemotyAmount;
    }
  }, {
    key: "setCompass",
    value: function setCompass(offset) {
      if (!this.renderer.compassNode) {
        var aspect = this.renderer.getAspect();
        var scale = this.renderer.getScaleByPixels(1, this.MapOptions.compassSize);
        var oTop = -this.renderer.getScaleByPixels(1, _offset[1]);
        var oLeft = this.renderer.getScaleByPixels(1, _offset[0]) / aspect;

        var _offset = this.renderer.getCompassOffset(this.MapOptions.compassPosition, scale, aspect, oLeft, oTop);

        this.renderer.compassNode = this.nodeManager.createCompassNode(scale, this._compassBG, this._compassFG, _offset.ox, _offset.oy);
        this.renderer.compassNode.material.uniforms["rotation"].value = this.controls.getAzimuthalAngle();
      }
    }
  }, {
    key: "setThemeByJson",
    value: function setThemeByJson(themeName, themeData) {
      var me = this;
      var scene = this.nodeManager.getSceneById(this._currentSceneId);
      me.initTheme(themeName, themeData, function (theme) {
        me.setBackgroundColor(theme.clearColor, theme.clearAlpha);
        scene.theme = theme;
        scene.changeTheme(theme);
      });
    }
    /**
     * 设置模型绕中心旋转
     * @param {bool} isrote 【true】：绕中心旋转，【false】：不旋转
     */

  }, {
    key: "setAutoRotateBymodel",
    value: function setAutoRotateBymodel(isrote) {
      this.autoRotateBymodel = isrote;
    }
    /**
     * 返回是否模型绕中心旋转
     * @property {bool} autoRotateBymodel
     */

  }, {
    key: "getAutoRotateBymodel",
    value: function getAutoRotateBymodel() {
      return this.autoRotateBymodel;
    }
    /**
     * 设置模型旋转速度
     * @property {number} speed 速度
     */

  }, {
    key: "setAutoRotateBymodelSpeed",
    value: function setAutoRotateBymodelSpeed(speed) {
      this.autoRotateBymodelSpeed = speed;
    }
    /**
     * 返回模型旋转速度
     * @property {number} speed 速度
     */

  }, {
    key: "getAutoRotateBymodelSpeed",
    value: function getAutoRotateBymodelSpeed() {
      return this.autoRotateBymodelSpeed;
    }
  }, {
    key: "showAllGroup",
    get: function get() {
      return this._showAllGroup;
    }
  }, {
    key: "compass",
    get: function get() {
      var map = this;
      var renderer = this.renderer;
      var mm = this.nodeManager.materialManager;
      return {
        setBgImage: function setBgImage(url) {
          map._compassBG = url;

          if (renderer.compassNode) {
            renderer.compassNode.material.uniforms.mapBack.value = mm.loadTexture(url, function (t) {
              renderer.compassNode.material.needsUpdate = true;
            });
          }
        },
        setFgImage: function setFgImage(url) {
          map._compassFG = url;

          if (renderer.compassNode) {
            renderer.compassNode.material.uniforms.mapfront.value = mm.loadTexture(url, function (t) {
              renderer.compassNode.material.needsUpdate = true;
            });
          }
        }
      };
    }
  }, {
    key: "modelSelectColor",
    get: function get() {
      return this._modelSelectColor;
    }
    /**
     * 获取当前地图的所有楼层groupID的集合
     * @property {array} groupIDs
     * @readonly
     */

  }, {
    key: "groupIDs",
    get: function get() {
      var result = [];
      result.push.apply(result, (0, _toConsumableArray2.default)(this.nodeManager.getSceneById(this._currentSceneId).groupIds));
      return result; // return this.getVisibleGroups();
    }
    /**
     * 设置可见的楼层集合
     * @property {array} visibleGroupIDs 例：[1,2,3]
     */

  }, {
    key: "visibleGroupIDs",
    get: function get() {
      return this.getVisibleGroups();
    }
    /**
     * 地图可见楼层ID发生变化时的回调。
     * @event fengmap.FMMap#visibleGroupIDsChanged
     * @type {json}
     * @property {string} type "visibleGroupIDsChanged"
     * @property {array} gids 改变后的可见楼层ID数组。
     */
    ,
    set: function set(gids) {
      this._visibleGroups = gids;
      this.hideOrShowLine();
      this.checkNode();
      this.setRenderList();
      this.avoidMarkers();
      this.renderer.resetSpriteSize();
      this.dispatchEvent({
        type: "visibleGroupIDsChanged",
        gids: gids
      });
    }
    /**
     * 所有getter setter
     */

    /**
     * 设置地图缩放等级
     * @property {number} mapScaleLevel
     */

  }, {
    key: "mapScaleLevel",
    set: function set(level) {
      var duration, callback;

      if ((0, _typeof2.default)(level) === "object") {
        duration = level.duration;
        callback = level.callback;
        level = level.level;
      } // level = level;


      if (level < this.minScaleLevel) {
        level = this.minScaleLevel;
      } else if (level > this.maxScaleLevel) {
        level = this.maxScaleLevel;
      }

      this.scaleLevelTo({
        level: level,
        duration: duration,
        callback: callback
      });
      this._mapScale = this.levelToScale(level);
      this._mapScaleLevel = level;
    },
    get: function get() {
      return this._mapScaleLevel;
    }
    /**
     * 地图缩放比例
     * @property {number} mapScale 表示当前的比例尺为： 1:mapScale
     */

  }, {
    key: "mapScale",
    get: function get() {
      return this._mapScale;
    },
    set: function set(scale) {
      if (scale < this.minScale) {
        scale = this.minScale;
      } else if (scale > this.maxScale) {
        scale = this.maxScale;
      }

      this.scaleTo({
        scale: scale
      });
      this._mapScaleLevel = this.scaleTolevel(scale);
      this._mapScale = scale;
    }
    /**
     * 当前缩放等级
     * @property {number} scaleLevel 默认范围为：16 - 23
     * @readonly
     */

  }, {
    key: "scaleLevel",
    get: function get() {
      return this.mapScaleLevel;
    }
    /**
     * 最大缩放比例
     * @property {number} maxScale
     */

  }, {
    key: "maxScale",
    set: function set(scale) {
      if (scale <= this.mapScaleLevels[this.mapScaleLevels.length - 1]) {
        scale = this.mapScaleLevels[this.mapScaleLevels.length - 2];
      } else if (scale > this.mapScaleLevels[0]) {
        scale = this.mapScaleLevels[0];
      }

      this._minScaleLevel = this.scaleTolevel(scale);
      this._maxScale = scale;
      this.controls.maxDistance = this.getCameraDistanceByScale(this._maxScale);
    },
    get: function get() {
      return this._maxScale;
    }
    /**
     * 最小缩放比例
     * @property {number} minScale
     */

  }, {
    key: "minScale",
    set: function set(scale) {
      if (scale < this.mapScaleLevels[this.mapScaleLevels.length - 1]) {
        scale = this.mapScaleLevels[this.mapScaleLevels.length - 1];
      } else if (scale >= this.mapScaleLevels[0]) {
        scale = this.mapScaleLevels[1];
      }

      this._maxScaleLevel = this.scaleTolevel(scale);
      this._minScale = scale;
      this.controls.minDistance = this.getCameraDistanceByScale(this._minScale);
    },
    get: function get() {
      return this._minScale;
    }
    /**
     * 最小缩放等级
     * @property  {number} minScaleLevel
     */

  }, {
    key: "minScaleLevel",
    set: function set(level) {
      if (level < 1) {
        level = 1;
      }

      if (level >= 29) {
        level = 28;
      }

      this._maxScale = this.levelToScale(level);
      this.controls.maxDistance = this.getCameraDistanceByScale(this._maxScale);
      this.controls.minZoom = 1 / this.getCameraScaleByScale(this._maxScale);
      this._minScaleLevel = level;
    },
    get: function get() {
      return this._minScaleLevel;
    }
    /**
     * 最大缩放等级
     * @property {number} maxScaleLevel
     */

  }, {
    key: "maxScaleLevel",
    set: function set(level) {
      if (level <= 1) {
        level = 2;
      }

      if (level > 29) {
        level = 29;
      }

      this._minScale = this.levelToScale(level);
      this._maxScaleLevel = level;
      this.controls.minDistance = this.getCameraDistanceByScale(this._minScale);
      this.controls.maxZoom = 1 / this.getCameraScaleByScale(this._minScale);
    },
    get: function get() {
      return this._maxScaleLevel;
    }
  }, {
    key: "maxFps",
    set: function set(v) {
      this._allowfps = v;
    },
    get: function get() {
      return this._allowfps;
    }
    /**
     * 视图模式
     * @property {fengmap.FMViewMode} viewMode FMViewMode类型。默认值:fengmap.FMViewMode.MODE_3D
     */

  }, {
    key: "viewMode",
    get: function get() {
      return this._viewMode;
    },
    set: function set(v) {
      var _this19 = this;

      if (_FMGlobal.default[this.uuid].isToggleViewMode) return;

      var vmodeChange = function vmodeChange() {
        _this19.dispatchEvent({
          type: "viewModeChange",
          mode: v
        });
      };

      if (v == '3d' && this._viewMode != '3d') {
        this.renderer.viewMode = v;
        this._viewMode = v;
        var rl = this.nodeManager.getRenderList();
        this.renderer.renderList = rl;
        this.toggleTo3D(function () {
          vmodeChange();
        }, this.MapOptions.viewModeAnimateTime * 1000);
      } else if (v == 'top' && this._viewMode != 'top') {
        this.toggleToTop(function () {
          _this19._viewMode = v;
          _this19.renderer.viewMode = v;

          var rl = _this19.nodeManager.getRenderList();

          _this19.renderer.renderList = rl;
          vmodeChange();
        }, this.MapOptions.viewModeAnimateTime * 1000);
      }
    }
    /**
     * 是否显示指北针
     * @property {bool} showCompass 默认值：false。
     */

  }, {
    key: "showCompass",
    set: function set(bool) {
      if (bool && !this.renderer.compassNode) {
        var aspect = this.renderer.getAspect();
        var scale = this.renderer.getScaleByPixels(1, this.MapOptions.compassSize);
        var otop = -this.renderer.getScaleByPixels(1, this.MapOptions.compassOffset[1]);
        var oleft = this.renderer.getScaleByPixels(1, this.MapOptions.compassOffset[0]) / aspect; // aspect,  ,oleft ,otop

        var offset = this.renderer.getCompassOffset(this.MapOptions.compassPosition, scale, aspect, oleft, otop);
        this.renderer.compassNode = this.nodeManager.createCompassNode(scale, this._compassBG, this._compassFG, offset.ox, offset.oy);
        this.renderer.compassNode.material.uniforms["rotation"].value = -this.controls.getAzimuthalAngle();
      }

      this.renderer.showCompass = bool;
    },
    get: function get() {
      return this.renderer.showCompass;
    }
    /*
     * 当前视线锁定的楼层
     */

  }, {
    key: "currentFocusGroup",
    get: function get() {
      return this._currentFocusGroup;
    },
    set: function set(gid) {
      this._currentFocusGroup = gid;

      if (this.visibleGroupIDs.length > 1) {
        if (!(this.visibleGroupIDs.indexOf(gid) > -1)) {
          this.visibleGroupIDs.push(gid);
          this.visibleGroupIDs = this.visibleGroupIDs;
          this.checkNode();
          this.setRenderList();
        }
      } else {
        this.visibleGroupIDs = [gid];
      }
      /**
       * 聚焦楼层改变事件
       * @event fengmap.FMMap#focusGroupIDChanged
       * @type {json}
       * @property {string} type "focusGroupIDChanged"
       * @property {number} gid 改变后的聚焦楼层goupID。
       */


      this.dispatchEvent({
        type: "focusGroupIDChanged",
        gid: gid
      });
    }
    /**
     * 当前视线锁定的楼层, 需要注意groupID有效, 防止引起不必要的错误。
     * @property {number} focusGroupID 楼层id
     */

  }, {
    key: "focusGroupID",
    set: function set(gid) {
      this.changeFocusToGroup({
        gid: gid
      });
    },
    get: function get() {
      return this.currentFocusGroup;
    }
    /**
     * 获取地图中心点
     * @property {json} center 返回地图坐标vector2
     * @readonly
     *
     */

  }, {
    key: "center",
    get: function get() {
      return new fm.Vector3().copy(this.nodeManager.getSceneById(this._currentSceneId).mapcenter);
    }
  }, {
    key: "threeCenter",
    get: function get() {
      return new fm.Vector3().copy(this.nodeManager.getSceneById(this._currentSceneId).center);
    }
    /**
     * 获取地图坐标x轴最大值
     * @property {number} maxX
     * @readonly
     */

  }, {
    key: "maxX",
    get: function get() {
      return this.nodeManager.getSceneById(this._currentSceneId).bbox.max.x;
    }
    /**
     * 获取地图坐标y轴最大值
     * @property {number} maxY
     * @readonly
     */

  }, {
    key: "maxY",
    get: function get() {
      return this.nodeManager.getSceneById(this._currentSceneId).bbox.max.y;
    }
    /**
     * 获取地图坐标x轴最小值
     * @property {number} minX
     * @readonly
     */

  }, {
    key: "minX",
    get: function get() {
      return this.nodeManager.getSceneById(this._currentSceneId).bbox.min.x;
    }
    /**
     * 获取地图坐标y轴最小值
     * @property {number} minY
     * @readonly
     */

  }, {
    key: "minY",
    get: function get() {
      return this.nodeManager.getSceneById(this._currentSceneId).bbox.min.y;
    }
    /**
     * 楼层间距
     * @property {number} groupSpace 楼层间距
     */

  }, {
    key: "groupSpace",
    get: function get() {
      return this.nodeManager.getSceneById(this._currentSceneId).space;
    },
    set: function set(s) {
      var scene = this.nodeManager.getSceneById(this._currentSceneId);
      scene.space = s;
      var center = scene.mapcenter;
      var maxgid = this.groupIDs[this.groupIDs.length - 1];
      this.nodeManager.checkNodeByFrustum(this.dataManager.getDecodeScene(this._currentSceneId), this.renderer.getFrustumByViewMode(this._viewMode), this.getVisibleGroups(), this.mapScaleLevel, this._currentSceneId);
      var _iteratorNormalCompletion9 = true;
      var _didIteratorError9 = false;
      var _iteratorError9 = undefined;

      try {
        for (var _iterator9 = (0, _getIterator2.default)(this._lineMarkers), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
          var marker = _step9.value;
          marker.rebuildLine(center, this, this._visibleGroups, maxgid);
        }
      } catch (err) {
        _didIteratorError9 = true;
        _iteratorError9 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
            _iterator9.return();
          }
        } finally {
          if (_didIteratorError9) {
            throw _iteratorError9;
          }
        }
      }
    }
    /**
     * 主题设置
     * @property {string} themeName 主题名如"2002"、"2003"，默认值：‘2001’
     */

  }, {
    key: "themeName",
    set: function set(themeName) {
      var themeUrl = this.MapOptions.mapThemeURL + '/' + themeName + '/' + themeName + '.theme';
      var me = this;
      var scene = this.nodeManager.getSceneById(this._currentSceneId);
      var currName = scene.theme.themeName;

      if (currName === themeName) {
        return;
      }

      this.MapOptions.defaultThemeName = themeName;
      this.fmServer.getTheme(themeUrl, function (themeData) {
        // console.log(themeData);
        me.initTheme(themeName, themeData, function (theme) {
          me.setBackgroundColor(theme.clearColor, theme.clearAlpha);
          scene.theme = theme;
          scene.changeTheme(theme);
        });
      });
    },
    get: function get() {
      var scene = this.nodeManager.getSceneById(this._currentSceneId);
      return scene.theme.themeName;
    }
    /**
     * 全屏设置
     * @property {bool} 是否全屏
     */

  }, {
    key: "fullScreen",
    get: function get() {
      return this._fullScreen;
    },
    set: function set(bool) {
      var dom = this.renderer.container;
      dom = dom || document.body;

      try {
        if (bool) {
          (dom.webkitRequestFullScreen || dom.mozRequestFullScreen).call(dom);
        } else {
          (document.webkitCancelFullScreen || document.mozCancelFullScreen).call(document);
        }

        this._fullScreen = bool;
      } catch (e) {
        console.error(e);
      }
    }
    /**
     * rotateAngle
     * @property {number} rotateAngle 旋转度，取值范围 -360 - 360
     */

  }, {
    key: "rotateAngle",
    get: function get() {
      return -this.controls.getAzimuthalAngle() * fm.Math.RAD2DEG;
    },
    set: function set(v) {
      v = -v * fm.Math.DEG2RAD;

      if (v > Math.PI) {
        v = v - 2 * Math.PI;
      } else if (v < -Math.PI) {
        v = 2 * Math.PI + v;
      }

      if (v < this.controls.minAzimuthAngle) v = this.controls.minAzimuthAngle;
      if (v > this.controls.maxAzimuthAngle) v = this.controls.maxAzimuthAngle;
      this.controls.setUpdate(undefined, undefined, undefined, v);
      this.controls.update();
    }
    /**
     * maxTitleAngle
     * @property {number} maxTitleAngle 地图的最大倾斜角度
     */

  }, {
    key: "maxTitleAngle",
    get: function get() {
      return (Math.PI / 2 - this.controls.minPolarAngle) * fm.Math.RAD2DEG;
    },
    set: function set(angle) {
      if (this._viewMode === "3d") {
        this.controls.minPolarAngle = (90 - angle) * fm.Math.DEG2RAD;
      }

      this.MapOptions.defaultMaxTiltAngle = angle;
    }
    /**
     * minTitleAngle
     * @property {number} minTitleAngle 地图的最小倾斜角度
     */

  }, {
    key: "minTitleAngle",
    get: function get() {
      return (Math.PI / 2 - this.controls.maxPolarAngle) * fm.Math.RAD2DEG;
    },
    set: function set(angle) {
      if (this._viewMode === "3d") {
        this.controls.maxPolarAngle = (90 - angle) * fm.Math.DEG2RAD;
      }

      this.MapOptions.defaultMinTiltAngle = angle;
    }
    /**
     * 当前store标注用的语言类型
     * @property {fengmap.FMLanguageType} labelLanguage "ZH"代表中文,"EN"代表英文
     */

  }, {
    key: "labelLanguage",
    get: function get() {
      return this.MapOptions.defaultLabelLanguage;
    },
    set: function set(v) {
      if (v !== this.labelLanguage) {
        this.MapOptions.defaultLabelLanguage = v;
        var scene = this.nodeManager.getSceneById(this._currentSceneId);
        scene && scene.setLabelLanguage(v);
      }
    }
    /**
     * 模型视窗的背景色 不可读
     * @property backgroundColor
     *
     * @type {int}
     */

  }, {
    key: "backgroundColor",
    set: function set(color) {
      this.renderer.renderer.setClearColor((0, _parseInt2.default)(color));
    }
    /**
     * 倾斜度
     * @property {float} tiltAngle 取值范围 minTitleAngle - maxTitleAngle
     */

  }, {
    key: "tiltAngle",
    get: function get() {
      return (Math.PI / 2 - this.controls.getPolarAngle()) * fm.Math.RAD2DEG;
    },
    set: function set(v) {
      v = (90 - v) * fm.Math.DEG2RAD;
      if (v < this.controls.minPolarAngle) v = this.controls.minPolarAngle;
      if (v > this.controls.maxPolarAngle) v = this.controls.maxPolarAngle; // console.log(v)

      this.controls.setUpdate(undefined, undefined, undefined, undefined, v);
    }
  }, {
    key: "listGroups",
    get: function get() {
      return this.dataManager.getDecodeScene(this._currentSceneId).scene.layerGroups;
    }
  }, {
    key: "layerLocalHeight",
    get: function get() {
      return 0;
    }
    /**
     * 获取地图的手势控制类
     * @property {fengmap.FMMapGestureEnableController} 获取地图手势控制类
     */

  }, {
    key: "gestureEnableController",
    get: function get() {
      return this._enterControl;
    }
  }]);
  return FMMap;
}(_EventDispatcher2.default);

var _default = FMMap;
exports.default = _default;

/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(48);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMAjax = _interopRequireDefault(__webpack_require__(202));

var _NetArea = _interopRequireDefault(__webpack_require__(108));

/**
 *	FMService 是对地图进行请求查询的服务模块
 * 	@class FMService
 *	@constructor
 * 	@module FMService
 */
var FMServer =
/*#__PURE__*/
function () {
  function FMServer() {
    (0, _classCallCheck2.default)(this, FMServer);
    this.netArea = _NetArea.default;
  }
  /**获取场景数据
   * @method getScene
   * @param {*} serverUrl 
   * @param {*} sceneId 
   * @param {*} back 
   */


  (0, _createClass2.default)(FMServer, [{
    key: "getScene",
    value: function getScene(serverUrl, sceneId, separate, sdata, method, back, fail) {
      var idurl;

      if (separate) {
        idurl = sceneId + ".scene";
      } else {
        idurl = sceneId;
      }

      var url = serverUrl + '/' + idurl + '.fmap';

      if (sceneId === null) {
        url = serverUrl;
      }

      var ajax = new _FMAjax.default();

      if (sdata) {
        if (!separate) {
          url = serverUrl;
        }

        ajax.setRequestHeader({
          "X-Requested-With": "XMLHttpRequest",
          'Content-type': 'application/json;charset=utf-8'
        });
      }

      ajax.requestMethod = method ? method : "GET";
      ajax.sendData = sdata;
      ajax.setResponseType("arraybuffer");
      ajax.getFile(url, function (data) {
        // console.log(data);
        back(data, sceneId);
      }, function (response) {
        console.error("网络请求错误");
        fail && fail(response);
      });
    }
  }, {
    key: "getFloor",
    value: function getFloor(serverUrl, floorUrl, sid, gid, back, sdata, obtainMapRoute) {
      if (obtainMapRoute) {
        this.getUrlFloor(serverUrl, floorUrl, sid, gid, back, sdata);
        return;
      }

      var ajax = new _FMAjax.default();

      if (serverUrl == "fengmap") {
        serverUrl = this.netArea + "sdk/authLayered/downMaps";
        ajax.requestMethod = "POST";
        ajax.sendData = sdata;
        ajax.setRequestHeader({
          "X-Requested-With": "XMLHttpRequest",
          'Content-type': 'application/json;charset=utf-8'
        });
      }

      var bizUrl = serverUrl + "/" + sid + "." + floorUrl + ".biz.fmap";
      var geoUrl = serverUrl + "/" + sid + "." + floorUrl + ".geo.fmap";
      var naviUrl = serverUrl + "/" + sid + "." + floorUrl + ".navi.fmap";
      ajax.setResponseType("arraybuffer");
      ajax.getFile(geoUrl, function (datag) {
        ajax.getFile(bizUrl, function (datab) {
          ajax.getFile(naviUrl, function (natab) {
            back(datag, datab, natab, gid);
          }, function () {
            console.error("网络请求错误");
          });
        }, function () {
          console.error("网络请求错误");
        });
      }, function () {
        console.error("网络请求错误");
      });
    }
  }, {
    key: "getUrlFloor",
    value: function getUrlFloor(serverUrl, floorUrl, sid, gid, back, sdata) {
      var ajax = new _FMAjax.default();

      if (serverUrl == "fengmap") {
        ////https://console.fengmap.club/api-s/sdk/authLayered/obtainMapRoute/{fname:.+}
        serverUrl = this.netArea + "sdk/authLayered/obtainMapRoute";
        ajax.requestMethod = "POST";
        ajax.sendData = sdata;
        ajax.setRequestHeader({
          "X-Requested-With": "XMLHttpRequest",
          'Content-type': 'application/json;charset=utf-8'
        });
      }

      var bizUrl = serverUrl + "/" + sid + "." + floorUrl + ".biz.fmap";
      var geoUrl = serverUrl + "/" + sid + "." + floorUrl + ".geo.fmap";
      var naviUrl = serverUrl + "/" + sid + "." + floorUrl + ".navi.fmap";

      var _this = this;

      ajax.getFile(geoUrl, function (datag) {
        ajax.getFile(bizUrl, function (datab) {
          ajax.getFile(naviUrl, function (natab) {
            //console.log(datag, datab, natab, gid);
            //back(datag, datab, natab, gid);
            console.log(natab);
            var na = natab.replace('"', '').replace('"', '');
            var bi = datab.replace('"', '').replace('"', '');
            var ge = datag.replace('"', '').replace('"', '');

            _this.getUrlFloorData(bi, ge, na, gid, sdata, back);
          }, function () {
            console.error("网络请求错误");
          });
        }, function () {
          console.error("网络请求错误");
        });
      }, function () {
        console.error("网络请求错误");
      });
    }
  }, {
    key: "getUrlFloorData",
    value: function getUrlFloorData(bizUrl, geoUrl, naviUrl, gid, sdata, back) {
      var ajax = new _FMAjax.default();
      ajax.sendData = null;
      ajax.requestMethod = "GET";
      ajax.setRequestHeader({
        "X-Requested-With": "XMLHttpRequest"
      });
      ajax.setResponseType("arraybuffer");
      ajax.getFile(geoUrl, function (datag) {
        ajax.getFile(bizUrl, function (datab) {
          ajax.getFile(naviUrl, function (natab) {
            back(datag, datab, natab, gid);
          }, function () {
            console.error("网络请求错误");
          });
        }, function () {
          console.error("网络请求错误");
        });
      }, function () {
        console.error("网络请求错误");
      });
    }
    /**
     * 获取主题数据
     * @param {*} url 
     * @param {*} success 
     */

  }, {
    key: "getTheme",
    value: function getTheme(url, success) {
      var ajax = new _FMAjax.default();
      ajax.getFile(url, function (data) {
        var theme = JSON.parse(data);
        success(theme);
      }, function () {});
    }
    /**
     * 
     * @param {*} url 
     * @param {*} success 
     */

  }, {
    key: "getData",
    value: function getData(url, success, fail, method, sdata, requestHead) {
      var ajax = new _FMAjax.default();
      ajax.requestMethod = method ? method : "GET";
      ajax.sendData = sdata;
      ajax.setRequestHeader(requestHead);
      ajax.getFile(url, function (data) {
        var data = JSON.parse(data);
        success(data);
      }, function (data) {
        fail(data);
      });
    }
  }, {
    key: "getUrl",
    value: function getUrl(serverUrl, sceneId, separate, sdata, method, back, fail) {
      var idurl;

      if (separate) {
        idurl = sceneId + ".scene";
      } else {
        idurl = sceneId;
      }

      var url = serverUrl + '/' + idurl + '.fmap';
      var ajax = new _FMAjax.default();

      if (sdata) {
        if (!separate) {
          url = serverUrl;
        }

        ajax.setRequestHeader({
          "X-Requested-With": "XMLHttpRequest",
          'Content-type': 'application/json;charset=utf-8'
        });
      }

      ajax.requestMethod = method ? method : "GET";
      ajax.sendData = sdata;
      ajax.getFile(url, function (data) {
        // console.log(data);
        back(data, sceneId);
      }, function (response) {
        console.error("网络请求错误");
        fail && fail(response);
      });
    }
  }]);
  return FMServer;
}();

var _default = FMServer;
exports.default = _default;

/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 *	FMAjax 是网络请求的类 封装了web端的ajax
 * 	@class FMAjax
 *	@constructor
 * 	@module FMAjax

 */
var FMAjax =
/*#__PURE__*/
function () {
  function FMAjax() {
    (0, _classCallCheck2.default)(this, FMAjax);
    this.requestMethod = "GET";
    this._requestHeader = {};
    this.sendData = null;
  }
  /**
   * 请求文件
   * @method getFile
   * @param {*} url @type string
   * @param {*} success @type function
   * @param {*} failure  @type function
   */


  (0, _createClass2.default)(FMAjax, [{
    key: "getFile",
    value: function getFile(url, success, failure, progress, abort) {
      if (this._path !== undefined) url = this._path + url;
      var request = new XMLHttpRequest();
      request.open(this.requestMethod, url, true);
      request.addEventListener('load', function (event) {
        var response = this.response;

        if (this.status === 200 || this.status === 0 || this.status === 201) {
          // Some browsers return HTTP Status 0 when using non-http protocol
          // e.g. 'file://' or 'data://'. Handle as success.
          if (this.status === 0) console.warn('FMMap FileLoader: HTTP Status 0 received.');
          success(response);
        } else {
          failure(response);
        }
      }, false);
      request.addEventListener('progress', function (event) {
        progress && progress();
      }, false);
      request.addEventListener('error', function (event) {
        failure();
      }, false);
      request.addEventListener('abort', function (event) {
        abort && abort();
      }, false);
      if (this._responseType !== undefined) request.responseType = this._responseType;
      if (this._withCredentials !== undefined) request.withCredentials = this._withCredentials;
      if (request.overrideMimeType) request.overrideMimeType(this._mimeType !== undefined ? this._mimeType : 'text/plain');

      for (var header in this._requestHeader) {
        request.setRequestHeader(header, this._requestHeader[header]);
      }

      request.send(this.sendData);
    }
  }, {
    key: "setPath",
    value: function setPath(value) {
      this._path = value;
      return this;
    }
    /**
     * 设置返回数据类型
     * @method setResponseType 
     * @param {*} value 
     */

  }, {
    key: "setResponseType",
    value: function setResponseType(value) {
      this._responseType = value;
      return this;
    }
  }, {
    key: "setWithCredentials",
    value: function setWithCredentials(value) {
      this._withCredentials = value;
      return this;
    }
  }, {
    key: "setMimeType",
    value: function setMimeType(value) {
      this._mimeType = value;
      return this;
    }
  }, {
    key: "setRequestHeader",
    value: function setRequestHeader(value) {
      if (value) {
        this._requestHeader = value;
      }

      return this;
    }
  }]);
  return FMAjax;
}();

var _default = FMAjax;
exports.default = _default;

/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

/**
*	FMDirection 地图方向状态枚举
* 	@class
* 	@memberof fengmap
*   @hideconstructor true
*/
var FMDirection = {
  /**
   * 正北
   * @property {string} NORTH -'n'
   * @final
   */
  NORTH: 'n',
  //0
  n: 0,

  /**
  * 正南
  * @property {string} SOUTH -'s'
  * @final
  */
  SOUTH: 's',
  //180
  s: 180,

  /**
  * 正西
  * @property {string} WEST -'w'
  * @final
  */
  WEST: 'w',
  //90
  w: -90,

  /**
  * 正东
  * @property {string} EAST -'e'
  * @final
  */
  EAST: 'e',
  //-90
  e: 90,

  /**
  * 东北
  * @property {string} NORTH_EAST -'ne'
  * @final
  */
  NORTH_EAST: 'ne',
  //-45
  ne: 45,

  /**
  * 西北
  * @property {string} NORTH_WEST -'nw'
  * @final
  */
  NORTH_WEST: 'nw',
  //45
  nw: -45,

  /**
  * 东南
  * @property {string} SOUTH_EAST -'se'
  * @final
  */
  SOUTH_EAST: 'se',
  //-135
  se: 135,

  /**
  * 西南
  * @property {string} SOUTH_WEST -'sw'
  * @final
  */
  SOUTH_WEST: 'sw',
  //135
  sw: -135
};
var _default = FMDirection;
exports.default = _default;

/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(147)))

/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _stringify = _interopRequireDefault(__webpack_require__(104));

var _FMAES = _interopRequireDefault(__webpack_require__(206));

var _FMMD = _interopRequireDefault(__webpack_require__(381));

var _FMServer = _interopRequireDefault(__webpack_require__(201));

// import {netArea} from "../enum/Enum.js";
var servere = new _FMServer.default();
var server = servere.netArea; // let server = 'http://192.168.1.94:8080/FMCloud';

var urls = {
  check: server + 'sdk/check',
  onlineCheck: server + 'sdk/auth/web',
  fmFileServer: server + 'sdk/auth/downMaps'
};
var licenseMD5 = '026685bf295f587b5dffc1f18d5dc27c';

var checkLicense = function checkLicense(key, license, mid) {
  if (!key || typeof license != 'string' || license.length != 32) {
    return false;
  }

  if (key == null || key == '') {
    return true;
  }

  var mapKey = _FMAES.default.decryption(license, licenseMD5);

  var midmd5 = _FMMD.default.encryption(mid);

  mapKey = _FMAES.default.decryption(mapKey, midmd5);

  if (mapKey == key) {
    return true;
  }

  return false;
};

var getAppInfo = function getAppInfo(key, appName, url) {
  url = url || 'fengmap.localhost:';

  var appInfo = _FMMD.default.encryption(url + appName);

  var md5 = _FMAES.default.decryption(key, appInfo);

  return md5;
};

var getSecretKey = function getSecretKey() {
  var d = new Date();
  var y = d.getFullYear();
  var m = d.getMonth() + 1;
  var d = d.getDate();
  var sign = d % 2 == 0 ? 1 : -1;
  var head = Math.max(Math.pow(d % 10 + sign * 1, 2) + sign * m, 0);
  var tail = Math.abs(d * 2 + sign * m);
  return '' + head + tail;
};

var _secret = getSecretKey();

var getCerityData = function getCerityData(key, appName, mapID) {
  var userInfo = getAppInfo(key, appName);
  var host = window.location.host;

  var _index = host.indexOf(':');

  if (_index > -1) {
    host = host.slice(0, _index);
  }

  var webUrl = host || '0.0.0.0';
  return {
    webURL: webUrl,
    appKey: key,
    mapId: mapID,
    appName: appName
  };
}; // let servere = new FMServer();


var checker = {
  // 本地验证
  checkOffLine: function checkOffLine(key, appName, checkStr, sceneKey) {
    checkStr = checkStr || sceneKey;
    var md5 = getAppInfo(key, appName);
    return checkStr == md5;
  },
  // 判断是否连接了 internet
  checkIsOnLine: function checkIsOnLine(sucess, fail, timeout) {
    servere.getData(urls.check, function (res) {
      // console.log('checked is onLine: ', res);
      if (sucess) {
        sucess();
      }
    }, function (res) {
      // console.log('checked is offLine: ', res);
      if (fail) {
        fail();
      }
    });
  },
  // 线上验证
  checkOnLine: function checkOnLine(key, appName, mapID, success, fail, method) {
    var url = urls.onlineCheck;
    var data = getCerityData(key, appName, mapID);
    data = (0, _stringify.default)(data);
    servere.getData(url, function (result) {
      // 判断为无网
      if (!result) {
        if (fail) {
          fail();
        }

        return;
      }

      if (result.success) {
        if (success) {
          success(result);
        }
      } else {
        if (fail) {
          fail(result);
        }
      }
    }, function (result) {
      if (!result) {
        if (fail) {
          fail();
        }

        return;
      }

      console.log('fail', result);
      result = JSON.parse(result);

      if (fail) {
        fail(result);
      }
    }, method, data, {
      'X-Requested-With': 'XMLHttpRequest',
      'Content-type': 'application/json;charset=utf-8'
    });
  },
  checkLicense: checkLicense,
  getCerityData: getCerityData,
  ls: 0
};
var _default = checker;
exports.default = _default;

/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(107);

__webpack_require__(67);

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

var FMAES = function () {
  var B = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22],
      C = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125],
      n = 0,
      q = 0,
      t = [2, 0, 0, 0],
      l = function l(f, e) {
    for (var b = 0, a = 0, k = 0, a = 0; 8 > a; a++) {
      e & 1 && (b ^= f), k = f & 128, f <<= 1, k && (f ^= 27), e >>= 1;
    }

    return b;
  },
      w = function w(f, e, b) {
    var a;

    for (a = 0; 4 > a; a++) {
      f[0 + a] ^= e[16 * b + 4 * a + 0], f[4 + a] ^= e[16 * b + 4 * a + 1], f[8 + a] ^= e[16 * b + 4 * a + 2], f[12 + a] ^= e[16 * b + 4 * a + 3];
    }
  },
      x = function x(f) {
    var e, b, a, k;

    for (e = 1; 4 > e; e++) {
      for (a = 0; a < e;) {
        k = f[4 * e + 4 - 1];

        for (b = 3; 0 < b; b--) {
          f[4 * e + b] = f[4 * e + b - 1];
        }

        f[4 * e + 0] = k;
        a++;
      }
    }
  },
      y = function y(f) {
    var e, b, a, k;

    for (e = 0; 4 > e; e++) {
      for (b = 0; 4 > b; b++) {
        a = (f[4 * e + b] & 240) >> 4, k = f[4 * e + b] & 15, f[4 * e + b] = C[16 * a + k];
      }
    }
  },
      z = function z(f) {
    var e;

    for (e = 0; 4 > e; e++) {
      f[e] = B[16 * ((f[e] & 240) >> 4) + (f[e] & 15)];
    }
  },
      u = function u(f) {
    return (0, _parseInt2.default)(f, 16);
  };

  return {
    decryption: function decryption(f, e) {
      var b,
          a = Array(16);

      for (b = 0; 16 > b; b++) {
        a[b] = 16 * u(e.substr(2 * b, 1)) + u(e.substr(2 * b + 1, 1));
      }

      var k = Array(16);

      for (b = 0; 16 > b; b++) {
        k[b] = 16 * u(f.substr(2 * b, 1)) + u(f.substr(2 * b + 1, 1));
      }

      var A = Array(16);
      b = [];

      switch (a.length) {
        default:
        case 16:
          n = 4;
          q = 10;
          break;

        case 24:
          n = 6;
          q = 12;
          break;

        case 32:
          n = 8, q = 14;
      }

      var g = b = Array(16 * (q + 1)),
          h = Array(4),
          c,
          r = 4 * (q + 1);

      for (c = 0; c < n; c++) {
        g[4 * c + 0] = a[4 * c + 0], g[4 * c + 1] = a[4 * c + 1], g[4 * c + 2] = a[4 * c + 2], g[4 * c + 3] = a[4 * c + 3];
      }

      for (c = n; c < r; c++) {
        h[0] = g[4 * (c - 1) + 0];
        h[1] = g[4 * (c - 1) + 1];
        h[2] = g[4 * (c - 1) + 2];
        h[3] = g[4 * (c - 1) + 3];

        if (0 == c % n) {
          for (var a = h, p = void 0, d = void 0, p = a[0], d = 0; 3 > d; d++) {
            a[d] = a[d + 1];
          }

          a[3] = p;
          z(h);
          a = c / n;
          if (1 == a) t[0] = 1;else if (1 < a) for (t[0] = 2, a--; 0 < a - 1;) {
            t[0] = l(t[0], 2), a--;
          }
          a = h;
          p = t;
          d = h;
          d[0] = a[0] ^ p[0];
          d[1] = a[1] ^ p[1];
          d[2] = a[2] ^ p[2];
          d[3] = a[3] ^ p[3];
        } else 6 < n && 4 == c % n && z(h);

        g[4 * c + 0] = g[4 * (c - n) + 0] ^ h[0];
        g[4 * c + 1] = g[4 * (c - n) + 1] ^ h[1];
        g[4 * c + 2] = g[4 * (c - n) + 2] ^ h[2];
        g[4 * c + 3] = g[4 * (c - n) + 3] ^ h[3];
      }

      g = Array(16);

      for (h = 0; 4 > h; h++) {
        for (c = 0; 4 > c; c++) {
          g[4 * h + c] = k[h + 4 * c];
        }
      }

      w(g, b, q);

      for (k = q - 1; 1 <= k; k--) {
        for (x(g), y(g), w(g, b, k), h = g, c = [14, 9, 13, 11], r = d = void 0, a = Array(4), p = Array(4), r = 0; 4 > r; r++) {
          for (d = 0; 4 > d; d++) {
            a[d] = h[4 * d + r];
          }

          var d = c,
              m = a,
              v = p;
          v[0] = l(d[0], m[0]) ^ l(d[3], m[1]) ^ l(d[2], m[2]) ^ l(d[1], m[3]);
          v[1] = l(d[1], m[0]) ^ l(d[0], m[1]) ^ l(d[3], m[2]) ^ l(d[2], m[3]);
          v[2] = l(d[2], m[0]) ^ l(d[1], m[1]) ^ l(d[0], m[2]) ^ l(d[3], m[3]);
          v[3] = l(d[3], m[0]) ^ l(d[2], m[1]) ^ l(d[1], m[2]) ^ l(d[0], m[3]);

          for (d = 0; 4 > d; d++) {
            h[4 * d + r] = p[d];
          }
        }
      }

      x(g);
      y(g);
      w(g, b, 0);

      for (h = 0; 4 > h; h++) {
        for (c = 0; 4 > c; c++) {
          A[h + 4 * c] = g[4 * h + c];
        }
      }

      k = "";

      for (b = 0; 16 > b; ++b) {
        g = A[b].toString(16), 2 > g.length && (g = "0" + g), k += g;
      }

      return k;
    }
  };
}();

var _default = FMAES;
exports.default = _default;

/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(13);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 *	WKTReader WKT格式集合对象解析
 * 	@class WKTReader
 *	@constructor
 * 	@module WKTReader
 */
var geo = geo || {};
geo.GLEN1 = 'MULTIPOLYGON((('.length;
geo.GLEN2 = 'POINT('.length;
geo.GLEN3 = 'MULTILINESTRING(('.length;

var WKTReader =
/*#__PURE__*/
function () {
  function WKTReader() {
    (0, _classCallCheck2.default)(this, WKTReader);
    this._points; // = [];

    this._holes; // = [[],..]
  }

  (0, _createClass2.default)(WKTReader, [{
    key: "parse",
    value: function parse(txt) {
      this._points = [];
      this._holes = []; //console.log(txt);

      if (txt.indexOf('MULTIPOLYGON(((') == 0) {
        var xys_s = txt.substring(geo.GLEN1, txt.length - 3).split(/\),\(/);

        for (var j = 0; j < xys_s.length; j++) {
          var xys = xys_s[j].split(/,/);

          if (j == 0) {
            for (var i = 0; i < xys.length; i++) {
              var xy = xys[i].split(' ');

              this._points.push({
                x: (0, _parseFloat2.default)(xy[0]),
                y: (0, _parseFloat2.default)(xy[1])
              });
            }
          } else {
            //> 0
            var hole = [];

            for (var i = 0; i < xys.length; i++) {
              var xy = xys[i].split(' ');
              hole.push({
                x: (0, _parseFloat2.default)(xy[0]),
                y: (0, _parseFloat2.default)(xy[1])
              });
            }

            this._holes.push(hole);
          }
        }
      } else if (txt.indexOf('POINT(') == 0) {
        var xy = txt.substring(geo.GLEN2, txt.length - 1).split(' ');

        this._points.push({
          x: (0, _parseFloat2.default)(xy[0]),
          y: (0, _parseFloat2.default)(xy[1])
        });
      } else if (txt.indexOf('MULTILINESTRING((') == 0) {
        var xys = txt.substring(geo.GLEN3, txt.length - 2).split(',');

        for (var i = 0; i < xys.length; i++) {
          var xy = xys[i].split(' ');

          this._points.push({
            x: (0, _parseFloat2.default)(xy[0]),
            y: (0, _parseFloat2.default)(xy[1])
          });
        }
      }

      return this;
    } //存储点保留2位，目的是缩小内存

  }, {
    key: "toFixed",
    value: function toFixed(val) {
      return +val.toFixed(2);
    }
  }, {
    key: "parsePnt",
    value: function parsePnt(txt) {
      this._points = [];

      if (txt.indexOf('MULTIPOLYGON(((') == 0) {
        var xys = txt.substring(geo.GLEN1, txt.length - 3).split(',');

        for (var i = 0; i < xys.length; i++) {
          var xy = xys[i].split(' ');

          this._points.push({
            x: (0, _parseFloat2.default)(xy[0]),
            y: (0, _parseFloat2.default)(xy[1])
          });
        }
      } else if (txt.indexOf('POINT(') == 0) {
        var xy = txt.substring(geo.GLEN2, txt.length - 1).split(' ');

        this._points.push({
          x: (0, _parseFloat2.default)(xy[0]),
          y: (0, _parseFloat2.default)(xy[1])
        });
      } else if (txt.indexOf('MULTILINESTRING((') == 0) {
        var xys = txt.substring(geo.GLEN3, txt.length - 2).split(',');

        for (var i = 0; i < xys.length; i++) {
          var xy = xys[i].split(' ');

          this._points.push({
            x: (0, _parseFloat2.default)(xy[0]),
            y: (0, _parseFloat2.default)(xy[1])
          });
        }
      }

      return this;
    }
  }, {
    key: "toPntStrip",
    value: function toPntStrip(removeLast) {
      var strip = [];
      var len = this._points.length;

      if (removeLast === true) {
        if (len >= 1) {
          for (var i = 0; i < len - 1; i++) {
            var p = this._points[i];
            strip.push(p.x, p.y);
          }
        }
      } else {
        for (var i = 0; i < len; i++) {
          var p = this._points[i];
          strip.push(p.x, p.y);
        }
      }

      return strip;
    } //去除重复的点

  }, {
    key: "mergePnts",
    value: function mergePnts(arr) {
      var uniqueArr = [],
          ilen = arr.length;

      for (var i = 0; i < ilen; i++) {
        var p = arr[i],
            pt = {
          x: this.toFixed(p.x),
          y: this.toFixed(p.y)
        },
            jlen = uniqueArr.length,
            isExist = false;

        for (var j = 0; j < jlen; j++) {
          var t = uniqueArr[j];

          if (t.x == pt.x && t.y == pt.y) {
            isExist = true;
            break;
          }
        }

        if (!isExist) uniqueArr.push(pt);
      }

      return uniqueArr;
    }
  }, {
    key: "toStrip",
    value: function toStrip(removeLast) {
      var strip = [];
      var len = this._points.length;
      if (len <= 0) return strip;

      var lastPnt = this._points.splice(len - 1, 1)[0]; //TODO://不确定去重合不合理


      var uniquePnts = this.mergePnts(this._points),
          ulen = uniquePnts.length;

      for (var i = 0; i < ulen; i++) {
        var p = uniquePnts[i];
        strip.push(p.x, p.y);
      }

      if (removeLast === true) {} else {
        t = {
          x: this.toFixed(lastPnt.x),
          y: this.toFixed(lastPnt.y)
        };
        strip.push(t.x, t.y);

        this._points.push(lastPnt);
      }

      return strip;
    }
  }, {
    key: "hasHoles",
    value: function hasHoles() {
      return this._holes != null && this._holes.length > 0;
    }
  }, {
    key: "toStripHoles",
    value: function toStripHoles(removeLast) {
      var holes = [];

      for (var j = 0; j < this._holes.length; j++) {
        var hole = this._holes[j];
        var strip = [];
        var len = hole.length;
        var lastPnt = hole.splice(len - 1, 1)[0];
        var uniquePnts = this.mergePnts(hole),
            ulen = uniquePnts.length;

        for (var i = 0; i < ulen; i++) {
          var p = uniquePnts[i];
          strip.push(p.x, p.y);
        }

        if (removeLast === true) {} else {
          t = {
            x: this.toFixed(lastPnt.x),
            y: this.toFixed(lastPnt.y)
          };
          strip.push(t.x, t.y); //hole.push(lastPnt);
        }

        holes.push(strip);
      }

      return holes;
    }
  }, {
    key: "holes",
    set: function set(h) {
      this._holes = h;
    },
    get: function get() {
      return this._holes;
    }
  }, {
    key: "points",
    get: function get() {
      return this._points;
    },
    set: function set(p) {
      this._points = p;
    }
  }]);
  return WKTReader;
}();

;
var _default = WKTReader;
exports.default = _default;

/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var ArrayReader =
/*#__PURE__*/
function () {
  function ArrayReader() {
    (0, _classCallCheck2.default)(this, ArrayReader);
    this._points; // = [];

    this._holes; // = [[],..]
  }

  (0, _createClass2.default)(ArrayReader, [{
    key: "parse",
    value: function parse(idxs, pts) {
      this._points = [];
      this._holes = [];
      var k = 0;

      for (var i = 0; i < idxs.length; i++) {
        var idx = idxs[i].idxs;

        if (!idx) {
          idx = idxs[i];
        }

        if (typeof idx === 'number') {
          while (k < idx) {
            this._points.push({
              x: pts[k],
              y: pts[k + 1]
            });

            k = k + 2;
          }
        } else {
          for (var ii = 0; ii < idx.length; ii++) {
            var param = idx[ii];

            while (k < param) {
              this._points.push({
                x: pts[k],
                y: pts[k + 1]
              });

              k = k + 2;
            }
          }
        }
      }

      return this;
    }
  }, {
    key: "parseGeometry",
    value: function parseGeometry(idxs, pts) {
      this._points = [];
      this._holes = []; //console.log(31,idxs.length);
      //console.log(32,JSON.stringify(idxs));
      //console.log(33,JSON.stringify(pts));

      var k = 0;

      for (var i = 0; i < idxs.length; i++) {
        var idx = idxs[i].idxs;

        if (!idx) {
          idx = idxs[i];
        }

        if (typeof idx === 'number') {
          while (k < idx) {
            this._points.push({
              x: pts[k],
              y: pts[k + 1]
            });

            k = k + 2;
          }
        } else {
          for (var ii = 0; ii < idx.length; ii++) {
            if (ii === 0) {
              var param = idx[ii];

              while (k < param) {
                this._points.push({
                  x: pts[k],
                  y: pts[k + 1]
                });

                k = k + 2;
              }
            } else {
              var hole = [];
              var _param = idx[ii];

              while (k < _param) {
                hole.push({
                  x: pts[k],
                  y: pts[k + 1]
                });
                k = k + 2;
              }

              this._holes.push(hole);
            }
          }
        }
      }
      /*if(this._holes.length!==0){
      	console.log(60,this._points);
      	console.log(61,this._holes);
      }*/


      return this;
    } //去除重复的点

  }, {
    key: "mergePnts",
    value: function mergePnts(arr) {
      var uniqueArr = [],
          ilen = arr.length;

      for (var i = 0; i < ilen; i++) {
        var p = arr[i],
            pt = {
          x: this.toFixed(p.x),
          y: this.toFixed(p.y)
        },
            jlen = uniqueArr.length,
            isExist = false;

        for (var j = 0; j < jlen; j++) {
          var t = uniqueArr[j];

          if (t.x == pt.x && t.y == pt.y) {
            isExist = true;
            break;
          }
        }

        if (!isExist) uniqueArr.push(pt);
      }

      return uniqueArr;
    }
  }, {
    key: "toStrip",
    value: function toStrip(removeLast) {
      var strip = [];
      var len = this._points.length;
      if (len <= 0) return strip;

      var lastPnt = this._points.splice(len - 1, 1)[0]; //TODO://不确定去重合不合理

      /*var uniquePnts = this.mergePnts(this._points),
      ulen = uniquePnts.length;*/


      var uniquePnts = this._points;
      var ulen = uniquePnts.length;

      for (var i = 0; i < ulen; i++) {
        var p = uniquePnts[i];
        strip.push(p.x, p.y);
      }

      if (removeLast === true) {} else {
        t = {
          x: this.toFixed(lastPnt.x),
          y: this.toFixed(lastPnt.y)
        };
        strip.push(t.x, t.y);

        this._points.push(lastPnt);
      }

      return strip;
    } //存储点保留2位，目的是缩小内存

  }, {
    key: "toFixed",
    value: function toFixed(val) {
      return +val.toFixed(2);
    }
  }, {
    key: "hasHoles",
    value: function hasHoles() {
      return this._holes != null && this._holes.length > 0;
    }
  }, {
    key: "toStripHoles",
    value: function toStripHoles(removeLast) {
      var holes = [];

      for (var j = 0; j < this._holes.length; j++) {
        var hole = this._holes[j];
        var strip = [];
        var len = hole.length;
        var lastPnt = hole.splice(len - 1, 1)[0];
        var uniquePnts = this.mergePnts(hole),
            ulen = uniquePnts.length;

        for (var i = 0; i < ulen; i++) {
          var p = uniquePnts[i];
          strip.push(p.x, p.y);
        }

        if (removeLast === true) {} else {
          t = {
            x: this.toFixed(lastPnt.x),
            y: this.toFixed(lastPnt.y)
          };
          strip.push(t.x, t.y); //hole.push(lastPnt);
        }

        holes.push(strip);
      }

      return holes;
    }
  }, {
    key: "holes",
    set: function set(h) {
      this._holes = h;
    },
    get: function get() {
      return this._holes;
    }
  }, {
    key: "points",
    get: function get() {
      return this._points;
    },
    set: function set(p) {
      this._points = p;
    }
  }]);
  return ArrayReader;
}();

var _default = ArrayReader;
exports.default = _default;

/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(56);

var _keys = _interopRequireDefault(__webpack_require__(54));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _Enum = __webpack_require__(109);

var _THREECsg = _interopRequireDefault(__webpack_require__(393));

var _Graphics = _interopRequireDefault(__webpack_require__(49));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

/**
 *  FMGroup 楼层对象，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @hideconstructor true
 *  @extends {fengmap.FMNode}
 */
var FMGroup =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMGroup, _FMNode);

  function FMGroup(id, data, message) {
    var _this;

    (0, _classCallCheck2.default)(this, FMGroup);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMGroup).call(this, id));
    _this._layers = {};

    _this.initLayers();

    _this.initLayersByData(data);

    _this._visible = true;
    _this._groupMessage = message;
    _this._locations = [];
    _this._height = message.height;
    _this._locationScene = new fm.Scene();
    _this._locationScene.userData.type = "location";

    _this._locationScene.position.setY(_this._height);

    _this._locationScene.updateMatrix();

    _this._locationScene.updateWorldMatrix();

    _this._offsetHeight = 0;
    _this._lineScene = new fm.Scene(); // this._lineScene.position.setY(this._height);

    _this._lineScene.userData.type = "line";
    _this.externalModels = {};
    _this.isGroup = true;
    _this.alwaysShowMarkers = [];
    _this._groupAlias = message.alias;
    _this._groupDesc = message.desc;
    _this._groupName = message.gname;
    _this._hideWithFree = false;
    _this.modelShadow = {};
    _this._group = new fm.Scene();
    _this._mainLight = null;

    _this.initScene();

    return _this;
  }

  (0, _createClass2.default)(FMGroup, [{
    key: "initScene",
    value: function initScene() {
      if (this._layers.extent[0]) {
        this._group.add(this._layers.extent[0]._scene);
      }

      if (this._layers.model[0]) {
        this._group.add(this._layers.model[0]._scene);
      }
    }
  }, {
    key: "getHeight",
    value: function getHeight() {
      return this.height + this._offsetHeight;
    }
    /**
     * 获取或者创建layer
     * @param {string} layerAlias layer的别名: "imageMarker", "textMarker","polygonMarker","storeImage"
     * @return {Object} 返回已有或新创建的layer对象。
     */

  }, {
    key: "getOrCreateLayer",
    value: function getOrCreateLayer(layerAlias) {
      if (this._layers[layerAlias][0]) {
        return this._layers[layerAlias][0];
      } else {
        var _constructor = _Enum.AliasLayerMap.get(layerAlias);

        var _layer = new _constructor();

        _layer.scene.position.setY(this._height);

        _layer.scene.updateMatrix();

        _layer.scene.updateWorldMatrix();

        _layer.parent = this;
        _layer._scene.visible = true;

        this._layers[layerAlias].push(_layer);

        this.parent.parent.map.setRenderList();
        return this._layers[layerAlias][0];
      }
    }
  }, {
    key: "getLayers",
    value: function getLayers(alias) {
      var array_ = [];
      var layers = this._layers[alias];
      array_.push.apply(array_, (0, _toConsumableArray2.default)(layers));
      return array_;
    }
  }, {
    key: "getDynmodel",
    value: function getDynmodel(back) {
      var singleLayers = this._layers["dynmodel"];

      for (var i = 0; i < singleLayers.length; i++) {
        // singleLayers[i].checkSceneNode();
        var scene = singleLayers[i].scene;
        scene && back(scene);
      }
    }
  }, {
    key: "everyLayers",
    value: function everyLayers(unSelecter, back) {
      if (!this._layers) return;

      for (var ly in this._layers) {
        if (unSelecter.indexOf(ly) > -1) continue;
        var singleLayers = this._layers[ly];

        for (var i = 0; i < singleLayers.length; i++) {
          // singleLayers[i].checkSceneNode();
          var scene = singleLayers[i].scene;
          scene && back(scene);
        }
      }
    }
  }, {
    key: "getNodeByLayerId",
    value: function getNodeByLayerId(layer, eid) {
      if (!this._layers) return;

      if (this._layers[layer][0]) {
        return this._layers[layer][0].getNodeById(eid);
      }
    }
  }, {
    key: "bcross",
    value: function bcross(m1, m2) {
      var min1 = m1.renderNode.boundingBox.min;
      var max1 = m1.renderNode.boundingBox.max;
      var min2 = m2.renderNode.boundingBox.min;
      var max2 = m2.renderNode.boundingBox.max;
      return _Graphics.default.isRectCross(new vector2(min1.x, min1.z), new vector2(max1.x, max1.z), new vector2(min2.x, min2.z), new vector2(max2.x, max2.z));
    }
  }, {
    key: "mergeModels",
    value: function mergeModels(fids) {
      var modelLayers = this._layers['model'][0];
      var mmodels = [];

      for (var m in modelLayers._models) {
        if (modelLayers._models[m].FID in fids) {
          mmodels.push(modelLayers._models[m]);
        }
      }

      var result = this.checkModelsNearly(mmodels);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(result.l), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _m = _step.value;
          modelLayers.removeNode(_m);
        } // return mmodels;

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "mergeModel",
    value: function mergeModel(m1, m2) {
      var bsp1 = new ThreeBSP(m1.renderNode.geometry);
      var bsp2 = new ThreeBSP(m2.renderNode.geometry);
      var inbsp = bsp1.union(bsp2.tree);
      var mesh = inbsp.toMesh(m1.material);
      return m1._renderNode = mesh;
    }
  }, {
    key: "couldMerge",
    value: function couldMerge(m1, m2) {
      var bsp1 = new ThreeBSP(m1.renderNode.geometry);
      var bsp2 = new ThreeBSP(m2.renderNode.geometry);
      var inbsp = bsp1.intersect(bsp2.tree);

      if (inbsp.tree.polygons.length > 0) {
        return true;
      }

      return false; // if(intersect)
      // return Graphics.isTwoPolygonsSeparate( m1._shape.getPoints() ,m2._shape.getPoints())
    }
  }, {
    key: "checkModelsNearly",
    value: function checkModelsNearly(models) {
      var lonely = [];

      for (var i = 0; i < models.length; i++) {
        var p = 0;

        for (var j = 0; j < models.length; j++) {
          if (this.bcross(models[i], models[j])) {
            p++;
          }
        }

        if (!p) {
          lonely.push(i);
        }
      }

      for (var k = lonely.length - 1; k > -1; k--) {
        var index = models.indexOf(models[lonely[k]]);

        if (index > -1) {
          models.splice(index, 1);
        }
      } // let model = models.pop();


      var mindex = 0;
      var currIndex = 1;
      var ends = [];
      var leaves = [];

      while (models.length > 0) {
        if (this.couldMerge(models[mindex], models[currIndex])) {
          var merged = this.mergeM(models[mindex], models[currIndex]);
          leaves.push(models[currIndex]);
          models.splice(currIndex, 1);
          models.splice(mindex, 1);
          models.push(merged);
          mindex = 0;
          currIndex = 1;
          continue;
        }

        if (currIndex === models.length - 1) {
          var comb = models.splice(mindex, 1);
          ends.push(comb);
          mindex = 0;
          currIndex = 1;
          continue;
        }

        currIndex++;
        return {
          e: ends,
          l: leaves
        }; // for(let n = 0; n < models.length; n++) {
        // }
      }
    }
    /**
     * 遍历所有layer图层
     * @param {function} back 遍历图层回调函数
     */

  }, {
    key: "traverse",
    value: function traverse(back) {
      if (!this._layers) return;

      for (var ly in this._layers) {
        var singleLayers = this._layers[ly];

        for (var i = 0; i < singleLayers.length; i++) {
          back(singleLayers[i]);
        }
      }
    }
    /**
     * 遍历别名数组所有node
     * @param {array} alias 别名数组
     * @param {function} back 回调函数 回调函数返回地图node对象以及别名 function(node ,alias){}
     */

  }, {
    key: "traverseByAlias",
    value: function traverseByAlias(alias, back, onlyLayer) {
      var _this2 = this;

      if (!this._layers) return;

      var _loop = function _loop(ly) {
        if (alias.indexOf(ly) > -1) {
          var singleLayers = _this2._layers[ly];

          for (var i = 0; i < singleLayers.length; i++) {
            if (onlyLayer) {
              back(singleLayers[i], ly);
            } else {
              singleLayers[i].traverse(function (node) {
                back(node, ly);
              });
            }
          }
        }
      };

      for (var ly in this._layers) {
        _loop(ly);
      }
    }
    /**
     * 给地板设置一张图片
     * @param {image|string} img 图片url或者image对象
     */

  }, {
    key: "setExtentImage",
    value: function setExtentImage(img) {
      var texture = this.parent.parent.materialManager.loadTexture(img, function () {});
      var extentLayers = this.getLayers("extent");
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator2.default)(extentLayers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var extentLayer = _step2.value;

          for (var en in extentLayer.extents) {
            var extent = extentLayer.extents[en];
            extent.renderNode.material.map && extent.renderNode.material.map.dispose();
            extent.renderNode.material.map = texture;
            extent.renderNode.material.needsUpdate = true;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /**
     * 清除地板图片
     */

  }, {
    key: "clearExtentImage",
    value: function clearExtentImage() {
      var extentLayers = this.getLayers("extent");
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator2.default)(extentLayers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var extentLayer = _step3.value;

          for (var en in extentLayer.extents) {
            var extent = extentLayer.extents[en];
            extent.renderNode.material.map.dispose();
            extent.renderNode.material.map = null;
            extent.renderNode.material.needsUpdate = true;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "_getLayers",
    value: function _getLayers(isCheck) {
      if (!this._layers) return;
      var renderGroup = {};

      for (var ly in this._layers) {
        var singleLayers = this._layers[ly];
        var scenes = [];

        for (var i = 0; i < singleLayers.length; i++) {
          if (isCheck) {
            //
            singleLayers[i].checkSceneNode();
          }

          var scene = singleLayers[i].scene;

          if (singleLayers[i].visible && scene) {
            scenes.push(scene);
          }
        }

        renderGroup[ly] = scenes;
      }

      return renderGroup;
    }
  }, {
    key: "initLayers",
    value: function initLayers() {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(_Enum.LayerAlias), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var alias = _step4.value;
          this._layers[alias] = [];
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: "initLayersByData",
    value: function initLayersByData(data) {
      var o = data.geo[0];
      var b = data.biz[0];
      var keys = (0, _keys.default)(o);
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator2.default)(keys), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var key = _step5.value;

          if (o[key] && o[key].length > 0) {
            if (_Enum.Prop2Alias[key]) {
              var constru = _Enum.AliasLayerMap.get(_Enum.Prop2Alias[key]);

              var _layer2 = new constru(o[key], b[key]);

              _layer2.scene.position.setY(this._height);

              _layer2.scene.updateMatrix();

              _layer2.scene.updateWorldMatrix();

              _layer2.parent = this;

              this._layers[_Enum.Prop2Alias[key]].push(_layer2);
            }
          }
        } //

      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }
    }
  }, {
    key: "removeAlwaysShowMarker",
    value: function removeAlwaysShowMarker(marker) {
      var index = this.alwaysShowMarkers.indexOf(marker);

      if (index > -1) {
        this.alwaysShowMarkers.splice(index, 1);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.alwaysShowMarkers.length = 0;

      for (var ly in this.layers) {
        var singleLayers = this.layers[ly];

        for (var i = 0; i < singleLayers.length; i++) {
          singleLayers[i].dispose();
          singleLayers[i].parent = undefined;
        }

        singleLayers.length = 0;
        this._layers[ly] = undefined;
      }

      for (var _i = this._locationScene.children.length - 1; _i > -1; _i--) {
        this._locationScene.remove(this._locationScene.children[_i]);
      }

      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = (0, _getIterator2.default)(this._locations), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var lm = _step6.value;
          lm.parent = undefined;
          lm.dispose();
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }

      this._groupMessage = undefined;
      this._layers = undefined;
    }
    /**
     * 添加一个图层
     * @param {object} layer 图层对象
     */

  }, {
    key: "addLayer",
    value: function addLayer(layer) {
      layer.parent = this;
      layer.scene.position.setY(this._height);
      layer.scene.updateMatrix();
      layer.scene.updateWorldMatrix();

      this._layers[layer.alias].push(layer);

      this.parent.parent.map.setRenderList();

      if (layer.prepareInited || layer.prepareInitObjects.length > 0) {
        layer.initPrepare();
      }
    }
    /**
     * 删除一个图层
     * @param {object} layer 图层对象
     */

  }, {
    key: "removeLayer",
    value: function removeLayer(layer) {
      layer.removeAll && layer.removeAll();
      layer.parent = undefined;

      var lindex = this._layers[layer.alias].indexOf(layer);

      if (lindex > -1) {
        this._layers[layer.alias].splice(lindex, 1);
      }

      this.parent.parent.map.setRenderList();
    }
    /**
     * 返回与指定 layer别名 层或所有层, 如要只有一个层与之相符则会将此层返回, 如果有两个层与之相符则会以数组的形式返回所有
     * @param {string} alias  layer的别名: "imageMarker", "textMarker"
     * @returns {array<object>|object} [layer] 或者 Layer
     */

  }, {
    key: "getLayer",
    value: function getLayer(alias) {
      var layers = this._layers[alias];

      if (layers.length > 1) {
        var rarray = [];
        rarray.push.apply(rarray, (0, _toConsumableArray2.default)(layers));
        return rarray;
      }

      return layers[0];
    }
    /**
     * 返回同别名alias第一个
     * @param {string} alias layer的别名: "imageMarker", "textMarker"
     * @returns {object} 根据别名找到的第一个layer对象
     */

  }, {
    key: "getFirstLayer",
    value: function getFirstLayer(alias) {
      var layers = this._layers[layer.alias];
      return layers[0];
    }
  }, {
    key: "addLocation",
    value: function addLocation(location) {
      location.parent = this;

      this._locations.push(location);

      this._locationScene.add(location.renderNode);
    }
  }, {
    key: "removeLocation",
    value: function removeLocation(location) {
      var index = this._locations.indexOf(location);

      if (location.isAlwaysShow) {
        this.removeAlwaysShowMarker(location);
      }

      location.parent = undefined;

      if (index > -1) {
        this._locations.splice(index, 1);
      }

      this._locationScene.remove(location.renderNode);
    }
  }, {
    key: "getCenterPosition",
    value: function getCenterPosition() {
      return new fm.Vector3(this.parent.center.x, this.parent.center.y + this._height, 0);
    }
  }, {
    key: "getModelMeshs",
    value: function getModelMeshs() {
      var meshs = [];
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = (0, _getIterator2.default)(this._layers['model']), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var mlayer = _step7.value;
          meshs.push.apply(meshs, (0, _toConsumableArray2.default)(mlayer.getAllMesh()));
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }

      return meshs;
    }
  }, {
    key: "getExtentMeshs",
    value: function getExtentMeshs() {
      var meshs = [];
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = (0, _getIterator2.default)(this._layers['extent']), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var mlayer = _step8.value;
          meshs.push.apply(meshs, (0, _toConsumableArray2.default)(mlayer.getAllMesh()));
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return meshs;
    }
    /**
     * 热力图绑定到group上
     * @param {fengmap.FMHeatMap} heatmap 热力图对象。
     * @see {@link fengmap.FMHeatMap.create}
     */

  }, {
    key: "applyHeatMap",
    value: function applyHeatMap(heatmap) {
      if (heatmap) {
        heatmap.renderToMap(this._groupId);
        this.heatmap_ = heatmap;
      }
    }
    /**
     * 移除当前楼层的热力图
     */

  }, {
    key: "removeHeatMap",
    value: function removeHeatMap(heatmap) {
      heatmap.disposeHeatMap(this._groupId);
      this.heatmap_ = null;
    }
  }, {
    key: "addLine",
    value: function addLine(line) {
      this._lineScene.add(line);
    }
  }, {
    key: "removeLine",
    value: function removeLine(line) {
      this._lineScene.remove(line);
    }
  }, {
    key: "locationScene",
    get: function get() {
      return this._locationScene;
    }
  }, {
    key: "lineScene",
    get: function get() {
      return this._lineScene;
    }
    /**
     * 楼层别名
     * @property {string} groupAlias 获取当前楼层的别名
     * @readonly
     */

  }, {
    key: "groupAlias",
    get: function get() {
      return this._groupAlias;
    }
    /**
     * 楼层描述
     * @property {string} groupDesc 获取当前楼层的描述
     * @readonly
     */

  }, {
    key: "groupDesc",
    get: function get() {
      return this._groupDesc;
    }
    /**
     * 楼层名称
     * @property {string} groupName 获取当前楼层名称
     * @readonly
     */

  }, {
    key: "groupName",
    get: function get() {
      return this._groupName;
    }
    /**
     * 楼层高度
     * @property {number} groupHeight 获取当前楼层离地面高度
     * @readonly
     */

  }, {
    key: "groupHeight",
    get: function get() {
      return this._groupHeight;
    }
  }, {
    key: "height",
    set: function set(h) {
      this._height = h;
      this.traverse(function (layer) {
        layer.scene.position.setY(h);
        layer.scene.updateMatrix();
        layer.scene.updateWorldMatrix();
      });

      this._locationScene.position.setY(h);

      this._locationScene.updateMatrix();

      this._locationScene.updateWorldMatrix(); // this._lineScene.position.setY(h);

    },
    get: function get() {
      return this._height;
    }
    /**
     * 楼层内图层集合
     * @property {array} layers 获取当前楼层中的图层集合
     * @readonly
     */

  }, {
    key: "layers",
    get: function get() {
      return this._layers;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      if (this._hideWithFree) {
        if (!v) {
          this.traverseByAlias(['extent', 'label', 'facility', 'model'], function (node) {
            node.releaseGpuMemory();
          });
        }
      }

      this._visible = v;
    }
  }, {
    key: "offsetHeight",
    set: function set(oh) {
      this._offsetHeight = oh;
    },
    get: function get() {
      return this._offsetHeight;
    }
  }, {
    key: "hideWithFree",
    set: function set(v) {
      this._hideWithFree = v;
    }
    /**
     * 中心坐标
     * @property {json} 楼层中心点坐标
     * @readonly
     */

  }, {
    key: "mapCoord",
    get: function get() {
      return new fm.Vector2().copy(this.parent.mapcenter);
    }
  }, {
    key: "mapCoordRange",
    get: function get() {
      var range = [{
        'x': Number.MAX_VALUE,
        'y': Number.MAX_VALUE
      }, {
        'x': -Number.MAX_VALUE,
        'y': -Number.MAX_VALUE
      }];
      var extentLayers = this._layers['extent'];

      for (var i = 0; i < extentLayers.length; i++) {
        var extentLayer = extentLayers[i];
        var extents = extentLayer._extents;

        for (var eid in extents) {
          var extent = extents[eid];
          var geo = extent.gdata.geo;
          var vertices = null; //DataManager.convertGeo2Geometry(geo).vertices;

          if (geo !== null) {
            vertices = _DataManager.default.convertGeo2Geometry(geo).vertices;
          } else {
            vertices = _DataManager.default.convertArray2Geometry(extent.gdata.idxs, extent.gdata.pts).vertices;
          }

          for (var j = 0; j < vertices.length; j++) {
            if (j % 2 == 0) {
              if (vertices[j] < range[0].x) {
                range[0].x = vertices[j];
              }

              if (vertices[j] > range[1].x) {
                range[1].x = vertices[j];
              }
            } else {
              if (vertices[j] < range[0].y) {
                range[0].y = vertices[j];
              }

              if (vertices[j] > range[1].y) {
                range[1].y = vertices[j];
              }
            }
          }
        }
      }

      return range;
    }
  }]);
  return FMGroup;
}(_FMNode2.default);

var _default = FMGroup;
exports.default = _default;

/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMExtent = _interopRequireDefault(__webpack_require__(382));

/**
 *	FMExtentLayer 作为地板extent的容器 同时做extent渲染逻辑处理
 * 	@class FMMap
 *	@constructor
 */
var FMExtentLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMExtentLayer, _FMNode);

  function FMExtentLayer(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMExtentLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMExtentLayer).call(this, "extentLayer"));
    _this._scene = new fm.Scene();
    _this._scene.name = "extent";
    _this._scene.userData.type = "extent";
    _this._extents = {};

    _this.initNode(gdata, bdata);

    _this._visible = true;

    _this.initLight();

    _this.putLight();

    return _this;
  }

  (0, _createClass2.default)(FMExtentLayer, [{
    key: "initLight",
    value: function initLight() {
      this._ambientLight = new fm.AmbientLight(0x747474);
      this._target = new fm.Object3D();
      this._mainLight = new fm.DirectionalLight(0x888888, 1.2);

      this._mainLight.position.set(-1, 1, 1).normalize();

      this._mainLight.castShadow = false;
      this._mainLight.target = this._target;
      this._secondLight = new fm.DirectionalLight(0x333333);

      this._secondLight.position.set(-0.5, 1, -1).normalize();

      this._secondLight.target = this._target;
    }
  }, {
    key: "initNode",
    value: function initNode(gdata, bdata) {
      for (var i = 0; i < gdata.length; i++) {
        this.createNode(gdata[i], bdata[i]);
      }
    }
  }, {
    key: "createNode",
    value: function createNode(geo, biz) {
      var node = new _FMExtent.default(geo, biz);
      node.parent = this;
      this._extents["" + node.eid] = node;
    }
  }, {
    key: "addNodes",
    value: function addNodes(node) {
      node.parent = this;
      node.renderNode && this._scene.add(node.renderNode);
      this._extents["" + node.eid] = node;
    }
  }, {
    key: "putLight",
    value: function putLight() {
      var _this2 = this;

      this.scene.add(this._mainLight);
      this.scene.add(this._ambientLight);
      this.scene.add(this._secondLight); // var helper1 = new fm.DirectionalLightHelper( this._mainLight, 100 ,0xff0000 );
      // var helper2 = new fm.DirectionalLightHelper( this._secondLight, 100 ,0xff0000);
      // this.scene.add(helper1);
      // this.scene.add(helper2);

      this.scene.add(this._target);

      this.scene.removeLight = function () {
        _this2.removeLight();
      };
    }
  }, {
    key: "removeLight",
    value: function removeLight() {
      this.scene.remove(this._mainLight);
      this.scene.remove(this._ambientLight);
      this.scene.remove(this._secondLight);
    }
  }, {
    key: "disposeLight",
    value: function disposeLight() {
      this._mainLight = undefined;
      this._ambientLight = undefined;
      this._secondLight = undefined;
    }
  }, {
    key: "getNodeById",
    value: function getNodeById(id) {
      return this._extents["" + id];
    }
  }, {
    key: "traverse",
    value: function traverse(back) {
      for (var n in this._extents) {
        back && back(this._extents[n]);
      }
    }
  }, {
    key: "getVideoMemoryAmount",
    value: function getVideoMemoryAmount() {
      var videoMemoryAmount = null;
      this.traverse(function (model) {
        if (!model._renderNode) return;

        if (model._renderNode.geometry) {
          if (model._renderNode.geometry._bufferGeometry) {
            videoMemoryAmount += model._renderNode.geometry._bufferGeometry.attributes.position.array.byteLength;
            videoMemoryAmount += model._renderNode.geometry._bufferGeometry.attributes.color.array.byteLength;
            videoMemoryAmount += model._renderNode.geometry._bufferGeometry.attributes.normal.array.byteLength;
            videoMemoryAmount += model._renderNode.geometry._bufferGeometry.attributes.uv.array.byteLength;
          }
        }
      });
      return videoMemoryAmount;
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;

      for (var n in this._extents) {
        if (this._extents[n].visible) {
          this._extents[n].renderNode && this._scene.add(this._extents[n].renderNode);
        }
      }

      this.putLight();
    }
  }, {
    key: "getAllMesh",
    value: function getAllMesh() {
      var meshs = [];

      for (var n in this._extents) {
        this._extents[n].renderNode && meshs.push(this._extents[n].renderNode);
      }

      return meshs;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var n in this._extents) {
        this._extents[n].dispose();

        this._scene.remove(this._extents[n].renderNode);

        this._extents[n].parent = undefined;
        this._extents[n] = undefined;
      }

      this.removeLight();
      this.disposeLight();
      this._scene.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "extents",
    get: function get() {
      return this._extents;
    },
    set: function set(e) {
      this._extents = e;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }]);
  return FMExtentLayer;
}(_FMNode2.default);

var _default = FMExtentLayer;
exports.default = _default;

/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

__webpack_require__(13);

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _isArray = _interopRequireDefault(__webpack_require__(35));

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _FMUtil = _interopRequireDefault(__webpack_require__(57));

/**
 *  FMExternalModel 外部建模模型对象，是一种地图内置图层的对象，只读，不可实例化。
 *  @class FMExternalModel
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMExternalModel =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMExternalModel, _FMNode);

  function FMExternalModel(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMExternalModel);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMExternalModel).call(this, bdata.eid, _FMNodeType.default.EXTERANL_MODEL));
    _this._parseData = null;
    _this._isInitMesh = true;
    _this._visible = true;
    _this._renderNode = null;
    _this._geometry = undefined;
    _this._line = null;
    _this._bdata = bdata;
    _this._selected = false;
    _this._preColor = null;
    _this._preOpacity = null;
    /**
     * name
     * @property {string} name 名称
     */

    _this.name = bdata.name;
    /**
     * FID
     * @property {string} FID 全地图内唯一的模型ID
     */

    _this.FID = bdata.fid;
    /**
     * ID
     * @property {string} ID 当前楼层内唯一的模型ID
     */

    _this.ID = bdata.eid;
    /**
     * typeID
     * @property {string} typeID 类型
     */

    _this.typeID = bdata.type;
    _this.gdata = gdata;
    return _this;
  }

  (0, _createClass2.default)(FMExternalModel, [{
    key: "initMesh",
    value: function initMesh(material, pos) {
      if (!this._geometry) return;
      this._renderNode = new fm.Mesh(this._geometry.geometry, material);
      this._renderNode.mapNode = this; // material.color = new fm.Color( 0x00ff00 );

      this._renderNode.scale.set(-1, 1, 1);

      this._renderNode.rotation.set(Math.PI / 2, 0, 0, 'XYZ');

      this._renderNode.position.copy(pos);

      this._renderNode.parent = this.parent.scene;
      this._renderNode.visible = this.show;
    }
  }, {
    key: "setByTheme",
    value: function setByTheme(theme) {
      var mater = this._renderNode.material;
      var mesh = this._renderNode;

      if ((0, _isArray.default)(mater)) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator2.default)(mater), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var mat = _step.value;
            mat.color = new fm.Color(_FMUtil.default.toColor(theme.color));
            mat.userData.opacity = mater.opacity;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      } else {
        mater.color = new fm.Color(_FMUtil.default.toColor(theme.color));
        mater.userData.opacity = mater.opacity;
      }

      var scales = theme.scale.split(",");
      var rotates = theme.rotate.split(",");
      var translates = theme.translate.split(",");
      mesh.scale.set((0, _parseInt2.default)(scales[0]), (0, _parseInt2.default)(scales[1]), (0, _parseInt2.default)(scales[2]));
      mesh.rotation.set((0, _parseInt2.default)(rotates[0]) * fm.Math.DEG2RAD, (0, _parseInt2.default)(rotates[2]) * fm.Math.DEG2RAD, (0, _parseInt2.default)(rotates[1]) * fm.Math.DEG2RAD);
    }
  }, {
    key: "checkByFrustum",
    value: function checkByFrustum(frustum) {
      var visible = true;

      if (this._renderNode) {
        if (this._renderNode.type === "Mesh") {// visible = frustum.intersectsObject(this._renderNode);
        } else if (this._renderNode.type === "Scene") {
          this._renderNode.traverse(function (mesh) {
            if (mesh instanceof fm.Mesh) {// visible = frustum.intersectsObject(mesh);
            }
          });
        }

        this._renderNode.updateMatrixWorld(true);

        this.visible = visible;
      }
    }
    /**
     * 设置模型颜色
     * @param {string|int} color 颜色值 
     * @param {float} opacity 透明度
     */

  }, {
    key: "setColor",
    value: function setColor(color, opacity) {
      var me = this;

      this._renderNode.traverse(function (mesh) {
        if (mesh instanceof fm.Mesh) {
          if (typeof mesh.material.length !== "undefined") {
            for (var i = 0; i < mesh.material.length; i++) {
              me._preColor = mesh.material[i].color;
              mesh.material[i].color = new fm.Color(_FMUtil.default.toRgba(color));
              me._preOpacity = mesh.material[i].opacity;

              if (typeof opacity === "number") {
                mesh.material[i].opacity = opacity;
              }

              mesh.material[i].needsUpdate = true;
            }
          } else {
            me._preColor = mesh.material.color;
            mesh.material.color = new fm.Color(_FMUtil.default.toRgba(color));
            me._preOpacity = mesh.material.opacity;

            if (typeof opacity === "number") {
              mesh.material.opacity = opacity;
            }

            mesh.material.needsUpdate = true;
          }
        }
      });
    }
    /**
     * 重置回模型默认颜色
     */

  }, {
    key: "setColorToDefault",
    value: function setColorToDefault() {
      var me = this;

      this._renderNode.traverse(function (mesh) {
        if (mesh instanceof fm.Mesh) {
          if (typeof mesh.material.length !== "undefined") {
            for (var i = 0; i < mesh.material.length; i++) {
              mesh.material[i].color = me._preColor;
              mesh.material[i].opacity = me._preOpacity;
              mesh.material[i].needsUpdate = true;
            }
          } else {
            mesh.material.color = me._preColor;
            mesh.material.opacity = me._preOpacity;
            mesh.material.needsUpdate = true;
          }
        }
      });
    }
  }, {
    key: "gradientColor",
    value: function gradientColor() {
      var _this2 = this;

      if (!this._renderNode) {
        return;
      }

      this._renderNode.material.userData.color = this._renderNode.material.color;
      var nodeManager = this.findParent(NodeManager);
      var map = nodeManager.map;
      var gcolor = map.modelSelectColor;
      animater = new Animater({
        r: gcolor.r / 2,
        g: gcolor.g / 2,
        b: gcolor.b / 2,
        a: gcolor.a / 2
      }, gcolor, 500, function () {
        map.removeAnimater(animater);
        animater = undefined;
      }, function (color) {
        _this2._renderNode.material.color = new fm.Color(color.r, color.g, color.b);
        _this2._renderNode.material.alpha = color.a;
        _this2._renderNode.material.update = true;
      }).start();
      map.addAnimater(animater);
    }
  }, {
    key: "clearGradient",
    value: function clearGradient() {
      if (!this._renderNode) {
        return;
      }

      var nodeManager = this.findParent(NodeManager);
      var map = nodeManager.map;

      if (animater) {
        map.removeAnimater(animater);
      }

      this._renderNode.material.color = this._renderNode.material.userData.color;
      this._renderNode.material.userData.color = undefined;
    }
    /**
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode && this._renderNode.type === "Mesh") {
        for (var uniform in this._renderNode.material.uniforms) {
          if (uniform.value instanceof fm.Texture) {
            uniform.value.dispose();
          }
        }

        if ((0, _isArray.default)(this._renderNode.material)) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = (0, _getIterator2.default)(this._renderNode.material), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var m = _step2.value;
              m.dispose();
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        } else {
          this._renderNode.material.dispose();
        }

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this._geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }
    }
  }, {
    key: "visible",
    set: function set(bool) {
      if (bool) {
        if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
          this._renderNode && this.parent.scene.add(this._renderNode);
        }
      } else {
        this._renderNode && this.parent.scene.remove(this._renderNode);
        this._renderNode.parent = this.parent.scene;
      }

      this._visible = bool;
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    },
    set: function set(r) {
      if (!this.parent) {
        //已经被dispose()
        return;
      }

      this._renderNode = r;
      this._renderNode.mapNode = this;

      if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
        this._renderNode && this.parent.scene.add(this._renderNode);
      }
    }
  }, {
    key: "bdata",
    get: function get() {
      return this._bdata;
    },
    set: function set(value) {
      this._bdata = value;
    }
  }]);
  return FMExternalModel;
}(_FMNode2.default);

var _default = FMExternalModel;
exports.default = _default;

/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _maxSafeInteger = _interopRequireDefault(__webpack_require__(385));

var _assign = _interopRequireDefault(__webpack_require__(11));

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(13);

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _Animater = _interopRequireDefault(__webpack_require__(58));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

var _Graphics = _interopRequireDefault(__webpack_require__(49));

var flashEvent;
var animater;
/**
 *  FMModel 模型对象，是一种地图内置图层的对象，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */

var FMModel =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMModel, _FMNode);

  function FMModel(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMModel);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMModel).call(this, bdata.eid, _FMNodeType.default.MODEL));
    _this._parseData = null;
    _this._isInitMesh = true;
    _this._visible = true;
    _this._renderNode = null;
    _this._data = null;
    _this._geometry;
    _this._shape;
    _this.currHeight = 2;
    _this._line = null;
    _this._modelColor = null;
    _this._modeAlpha = 1;
    _this._lineColor = null;
    _this._lineAlpha = 1;
    _this._selected = false; // this._storeGeo = new fm.Geometry();

    _this._sgstat = false;
    _this._flashColor = null;
    _this._card = {
      top: null,
      left: null,
      right: null,
      front: null,
      back: null
    };
    _this.precolor = {
      useModel: false,
      useStroke: false,
      mcolor: null,
      strokeColor: null,
      malpha: 1,
      strokeAlpha: 1
    };
    /**
     * FID
     * @property {string} FID 全地图内唯一的模型ID
     */

    _this.FID = bdata.fid;
    /**
     * ID
     * @property {number} ID 当前楼层内唯一的模型ID
     */

    _this.ID = bdata.eid;
    /**
     * ename
     * @property {string} ename 英文名称
     */

    _this.ename = bdata.ename;
    /**
     * name
     * @property {string} name 名称
     */

    _this.name = bdata.name;
    /**
     * typeID
     * @property {string} typeID 类型
     */

    _this.typeID = bdata.type;
    /**
     * minlevel
     * @property {string} minlevel 最小显示级别
     */

    _this.minlevel = bdata.minlevel;
    /**
     * maxlevel
     * @property {string} maxlevel 最大显示级别
     */

    _this.maxlevel = bdata.maxlevel;
    _this.bdata = bdata;
    _this.gdata = gdata;
    _this.preSelect = false;
    return _this;
  }

  (0, _createClass2.default)(FMModel, [{
    key: "initMesh",
    value: function initMesh(material, pos, isNeedSweep) {
      if (!this._geometry) return;
      this._renderNode = new fm.Mesh(this._geometry.geometry, material);
      this._renderNode.mapNode = this;
      this._modelColor = material.color;
      this._modelAlpha = material.opacity;

      this._renderNode.scale.set(1, -1, 1);

      this._renderNode.rotation.set(Math.PI / 2, 0, 0, 'XYZ');

      this._renderNode.position.copy(pos);

      this._renderNode.frustumCulled = false;
      this._renderNode.parent = this.parent.scene;
      this._renderNode.castShadow = true;
      this._renderNode.name = "oneModel";

      if (isNeedSweep) {
        // this._renderNode.name = "isNeedSweep";
        this._renderNode.material.uniforms = {
          "maxPos": {
            value: 10.0
          },
          "minPos": {
            value: 0.0
          },
          "relativeModelMatrix": {
            value: this._renderNode.matrixWorld
          }
        };
      } // this._renderNode.receiveShadow = true;
      // this._renderNode.matrixAutoUpdate = false;
      // let d = this._renderNode.parent.getObjectByName('DirectionalLight');
      // this.parent.parent.modelShadow = d.shadow;


      this.renderNodeInited = true;

      if (this.precolor.useModel) {
        if (this.precolor.mcolor) {
          material.color = this.precolor.mcolor;
        }

        if (typeof this.precolor.malpha === "number") {
          material.opacity = this.precolor.malpha;
        }
      }

      if (this.preSelect) {
        this.selected = true;
        this.preSelect = false;
      }
    }
  }, {
    key: "releaseGpuMemory",
    value: function releaseGpuMemory() {
      if (this.renderNode) {
        // this._storeGeo.copy(this.renderNode.geometry);
        // this._sgstat = true;
        // let g = this.renderNode.geometry;
        // let g1 = this._line.geometry;
        // g.dispose();
        // g1.dispose();
        this._geometry = null;
        this._data = null;
        this.renderNodeInited = false;
        this.renderNode.parent.remove(this.renderNode);
        this.dispose(); // g.vertices = [];
        // g.colors = [];
        // g.faces = [];
        // g.faceVertexUvs = [[]];
        // g.morphTargets = [];
        // g.morphNormals = [];
        // g.skinWeights = [];
        // g.skinIndices = [];
        // g.lineDistances = [];
        // g.elementsNeedUpdate = true;
        // g.verticesNeedUpdate = true;
        // g.uvsNeedUpdate = true;
        // g.normalsNeedUpdate = true;
        // g.colorsNeedUpdate = true;
        // g.lineDistancesNeedUpdate = true;
        // g.groupsNeedUpdate = true;
      }
    }
  }, {
    key: "restoreGpuMemeory",
    value: function restoreGpuMemeory() {// if(!this._sgstat ) return;
      // this.renderNode.geometry.copy( this._storeGeo);
      // let g = this.renderNode.geometry;
      // g.elementsNeedUpdate = true;
      // g.verticesNeedUpdate = true;
      // g.uvsNeedUpdate = true;
      // g.normalsNeedUpdate = true;
      // g.colorsNeedUpdate = true;
      // g.lineDistancesNeedUpdate = true;
      // g.groupsNeedUpdate = true;
    }
  }, {
    key: "getBbox",
    value: function getBbox() {}
  }, {
    key: "getRadius1",
    value: function getRadius1() {
      return this._renderNode.geometry.boundingSphere.radius;
    }
  }, {
    key: "getRadius",
    value: function getRadius() {
      var radius = null;
      var center = {
        x: this._renderNode._x - this.parent.parent.parent.mapcenter.x,
        y: this._renderNode._y - this.parent.parent.parent.mapcenter.y
      };
      var TwoShortestLines = [];
      var vertices = this._renderNode.geometry.vertices;

      for (var i = 0; i < vertices.length; i++) {
        var box = {};
        box.vertex = vertices[i];
        box.distance = Math.abs(Math.sqrt(Math.pow(vertices[i].x - center.x, 2) + Math.pow(vertices[i].y - center.y, 2)));

        if (TwoShortestLines.length < 2) {
          TwoShortestLines.push(box);
        } else if (TwoShortestLines.length === 2) {
          if (TwoShortestLines[0].distance > TwoShortestLines[1].distance) {
            var temp = null;
            temp = TwoShortestLines.shift();
            TwoShortestLines.push(temp);
          }
        } else {
          if (box.distance < TwoShortestLines[1].distance) {
            if (box.distance < TwoShortestLines[0].distance) {
              var _temp = null;
              TwoShortestLines.pop();
              _temp = TwoShortestLines.shift();
              TwoShortestLines.push(box);
              TwoShortestLines.push(_temp);
            } else {
              TwoShortestLines.pop();
              TwoShortestLines.push(box);
            }
          }
        }
      }

      var centerPoint = {
        x: (TwoShortestLines[0].vertex.x + TwoShortestLines[1].vertex.x) / 2,
        y: (TwoShortestLines[0].vertex.y + TwoShortestLines[1].vertex.y) / 2
      };
      var distance = Math.abs(Math.sqrt(Math.pow(centerPoint.x - center.x, 2) + Math.pow(centerPoint.y - center.y, 2)));

      if (TwoShortestLines[0].distance < distance) {
        radius = TwoShortestLines[0].distance;
      } else {
        radius = distance;
      }

      return radius;
    }
  }, {
    key: "setByTheme",
    value: function setByTheme(theme) {
      if (!this._renderNode) {
        return;
      }

      var nodeManager = this.findParent(_NodeManager.default);
      var modelMaterial = nodeManager.materialManager.createNormalMaterial(theme);
      var lineMaterial = nodeManager.materialManager.createLineMaterial(theme);
      this._lineColor = lineMaterial.color;
      this._lineAlpha = lineMaterial.opacity;
      this._modelColor = modelMaterial.color;
      this._modeAlpha = modelMaterial.opacity;

      this._renderNode.material.dispose();

      this._renderNode.material = modelMaterial;
      this._line && (this._line.material = lineMaterial);
      this._geometry = null;

      if (this._card.top) {
        this.removeStoreImage();
      }

      if (theme.image && theme.sizes) {
        var s = theme.sizes.split(",");
        var c = [];

        if (theme.coords) {
          c = theme.coords.split(",");
        } //image: theme.image ? this._map.MapOptions.mapThemeURL + '/' + this._map.MapOptions.defaultThemeName + '/' + theme.image : "",


        this.addStoreImage({
          //image: theme.image ? nodeManager._map.MapOptions.mapThemeURL + theme.logoPath + '/' + theme.image : "",
          image: theme.image ? nodeManager._map.MapOptions.mapThemeURL + '/' + nodeManager._map.MapOptions.defaultThemeName + '/' + theme.image : "",
          angle: theme.angle ? theme.angle : 0,
          size: [(0, _parseFloat2.default)(s[0]), (0, _parseFloat2.default)(s[1])],
          // offset : theme.offset ? theme.offset : [0,0],
          mapCoord: theme.coords ? new fm.Vector2((0, _parseFloat2.default)(c[0]), (0, _parseFloat2.default)(c[1])) : undefined
        });
      }
    }
  }, {
    key: "initLine",
    value: function initLine(material, amount) {
      if (!this._geometry) return; //console.log(this._geometry);

      var points = new fm.Geometry().setFromPoints(this._geometry.shape.getPoints());
      if (points && points.vertices.length > 0) points.vertices.push(points.vertices[0]); ////////////////////////////////////////////////////
      /// 将 Line 变为 LineSegments 方便之后的合并工作 ///
      ////////////////////////////////////////////////////

      var segVerts = [];
      var len = points.vertices.length;

      for (var j = 0; j < len; j++) {
        if (j == 0 || j == len - 1) {
          segVerts.push(points.vertices[j]);
        } else {
          segVerts.push(points.vertices[j], points.vertices[j]);
        }
      }

      points.vertices = segVerts;
      var line = new fm.LineSegments(points, material);
      this._lineColor = material.color;
      this._lineAlpha = material.opacity;
      line.castShadow = false; // line.rotation.set(Math.PI/2,0,0,'XYZ');
      // amout 加了一点距离, 是为了解决, 在2D或3D(垂直视角)时
      // 中间的线段会消失的问题

      line.position.setZ(-amount * .005);
      line.geometry.computeBoundingSphere();

      if (this.precolor.useStroke) {
        material.color = this.precolor.strokeColor;
        material.opacity = this.precolor.strokeAlpha;
      }

      if (this._geometry.shape.holes) {
        for (var i = 0; i < this._geometry.shape.holes.length; i++) {
          createOtherLine(line, this._geometry.shape.holes[i].curves);
        }
      }

      this._line = line;
      this._line.frustumCulled = false;
      this._line.matrixAutoUpdate = false;

      this._renderNode.add(line); // this._renderNode.material.visible = false;


      this._shape = this._geometry.shape;
      this._geometry = null;

      function createOtherLine(line3, curves) {
        for (var i = 0; i < curves.length; i++) {
          var points = [];
          points.push(new fm.Vector3(curves[i].v1.x, curves[i].v1.y, 0));
          points.push(new fm.Vector3(curves[i].v2.x, curves[i].v2.y, 0));
          var geometry2 = new fm.BufferGeometry().setFromPoints(points);
          var line2 = new fm.LineSegments(geometry2, material);
          line3.add(line2);
        }
      }
    }
  }, {
    key: "setHeight",
    value: function setHeight(h) {
      if (this.currHeight) {
        this._renderNode.scale.z *= h / this.currHeight;
        this._renderNode.position.y += h - this.currHeight;
      }

      this.currHeight = h;
    }
  }, {
    key: "checkByFrustum",
    value: function checkByFrustum(frustum) {
      var visible = true;

      if (this._renderNode) {
        this._renderNode.updateMatrixWorld(true);

        visible = frustum.intersectsObject(this._renderNode);
      }

      this.visible = visible;
    }
    /**
     * 设置模型颜色
     * @param {string|int} color 颜色值 
     * @param {float} opacity 透明度
     */

  }, {
    key: "setColor",
    value: function setColor(color, opacity) {
      if (!this._renderNode) {
        this.precolor.mcolor = color ? new fm.Color(color) : color;
        this.precolor.malpha = opacity;
        this.precolor.useModel = true;
        return;
      }

      color && (this._renderNode.material.color = new fm.Color(color));

      if (typeof opacity === "number") {
        this._renderNode.material.opacity = opacity;

        if (opacity !== this._renderNode.material.userData.opacity) {
          this._renderNode.material.userData.opacity = opacity;
        }
      }
    }
    /**
     * 设置闪烁颜色
     * @param {string|int} color 颜色值 
     */

  }, {
    key: "setFlashColor",
    value: function setFlashColor(color) {
      this._flashColor = new fm.Color(color);
    }
    /**
     * 设置线颜色
     * @param {string|int} color 颜色值
     * @param {float} opacity 透明度 
     */

  }, {
    key: "setStrokeColor",
    value: function setStrokeColor(color, opacity) {
      if (!this._renderNode) {
        this.precolor.strokeColor = new fm.Color(color);
        this.precolor.strokeAlpha = opacity;
        this.precolor.useStroke = true;
        return;
      }

      this._line.material.color = new fm.Color(color);
      this._line.material.opacity = opacity;
    }
    /**
     * 重置回模型默认颜色
     */

  }, {
    key: "setColorToDefault",
    value: function setColorToDefault() {
      if (this._renderNode) {
        this._renderNode.material.color = this._modelColor;
        this._renderNode.material.opacity = this._modeAlpha;
      }
    }
    /**
     * 重置回模型线默认颜色
     */

  }, {
    key: "setStrokeColorToDefault",
    value: function setStrokeColorToDefault() {
      this._line.material.color = this._lineColor;
      this._line.material.opacity = this._lineAlpha;
    }
    /**
     * 添加顶面贴图
     * @param {json} param
     * @param {json} param.mapCoord 地图坐标
     * @param {string} param.image 贴图图片路径 
     * @param {array} param.offSet 贴图图片偏移值。[offsetx,offsety]
     * @param {array} param.size 贴图图片尺寸。[width,height]
     * @param {number} param.angle 旋转角度
     */

  }, {
    key: "addStoreImage",
    value: function addStoreImage(param) {
      var nodeManager = this.findParent(_NodeManager.default);
      var scene = this.parent.parent.parent;
      var center = scene.mapcenter;
      var coord = param.mapCoord ? param.mapCoord : this.mapCoord;

      if (!this._renderNode || !param.image) {
        return;
      }

      param = (0, _assign.default)({
        size: [5, 5],
        height: 0.1,
        angle: 0,
        offset: [0, 0]
      }, param);

      if (this._card.top) {
        this.removeStoreImage();
      }

      var geo = new fm.PlaneBufferGeometry(1, 1, 1, 1);
      var material = new fm.MeshLambertMaterial({
        transparent: true,
        depthWrite: false // color : new fm.Color("#ff0000")

      });
      nodeManager.materialManager.loadTexture(param.image, function (t) {
        t.anisotropy = 4;
        t.minFilter = fm.LinearFilter;
        material.map = t;
        material.needsUpdate = true;
      });
      var topImage = new fm.Mesh(geo, material);
      topImage.scale.set(param.size[0], param.size[1], -1);
      topImage.position.set(param.offset[0] + coord.x - center.x, param.offset[1] + coord.y - center.y, -param.height);
      topImage.rotation.z = -param.angle * fm.Math.DEG2RAD;
      topImage.renderOrder = 10;

      this._renderNode.add(topImage);

      this._card.top = topImage; // this._renderNode.material._color = this._renderNode.material.color.clone();
      // this._renderNode.material.color = new fm.Color(0xffffff);
      // this._renderNode.material.transparent = false;
      // this._renderNode.material.needsUpdate = true;
    }
  }, {
    key: "getUvTransForm",
    value: function getUvTransForm() {
      //保留待定
      var scene = this.parent.parent.parent;
      var center = scene.center;
      var sceneBbox = scene.bbox;
      var sw = sceneBbox.max.x - sceneBbox.min.x;
      var sh = sceneBbox.max.y - sceneBbox.min.y;
      var modelBbox = this.renderNode;
    }
    /**
     * 移除顶面贴图
     */

  }, {
    key: "removeStoreImage",
    value: function removeStoreImage() {
      if (!this._card.top) {
        return;
      }

      this._renderNode.remove(this._card.top);

      this._card.top.geometry.dispose();

      this._card.top.material.map && this._card.top.material.map.dispose();

      this._card.top.material.dispose();

      this._card.top = null;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode) {
        if (this._line) {
          this._renderNode.remove(this._line);

          this._line.material.dispose();

          this._line.geometry.dispose();

          this._line = undefined;
        }

        this.removeStoreImage();

        this._renderNode.material.dispose();

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this._geometry = undefined;
        this._data = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }
    }
    /**
     * 闪烁
     */

  }, {
    key: "flash",
    value: function flash() {
      var _this2 = this;

      if (!this._renderNode) {
        return;
      }

      this._renderNode.material.userData.color = this._renderNode.material.color;
      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;
      var selectColor = null;

      if (this._flashColor === null) {
        selectColor = map.modelSelectColor;
      } else {
        selectColor = this._flashColor;
      }

      var baseColor = {
        r: selectColor.r / 2,
        g: selectColor.g / 2,
        b: selectColor.b / 2,
        a: selectColor.a / 2
      };

      flashEvent = function flashEvent(event) {
        var rate = (Math.sin(new Date().getTime() / 180) + 1) / 2;
        _this2._renderNode.material.color = new fm.Color(baseColor.r * (1 + rate), baseColor.g * (1 + rate), baseColor.b * (1 + rate)); // this._renderNode.material.alpbaseColor.g * (1 + rate)
      };

      map.on("frameLoop", flashEvent);
    }
    /**
     * 取消闪烁
     */

  }, {
    key: "stopFlash",
    value: function stopFlash() {
      if (!this._renderNode) {
        return;
      }

      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;
      map.off("frameLoop", flashEvent);
      this._renderNode.material.color = this._renderNode.material.userData.color;
    }
  }, {
    key: "gradientColor",
    value: function gradientColor() {
      var _this3 = this;

      if (!this._renderNode) {
        return;
      }

      this._renderNode.material.userData.color = this._renderNode.material.color;
      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;
      var gcolor = map.modelSelectColor;
      animater = new _Animater.default({
        r: gcolor.r / 2,
        g: gcolor.g / 2,
        b: gcolor.b / 2,
        a: gcolor.a / 2
      }, gcolor, 500, function () {
        map.removeAnimater(animater);
        animater = undefined;
      }, function (color) {
        _this3._renderNode.material.color = new fm.Color(color.r, color.g, color.b);
        _this3._renderNode.material.alpha = color.a;
        _this3._renderNode.material.update = true;
      }).start();
      map.addAnimater(animater);
    }
  }, {
    key: "clearGradient",
    value: function clearGradient() {
      if (!this._renderNode) {
        return;
      }

      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;

      if (animater) {
        map.removeAnimater(animater);
      }

      this._renderNode.material.color = this._renderNode.material.userData.color;
      this._renderNode.material.userData.color = undefined;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(p) {
      var points = this._shape.getPoints();

      var inPolygon = _Graphics.default.isInPolygon(p, points);

      if (inPolygon) {
        return 0;
      }

      var minDis = _maxSafeInteger.default;

      for (var i = 0; i < points.length - 1; i++) {
        var ldis = _Graphics.default.pointDistanceToLine(p, points[i], points[i + 1], new fm.Vector2());

        if (ldis < minDis) minDis = ldis;
      }

      return minDis;
    }
    /**
     * 选中高亮
     * @property {bool} selected 选中高亮。【true】:高亮 【false】: 取消高亮
     */

  }, {
    key: "selected",
    set: function set(bool) {
      if (bool !== this._selected) {
        this._selected = bool;

        if (!this.renderNodeInited) {
          this.preSelect = true;
          return;
        }

        if (bool) {
          this.gradientColor();
        } else {
          this.clearGradient();
        }
      }
    },
    get: function get() {
      return this._selected;
    }
  }, {
    key: "visible",
    set: function set(bool) {
      if (bool) {
        if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
          // this.restoreGpuMemeory();
          this._renderNode && this.parent.scene.add(this._renderNode);
        }
      } else {
        if (this._renderNode) {
          // this.releaseGpuMemory();
          this.parent.scene.remove(this._renderNode);
          this._renderNode.parent = this.parent.scene;
        }
      }

      this._visible = bool;
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    },
    set: function set(r) {
      this._renderNode = r;
    }
    /**
     * 模型中心点坐标
     * @property {json} mapCoord 模型中心点坐标
     * @readonly
     */

  }, {
    key: "mapCoord",
    get: function get() {
      //doublechang
      //console.log(610,this.parent.parent.parent.parent.map.dataManager.file_ver);
      var file_ver = this.parent.parent.parent.parent.map.dataManager.file_ver;
      var label = this.parent.parent.layers["label"][0].labels["" + this._eid];

      if (label) {
        if (label.renderNodeInited) {
          return {
            x: label.x,
            y: label.y,
            z: this.height
          };
        } else {
          var point = null;

          if (file_ver === 1) {
            point = _DataManager.default.convertGeo2Points(label.gdata.geo);
          } else {
            point = _DataManager.default.convertArrayPoints(label.gdata.idxs, label.gdata.pts);
          } //console.log(630,point);


          return {
            x: point.vertices[0].x,
            y: point.vertices[0].y,
            z: this.height
          };
        }
      } else {
        return {
          x: null,
          y: null,
          z: null
        };
      }
    }
  }, {
    key: "label",
    get: function get() {
      return this.parent.parent.layers["label"][0].labels["" + this._eid];
    }
  }, {
    key: "height",
    set: function set(height) {
      this._height = height;
    },
    get: function get() {
      if (!this.renderNodeInited) {
        return this.gdata.height;
      }

      return this._height;
    }
  }, {
    key: "line",
    get: function get() {
      return this._line;
    }
  }]);
  return FMModel;
}(_FMNode2.default);

var _default = FMModel;
exports.default = _default;

/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMLabel = _interopRequireDefault(__webpack_require__(214));

//系统label

/**
 *  FMLabelLayer 文字标注图层，是一种地图内置图层，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 *    
 */
var FMLabelLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMLabelLayer, _FMNode);

  function FMLabelLayer(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMLabelLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMLabelLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "label";
    _this._scene.name = "label";
    _this.alias = "label";
    _this._labels = {};

    _this.initNode(gdata, bdata);
    /**
     *  @property {bool} needAvoid 是否需要避让【true】:需要避让;【false】：不需要避让。默认为true
     */


    _this.needAvoid = true;
    _this._visible = true;
    return _this;
  }

  (0, _createClass2.default)(FMLabelLayer, [{
    key: "traverse",
    value: function traverse(back) {
      for (var n in this._labels) {
        back && back(this._labels[n]);
      }
    }
  }, {
    key: "getVideoMemoryAmount",
    value: function getVideoMemoryAmount() {
      var videoMemoryAmount = null;
      this.traverse(function (model) {
        if (model._renderNode) {
          videoMemoryAmount += model._renderNode.geometry.attributes.position.array.byteLength;
          videoMemoryAmount += model._renderNode.geometry.attributes.uv.array.byteLength;

          if (model._renderNode.material.map) {
            var memory = null;
            memory = model._renderNode.material.map.image.width * model._renderNode.material.map.image.height * 32 / 8;
            videoMemoryAmount += memory;
          }
        }
      });
      return videoMemoryAmount;
    }
  }, {
    key: "initNode",
    value: function initNode(gdata, bdata) {
      for (var i = 0; i < gdata.length; i++) {
        this.createNode(gdata[i], bdata[i]);
      }
    }
  }, {
    key: "createNode",
    value: function createNode(geo, biz) {
      var node = new _FMLabel.default(geo, biz);
      node.parent = this;
      this._labels["" + node.eid] = node;
    }
  }, {
    key: "addNodes",
    value: function addNodes(node) {
      node.parent = this;
      node.renderNode && this._scene.add(node.renderNode);
      this._labels["" + node.eid] = node;
    }
  }, {
    key: "allShow",
    value: function allShow() {
      for (var i = 0; i < this._scene.children.length; i++) {
        this._scene.children[i].visible = true;
      }
    }
  }, {
    key: "getNodeById",
    value: function getNodeById(id) {
      return this._labels["" + id];
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0; // let i =0;

      for (var n in this._labels) {
        // i++;
        if (this._labels[n].visible) {
          this._labels[n].renderNode && this._scene.add(this._labels[n].renderNode);
        }
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var n in this._labels) {
        this._labels[n].dispose();

        this._scene.remove(this._labels[n].renderNode);

        this._labels[n].parent = undefined;
        this._labels[n] = undefined;
      }

      this._scene = undefined;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.rushRenderNode();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }, {
    key: "labels",
    get: function get() {
      return this._labels;
    }
  }]);
  return FMLabelLayer;
}(_FMNode2.default);

var _default = FMLabelLayer;
exports.default = _default;

/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(68);

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _Sprite = _interopRequireDefault(__webpack_require__(111));

var _FMLanguageType = _interopRequireDefault(__webpack_require__(80));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

/**
 *  FMLabel 文本标注对象，是一种地图内置图层的对象，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMLabel =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMLabel, _FMNode);

  function FMLabel(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMLabel);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMLabel).call(this, bdata.eid, _FMNodeType.default.LABEL));
    _this._isInitSprite = true;
    _this._visible = true;
    _this._renderNode = null;
    _this._geometry = undefined;
    _this._size = 20;
    _this._theme = undefined;
    _this.bdata = bdata;
    /**
     * ename
     * @property {string} ename 英文名称
     */

    _this.ename = bdata.ename;
    _this._text = bdata.name;
    _this.gdata = gdata;
    /**
    * FID
    * @property {string} FID 全地图内唯一的模型ID
    */

    _this.FID = bdata.fid;
    /**
     * ID
     * @property {number} ID 当前楼层内唯一的模型ID
     */

    _this.ID = bdata.eid;
    /**
     * name
     * @property {string} name 名称
     */

    _this.name = bdata.name;
    /**
    * typeID
    * @property {string} typeID 类型
    */

    _this.typeID = bdata.type;
    /**
    * minlevel
    * @property {string} minlevel 最小显示级别
    */

    _this.minlevel = bdata.minlevel;
    /**
     * maxlevel
     * @property {string} maxlevel 最大显示级别
     */

    _this.maxlevel = bdata.maxlevel;
    return _this;
  }

  (0, _createClass2.default)(FMLabel, [{
    key: "checkByFrustum",
    value: function checkByFrustum(frustum) {
      var visible = true;

      if (this._renderNode) {
        this._renderNode.updateMatrixWorld(true);

        visible = frustum.intersectsSprite(this._renderNode);
      }

      this.visible = visible;
    }
  }, {
    key: "initSprite",
    value: function initSprite(material, pos) {
      if (!material) {
        return;
      }

      this._renderNode = new _Sprite.default(material);

      this._renderNode.position.copy(pos);

      this._renderNode.mapNode = this;
      this._renderNode.frustumCulled = true;
      this.renderNodeInited = true;
      this._renderNode.parent = this.parent.scene;
      this._renderNode.visible = this.show;
      this._renderNode.name = "spirit"; // this._renderNode.matrixAutoUpdate = false;
      // this.setSize();
    }
    /**
     * 改变label文字
     * @param {string} text 文字
     */

  }, {
    key: "setText",
    value: function setText(text) {
      if (!this._renderNode) {
        return;
      }

      if (!this._theme) {
        return;
      }

      var nodeManager = this.findParent(_NodeManager.default);
      this._renderNode.material.map && this._renderNode.material.map.dispose();
      this._renderNode.material && this._renderNode.material.dispose();
      this._renderNode.material = nodeManager.materialManager.createLabelMaterial(text, this._theme);
      this._text = text;
      this.setSize();
    }
  }, {
    key: "releaseGpuMemory",
    value: function releaseGpuMemory() {
      if (this.renderNode) {
        // this.renderNode.material.map && this.renderNode.material.map.dispose();
        // this.renderNode.material.dispose();
        this.renderNodeInited = false;
        this._isInitSprite = false;
        this.tryInit = false;
        this.renderNode.parent.remove(this.renderNode);
        this.dispose();
      }
    }
  }, {
    key: "setByLanguage",
    value: function setByLanguage(type) {
      var text;

      if (type === _FMLanguageType.default.EN) {
        text = this.bdata.ename;
      } else {
        text = this.bdata.name;
      }

      if (!text) {
        this.visible = false;
        this.dispose();
        return;
      }

      if (this._renderNode) {
        this.setText(text);
      } else {
        if (this.tryInit && !this.renderNodeInited) {
          var nodeManager = this.findParent(_NodeManager.default);
          var theme = this.parent.parent.parent.theme.getLabelTheme(this.bdata);
          this._theme = theme;
          var material = nodeManager.materialManager.createLabelMaterial(text, theme);
          this.initSprite(material, this.pos);
          this.setSize();
        }
      }

      this.visible = true;
    }
  }, {
    key: "setByTheme",
    value: function setByTheme(theme) {
      if (!this._text) return;
      var nodeManager = this.findParent(_NodeManager.default);
      this._theme = theme;
      this._size = theme.fontsize * 1.4;
      this._renderNode.material.map && this._renderNode.material.map.dispose();
      this._renderNode.material && this._renderNode.material.dispose();
      this._renderNode && (this._renderNode.material = nodeManager.materialManager.createLabelMaterial(this._text, this._theme));
      this.setSize();
    }
  }, {
    key: "setSize",
    value: function setSize() {
      var nodeManager = this.findParent(_NodeManager.default);
      nodeManager.map.renderer.setLabelSize(this._renderNode, this._size);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode) {
        this._renderNode.material.dispose();

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this.geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
        this.renderNodeInited = false;
      }
    }
    /**
     * label点坐标
     * @property {json} mapCoord label点坐标
     * @readonly
     */

  }, {
    key: "mapCoord",
    get: function get() {
      var file_ver = this.parent.parent.parent.parent.map.dataManager.file_ver;
      var label = this;

      if (label) {
        if (label.renderNodeInited) {
          return {
            x: label.x,
            y: label.y,
            z: this.height
          };
        } else {
          var point = null;

          if (file_ver === 1) {
            point = _DataManager.default.convertGeo2Points(label.gdata.geo);
          } else {
            point = _DataManager.default.convertArrayPoints(label.gdata.idxs, label.gdata.pts);
          }

          return {
            x: point.vertices[0].x,
            y: point.vertices[0].y,
            z: this.height
          };
        }
      } else {
        return {
          x: null,
          y: null,
          z: null
        };
      }
    }
  }, {
    key: "model",
    get: function get() {
      return this.parent.parent.layers["model"][0].models["" + this._eid];
    }
  }, {
    key: "visible",
    set: function set(bool) {
      if (this._renderNode) {
        if (bool) {
          if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
            this._renderNode && this.parent.scene.add(this._renderNode);
          }
        } else {
          // this.releaseGpuMemory()
          this.parent.scene.remove(this._renderNode);
          this._renderNode.parent = this.parent.scene;
        }
      }

      this._visible = bool;
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    },
    set: function set(r) {
      this._renderNode = r;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    },
    set: function set(v) {
      this._size = v;
    }
  }, {
    key: "theme",
    set: function set(t) {
      this._theme = t;
    }
  }]);
  return FMLabel;
}(_FMNode2.default);

var _default = FMLabel;
exports.default = _default;

/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMPoi = _interopRequireDefault(__webpack_require__(216));

/**
 *  FMFacilityLayer 公共设施图层，是一种地图内置图层，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMFacilityLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMFacilityLayer, _FMNode);

  function FMFacilityLayer(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMFacilityLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMFacilityLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "facility";
    _this.alias = "facility";
    _this._facility = {};
    _this.needAvoid = true;

    _this.initNode(gdata, bdata);

    _this._visible = true;
    return _this;
  }

  (0, _createClass2.default)(FMFacilityLayer, [{
    key: "initNode",
    value: function initNode(gdata, bdata) {
      if (!gdata) return;

      for (var i = 0; i < gdata.length; i++) {
        this.createNode(gdata[i], bdata[i]);
      }
    }
  }, {
    key: "createNode",
    value: function createNode(geo, biz) {
      var node = new _FMPoi.default(geo, biz);
      node.parent = this;
      this._facility["" + node.eid] = node;
    }
  }, {
    key: "addNodes",
    value: function addNodes(node) {
      node.parent = this;
      node.renderNode && this._scene.add(node.renderNode);
      this._facility["" + node.eid] = node;
    }
  }, {
    key: "traverse",
    value: function traverse(back) {
      for (var n in this._facility) {
        back && back(this._facility[n]);
      }
    }
  }, {
    key: "getNodeById",
    value: function getNodeById(id) {
      return this._facility["" + id];
    }
  }, {
    key: "getVideoMemoryAmount",
    value: function getVideoMemoryAmount() {
      var videoMemoryAmount = null;
      this.traverse(function (model) {
        if (model._renderNode) {
          videoMemoryAmount += model._renderNode.geometry.attributes.position.array.byteLength;
          videoMemoryAmount += model._renderNode.geometry.attributes.uv.array.byteLength;

          if (model._renderNode.material.map) {
            var memory = null;
            memory = model._renderNode.material.map.image.width * model._renderNode.material.map.image.height * 32 / 8;
            videoMemoryAmount += memory;
          }
        }
      });
      return videoMemoryAmount;
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;

      for (var n in this._facility) {
        if (this._facility[n].visible) {
          this._facility[n].renderNode && this._scene.add(this._facility[n].renderNode);
        }
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var n in this._facility) {
        this._facility[n].dispose();

        this._scene.remove(this._facility[n].renderNode);

        this._facility[n].parent = undefined;
        this._facility[n] = undefined;
      }

      this._scene = undefined;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }]);
  return FMFacilityLayer;
}(_FMNode2.default);

var _default = FMFacilityLayer;
exports.default = _default;

/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

var _assign = _interopRequireDefault(__webpack_require__(11));

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _Sprite = _interopRequireDefault(__webpack_require__(111));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

/**
 *  FMFacility 公共设施对象，是一种地图内置图层的对象，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMFacility =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMFacility, _FMNode);

  function FMFacility(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMFacility);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMFacility).call(this, bdata.eid, _FMNodeType.default.FACILITY));
    _this._isInitSprite = true;
    _this._visible = true;
    _this._renderNode = null;
    _this._geometry = undefined;
    _this._size = 20;
    _this.bdata = bdata;
    _this.gdata = gdata;
    /**
     * FID
     * @property {string} FID 全地图内唯一的模型ID
     */

    _this.FID = bdata.fid;
    /**
     * ID
     * @property {number} ID 当前楼层内唯一的模型ID
     */

    _this.ID = bdata.eid;
    /**
     * ename
     * @property {string} ename 英文名称
     */

    _this.ename = bdata.ename;
    /**
     * name
     * @property {string} name 名称
     */

    _this.name = bdata.name;
    /**
    * typeID
    * @property {string} typeID 类型
    */

    _this.typeID = bdata.type;
    /**
    * minlevel
    * @property {string} minlevel 最小显示级别
    */

    _this.minlevel = bdata.minlevel;
    /**
     * maxlevel
     * @property {string} maxlevel 最大显示级别
     */

    _this.maxlevel = bdata.maxlevel;
    return _this;
  }

  (0, _createClass2.default)(FMFacility, [{
    key: "checkByFrustum",
    value: function checkByFrustum(frustum) {
      var visible = true;

      if (this._renderNode) {
        this._renderNode.updateMatrixWorld(true);

        visible = frustum.intersectsObject(this._renderNode);
      }

      this.visible = visible;
    }
    /**
    * 图标标注跳动动画。
    * @param {json} params 
    *      @param {number} params.height 图标跳动的高度。
    *      @param {number} params.times 图标跳动次数。不设置该参数或设置为0时, 一直跳动。 
    *      @param {number} params.duration 单次跳动动画的持续时长（秒）。
    *      @param {number} params.delay 一次跳动完成到下次跳动开始的等待时长（秒）。
    */

  }, {
    key: "jump",
    value: function jump(params) {
      var _this2 = this;

      if (!this._renderNode || this._isJumping) {
        return;
      }

      this._isJumping = true;
      var option = (0, _assign.default)({
        'height': 8,
        'times': 0,
        'duration': 1,
        'delay': 0
      }, params);

      if (typeof option.height != 'number' || typeof option.times != 'number' || typeof option.duration != 'number' || typeof option.delay != 'number') {
        return;
      }

      option.duration *= 1000;
      option.delay *= 1000;
      option.all = option.duration + option.delay;
      option.halfDuration = option.duration / 2;
      var heightOffset = option.height - this._height;
      this._origonY = this._renderNode.position.y;
      var time = new Date().getTime();
      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;

      this.jumpEvent = function (event) {
        if (!_this2._renderNode) {
          map.off("frameLoop", _this2.jumpEvent);
          return;
        }

        var deltaTime = new Date().getTime() - time;

        if (option.times != 0 && deltaTime / option.all > option.times) {
          _this2.stopJump();

          return;
        }

        deltaTime = deltaTime % option.all;

        if (deltaTime > option.duration) {
          if (_this2._renderNode.position.y != _this2._origonY) {
            _this2._renderNode.position.y = _this2._origonY;
          }
        } else {
          var ratio = deltaTime / option.halfDuration - 1;
          ratio = 1.0 - ratio * ratio;
          _this2._renderNode.position.y = _this2._origonY + heightOffset * ratio;
        }
      };

      map.on("frameLoop", this.jumpEvent);
    }
    /**
     * 停止图标标注jump动画。
     */

  }, {
    key: "stopJump",
    value: function stopJump() {
      if (!this._renderNode || !this.jumpEvent) {
        return;
      }

      this._renderNode.position.y = this._origonY;
      this._isJumping = false;
      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;
      map.off("frameLoop", this.jumpEvent);
    }
    /**
    * 图标标注跳动动画。
    * @param {json} params 
    *      @param {number} params.size 图标变化限制。
    *      @param {number} params.times 图标变化次数。 
    *      @param {number} params.duration 单次变化动画的持续时长（秒）。
    *      @param {number} params.delay 一次跳动完成到下次跳动开始的等待时长（秒）。
    */

  }, {
    key: "boost",
    value: function boost(params) {
      var _this3 = this;

      if (!this._renderNode || this._isBoosting) {
        return;
      }

      this._isBoosting = true;
      var option = (0, _assign.default)({
        'size': 8,
        'ratio': 0,
        'duration': 1,
        'delay': 0
      }, params);

      if (typeof option.size != 'number' || typeof option.ratio != 'number' || typeof option.duration != 'number' || typeof option.delay != 'number') {
        return;
      }

      option.duration *= 1000;
      option.delay *= 1000;
      option.all = option.duration + option.delay;
      option.halfDuration = option.duration / 2;
      var heightOffset = option.size - this._size;
      this._origonSize = this._size; // let time = new Date().getTime();

      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;

      this.boostEvent = function (event) {
        if (!_this3._renderNode) {
          map.off("frameLoop", _this3.boostEvent);
          return;
        }

        var time = new Date().getTime();
        var ratio = Math.sin(time * option.ratio) / 2 + 0.5;
        _this3._size = _this3._origonSize + ratio * heightOffset;

        _this3.setSize();
      };

      map.on("frameLoop", this.boostEvent);
    }
    /**
     * 停止图标标注jump动画。
     */

  }, {
    key: "stopBoost",
    value: function stopBoost() {
      if (!this._renderNode || !this.boostEvent) {
        return;
      }

      this._size = this._origonSize;
      this._isBoosting = false;
      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;
      map.off("frameLoop", this.boostEvent);
      this.setSize();
    }
  }, {
    key: "initSprite",
    value: function initSprite(material, pos) {
      this._renderNode = new _Sprite.default(material);
      this._renderNode.mapNode = this;
      this._renderNode.frustumCulled = false;

      this._renderNode.position.copy(pos);

      this._renderNode.parent = this.parent.scene;
      this.renderNodeInited = true;
      this._renderNode.visible = this.show;
      this._renderNode.name = "spirit"; // this._renderNode.matrixAutoUpdate = false;
      // this.setSize();
    }
  }, {
    key: "releaseGpuMemory",
    value: function releaseGpuMemory() {
      if (this.renderNode) {
        // this.renderNode.material.map && this.renderNode.material.map.dispose();
        // this.renderNode.material.dispose();
        this.renderNodeInited = false;
        this.renderNode.parent.remove(this.renderNode);
        this.dispose();
      }
    }
  }, {
    key: "setByTheme",
    value: function setByTheme(theme) {
      if (!this._renderNode) {
        return;
      }

      var nodeManager = this.findParent(_NodeManager.default);
      var material = nodeManager.materialManager.createPoiMaterial(theme);

      this._renderNode.material.dispose();

      this._renderNode.material = material;
    }
  }, {
    key: "setSize",
    value: function setSize() {
      var nodeManager = this.findParent(_NodeManager.default);
      nodeManager.map.renderer.setFacilitySize(this._renderNode, this._size);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode) {
        this._renderNode.material.dispose();

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this.geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }
    }
  }, {
    key: "visible",
    set: function set(bool) {
      if (bool) {
        if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
          this._renderNode && this.parent.scene.add(this._renderNode);
          this.setSize();
        }
      } else {
        // this.releaseGpuMemory();
        this._renderNode && this.parent.scene.remove(this._renderNode);
        this._renderNode && (this._renderNode.parent = this.parent.scene);
      }

      this._visible = bool;
      this._visible = bool;
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    },
    set: function set(r) {
      this._renderNode = r;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    },
    set: function set(v) {
      this._size = (0, _parseFloat2.default)(v);
    }
    /**
     * 点坐标
     * @property {json} mapCoord 点坐标
     * @readonly
     */

  }, {
    key: "mapCoord",
    get: function get() {
      var file_ver = this.parent.parent.parent.parent.map.dataManager.file_ver;
      var poi = this;

      if (poi) {
        if (poi.renderNodeInited) {
          return {
            x: poi.x,
            y: poi.y,
            z: this.height
          };
        } else {
          var point = null;

          if (file_ver === 1) {
            point = _DataManager.default.convertGeo2Points(poi.gdata.geo);
          } else {
            point = _DataManager.default.convertArrayPoints(poi.gdata.idxs, poi.gdata.pts);
          }

          return {
            x: point.vertices[0].x,
            y: point.vertices[0].y,
            z: this.height
          };
        }
      } else {
        return {
          x: null,
          y: null,
          z: null
        };
      }
    }
  }]);
  return FMFacility;
}(_FMNode2.default);

var FMPoi = FMFacility;
var _default = FMPoi;
exports.default = _default;

/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

/**
 *  FMImageMarkerLayer 图片标注层对象，可添加任意个图片标注,并继承FMNode 属性
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 */
var FMImageMarkerLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMImageMarkerLayer, _FMNode);

  function FMImageMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMImageMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMImageMarkerLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "imageMarker";
    _this.alias = "imageMarker";
    _this.imageMarkers = [];
    _this._visible = true;
    _this.needAvoid = true;
    _this.prepareInitObjects = [];
    return _this;
  }
  /**
   * 新增图片标注
   * @param {marker} marker 一个imageMarker
   */


  (0, _createClass2.default)(FMImageMarkerLayer, [{
    key: "addMarker",
    value: function addMarker(marker) {
      marker.parent = this;

      if (!marker.isInitSprite) {
        if (!marker.initSprite()) {
          this.prepareInitObjects.push(marker);
        } else {
          this.pushImageMarker(marker);
        }
      } else {
        this.pushImageMarker(marker);
      }
    }
  }, {
    key: "initPrepare",
    value: function initPrepare() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this.prepareInitObjects), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var marker = _step.value;

          if (marker.initSprite()) {
            var index = this.prepareInitObjects.indexOf(marker);

            if (index > -1) {
              this.prepareInitObjects.splice(index, 1);
            }

            this.pushImageMarker(marker);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "pushImageMarker",
    value: function pushImageMarker(marker) {
      this.imageMarkers.push(marker);
      marker.renderNode && this._scene.add(marker.renderNode);
    }
    /**
     * 删除所有marker
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator2.default)(this.imageMarkers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var imageMarker = _step2.value;
          this.removeNode(imageMarker, true);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      this.imageMarkers.length = 0;
    }
  }, {
    key: "untiedMarker",
    value: function untiedMarker(marker) {
      marker.parent = undefined;

      this._scene.remove(marker.renderNode);
    }
  }, {
    key: "removeNode",
    value: function removeNode(marker, noClearMarkers) {
      marker.parent = undefined;

      this._scene.remove(marker.renderNode);

      if (marker.isAlwaysShow) {
        this.parent.removeAlwaysShowMarker(marker.renderNode);
        marker.show = false;
      }

      marker.dispose();

      if (noClearMarkers) {
        return;
      }

      var index = this.imageMarkers.indexOf(marker);

      if (index > -1) {
        this.imageMarkers.splice(index, 1);
      }
    }
    /**
     * 删除imageMarker
     * @param {ImagerMarker} marker ImageMarker对象
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      this.removeNode(marker);
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator2.default)(this.imageMarkers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var imageMarker = _step3.value;

          if (imageMarker.visible) {
            imageMarker.renderNode && this._scene.add(imageMarker.renderNode);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }
  }, {
    key: "traverse",
    value: function traverse(back) {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(this.imageMarkers), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var marker = _step4.value;
          back && back(marker);
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator2.default)(this.imageMarkers), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var imageMarker = _step5.value;
          imageMarker.dispose();

          this._scene.remove(imageMarker.renderNode);

          imageMarker.parent = undefined;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this.imageMarkers.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
    /** 
     * 获得当前图层内部markers数组
     * @property {Array<fengmap.FMImageMarker>} markers FMImageMarker对象数组
     */

  }, {
    key: "markers",
    get: function get() {
      var markers = [];
      markers.push.apply(markers, (0, _toConsumableArray2.default)(this.imageMarkers));
      return markers;
    }
  }]);
  return FMImageMarkerLayer;
}(_FMNode2.default);

var _default = FMImageMarkerLayer;
exports.default = _default;

/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

/**
 *   FMPolygonMarkerLayer 多边形标注层图层，自定义图层，每个标注图层可添加任意个多边形标注。
 *   @class
 *   @memberof fengmap
 *   @extends fengmap.FMNode
 */
var FMPolygonMarkerLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMPolygonMarkerLayer, _FMNode);

  /**
   * @constructor
   */
  function FMPolygonMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMPolygonMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMPolygonMarkerLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "polygonMarker";
    _this.alias = "polygonMarker";
    _this.polygonMarkers = [];
    _this._visible = true;
    _this.prepareInitObjects = [];
    return _this;
  }
  /**
   * 新增多边形标注对象
   * @param {fengmap.FMPolygonMarker} marker 一个多边形标注对象
   */


  (0, _createClass2.default)(FMPolygonMarkerLayer, [{
    key: "addMarker",
    value: function addMarker(marker) {
      marker.parent = this;

      if (!marker.isInitPolygon) {
        if (!marker.initPolygon()) {
          this.prepareInitObjects.push(marker);
        } else {
          this.pushPolygonMarker(marker);
        }
      } else {
        this.pushPolygonMarker(marker);
      }
    }
  }, {
    key: "traverse",
    value: function traverse(back) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this.polygonMarkers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var marker = _step.value;
          back && back(marker);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "initPrepare",
    value: function initPrepare() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator2.default)(this.prepareInitObjects), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var marker = _step2.value;

          if (marker.initPolygon()) {
            var index = this.prepareInitObjects.indexOf(marker);

            if (index > -1) {
              this.prepareInitObjects.splice(index, 1);
            }

            this.pushPolygonMarker(marker);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /***
     * 添加marker
     * @param marker
     */

  }, {
    key: "pushPolygonMarker",
    value: function pushPolygonMarker(marker) {
      this.polygonMarkers.push(marker);
      marker.renderNode && this._scene.add(marker.renderNode);
    }
    /**
     * 删除所有marker
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator2.default)(this.polygonMarkers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var polygonMarker = _step3.value;
          polygonMarker.parent = undefined;

          this._scene.remove(polygonMarker.renderNode);

          polygonMarker.dispose();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.polygonMarkers.length = 0;
    }
    /***
     * 删除marker
     * @param marker
     * @deprecated
     */

  }, {
    key: "removeNode",
    value: function removeNode(marker) {
      this.removeMarker(marker);
    }
    /**
     * 删除单个多边形标注
     * @param {fengmap.FMPolygonMarker} marker 多边形标注
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      marker.parent = undefined;

      this._scene.remove(marker.renderNode);

      marker.dispose();
      var index = this.polygonMarkers.indexOf(marker);

      if (index > -1) {
        this.polygonMarkers.splice(index, 1);
      }
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(this.polygonMarkers), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var polygonMarker = _step4.value;

          if (polygonMarker.visible) {
            polygonMarker.renderNode && this._scene.add(polygonMarker.renderNode);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
    /**
     * 获得该图层内部markers数组
     * @property {Array<fengmap.FMPolygonMarker>} markers 多边形标注数组
     */

  }, {
    key: "dispose",

    /**
     * 释放
     */
    value: function dispose() {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator2.default)(this.polygonMarkers), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var polygonMarker = _step5.value;
          polygonMarker.dispose();

          this._scene.remove(polygonMarker.renderNode);

          polygonMarker.parent = undefined;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this.polygonMarkers.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "markers",
    get: function get() {
      //cwj 新增
      return this.polygonMarkers;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }]);
  return FMPolygonMarkerLayer;
}(_FMNode2.default);

var _default = FMPolygonMarkerLayer;
exports.default = _default;

/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMMarkerLayer2 = _interopRequireDefault(__webpack_require__(220));

/**
 * @class FMGradientPolygonMarkerLayer 多边形渐变标注层图层，自定义图层，每层可以包含多个多边形渐变标注图层，每个标注图层可添加任意个多边形渐变标注。
 * @memberof fengmap
 * @extends fengmap.FMMarkerLayer
 * @hideconstructor
 */
var FMGradientPolygonMarkerLayer =
/*#__PURE__*/
function (_FMMarkerLayer) {
  (0, _inherits2.default)(FMGradientPolygonMarkerLayer, _FMMarkerLayer);

  /***
   * @constructor
   */
  function FMGradientPolygonMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMGradientPolygonMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMGradientPolygonMarkerLayer).call(this));
    _this._scene.userData.type = "gradientPolygonMarker";
    _this.alias = "gradientPolygonMarker";
    return _this;
  }

  return FMGradientPolygonMarkerLayer;
}(_FMMarkerLayer2.default);

var _default = FMGradientPolygonMarkerLayer;
exports.default = _default;

/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMLayer2 = _interopRequireDefault(__webpack_require__(388));

/**
 * FMMarkerLayer markers渲染层基类
 * @interface
 * @memberof fengmap
 * @extends {fengmap.FMLayer}
 * @hideconstructor true
 */
var FMMarkerLayer =
/*#__PURE__*/
function (_FMLayer) {
  (0, _inherits2.default)(FMMarkerLayer, _FMLayer);

  /***
   * @constructor
   */
  function FMMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMMarkerLayer).call(this));
    _this._markers = []; // 存放marker

    _this.prepareInitMarkers = []; // 存放未完成初始化的marker

    return _this;
  }
  /**
   * 新增marker对象
   * @param {fengmap.FMMarker} marker marker对象
   */


  (0, _createClass2.default)(FMMarkerLayer, [{
    key: "addMarker",
    value: function addMarker(marker) {
      marker.parent = this;

      if (!marker.isInit) {
        if (!marker.init()) {
          this.prepareInitMarkers.push(marker);
        } else {
          this.pushMarker(marker);
        }
      } else {
        this.pushMarker(marker);
      }
    }
    /***
     * 遍历marker
     * @param back
     */

  }, {
    key: "traverse",
    value: function traverse(back) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this._markers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var marker = _step.value;
          back && back(marker);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /***
     * 初始化准备初始化的marker
     */

  }, {
    key: "initPrepare",
    value: function initPrepare() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator2.default)(this.prepareInitMarkers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var marker = _step2.value;

          if (marker.init()) {
            var index = this.prepareInitMarkers.indexOf(marker);

            if (index > -1) {
              this.prepareInitMarkers.splice(index, 1);
            }

            this.pushMarker(marker);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
    /***
     * 添加marker
     * @param marker
     * @private
     */

  }, {
    key: "pushMarker",
    value: function pushMarker(marker) {
      this._markers.push(marker);

      marker.renderNode && this._scene.add(marker.renderNode);
    }
    /**
     * 删除所有marker
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator2.default)(this._markers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var marker = _step3.value;
          marker.parent = undefined;

          this._scene.remove(marker.renderNode);

          marker.dispose();
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this._markers.length = 0;
    }
    /***
     * 删除单个多边形标注
     * @param marker
     * @deprecated
     */

  }, {
    key: "removeNode",
    value: function removeNode(marker) {
      this.removeMarker(marker);
    }
    /**
     * 移除marker
     * @param marker
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      marker.parent = undefined;

      this._scene.remove(marker.renderNode);

      marker.dispose();

      var index = this._markers.indexOf(marker);

      if (index > -1) {
        this._markers.splice(index, 1);
      }
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(this._markers), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var marker = _step4.value;

          if (marker.visible) {
            marker.renderNode && this._scene.add(marker.renderNode);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
    /**
     * 获得该图层内部markers数组
     * @property {Array<fengmap.FMPolygonMarker>} markers 多边形标注数组
     */

  }, {
    key: "dispose",

    /**
     * 释放
     */
    value: function dispose() {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator2.default)(this._markers), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var marker = _step5.value;
          marker.dispose();

          this._scene.remove(marker.renderNode);

          marker.parent = undefined;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this._markers.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "markers",
    get: function get() {
      //cwj 新增
      return this._markers;
    }
  }]);
  return FMMarkerLayer;
}(_FMLayer2.default);

var _default = FMMarkerLayer;
exports.default = _default;

/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

//用户label

/**
 *   FMTextMarkerLayer 文本标注层图层，自定义图层，每层可以包含多个文本标注图层，每个标注图层可添加任意个文本标注。
 *   @class
 *   @memberof fengmap
 *   @extends {fengmap.FMNode}
 */
var FMTextMarkerLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMTextMarkerLayer, _FMNode);

  function FMTextMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMTextMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMTextMarkerLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "textMarker";
    _this._scene.name = "textMarker";
    _this.alias = "textMarker";
    _this.textMarkers = [];
    _this._visible = true;
    _this.prepareInitObjects = [];
    return _this;
  }
  /**
   * 添加文本标注
   * @param {fengmap.FMTextMarker} marker 此图层可为FMTextMarker对象	 
   */


  (0, _createClass2.default)(FMTextMarkerLayer, [{
    key: "addMarker",
    value: function addMarker(marker) {
      marker.parent = this;

      if (!marker.isInitSprite) {
        if (!marker.initSprite()) {
          this.prepareInitObjects.push(marker);
        } else {
          this.pushImageMarker(marker);
        }
      } else {
        this.pushImageMarker(marker);
      }
    }
  }, {
    key: "traverse",
    value: function traverse(back) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this.textMarkers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var marker = _step.value;
          back && back(marker);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "initPrepare",
    value: function initPrepare() {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _getIterator2.default)(this.prepareInitObjects), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var marker = _step2.value;

          if (marker.initSprite()) {
            var index = this.prepareInitObjects.indexOf(marker);

            if (index > -1) {
              this.prepareInitObjects.splice(index, 1);
            }

            this.pushImageMarker(marker);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }, {
    key: "pushImageMarker",
    value: function pushImageMarker(marker) {
      this.textMarkers.push(marker);
      marker.renderNode && this._scene.add(marker.renderNode);
    }
    /**
     * 移除该图层的所有图片标注
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator2.default)(this.textMarkers), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var imageMarker = _step3.value;
          this.removeNode(imageMarker, true);
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      this.textMarkers.length = 0;
    }
  }, {
    key: "untiedMarker",
    value: function untiedMarker(marker) {
      marker.parent = undefined;

      this._scene.remove(marker.renderNode);
    }
  }, {
    key: "removeNode",
    value: function removeNode(marker, noClearMarkers) {
      marker.parent = undefined;

      this._scene.remove(marker.renderNode);

      if (marker.isAlwaysShow) {
        this.parent.removeAlwaysShowMarker(marker.renderNode);
        marker.show = false;
      }

      marker.dispose();

      if (noClearMarkers) {
        return;
      }

      var index = this.textMarkers.indexOf(marker);

      if (index > -1) {
        this.textMarkers.splice(index, 1);
      }
    }
    /**
     * 移除单个文本标注
     * @param {fengmap.FMTextMarker} marker 此图层可为已添加的某个FMTextMarker对象	 
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      this.removeNode(marker);
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(this.textMarkers), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var imageMarker = _step4.value;

          if (imageMarker.visible) {
            imageMarker.renderNode && this._scene.add(imageMarker.renderNode);
          }
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }
    }
    /**
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = (0, _getIterator2.default)(this.textMarkers), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var imageMarker = _step5.value;
          imageMarker.dispose();

          this._scene.remove(imageMarker.renderNode);

          imageMarker.parent = undefined;
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      this.textMarkers.length = 0;
      this._scene = undefined;
    }
    /** 
     * 获得当前FMTextMarkerLayer的内部markers数组
     * @property {array} markers FMTextMarker对象数组
     * @readonly
     */

  }, {
    key: "markers",
    get: function get() {
      return this.textMarkers;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }]);
  return FMTextMarkerLayer;
}(_FMNode2.default);

var _default = FMTextMarkerLayer;
exports.default = _default;

/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _ThreeHeatMap = _interopRequireDefault(__webpack_require__(390));

var FMHeatMapLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMHeatMapLayer, _FMNode);

  function FMHeatMapLayer(opt) {
    var _this;

    (0, _classCallCheck2.default)(this, FMHeatMapLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMHeatMapLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "heatmap";
    _this.alias = "heatmap";
    _this._prepareInited = false;
    _this._randomInited = true;
    _this._randomNum = 0; // this._gradient = opt.gradient || { 0.45: "rgb(0,0,255)", 0.55: "rgb(0,255,255)", 0.65: "rgb(0,255,0)", 0.95: "yellow", 1.0: "rgb(255,0,0)" };

    _this._gradient = opt.gradient == null ? {
      0.45: "rgb(0,0,255)",
      0.55: "rgb(0,255,255)",
      0.65: "rgb(0,255,0)",
      0.95: "yellow",
      1.0: "rgb(255,0,0)"
    } : opt.gradient;
    _this._points = null;
    _this._opacity = typeof opt.opacity === "number" ? opt.opacity : 0.5;
    _this._prepareInitObjects = [];
    _this._visible = true;
    return _this;
  }

  (0, _createClass2.default)(FMHeatMapLayer, [{
    key: "init",
    value: function init() {
      var nodemanager = this.findParent(_NodeManager.default);

      if (!nodemanager || !this._points) {
        this._prepareInited = true;
        return;
      }

      var scene = this.parent.parent;
      var height = this.parent.getHeight();
      var center = scene.center;
      var materialManager = nodemanager.materialManager;
      var map = materialManager.getHeatMapGradient(this._gradient);
      var heatMesh = new _ThreeHeatMap.default({}, {}, map);
      heatMesh.material.opacity = this._opacity;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this._points), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var point = _step.value;
          var m = heatMesh.clone();
          m.position.set(point.x, center.y + 3 + height, point.y - center.y);
          m.mapNode = this;

          this._scene.add(m);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      this._prepareInited = false;
    }
  }, {
    key: "initPrepare",
    value: function initPrepare() {
      console.log(34);

      if (!this._randomInited) {
        this.randomPoints(this._randomNum, true);
        this._randomInited = true;
        this._randomNum = 0;
      }

      console.log(this._points);
      this.init();
    }
  }, {
    key: "removeAll",
    value: function removeAll() {
      var scene = this._scene;

      if (scene) {
        for (var i = scene.children.length - 1; i > -1; i--) {
          var mesh = scene.children[i];
          scene.remove(mesh);
          mesh.mapNode = undefined;
          mesh.geometry.dispose();
          mesh.material.dispose();
          mesh.material.map.dispose();
        }

        scene.children.length = 0;
      }

      this._points.length = 0;
    }
  }, {
    key: "clearPoints",
    value: function clearPoints() {
      this.removeAll();
    }
  }, {
    key: "addPoints",
    value: function addPoints(points) {
      this._points = points;
      this.init();
    }
  }, {
    key: "randomPoints",
    value: function randomPoints(num, ninit) {
      var nodemanager = this.findParent(_NodeManager.default);

      if (!nodemanager) {
        this._prepareInited = true;
        this._randomInited = false;
        this._randomNum = num;
        return;
      }

      var scene = this.parent.parent;
      var bbox = scene.bbox;
      var dx = bbox.max.x - bbox.min.x;
      var dy = bbox.max.y - bbox.min.y;
      var points = [];

      for (var i = 0; i < num; i++) {
        points.push({
          x: Math.random() * dx + bbox.min.x,
          y: Math.random() * dy + bbox.min.y
        });
      }

      this._points = points;

      if (!ninit) {
        this.init();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.removeAll();
      this._scene = undefined;
      this._gradient = undefined;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "prepareInited",
    get: function get() {
      return this._prepareInited;
    }
  }, {
    key: "prepareInitObjects",
    get: function get() {
      return this._prepareInitObjects;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    }
  }]);
  return FMHeatMapLayer;
}(_FMNode2.default);

var _default = FMHeatMapLayer;
exports.default = _default;

/***/ }),
/* 223 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(55);

__webpack_require__(143);

__webpack_require__(25);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMAES = _interopRequireDefault(__webpack_require__(206));

/*
 * f(x) =1/sqrt(2 * PI) e (-x2 /2)
 */
var GeometryMath =
/*#__PURE__*/
function () {
  function GeometryMath() {
    (0, _classCallCheck2.default)(this, GeometryMath);
  }

  (0, _createClass2.default)(GeometryMath, [{
    key: "createGeometry",
    value: function createGeometry(r, xnum, rnum, theta) {
      var vertices = new Float32Array((xnum + 1) * rnum * 3);
      var uvs = new Float32Array((xnum + 1) * rnum * 2);
      var indexs = new Uint16Array(xnum * rnum * 2 * 3);

      for (var i = 0; i < xnum + 1; i++) {
        var x = i / xnum * r;
        var y = 4 / Math.sqrt(2 * Math.PI) * Math.exp(-x * x / 2 / theta) / Math.sqrt(theta); //正态分布

        for (var j = 0; j < rnum; j++) {
          var rotate = j / rnum * Math.PI * 2;
          var z = x * Math.sin(rotate);
          var xr = x * Math.cos(rotate); //x result

          var index = i * rnum * 3 + j * 3;
          vertices[index] = xr;
          vertices[index + 1] = y;
          vertices[index + 2] = z;
          var indexuv = i * rnum * 2 + j * 2;
          uvs[indexuv] = j / rnum;
          uvs[indexuv + 1] = i / xnum;

          if (i < xnum) {
            var nindex = void 0,
                rightIndex = void 0,
                downIndex = void 0,
                rdIndex = void 0;
            var indicesIndex = i * rnum * 6 + j * 6;
            nindex = i * rnum + j;

            if (j + 1 === rnum) {
              rightIndex = i * rnum;
            } else {
              rightIndex = nindex + 1;
            }

            downIndex = nindex + rnum;
            rdIndex = rightIndex + rnum;
            indexs[indicesIndex] = nindex;
            indexs[indicesIndex + 1] = rightIndex;
            indexs[indicesIndex + 2] = downIndex;
            indexs[indicesIndex + 3] = rightIndex;
            indexs[indicesIndex + 4] = rdIndex;
            indexs[indicesIndex + 5] = downIndex;
          }
        }
      }

      return {
        index: indexs,
        uv: uvs,
        vertice: vertices
      };
    }
  }, {
    key: "computerArcLineByPoints",
    value: function computerArcLineByPoints(start, center, end, r, seq) {
      var disStart = new fm.Vector3().copy(start).distanceTo(center);
      var disEnd = new fm.Vector3().copy(end).distanceTo(center);
      var startP = new fm.Vector3().copy(start);
      var endP = new fm.Vector3().copy(start);
      var line = [];

      if (disStart > r) {
        startP = new fm.Vector3().copy(center).add(new fm.Vector3().copy(start).sub(center).normalize().multiplyScalar(r));
        line.push(startP);
      }

      if (disEnd > r) {
        endP = new fm.Vector3().copy(center).add(new fm.Vector3().copy(end).sub(center).normalize().multiplyScalar(r));
      }

      var quadraCurve = new fm.QuadraticBezierCurve3(startP, center, endP);

      for (var i = 0; i < seq - 1; i++) {
        var t = (i + 1) / seq;
        var p = quadraCurve.getPoint(t);
        line.push(p);
      }

      if (disEnd > r) {
        line.push(endP);
      }

      return line;
    }
  }]);
  return GeometryMath;
}();

var _default = GeometryMath;
exports.default = _default;

/***/ }),
/* 224 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(112);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

/**
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMDomMarkerLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMDomMarkerLayer, _FMNode);

  function FMDomMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMDomMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMDomMarkerLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "domMarker";
    _this.alias = "domMarker";
    _this._visible = true;
    _this.domMarkers = [];
    _this.anchor = 9;
    _this.temp = [];
    return _this;
  }
  /**
   * 添加文本标注
   * @param {fengmap.FMDomMarker} marker 此图层可为FMDomMarker对象  
   */


  (0, _createClass2.default)(FMDomMarkerLayer, [{
    key: "addMarker",
    value: function addMarker(marker) {
      marker.parent = this;
      this.domMarkers.push(marker);
      var myDate = new Date();
      var time = myDate.getTime();
      var randomNum1 = Math.random();
      marker._param.id = 'domMarker' + time + randomNum1;
      marker.initDom(marker._param);
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return;

      this._displayMarker();

      nodeManager._map.on('update', this._moveMarker.bind(this));

      nodeManager._map.on('focusGroupIDChanged', this._displayMarker.bind(this));

      nodeManager._map.on('visibleGroupIDsChanged', this._displayMarker.bind(this));
    }
  }, {
    key: "_moveMarker",
    value: function _moveMarker() {
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return; // this.domMarkers.concat(this.temp);

      for (var i = 0; i < this.domMarkers.length; i++) {
        var marker = this.domMarkers[i];
        var dm = marker.domNode;

        if (dm) {
          var h = null;

          if (marker.gid) {
            if (marker.height) {
              h = marker.height + nodeManager._map.groupSpace * marker.gid;
            } else {
              h = nodeManager._map.groupSpace * marker.gid;
            }
          } else {
            if (marker.height) {
              h = marker.height + this.height;
            } else {
              h = this.height;
            }
          }

          var a = nodeManager._map.coordMapToScreen(marker.x, marker.y, h);

          dm.style.left = this._anchor(marker, a).left;
          dm.style.top = this._anchor(marker, a).top; // for (let a = 0; a < this.domMarkers.length; a++) {
          //     if (a != i) {
          //         let dm2 = this.domMarkers[a].domNode;
          //         let circleCenter = {
          //             x: parseFloat(dm.style.left),
          //             y: parseFloat(dm.style.top)
          //         };
          //         let circleCenter2 = {
          //             x: parseFloat(dm2.style.left),
          //             y: parseFloat(dm2.style.top)
          //         };
          //         let ppl = Math.abs(Math.sqrt(Math.pow(circleCenter.x - circleCenter2.x, 2) + Math.pow(circleCenter.y - circleCenter2.y, 2)));
          //         let radius = parseFloat(dm.style.width) > parseFloat(dm.style.height) ? parseFloat(dm.style.width) : parseFloat(dm.style.height);
          //         if (ppl <= radius) {
          //             dm2.style.display = "none";
          //             this.temp.push(this.domMarkers.splice(a, 1));
          //         }else{
          //         	dm2.style.display = "block";
          //         }
          //     }
          // }
          // this.domMarkers.splice(i, 1);
          // let a = nodeManager._map.coordMapToScreen(marker.x, marker.y, h);
          // dm.style.left = this._anchor(marker, a).left;
          // dm.style.top = this._anchor(marker, a).top;
        }
      }
    }
  }, {
    key: "_anchor",
    value: function _anchor(marker, a) {
      var left = null;
      var top = null;

      switch (marker.anchor) {
        case 9:
          //'cMiddle'
          left = a.x - marker.domWidth / 2 + "px";
          top = a.y - marker.domHeight / 2 + "px";
          break;

        case 5:
          //'lTop'
          left = a.x - marker.domWidth + "px";
          top = a.y - marker.domHeight + "px";
          break;

        case 6:
          //'rTop'
          left = a.x + "px";
          top = a.y - marker.domHeight + "px";
          break;

        case 7:
          //'lDown'
          left = a.x - marker.domWidth + "px";
          top = a.y + "px";
          break;

        case 8:
          //'rDown'- marker.domWidth
          left = a.x + "px";
          top = a.y + "px";
          break;

        case 1:
          //'lMiddle'
          left = a.x - marker.domWidth + "px";
          top = a.y - marker.domHeight / 2 + "px";
          break;

        case 2:
          //'rMiddle'- marker.domWidth
          left = a.x + "px";
          top = a.y - marker.domHeight / 2 + "px";
          break;

        case 3:
          //'tCenter'
          left = a.x - marker.domWidth / 2 + "px";
          top = a.y - marker.domHeight + "px";
          break;

        case 4:
          //'dCenter'
          left = a.x - marker.domWidth / 2 + "px";
          top = a.y + "px";
          break;

        default:
          left = a.x - marker.domWidth / 2 + "px";
          top = a.y - marker.domHeight / 2 + "px";
          break;
      }

      return {
        'left': left,
        'top': top
      };
    }
  }, {
    key: "_displayMarker",
    value: function _displayMarker() {
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return;

      if (nodeManager._map._visibleGroups.length === 1) {
        if (this.parent.eid === nodeManager._map.focusGroupID) {
          for (var i = 0; i < this.domMarkers.length; i++) {
            this.domMarkers[i].domNode.style.display = "block";
            this.domMarkers[i].domNode.style.opacity = 1;
          }
        } else {
          for (var _i = 0; _i < this.domMarkers.length; _i++) {
            this.domMarkers[_i].domNode.style.display = "none";
            this.domMarkers[_i].domNode.style.opacity = nodeManager._map.MapOptions.focusAlpha;
          }
        }
      } else {
        if (this.parent.eid === nodeManager._map.focusGroupID) {
          for (var _i2 = 0; _i2 < this.domMarkers.length; _i2++) {
            this.domMarkers[_i2].domNode.style.display = "block";
            this.domMarkers[_i2].domNode.style.opacity = 1;
          }
        } else {
          for (var _i3 = 0; _i3 < this.domMarkers.length; _i3++) {
            this.domMarkers[_i3].domNode.style.display = "block";
            this.domMarkers[_i3].domNode.style.opacity = nodeManager._map.MapOptions.focusAlpha;
          }
        }
      }
    }
    /**
     * 删除marker
     * @param {fengmap.FMDomMarker} marker 删除指定的dommarker
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      if (typeof marker != 'undefined') {
        marker.parent = null;
        var b = document.getElementById(marker._param.id);

        if (b) {
          b.parentNode.removeChild(b);
          b = null;
        }

        var index = this.domMarkers.indexOf(marker);

        if (index > -1) {
          this.domMarkers.splice(index, 1);
        }
      } else {
        return null;
      }
    }
    /**
     * 删除当前层所有dommarker
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      if (typeof this.domMarkers.length !== "undefined") {
        for (var i = 0; i < this.domMarkers.length; i++) {
          var b = document.getElementById(this.domMarkers[i]._param.id);

          if (b) {
            b.parentNode.removeChild(b);
            b = null;
          }
        }

        this.domMarkers.length = 0;
      } else {
        return null;
      }
    }
    /**
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      this.removeAll();
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "height",
    get: function get() {
      return this.parent._height;
    }
  }, {
    key: "show",
    get: function get() {
      return this.show;
    },
    set: function set(v) {
      if (typeof this.domMarkers.length !== "undefined") {
        for (var i = 0; i < this.domMarkers.length; i++) {
          var b = document.getElementById(this.domMarkers[i]._param.id);

          if (b) {
            if (v) {
              b.style.display = "block";
            } else {
              b.style.display = "none";
            }
          }
        }
      } else {
        return null;
      }
    }
  }]);
  return FMDomMarkerLayer;
}(_FMNode2.default);

var _default = FMDomMarkerLayer;
exports.default = _default;

/***/ }),
/* 225 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

/**
 *  FMDynamicModelLayer 模型图层，是一种地图内置图层，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMDynamicModelLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMDynamicModelLayer, _FMNode);

  function FMDynamicModelLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMDynamicModelLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMDynamicModelLayer).call(this, "dynmodel"));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "dynmodel";
    _this._scene.name = "dynmodel";
    _this.alias = "dynmodel";
    _this._models = {};
    _this.prepareInitObjects = [];
    _this._visible = true; // this

    _this.initLight();

    _this.putLight();

    return _this;
  }

  (0, _createClass2.default)(FMDynamicModelLayer, [{
    key: "initLight",
    value: function initLight() {
      this._ambientLight = new fm.AmbientLight(0x747474);
      this._target = new fm.Object3D();
      this._mainLight = new fm.DirectionalLight(0x888888, 1.2);

      this._mainLight.position.set(-1, 1, 1).normalize();

      this._mainLight.target = this._target;
      this._secondLight = new fm.DirectionalLight(0x333333);

      this._secondLight.position.set(-0.5, 1, -1).normalize();

      this._secondLight.target = this._target;
    }
    /**
     *
     * @param {*} node 动态模型对象
     */

  }, {
    key: "addNodes",
    value: function addNodes(node) {
      node.parent = this;
      node.renderNode && this._scene.add(node.renderNode);
      this._models["" + node.eid] = node;
    }
    /***
     * 移除marker
     * @param {*} node 动态模型对象
     * @deprecated
     */

  }, {
    key: "removeNode",
    value: function removeNode(node) {
      this.removeMarker(node);
    }
    /**
     * 移除marker
     * @param marker 动态模型对象
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      marker.parent = undefined;
      var scope = this;
      marker.renderNode.traverse(function (mesh) {
        if (mesh instanceof fm.Mesh) {
          mesh.material.transparent = true;

          if (marker._fadeOut) {
            var interval = setInterval(function () {
              if (mesh.material.opacity > 0.05) {
                mesh.material.opacity -= 0.05;
              } else {
                clearInterval(interval);

                scope._scene.remove(marker.renderNode); //scope._models["" + node.eid] = null;

              }
            }, 200);
          } else {
            scope._scene.remove(marker.renderNode); //scope._models["" + node.eid] = null;

          }
        }
      });
      marker.dispose();
    }
  }, {
    key: "untiedMarker",
    value: function untiedMarker(marker) {
      marker.parent = undefined;

      this._scene.remove(marker.renderNode);
    }
  }, {
    key: "putLight",
    value: function putLight() {
      var _this2 = this;

      this.scene.add(this._mainLight);
      this.scene.add(this._ambientLight);
      this.scene.add(this._secondLight); // var helper1 = new fm.DirectionalLightHelper( this._mainLight, 100 ,0xff0000 );
      // var helper2 = new fm.DirectionalLightHelper( this._secondLight, 100 ,0xff0000);
      // this.scene.add(helper1);
      // this.scene.add(helper2);

      this.scene.add(this._target);

      this.scene.removeLight = function () {
        _this2.removeLight();
      };
    }
  }, {
    key: "removeLight",
    value: function removeLight() {
      this.scene.remove(this._mainLight);
      this.scene.remove(this._ambientLight);
      this.scene.remove(this._secondLight);
    }
  }, {
    key: "disposeLight",
    value: function disposeLight() {
      this._mainLight = undefined;
      this._ambientLight = undefined;
      this._secondLight = undefined;
    }
  }, {
    key: "getNodeById",
    value: function getNodeById(id) {
      return this._models["" + id];
    }
  }, {
    key: "traverse",
    value: function traverse(back) {
      for (var n in this._models) {
        back && back(this._models[n]);
      }
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;

      for (var n in this._models) {
        if (this._models[n].visible) {
          this._models[n].renderNode && this._scene.add(this._models[n].renderNode);
        }
      }

      this.putLight();
    }
  }, {
    key: "getAllMesh",
    value: function getAllMesh() {
      var meshs = [];

      for (var n in this._models) {
        this._models[n].renderNode && meshs.push(this._models[n].renderNode);
      }

      return meshs;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var n in this._models) {
        this._models[n].dispose();

        this._scene.remove(this._models[n].renderNode);

        this._models[n].parent = undefined;
        this._models[n] = undefined;
      }

      this.removeLight();
      this.disposeLight();
      this._scene.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "models",
    get: function get() {
      return this._models;
    },
    set: function set(e) {
      this._models = e;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }]);
  return FMDynamicModelLayer;
}(_FMNode2.default);

var _default = FMDynamicModelLayer;
exports.default = _default;

/***/ }),
/* 226 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

/**
 * @author Mif / Made on May 19, 2020/
 */

/**
 * @class
 * @memberof fengmap
 */
var FMFlowLineMarkerLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMFlowLineMarkerLayer, _FMNode);

  /**
   * FMFlowLineMarkerLayer 是流线标注的图层，用于管理流线标注
   */
  function FMFlowLineMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMFlowLineMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMFlowLineMarkerLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.userData.type = "flmMarker";
    _this._scene.name = "flmMarker";
    _this.alias = "flmMarker";
    _this.lines = [];
    _this._visible = true;
    return _this;
  }
  /**
   * 添加marker
   * @param {Object} marker 流线marker
   */


  (0, _createClass2.default)(FMFlowLineMarkerLayer, [{
    key: "addMarker",
    value: function addMarker(marker) {
      marker.parent = this;
      marker.initLine();
      marker.renderNode && this._scene.add(marker.renderNode);
      this.lines.push(marker);
    }
    /**
     * 移除marker
     * @param {Object} marker 流线marker
     * @returns {boolean}
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      if (!marker.renderNode) return false;

      for (var i = 0; i < this.lines.length; i++) {
        if (this.lines[i].renderNode.uuid === marker.renderNode.uuid) {
          this.lines.splice(i, 1);
          break;
        }
      }

      this._scene.remove(marker.renderNode);
    }
    /**
     * 移除所有marker
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      for (var i = 0; i < this.lines.length; i++) {
        this._scene.remove(this.lines[i].renderNode);
      }

      this.lines = [];
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var i = 0; i < this.lines.length; i++) {
        this._scene.remove(this.lines[i].renderNode);

        this.lines[i].parent = undefined;
        this.lines[i] = undefined;
      }

      this._scene.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    }
  }]);
  return FMFlowLineMarkerLayer;
}(_FMNode2.default);

var _default = FMFlowLineMarkerLayer;
exports.default = _default;

/***/ }),
/* 227 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMMarkerLayer2 = _interopRequireDefault(__webpack_require__(220));

/**
 * @class FMExtrudeMarkerLayer 自定义多边形拉伸几何体体图层，自定义图层，每个图层可添加任意个多边形拉伸几何体。
 * @memberof fengmap
 * @extends fengmap.FMMarkerLayer
 * @hideconstructor ture
 */
var FMExtrudeMarkerLayer =
/*#__PURE__*/
function (_FMMarkerLayer) {
  (0, _inherits2.default)(FMExtrudeMarkerLayer, _FMMarkerLayer);

  /**
   * @constructor
   */
  function FMExtrudeMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMExtrudeMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMExtrudeMarkerLayer).call(this));
    _this._scene.userData.type = "extrudeMarker";
    _this.alias = "extrudeMarker";
    return _this;
  }

  return FMExtrudeMarkerLayer;
}(_FMMarkerLayer2.default);

var _default = FMExtrudeMarkerLayer;
exports.default = _default;

/***/ }),
/* 228 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(25);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var CompassGeometry =
/*#__PURE__*/
function (_fm$BufferGeometry) {
  (0, _inherits2.default)(CompassGeometry, _fm$BufferGeometry);

  function CompassGeometry() {
    var _this;

    (0, _classCallCheck2.default)(this, CompassGeometry);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CompassGeometry).call(this));
    var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
    var interleavedBuffer = new fm.InterleavedBuffer(float32Array, 5);

    _this.setIndex([0, 1, 2, 0, 2, 3]);

    _this.setAttribute('position', new fm.InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

    _this.setAttribute('uv', new fm.InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));

    return _this;
  }

  return CompassGeometry;
}(fm.BufferGeometry);

var _default = CompassGeometry;
exports.default = _default;

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _keys = _interopRequireDefault(__webpack_require__(54));

__webpack_require__(53);

var _assign = _interopRequireDefault(__webpack_require__(11));

var _typeof2 = _interopRequireDefault(__webpack_require__(47));

__webpack_require__(25);

__webpack_require__(195);

__webpack_require__(143);

__webpack_require__(196);

__webpack_require__(197);

var _create = _interopRequireDefault(__webpack_require__(31));

__webpack_require__(48);

__webpack_require__(146);

__webpack_require__(98);

__webpack_require__(62);

__webpack_require__(67);

__webpack_require__(402);

var _isArray = _interopRequireDefault(__webpack_require__(35));

var _promise = _interopRequireDefault(__webpack_require__(403));

__webpack_require__(8);

__webpack_require__(144);

function GLTFLoader(manager) {
  this.manager = manager !== undefined ? manager : fm.DefaultLoadingManager;
  this.dracoLoader = null;
  this.ddsLoader = null;
}

GLTFLoader.prototype = {
  constructor: GLTFLoader,
  crossOrigin: 'anonymous',
  load: function load(url, onLoad, onProgress, onError) {
    var scope = this;
    var resourcePath;

    if (this.resourcePath !== undefined) {
      resourcePath = this.resourcePath;
    } else if (this.path !== undefined) {
      resourcePath = this.path;
    } else {
      resourcePath = fm.LoaderUtils.extractUrlBase(url);
    } // Tells the LoadingManager to track an extra item, which resolves after
    // the model is fully loaded. This means the count of items loaded will
    // be incorrect, but ensures manager.onLoad() does not fire early.


    scope.manager.itemStart(url);

    var _onError = function _onError(e) {
      if (onError) {
        onError(e);
      } else {
        console.error(e);
      }

      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };

    var loader = new fm.FileLoader(scope.manager);
    loader.setPath(this.path);
    loader.setResponseType('arraybuffer');

    if (scope.crossOrigin === 'use-credentials') {
      loader.setWithCredentials(true);
    }

    loader.load(url, function (data) {
      try {
        scope.parse(data, resourcePath, function (gltf) {
          onLoad(gltf, data);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e) {
        _onError(e);
      }
    }, onProgress, _onError);
  },
  setCrossOrigin: function setCrossOrigin(value) {
    this.crossOrigin = value;
    return this;
  },
  setPath: function setPath(value) {
    this.path = value;
    return this;
  },
  setResourcePath: function setResourcePath(value) {
    this.resourcePath = value;
    return this;
  },
  setDRACOLoader: function setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  },
  setDDSLoader: function setDDSLoader(ddsLoader) {
    this.ddsLoader = ddsLoader;
    return this;
  },
  parse: function parse(data, path, onLoad, onError) {
    var content;
    var extensions = {};

    if (typeof data === 'string') {
      content = data;
    } else {
      var magic = fm.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
        } catch (error) {
          if (onError) onError(error);
          return;
        }

        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
      } else {
        content = fm.LoaderUtils.decodeText(new Uint8Array(data));
      }
    }

    var json = JSON.parse(content);

    if (json.asset === undefined || json.asset.version[0] < 2) {
      //if ( onError ) onError( new Error( 'fm.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported. Use LegacyGLTFLoader instead.' ) );
      if (onError) onError(new Error('fm.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
      return;
    }

    if (json.extensionsUsed) {
      for (var i = 0; i < json.extensionsUsed.length; ++i) {
        var extensionName = json.extensionsUsed[i];
        var extensionsRequired = json.extensionsRequired || [];

        switch (extensionName) {
          case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
            extensions[extensionName] = new GLTFLightsExtension(json);
            break;

          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;

          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
            break;

          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;

          case EXTENSIONS.MSFT_TEXTURE_DDS:
            extensions[EXTENSIONS.MSFT_TEXTURE_DDS] = new GLTFTextureDDSExtension(this.ddsLoader);
            break;

          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] = new GLTFTextureTransformExtension();
            break;

          default:
            if (extensionsRequired.indexOf(extensionName) >= 0) {
              console.warn('fm.GLTFLoader: Unknown extension "' + extensionName + '".');
            }

        }
      }
    }

    var parser = new GLTFParser(json, extensions, {
      path: path || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      manager: this.manager
    });
    parser.parse(onLoad, onError);
  }
};
/* GLTFREGISTRY */

function GLTFRegistry() {
  var objects = {};
  return {
    get: function get(key) {
      return objects[key];
    },
    add: function add(key, object) {
      objects[key] = object;
    },
    remove: function remove(key) {
      delete objects[key];
    },
    removeAll: function removeAll() {
      objects = {};
    }
  };
}
/*********************************/

/********** EXTENSIONS ***********/

/*********************************/


var EXTENSIONS = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
};
/**
 * DDS Texture Extension
 *
 * Specification:
 * https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
 *
 */

function GLTFTextureDDSExtension(ddsLoader) {
  if (!ddsLoader) {
    throw new Error('fm.GLTFLoader: Attempting to load .dds texture without importing fm.DDSLoader');
  }

  this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
  this.ddsLoader = ddsLoader;
}
/**
 * Lights Extension
 *
 * Specification: PENDING
 */


function GLTFLightsExtension(json) {
  this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
  var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};
  this.lightDefs = extension.lights || [];
}

GLTFLightsExtension.prototype.loadLight = function (lightIndex) {
  var lightDef = this.lightDefs[lightIndex];
  var lightNode;
  var color = new fm.Color(0xffffff);
  if (lightDef.color !== undefined) color.fromArray(lightDef.color);
  var range = lightDef.range !== undefined ? lightDef.range : 0;

  switch (lightDef.type) {
    case 'directional':
      lightNode = new fm.DirectionalLight(color);
      lightNode.target.position.set(0, 0, -1);
      lightNode.add(lightNode.target);
      break;

    case 'point':
      lightNode = new fm.PointLight(color);
      lightNode.distance = range;
      break;

    case 'spot':
      lightNode = new fm.SpotLight(color);
      lightNode.distance = range; // Handle spotlight properties.

      lightDef.spot = lightDef.spot || {};
      lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
      lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
      lightNode.angle = lightDef.spot.outerConeAngle;
      lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
      lightNode.target.position.set(0, 0, -1);
      lightNode.add(lightNode.target);
      break;

    default:
      throw new Error('fm.GLTFLoader: Unexpected light type, "' + lightDef.type + '".');
  } // Some lights (e.g. spot) default to a position other than the origin. Reset the position
  // here, because node-level parsing will only override position if explicitly specified.


  lightNode.position.set(0, 0, 0);
  lightNode.decay = 2;
  if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
  lightNode.name = lightDef.name || 'light_' + lightIndex;
  return _promise.default.resolve(lightNode);
};
/**
 * Unlit Materials Extension (pending)
 *
 * PR: https://github.com/KhronosGroup/glTF/pull/1163
 */


function GLTFMaterialsUnlitExtension() {
  this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
}

GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {
  return fm.MeshBasicMaterial;
};

GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {
  var pending = [];
  materialParams.color = new fm.Color(1.0, 1.0, 1.0);
  materialParams.opacity = 1.0;
  var metallicRoughness = materialDef.pbrMetallicRoughness;

  if (metallicRoughness) {
    if ((0, _isArray.default)(metallicRoughness.baseColorFactor)) {
      var array = metallicRoughness.baseColorFactor;
      materialParams.color.fromArray(array);
      materialParams.opacity = array[3];
    }

    if (metallicRoughness.baseColorTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
    }
  }

  return _promise.default.all(pending);
};
/* BINARY EXTENSION */


var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = {
  JSON: 0x4E4F534A,
  BIN: 0x004E4942
};

function GLTFBinaryExtension(data) {
  this.name = EXTENSIONS.KHR_BINARY_GLTF;
  this.content = null;
  this.body = null;
  var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
  this.header = {
    magic: fm.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
    version: headerView.getUint32(4, true),
    length: headerView.getUint32(8, true)
  };

  if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
    throw new Error('fm.GLTFLoader: Unsupported glTF-Binary header.');
  } else if (this.header.version < 2.0) {
    throw new Error('fm.GLTFLoader: Legacy binary file detected. Use LegacyGLTFLoader instead.');
  }

  var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
  var chunkIndex = 0;

  while (chunkIndex < chunkView.byteLength) {
    var chunkLength = chunkView.getUint32(chunkIndex, true);
    chunkIndex += 4;
    var chunkType = chunkView.getUint32(chunkIndex, true);
    chunkIndex += 4;

    if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
      var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
      this.content = fm.LoaderUtils.decodeText(contentArray);
    } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
      var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
      this.body = data.slice(byteOffset, byteOffset + chunkLength);
    } // Clients must ignore chunks with unknown types.


    chunkIndex += chunkLength;
  }

  if (this.content === null) {
    throw new Error('fm.GLTFLoader: JSON content not found.');
  }
}
/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/pull/874
 */


function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
  if (!dracoLoader) {
    throw new Error('fm.GLTFLoader: No DRACOLoader instance provided.');
  }

  this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
  this.json = json;
  this.dracoLoader = dracoLoader;
}

GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {
  var json = this.json;
  var dracoLoader = this.dracoLoader;
  var bufferViewIndex = primitive.extensions[this.name].bufferView;
  var gltfAttributeMap = primitive.extensions[this.name].attributes;
  var threeAttributeMap = {};
  var attributeNormalizedMap = {};
  var attributeTypeMap = {};

  for (var attributeName in gltfAttributeMap) {
    var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
    threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
  }

  for (attributeName in primitive.attributes) {
    var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

    if (gltfAttributeMap[attributeName] !== undefined) {
      var accessorDef = json.accessors[primitive.attributes[attributeName]];
      var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      attributeTypeMap[threeAttributeName] = componentType;
      attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
    }
  }

  return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
    return new _promise.default(function (resolve) {
      dracoLoader.decodeDracoFile(bufferView, function (geometry) {
        for (var attributeName in geometry.attributes) {
          var attribute = geometry.attributes[attributeName];
          var normalized = attributeNormalizedMap[attributeName];
          if (normalized !== undefined) attribute.normalized = normalized;
        }

        resolve(geometry);
      }, threeAttributeMap, attributeTypeMap);
    });
  });
};
/**
 * Texture Transform Extension
 *
 * Specification:
 */


function GLTFTextureTransformExtension() {
  this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
}

GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {
  texture = texture.clone();

  if (transform.offset !== undefined) {
    texture.offset.fromArray(transform.offset);
  }

  if (transform.rotation !== undefined) {
    texture.rotation = transform.rotation;
  }

  if (transform.scale !== undefined) {
    texture.repeat.fromArray(transform.scale);
  }

  if (transform.texCoord !== undefined) {
    console.warn('fm.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
  }

  texture.needsUpdate = true;
  return texture;
};
/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
 */


function GLTFMaterialsPbrSpecularGlossinessExtension() {
  return {
    name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
    specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],
    getMaterialType: function getMaterialType() {
      return fm.ShaderMaterial;
    },
    extendParams: function extendParams(materialParams, materialDef, parser) {
      var pbrSpecularGlossiness = materialDef.extensions[this.name];
      var shader = fm.ShaderLib['standard'];
      var uniforms = fm.UniformsUtils.clone(shader.uniforms);
      var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
      var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
      var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
      var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
      var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\n');
      var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
      delete uniforms.roughness;
      delete uniforms.metalness;
      delete uniforms.roughnessMap;
      delete uniforms.metalnessMap;
      uniforms.specular = {
        value: new fm.Color().setHex(0x111111)
      };
      uniforms.glossiness = {
        value: 0.5
      };
      uniforms.specularMap = {
        value: null
      };
      uniforms.glossinessMap = {
        value: null
      };
      materialParams.vertexShader = shader.vertexShader;
      materialParams.fragmentShader = fragmentShader;
      materialParams.uniforms = uniforms;
      materialParams.defines = {
        'STANDARD': ''
      };
      materialParams.color = new fm.Color(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;
      var pending = [];

      if ((0, _isArray.default)(pbrSpecularGlossiness.diffuseFactor)) {
        var array = pbrSpecularGlossiness.diffuseFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
      }

      materialParams.emissive = new fm.Color(0.0, 0.0, 0.0);
      materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
      materialParams.specular = new fm.Color(1.0, 1.0, 1.0);

      if ((0, _isArray.default)(pbrSpecularGlossiness.specularFactor)) {
        materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
      }

      if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
        var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
        pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
        pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
      }

      return _promise.default.all(pending);
    },
    createMaterial: function createMaterial(params) {
      // setup material properties based on MeshStandardMaterial for Specular-Glossiness
      var material = new fm.ShaderMaterial({
        defines: params.defines,
        vertexShader: params.vertexShader,
        fragmentShader: params.fragmentShader,
        uniforms: params.uniforms,
        fog: true,
        lights: true,
        opacity: params.opacity,
        transparent: params.transparent
      });
      material.isGLTFSpecularGlossinessMaterial = true;
      material.color = params.color;
      material.map = params.map === undefined ? null : params.map;
      material.lightMap = null;
      material.lightMapIntensity = 1.0;
      material.aoMap = params.aoMap === undefined ? null : params.aoMap;
      material.aoMapIntensity = 1.0;
      material.emissive = params.emissive;
      material.emissiveIntensity = 1.0;
      material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;
      material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;
      material.bumpScale = 1;
      material.normalMap = params.normalMap === undefined ? null : params.normalMap;
      if (params.normalScale) material.normalScale = params.normalScale;
      material.displacementMap = null;
      material.displacementScale = 1;
      material.displacementBias = 0;
      material.specularMap = params.specularMap === undefined ? null : params.specularMap;
      material.specular = params.specular;
      material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;
      material.glossiness = params.glossiness;
      material.alphaMap = null;
      material.envMap = params.envMap === undefined ? null : params.envMap;
      material.envMapIntensity = 1.0;
      material.refractionRatio = 0.98;
      material.extensions.derivatives = true;
      return material;
    },

    /**
     * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can
     * copy only properties it knows about or inherits, and misses many properties that would
     * normally be defined by MeshStandardMaterial.
     *
     * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of
     * loading a glTF model, but cloning later (e.g. by the user) would require these changes
     * AND also updating `.onBeforeRender` on the parent mesh.
     *
     * @param  {fm.ShaderMaterial} source
     * @return {fm.ShaderMaterial}
     */
    cloneMaterial: function cloneMaterial(source) {
      var target = source.clone();
      target.isGLTFSpecularGlossinessMaterial = true;
      var params = this.specularGlossinessParams;

      for (var i = 0, il = params.length; i < il; i++) {
        var value = source[params[i]];
        target[params[i]] = value && value.isColor ? value.clone() : value;
      }

      return target;
    },
    // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
    refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material) {
      if (material.isGLTFSpecularGlossinessMaterial !== true) {
        return;
      }

      var uniforms = material.uniforms;
      var defines = material.defines;
      uniforms.opacity.value = material.opacity;
      uniforms.diffuse.value.copy(material.color);
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
      uniforms.map.value = material.map;
      uniforms.specularMap.value = material.specularMap;
      uniforms.alphaMap.value = material.alphaMap;
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities
      // 1. color map
      // 2. specular map
      // 3. normal map
      // 4. bump map
      // 5. alpha map
      // 6. emissive map

      var uvScaleMap;

      if (material.map) {
        uvScaleMap = material.map;
      } else if (material.specularMap) {
        uvScaleMap = material.specularMap;
      } else if (material.displacementMap) {
        uvScaleMap = material.displacementMap;
      } else if (material.normalMap) {
        uvScaleMap = material.normalMap;
      } else if (material.bumpMap) {
        uvScaleMap = material.bumpMap;
      } else if (material.glossinessMap) {
        uvScaleMap = material.glossinessMap;
      } else if (material.alphaMap) {
        uvScaleMap = material.alphaMap;
      } else if (material.emissiveMap) {
        uvScaleMap = material.emissiveMap;
      }

      if (uvScaleMap !== undefined) {
        // backwards compatibility
        if (uvScaleMap.isWebGLRenderTarget) {
          uvScaleMap = uvScaleMap.texture;
        }

        if (uvScaleMap.matrixAutoUpdate === true) {
          uvScaleMap.updateMatrix();
        }

        uniforms.uvTransform.value.copy(uvScaleMap.matrix);
      }

      if (material.envMap) {
        uniforms.envMap.value = material.envMap;
        uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else:
        //  WebGLRenderTargetCube will be flipped for backwards compatibility
        //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
        // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future

        uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
        uniforms.reflectivity.value = material.reflectivity;
        uniforms.refractionRatio.value = material.refractionRatio;
        uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;
      }

      uniforms.specular.value.copy(material.specular);
      uniforms.glossiness.value = material.glossiness;
      uniforms.glossinessMap.value = material.glossinessMap;
      uniforms.emissiveMap.value = material.emissiveMap;
      uniforms.bumpMap.value = material.bumpMap;
      uniforms.normalMap.value = material.normalMap;
      uniforms.displacementMap.value = material.displacementMap;
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;

      if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {
        defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv

        defines.USE_ROUGHNESSMAP = '';
      }

      if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {
        delete defines.USE_GLOSSINESSMAP;
        delete defines.USE_ROUGHNESSMAP;
      }
    }
  };
}
/*********************************/

/********** INTERPOLATION ********/

/*********************************/
// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation


function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
  fm.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
}

GLTFCubicSplineInterpolant.prototype = (0, _create.default)(fm.Interpolant.prototype);
GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {
  // Copies a sample value to the result buffer. See description of glTF
  // CUBICSPLINE values layout in interpolate_() function below.
  var result = this.resultBuffer,
      values = this.sampleValues,
      valueSize = this.valueSize,
      offset = index * valueSize * 3 + valueSize;

  for (var i = 0; i !== valueSize; i++) {
    result[i] = values[offset + i];
  }

  return result;
};

GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
  var result = this.resultBuffer;
  var values = this.sampleValues;
  var stride = this.valueSize;
  var stride2 = stride * 2;
  var stride3 = stride * 3;
  var td = t1 - t0;
  var p = (t - t0) / td;
  var pp = p * p;
  var ppp = pp * p;
  var offset1 = i1 * stride3;
  var offset0 = offset1 - stride3;
  var s2 = -2 * ppp + 3 * pp;
  var s3 = ppp - pp;
  var s0 = 1 - s2;
  var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:
  //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]

  for (var i = 0; i !== stride; i++) {
    var p0 = values[offset0 + i + stride]; // splineVertex_k

    var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)

    var p1 = values[offset1 + i + stride]; // splineVertex_k+1

    var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
  }

  return result;
};
/*********************************/

/********** INTERNALS ************/

/*********************************/

/* CONSTANTS */


var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: fm.NearestFilter,
  9729: fm.LinearFilter,
  9984: fm.NearestMipmapNearestFilter,
  9985: fm.LinearMipmapNearestFilter,
  9986: fm.NearestMipmapLinearFilter,
  9987: fm.LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: fm.ClampToEdgeWrapping,
  33648: fm.MirroredRepeatWrapping,
  10497: fm.RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  'SCALAR': 1,
  'VEC2': 2,
  'VEC3': 3,
  'VEC4': 4,
  'MAT2': 4,
  'MAT3': 9,
  'MAT4': 16
};
var ATTRIBUTES = {
  POSITION: 'position',
  NORMAL: 'normal',
  TANGENT: 'tangent',
  TEXCOORD_0: 'uv',
  TEXCOORD_1: 'uv2',
  COLOR_0: 'color',
  WEIGHTS_0: 'skinWeight',
  JOINTS_0: 'skinIndex'
};
var PATH_PROPERTIES = {
  scale: 'scale',
  translation: 'position',
  rotation: 'quaternion',
  weights: 'morphTargetInfluences'
};
var INTERPOLATION = {
  CUBICSPLINE: undefined,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: fm.InterpolateLinear,
  STEP: fm.InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: 'OPAQUE',
  MASK: 'MASK',
  BLEND: 'BLEND'
};
var MIME_TYPE_FORMATS = {
  'image/png': fm.RGBAFormat,
  'image/jpeg': fm.RGBFormat
};
/* UTILITY FUNCTIONS */

function resolveURL(url, path) {
  // Invalid URL
  if (typeof url !== 'string' || url === '') return ''; // Host Relative URL

  if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
    path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
  } // Absolute URL http://,https://,//


  if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

  if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

  if (/^blob:.*$/i.test(url)) return url; // Relative URL

  return path + url;
}

var defaultMaterial;
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */

function createDefaultMaterial() {
  defaultMaterial = defaultMaterial || new fm.MeshStandardMaterial({
    color: 0xFFFFFF,
    emissive: 0x000000,
    metalness: 1,
    roughness: 1,
    transparent: false,
    depthTest: true,
    side: fm.FrontSide
  });
  return defaultMaterial;
}

function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  // Add unknown glTF extensions to an object's userData.
  for (var name in objectDef.extensions) {
    if (knownExtensions[name] === undefined) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
/**
 * @param {fm.Object3D|fm.Material|fm.BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */


function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== undefined) {
    if ((0, _typeof2.default)(gltfDef.extras) === 'object') {
      (0, _assign.default)(object.userData, gltfDef.extras);
    } else {
      console.warn('fm.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
    }
  }
}
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {fm.BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<fm.BufferGeometry>}
 */


function addMorphTargets(geometry, targets, parser) {
  var hasMorphPosition = false;
  var hasMorphNormal = false;

  for (var i = 0, il = targets.length; i < il; i++) {
    var target = targets[i];
    if (target.POSITION !== undefined) hasMorphPosition = true;
    if (target.NORMAL !== undefined) hasMorphNormal = true;
    if (hasMorphPosition && hasMorphNormal) break;
  }

  if (!hasMorphPosition && !hasMorphNormal) return _promise.default.resolve(geometry);
  var pendingPositionAccessors = [];
  var pendingNormalAccessors = [];

  for (var i = 0, il = targets.length; i < il; i++) {
    var target = targets[i];

    if (hasMorphPosition) {
      var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }

    if (hasMorphNormal) {
      var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
  }

  return _promise.default.all([_promise.default.all(pendingPositionAccessors), _promise.default.all(pendingNormalAccessors)]).then(function (accessors) {
    var morphPositions = accessors[0];
    var morphNormals = accessors[1]; // Clone morph target accessors before modifying them.

    for (var i = 0, il = morphPositions.length; i < il; i++) {
      if (geometry.attributes.position === morphPositions[i]) continue;
      morphPositions[i] = cloneBufferAttribute(morphPositions[i]);
    }

    for (var i = 0, il = morphNormals.length; i < il; i++) {
      if (geometry.attributes.normal === morphNormals[i]) continue;
      morphNormals[i] = cloneBufferAttribute(morphNormals[i]);
    }

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      var attributeName = 'morphTarget' + i;

      if (hasMorphPosition) {
        // Three.js morph position is absolute value. The formula is
        //   basePosition
        //     + weight0 * ( morphPosition0 - basePosition )
        //     + weight1 * ( morphPosition1 - basePosition )
        //     ...
        // while the glTF one is relative
        //   basePosition
        //     + weight0 * glTFmorphPosition0
        //     + weight1 * glTFmorphPosition1
        //     ...
        // then we need to convert from relative to absolute here.
        if (target.POSITION !== undefined) {
          var positionAttribute = morphPositions[i];
          positionAttribute.name = attributeName;
          var position = geometry.attributes.position;

          for (var j = 0, jl = positionAttribute.count; j < jl; j++) {
            positionAttribute.setXYZ(j, positionAttribute.getX(j) + position.getX(j), positionAttribute.getY(j) + position.getY(j), positionAttribute.getZ(j) + position.getZ(j));
          }
        }
      }

      if (hasMorphNormal) {
        // see target.POSITION's comment
        if (target.NORMAL !== undefined) {
          var normalAttribute = morphNormals[i];
          normalAttribute.name = attributeName;
          var normal = geometry.attributes.normal;

          for (var j = 0, jl = normalAttribute.count; j < jl; j++) {
            normalAttribute.setXYZ(j, normalAttribute.getX(j) + normal.getX(j), normalAttribute.getY(j) + normal.getY(j), normalAttribute.getZ(j) + normal.getZ(j));
          }
        }
      }
    }

    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    return geometry;
  });
}
/**
 * @param {fm.Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */


function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();

  if (meshDef.weights !== undefined) {
    for (var i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i];
    }
  } // .extras has user-defined data, so check that .extras.targetNames is an array.


  if (meshDef.extras && (0, _isArray.default)(meshDef.extras.targetNames)) {
    var targetNames = meshDef.extras.targetNames;

    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};

      for (var i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i;
      }
    } else {
      console.warn('fm.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
    }
  }
}

function createPrimitiveKey(primitiveDef) {
  var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  var geometryKey;

  if (dracoExtension) {
    geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
  }

  return geometryKey;
}

function createAttributesKey(attributes) {
  var attributesKey = '';
  var keys = (0, _keys.default)(attributes).sort();

  for (var i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
  }

  return attributesKey;
}

function cloneBufferAttribute(attribute) {
  if (attribute.isInterleavedBufferAttribute) {
    var count = attribute.count;
    var itemSize = attribute.itemSize;
    var array = attribute.array.slice(0, count * itemSize);

    for (var i = 0, j = 0; i < count; ++i) {
      array[j++] = attribute.getX(i);
      if (itemSize >= 2) array[j++] = attribute.getY(i);
      if (itemSize >= 3) array[j++] = attribute.getZ(i);
      if (itemSize >= 4) array[j++] = attribute.getW(i);
    }

    return new fm.BufferAttribute(array, itemSize, attribute.normalized);
  }

  return attribute.clone();
}
/* GLTF PARSER */


function GLTFParser(json, extensions, options) {
  this.json = json || {};
  this.extensions = extensions || {};
  this.options = options || {}; // loader object cache

  this.cache = new GLTFRegistry(); // BufferGeometry caching

  this.primitiveCache = {};
  this.textureLoader = new fm.TextureLoader(this.options.manager);
  this.textureLoader.setCrossOrigin(this.options.crossOrigin);
  this.fileLoader = new fm.FileLoader(this.options.manager);
  this.fileLoader.setResponseType('arraybuffer');

  if (this.options.crossOrigin === 'use-credentials') {
    this.fileLoader.setWithCredentials(true);
  }
}

GLTFParser.prototype.parse = function (onLoad, onError) {
  var parser = this;
  var json = this.json;
  var extensions = this.extensions; // Clear the loader cache

  this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse

  this.markDefs();

  _promise.default.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {
    var result = {
      scene: dependencies[0][json.scene || 0],
      scenes: dependencies[0],
      animations: dependencies[1],
      cameras: dependencies[2],
      asset: json.asset,
      parser: parser,
      userData: {}
    };
    addUnknownExtensionsToUserData(extensions, result, json);
    assignExtrasToUserData(result, json);
    onLoad(result);
  }).catch(onError);
};
/**
 * Marks the special nodes/meshes in json for efficient parse.
 */


GLTFParser.prototype.markDefs = function () {
  var nodeDefs = this.json.nodes || [];
  var skinDefs = this.json.skins || [];
  var meshDefs = this.json.meshes || [];
  var meshReferences = {};
  var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an
  // Object3D. Use the skins' joint references to mark bones.

  for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
    var joints = skinDefs[skinIndex].joints;

    for (var i = 0, il = joints.length; i < il; i++) {
      nodeDefs[joints[i]].isBone = true;
    }
  } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To
  // avoid having more than one fm.Mesh with the same name, count
  // references and rename instances below.
  //
  // Example: CesiumMilkTruck sample model reuses "Wheel" meshes.


  for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
    var nodeDef = nodeDefs[nodeIndex];

    if (nodeDef.mesh !== undefined) {
      if (meshReferences[nodeDef.mesh] === undefined) {
        meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;
      }

      meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is
      // a SkinnedMesh or Mesh. Use the node's mesh reference
      // to mark SkinnedMesh if node has skin.

      if (nodeDef.skin !== undefined) {
        meshDefs[nodeDef.mesh].isSkinnedMesh = true;
      }
    }
  }

  this.json.meshReferences = meshReferences;
  this.json.meshUses = meshUses;
};
/**
 * Requests the specified dependency asynchronously, with caching.
 * @param {string} type
 * @param {number} index
 * @return {Promise<fm.Object3D|fm.Material|fm.Texture|fm.AnimationClip|ArrayBuffer|Object>}
 */


GLTFParser.prototype.getDependency = function (type, index) {
  var cacheKey = type + ':' + index;
  var dependency = this.cache.get(cacheKey);

  if (!dependency) {
    switch (type) {
      case 'scene':
        dependency = this.loadScene(index);
        break;

      case 'node':
        dependency = this.loadNode(index);
        break;

      case 'mesh':
        dependency = this.loadMesh(index);
        break;

      case 'accessor':
        dependency = this.loadAccessor(index);
        break;

      case 'bufferView':
        dependency = this.loadBufferView(index);
        break;

      case 'buffer':
        dependency = this.loadBuffer(index);
        break;

      case 'material':
        dependency = this.loadMaterial(index);
        break;

      case 'texture':
        dependency = this.loadTexture(index);
        break;

      case 'skin':
        dependency = this.loadSkin(index);
        break;

      case 'animation':
        dependency = this.loadAnimation(index);
        break;

      case 'camera':
        dependency = this.loadCamera(index);
        break;

      case 'light':
        dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
        break;

      default:
        throw new Error('Unknown type: ' + type);
    }

    this.cache.add(cacheKey, dependency);
  }

  return dependency;
};
/**
 * Requests all dependencies of the specified type asynchronously, with caching.
 * @param {string} type
 * @return {Promise<Array<Object>>}
 */


GLTFParser.prototype.getDependencies = function (type) {
  var dependencies = this.cache.get(type);

  if (!dependencies) {
    var parser = this;
    var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
    dependencies = _promise.default.all(defs.map(function (def, index) {
      return parser.getDependency(type, index);
    }));
    this.cache.add(type, dependencies);
  }

  return dependencies;
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
 * @param {number} bufferIndex
 * @return {Promise<ArrayBuffer>}
 */


GLTFParser.prototype.loadBuffer = function (bufferIndex) {
  var bufferDef = this.json.buffers[bufferIndex];
  var loader = this.fileLoader;

  if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
    throw new Error('fm.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
  } // If present, GLB container is required to be the first buffer.


  if (bufferDef.uri === undefined && bufferIndex === 0) {
    return _promise.default.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
  }

  var options = this.options;
  return new _promise.default(function (resolve, reject) {
    loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
      reject(new Error('fm.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
    });
  });
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
 * @param {number} bufferViewIndex
 * @return {Promise<ArrayBuffer>}
 */


GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {
  var bufferViewDef = this.json.bufferViews[bufferViewIndex];
  return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
    var byteLength = bufferViewDef.byteLength || 0;
    var byteOffset = bufferViewDef.byteOffset || 0;
    return buffer.slice(byteOffset, byteOffset + byteLength);
  });
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
 * @param {number} accessorIndex
 * @return {Promise<fm.BufferAttribute|fm.InterleavedBufferAttribute>}
 */


GLTFParser.prototype.loadAccessor = function (accessorIndex) {
  var parser = this;
  var json = this.json;
  var accessorDef = this.json.accessors[accessorIndex];

  if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
    // Ignore empty accessors, which may be used to declare runtime
    // information about attributes coming from another source (e.g. Draco
    // compression extension).
    return _promise.default.resolve(null);
  }

  var pendingBufferViews = [];

  if (accessorDef.bufferView !== undefined) {
    pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
  } else {
    pendingBufferViews.push(null);
  }

  if (accessorDef.sparse !== undefined) {
    pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
    pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
  }

  return _promise.default.all(pendingBufferViews).then(function (bufferViews) {
    var bufferView = bufferViews[0];
    var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
    var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.

    var elementBytes = TypedArray.BYTES_PER_ELEMENT;
    var itemBytes = elementBytes * itemSize;
    var byteOffset = accessorDef.byteOffset || 0;
    var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
    var normalized = accessorDef.normalized === true;
    var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.

    if (byteStride && byteStride !== itemBytes) {
      // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
      // This makes sure that IBA.count reflects accessor.count properly
      var ibSlice = Math.floor(byteOffset / byteStride);
      var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
      var ib = parser.cache.get(ibCacheKey);

      if (!ib) {
        array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.

        ib = new fm.InterleavedBuffer(array, byteStride / elementBytes);
        parser.cache.add(ibCacheKey, ib);
      }

      bufferAttribute = new fm.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
    } else {
      if (bufferView === null) {
        array = new TypedArray(accessorDef.count * itemSize);
      } else {
        array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
      }

      bufferAttribute = new fm.BufferAttribute(array, itemSize, normalized);
    } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors


    if (accessorDef.sparse !== undefined) {
      var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
      var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
      var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
      var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
      var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
      var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

      if (bufferView !== null) {
        // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
        bufferAttribute.setArray(bufferAttribute.array.slice());
      }

      for (var i = 0, il = sparseIndices.length; i < il; i++) {
        var index = sparseIndices[i];
        bufferAttribute.setX(index, sparseValues[i * itemSize]);
        if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
        if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
        if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
        if (itemSize >= 5) throw new Error('fm.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
      }
    }

    return bufferAttribute;
  });
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
 * @param {number} textureIndex
 * @return {Promise<fm.Texture>}
 */


GLTFParser.prototype.loadTexture = function (textureIndex) {
  var parser = this;
  var json = this.json;
  var options = this.options;
  var textureLoader = this.textureLoader;
  var URL = window.URL || window.webkitURL;
  var textureDef = json.textures[textureIndex];
  var textureExtensions = textureDef.extensions || {};
  var source;

  if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {
    source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
  } else {
    source = json.images[textureDef.source];
  }

  var sourceURI = source.uri;
  var isObjectURL = false;

  if (source.bufferView !== undefined) {
    // Load binary image data from bufferView, if provided.
    sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
      isObjectURL = true;
      var blob = new Blob([bufferView], {
        type: source.mimeType
      });
      sourceURI = URL.createObjectURL(blob);
      return sourceURI;
    });
  }

  return _promise.default.resolve(sourceURI).then(function (sourceURI) {
    // Load Texture resource.
    // var loader = fm.Loader.Handlers.get( sourceURI );
    var lo = new fm.LoadingManager();
    var loader = lo.getHandler(sourceURI);

    if (!loader) {
      loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;
    }

    return new _promise.default(function (resolve, reject) {
      loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);
    });
  }).then(function (texture) {
    // Clean up resources and configure Texture.
    if (isObjectURL === true) {
      URL.revokeObjectURL(sourceURI);
    }

    texture.flipY = false;
    if (textureDef.name !== undefined) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.

    if (source.mimeType in MIME_TYPE_FORMATS) {
      texture.format = MIME_TYPE_FORMATS[source.mimeType];
    }

    var samplers = json.samplers || {};
    var sampler = samplers[textureDef.sampler] || {};
    texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || fm.LinearFilter;
    texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || fm.LinearMipmapLinearFilter;
    texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || fm.RepeatWrapping;
    texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || fm.RepeatWrapping;
    return texture;
  });
};
/**
 * Asynchronously assigns a texture to the given material parameters.
 * @param {Object} materialParams
 * @param {string} mapName
 * @param {Object} mapDef
 * @return {Promise}
 */


GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {
  var parser = this;
  return this.getDependency('texture', mapDef.index).then(function (texture) {
    if (!texture.isCompressedTexture) {
      switch (mapName) {
        case 'aoMap':
        case 'emissiveMap':
        case 'metalnessMap':
        case 'normalMap':
        case 'roughnessMap':
          texture.format = fm.RGBFormat;
          break;
      }
    }

    if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
      var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

      if (transform) {
        texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
      }
    }

    materialParams[mapName] = texture;
  });
};
/**
 * Assigns final material to a Mesh, Line, or Points instance. The instance
 * already has a material (generated from the glTF material options alone)
 * but reuse of the same glTF material may require multiple threejs materials
 * to accomodate different primitive types, defines, etc. New materials will
 * be created if necessary, and reused from a cache.
 * @param  {fm.Object3D} mesh Mesh, Line, or Points instance.
 */


GLTFParser.prototype.assignFinalMaterial = function (mesh) {
  var geometry = mesh.geometry;
  var material = mesh.material;
  var extensions = this.extensions;
  var useVertexTangents = geometry.attributes.tangent !== undefined;
  var useVertexColors = geometry.attributes.color !== undefined;
  var useFlatShading = geometry.attributes.normal === undefined;
  var useSkinning = mesh.isSkinnedMesh === true;
  var useMorphTargets = (0, _keys.default)(geometry.morphAttributes).length > 0;
  var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

  if (mesh.isPoints) {
    var cacheKey = 'PointsMaterial:' + material.uuid;
    var pointsMaterial = this.cache.get(cacheKey);

    if (!pointsMaterial) {
      pointsMaterial = new fm.PointsMaterial();
      fm.Material.prototype.copy.call(pointsMaterial, material);
      pointsMaterial.color.copy(material.color);
      pointsMaterial.map = material.map;
      pointsMaterial.lights = false; // PointsMaterial doesn't support lights yet

      this.cache.add(cacheKey, pointsMaterial);
    }

    material = pointsMaterial;
  } else if (mesh.isLine) {
    var cacheKey = 'LineBasicMaterial:' + material.uuid;
    var lineMaterial = this.cache.get(cacheKey);

    if (!lineMaterial) {
      lineMaterial = new fm.LineBasicMaterial();
      fm.Material.prototype.copy.call(lineMaterial, material);
      lineMaterial.color.copy(material.color);
      lineMaterial.lights = false; // LineBasicMaterial doesn't support lights yet

      this.cache.add(cacheKey, lineMaterial);
    }

    material = lineMaterial;
  } // Clone the material if it will be modified


  if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
    var cacheKey = 'ClonedMaterial:' + material.uuid + ':';
    if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';
    if (useSkinning) cacheKey += 'skinning:';
    if (useVertexTangents) cacheKey += 'vertex-tangents:';
    if (useVertexColors) cacheKey += 'vertex-colors:';
    if (useFlatShading) cacheKey += 'flat-shading:';
    if (useMorphTargets) cacheKey += 'morph-targets:';
    if (useMorphNormals) cacheKey += 'morph-normals:';
    var cachedMaterial = this.cache.get(cacheKey);

    if (!cachedMaterial) {
      cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();
      if (useSkinning) cachedMaterial.skinning = true;
      if (useVertexTangents) cachedMaterial.vertexTangents = true;
      if (useVertexColors) cachedMaterial.vertexColors = fm.VertexColors;
      if (useFlatShading) cachedMaterial.flatShading = true;
      if (useMorphTargets) cachedMaterial.morphTargets = true;
      if (useMorphNormals) cachedMaterial.morphNormals = true;
      this.cache.add(cacheKey, cachedMaterial);
    }

    material = cachedMaterial;
  } // workarounds for mesh and geometry


  if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
    console.log('fm.GLTFLoader: Duplicating UVs to support aoMap.');
    geometry.addAttribute('uv2', new fm.BufferAttribute(geometry.attributes.uv.array, 2));
  }

  if (material.isGLTFSpecularGlossinessMaterial) {
    // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update
    mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;
  }

  mesh.material = material;
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
 * @param {number} materialIndex
 * @return {Promise<fm.Material>}
 */


GLTFParser.prototype.loadMaterial = function (materialIndex) {
  var parser = this;
  var json = this.json;
  var extensions = this.extensions;
  var materialDef = json.materials[materialIndex];
  var materialType;
  var materialParams = {};
  var materialExtensions = materialDef.extensions || {};
  var pending = [];

  if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
    var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
    materialType = sgExtension.getMaterialType();
    pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
  } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
    var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
    materialType = kmuExtension.getMaterialType();
    pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
  } else {
    // Specification:
    // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
    materialType = fm.MeshStandardMaterial;
    var metallicRoughness = materialDef.pbrMetallicRoughness || {};
    materialParams.color = new fm.Color(1.0, 1.0, 1.0);
    materialParams.opacity = 1.0;

    if ((0, _isArray.default)(metallicRoughness.baseColorFactor)) {
      var array = metallicRoughness.baseColorFactor;
      materialParams.color.fromArray(array);
      materialParams.opacity = array[3];
    }

    if (metallicRoughness.baseColorTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
    }

    materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
    materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

    if (metallicRoughness.metallicRoughnessTexture !== undefined) {
      pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
      pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
    }
  }

  if (materialDef.doubleSided === true) {
    materialParams.side = fm.DoubleSide;
  }

  var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

  if (alphaMode === ALPHA_MODES.BLEND) {
    materialParams.transparent = true;
  } else {
    materialParams.transparent = false;

    if (alphaMode === ALPHA_MODES.MASK) {
      materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
    }
  }

  if (materialDef.normalTexture !== undefined && materialType !== fm.MeshBasicMaterial) {
    pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));
    materialParams.normalScale = new fm.Vector2(1, 1);

    if (materialDef.normalTexture.scale !== undefined) {
      materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
    }
  }

  if (materialDef.occlusionTexture !== undefined && materialType !== fm.MeshBasicMaterial) {
    pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

    if (materialDef.occlusionTexture.strength !== undefined) {
      materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
    }
  }

  if (materialDef.emissiveFactor !== undefined && materialType !== fm.MeshBasicMaterial) {
    materialParams.emissive = new fm.Color().fromArray(materialDef.emissiveFactor);
  }

  if (materialDef.emissiveTexture !== undefined && materialType !== fm.MeshBasicMaterial) {
    pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
  }

  return _promise.default.all(pending).then(function () {
    var material;

    if (materialType === fm.ShaderMaterial) {
      material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
    } else {
      material = new materialType(materialParams);
    }

    if (materialDef.name !== undefined) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.

    if (material.map) material.map.encoding = fm.sRGBEncoding;
    if (material.emissiveMap) material.emissiveMap.encoding = fm.sRGBEncoding;
    if (material.specularMap) material.specularMap.encoding = fm.sRGBEncoding;
    assignExtrasToUserData(material, materialDef);
    if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
    return material;
  });
};
/**
 * @param {fm.BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<fm.BufferGeometry>}
 */


function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  var attributes = primitiveDef.attributes;
  var pending = [];

  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }

  for (var gltfAttributeName in attributes) {
    var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.

    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }

  if (primitiveDef.indices !== undefined && !geometry.index) {
    var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
      geometry.setIndex(accessor);
    });
    pending.push(accessor);
  }

  assignExtrasToUserData(geometry, primitiveDef);
  return _promise.default.all(pending).then(function () {
    return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
 *
 * Creates BufferGeometries from primitives.
 *
 * @param {Array<GLTF.Primitive>} primitives
 * @return {Promise<Array<fm.BufferGeometry>>}
 */


GLTFParser.prototype.loadGeometries = function (primitives) {
  var parser = this;
  var extensions = this.extensions;
  var cache = this.primitiveCache;

  function createDracoPrimitive(primitive) {
    return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
      return addPrimitiveAttributes(geometry, primitive, parser);
    });
  }

  var pending = [];

  for (var i = 0, il = primitives.length; i < il; i++) {
    var primitive = primitives[i];
    var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry

    var cached = cache[cacheKey];

    if (cached) {
      // Use the cached geometry if it exists
      pending.push(cached.promise);
    } else {
      var geometryPromise;

      if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
        // Use DRACO geometry if available
        geometryPromise = createDracoPrimitive(primitive);
      } else {
        // Otherwise create a new geometry
        geometryPromise = addPrimitiveAttributes(new fm.BufferGeometry(), primitive, parser);
      } // Cache this geometry


      cache[cacheKey] = {
        primitive: primitive,
        promise: geometryPromise
      };
      pending.push(geometryPromise);
    }
  }

  return _promise.default.all(pending);
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
 * @param {number} meshIndex
 * @return {Promise<fm.Group|fm.Mesh|fm.SkinnedMesh>}
 */


GLTFParser.prototype.loadMesh = function (meshIndex) {
  var parser = this;
  var json = this.json;
  var meshDef = json.meshes[meshIndex];
  var primitives = meshDef.primitives;
  var pending = [];

  for (var i = 0, il = primitives.length; i < il; i++) {
    var material = primitives[i].material === undefined ? createDefaultMaterial() : this.getDependency('material', primitives[i].material);
    pending.push(material);
  }

  return _promise.default.all(pending).then(function (originalMaterials) {
    return parser.loadGeometries(primitives).then(function (geometries) {
      var meshes = [];

      for (var i = 0, il = geometries.length; i < il; i++) {
        var geometry = geometries[i];
        var primitive = primitives[i]; // 1. create Mesh

        var mesh;
        var material = originalMaterials[i];

        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
          // .isSkinnedMesh isn't in glTF spec. See .markDefs()
          mesh = meshDef.isSkinnedMesh === true ? new fm.SkinnedMesh(geometry, material) : new fm.Mesh(geometry, material);

          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            // we normalize floating point skin weight array to fix malformed assets (see #15319)
            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
            mesh.normalizeSkinWeights();
          }

          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.drawMode = fm.TriangleStripDrawMode;
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.drawMode = fm.TriangleFanDrawMode;
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new fm.LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new fm.Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new fm.LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new fm.Points(geometry, material);
        } else {
          throw new Error('fm.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
        }

        if ((0, _keys.default)(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }

        mesh.name = meshDef.name || 'mesh_' + meshIndex;
        if (geometries.length > 1) mesh.name += '_' + i;
        assignExtrasToUserData(mesh, meshDef);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }

      if (meshes.length === 1) {
        return meshes[0];
      }

      var group = new fm.Group();

      for (var i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }

      return group;
    });
  });
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
 * @param {number} cameraIndex
 * @return {Promise<fm.Camera>}
 */


GLTFParser.prototype.loadCamera = function (cameraIndex) {
  var camera;
  var cameraDef = this.json.cameras[cameraIndex];
  var params = cameraDef[cameraDef.type];

  if (!params) {
    console.warn('fm.GLTFLoader: Missing camera parameters.');
    return;
  }

  if (cameraDef.type === 'perspective') {
    camera = new fm.PerspectiveCamera(fm.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
  } else if (cameraDef.type === 'orthographic') {
    camera = new fm.OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);
  }

  if (cameraDef.name !== undefined) camera.name = cameraDef.name;
  assignExtrasToUserData(camera, cameraDef);
  return _promise.default.resolve(camera);
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
 * @param {number} skinIndex
 * @return {Promise<Object>}
 */


GLTFParser.prototype.loadSkin = function (skinIndex) {
  var skinDef = this.json.skins[skinIndex];
  var skinEntry = {
    joints: skinDef.joints
  };

  if (skinDef.inverseBindMatrices === undefined) {
    return _promise.default.resolve(skinEntry);
  }

  return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
    skinEntry.inverseBindMatrices = accessor;
    return skinEntry;
  });
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
 * @param {number} animationIndex
 * @return {Promise<fm.AnimationClip>}
 */


GLTFParser.prototype.loadAnimation = function (animationIndex) {
  var json = this.json;
  var animationDef = json.animations[animationIndex];
  var pendingNodes = [];
  var pendingInputAccessors = [];
  var pendingOutputAccessors = [];
  var pendingSamplers = [];
  var pendingTargets = [];

  for (var i = 0, il = animationDef.channels.length; i < il; i++) {
    var channel = animationDef.channels[i];
    var sampler = animationDef.samplers[channel.sampler];
    var target = channel.target;
    var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.

    var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
    var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
    pendingNodes.push(this.getDependency('node', name));
    pendingInputAccessors.push(this.getDependency('accessor', input));
    pendingOutputAccessors.push(this.getDependency('accessor', output));
    pendingSamplers.push(sampler);
    pendingTargets.push(target);
  }

  return _promise.default.all([_promise.default.all(pendingNodes), _promise.default.all(pendingInputAccessors), _promise.default.all(pendingOutputAccessors), _promise.default.all(pendingSamplers), _promise.default.all(pendingTargets)]).then(function (dependencies) {
    var nodes = dependencies[0];
    var inputAccessors = dependencies[1];
    var outputAccessors = dependencies[2];
    var samplers = dependencies[3];
    var targets = dependencies[4];
    var tracks = [];

    for (var i = 0, il = nodes.length; i < il; i++) {
      var node = nodes[i];
      var inputAccessor = inputAccessors[i];
      var outputAccessor = outputAccessors[i];
      var sampler = samplers[i];
      var target = targets[i];
      if (node === undefined) continue;
      node.updateMatrix();
      node.matrixAutoUpdate = true;
      var TypedKeyframeTrack;

      switch (PATH_PROPERTIES[target.path]) {
        case PATH_PROPERTIES.weights:
          TypedKeyframeTrack = fm.NumberKeyframeTrack;
          break;

        case PATH_PROPERTIES.rotation:
          TypedKeyframeTrack = fm.QuaternionKeyframeTrack;
          break;

        case PATH_PROPERTIES.position:
        case PATH_PROPERTIES.scale:
        default:
          TypedKeyframeTrack = fm.VectorKeyframeTrack;
          break;
      }

      var targetName = node.name ? node.name : node.uuid;
      var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : fm.InterpolateLinear;
      var targetNames = [];

      if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
        // Node may be a fm.Group (glTF mesh with several primitives) or a fm.Mesh.
        node.traverse(function (object) {
          if (object.isMesh === true && object.morphTargetInfluences) {
            targetNames.push(object.name ? object.name : object.uuid);
          }
        });
      } else {
        targetNames.push(targetName);
      }

      var outputArray = outputAccessor.array;

      if (outputAccessor.normalized) {
        var scale;

        if (outputArray.constructor === Int8Array) {
          scale = 1 / 127;
        } else if (outputArray.constructor === Uint8Array) {
          scale = 1 / 255;
        } else if (outputArray.constructor == Int16Array) {
          scale = 1 / 32767;
        } else if (outputArray.constructor === Uint16Array) {
          scale = 1 / 65535;
        } else {
          throw new Error('fm.GLTFLoader: Unsupported output accessor component type.');
        }

        var scaled = new Float32Array(outputArray.length);

        for (var j = 0, jl = outputArray.length; j < jl; j++) {
          scaled[j] = outputArray[j] * scale;
        }

        outputArray = scaled;
      }

      for (var j = 0, jl = targetNames.length; j < jl; j++) {
        var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.

        if (sampler.interpolation === 'CUBICSPLINE') {
          track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
            // A CUBICSPLINE keyframe in glTF has three output values for each input value,
            // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
            // must be divided by three to get the interpolant's sampleSize argument.
            return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
          }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.


          track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
        }

        tracks.push(track);
      }
    }

    var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;
    return new fm.AnimationClip(name, undefined, tracks);
  });
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
 * @param {number} nodeIndex
 * @return {Promise<fm.Object3D>}
 */


GLTFParser.prototype.loadNode = function (nodeIndex) {
  var json = this.json;
  var extensions = this.extensions;
  var parser = this;
  var meshReferences = json.meshReferences;
  var meshUses = json.meshUses;
  var nodeDef = json.nodes[nodeIndex];
  return function () {
    var pending = [];

    if (nodeDef.mesh !== undefined) {
      pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
        var node;

        if (meshReferences[nodeDef.mesh] > 1) {
          var instanceNum = meshUses[nodeDef.mesh]++;
          node = mesh.clone();
          node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness

          node.onBeforeRender = mesh.onBeforeRender;

          for (var i = 0, il = node.children.length; i < il; i++) {
            node.children[i].name += '_instance_' + instanceNum;
            node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;
          }
        } else {
          node = mesh;
        } // if weights are provided on the node, override weights on the mesh.


        if (nodeDef.weights !== undefined) {
          node.traverse(function (o) {
            if (!o.isMesh) return;

            for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
              o.morphTargetInfluences[i] = nodeDef.weights[i];
            }
          });
        }

        return node;
      }));
    }

    if (nodeDef.camera !== undefined) {
      pending.push(parser.getDependency('camera', nodeDef.camera));
    }

    if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {
      pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));
    }

    return _promise.default.all(pending);
  }().then(function (objects) {
    var node; // .isBone isn't in glTF spec. See .markDefs

    if (nodeDef.isBone === true) {
      node = new fm.Bone();
    } else if (objects.length > 1) {
      node = new fm.Group();
    } else if (objects.length === 1) {
      node = objects[0];
    } else {
      node = new fm.Object3D();
    }

    if (node !== objects[0]) {
      for (var i = 0, il = objects.length; i < il; i++) {
        node.add(objects[i]);
      }
    }

    if (nodeDef.name !== undefined) {
      node.userData.name = nodeDef.name;
      node.name = fm.PropertyBinding.sanitizeNodeName(nodeDef.name);
    }

    assignExtrasToUserData(node, nodeDef);
    if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

    if (nodeDef.matrix !== undefined) {
      var matrix = new fm.Matrix4();
      matrix.fromArray(nodeDef.matrix);
      node.applyMatrix(matrix);
    } else {
      if (nodeDef.translation !== undefined) {
        node.position.fromArray(nodeDef.translation);
      }

      if (nodeDef.rotation !== undefined) {
        node.quaternion.fromArray(nodeDef.rotation);
      }

      if (nodeDef.scale !== undefined) {
        node.scale.fromArray(nodeDef.scale);
      }
    }

    return node;
  });
};
/**
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
 * @param {number} sceneIndex
 * @return {Promise<fm.Scene>}
 */


GLTFParser.prototype.loadScene = function () {
  // scene node hierachy builder
  function buildNodeHierachy(nodeId, parentObject, json, parser) {
    var nodeDef = json.nodes[nodeId];
    return parser.getDependency('node', nodeId).then(function (node) {
      if (nodeDef.skin === undefined) return node; // build skeleton here as well

      var skinEntry;
      return parser.getDependency('skin', nodeDef.skin).then(function (skin) {
        skinEntry = skin;
        var pendingJoints = [];

        for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
          pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
        }

        return _promise.default.all(pendingJoints);
      }).then(function (jointNodes) {
        node.traverse(function (mesh) {
          if (!mesh.isMesh) return;
          var bones = [];
          var boneInverses = [];

          for (var j = 0, jl = jointNodes.length; j < jl; j++) {
            var jointNode = jointNodes[j];

            if (jointNode) {
              bones.push(jointNode);
              var mat = new fm.Matrix4();

              if (skinEntry.inverseBindMatrices !== undefined) {
                mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
              }

              boneInverses.push(mat);
            } else {
              console.warn('fm.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
            }
          }

          mesh.bind(new fm.Skeleton(bones, boneInverses), mesh.matrixWorld);
        });
        return node;
      });
    }).then(function (node) {
      // build node hierachy
      parentObject.add(node);
      var pending = [];

      if (nodeDef.children) {
        var children = nodeDef.children;

        for (var i = 0, il = children.length; i < il; i++) {
          var child = children[i];
          pending.push(buildNodeHierachy(child, node, json, parser));
        }
      }

      return _promise.default.all(pending);
    });
  }

  return function loadScene(sceneIndex) {
    var json = this.json;
    var extensions = this.extensions;
    var sceneDef = this.json.scenes[sceneIndex];
    var parser = this;
    var scene = new fm.Scene();
    if (sceneDef.name !== undefined) scene.name = sceneDef.name;
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    var nodeIds = sceneDef.nodes || [];
    var pending = [];

    for (var i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
    }

    return _promise.default.all(pending).then(function () {
      return scene;
    });
  };
}();

var _default = GLTFLoader;
exports.default = _default;

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(29);
var aFunction = __webpack_require__(70);
var SPECIES = __webpack_require__(19)('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(36);
var invoke = __webpack_require__(406);
var html = __webpack_require__(169);
var cel = __webpack_require__(115);
var global = __webpack_require__(14);
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (__webpack_require__(77)(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};


/***/ }),
/* 232 */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};


/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(29);
var isObject = __webpack_require__(17);
var newPromiseCapability = __webpack_require__(151);

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var FMVersion = {
  VERSION: '2.7.1',
  BUILD: 1250
};
var _default = FMVersion;
exports.default = _default;

/***/ }),
/* 235 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var EventDispatcher =
/*#__PURE__*/
function () {
  function EventDispatcher() {
    (0, _classCallCheck2.default)(this, EventDispatcher);
  }

  (0, _createClass2.default)(EventDispatcher, [{
    key: "addEventListener",
    value: function addEventListener(type, listener) {
      if (this._listeners === undefined) this._listeners = {};
      var listeners = this._listeners;

      if (listeners[type] === undefined) {
        listeners[type] = [];
      }

      if (listeners[type].indexOf(listener) === -1) {
        listeners[type].push(listener);
      }
    }
  }, {
    key: "hasEventListener",
    value: function hasEventListener(type, listener) {
      if (this._listeners === undefined) return false;
      var listeners = this._listeners;
      return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
    }
  }, {
    key: "removeEventListener",
    value: function removeEventListener(type, listener) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[type];

      if (listenerArray !== undefined) {
        var index = listenerArray.indexOf(listener);

        if (index !== -1) {
          listenerArray.splice(index, 1);
        }
      }
    }
  }, {
    key: "dispatchEvent",
    value: function dispatchEvent(event) {
      if (this._listeners === undefined) return;
      var listeners = this._listeners;
      var listenerArray = listeners[event.type];

      if (listenerArray !== undefined) {
        var array = listenerArray.slice(0);

        for (var i = 0, l = array.length; i < l; i++) {
          array[i].call(this, event);
        }
      }
    }
  }]);
  return EventDispatcher;
}();

var _default = EventDispatcher;
exports.default = _default;

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(53);

var _keys = _interopRequireDefault(__webpack_require__(54));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _Animater = _interopRequireDefault(__webpack_require__(58));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

/**
 *  FMDynamicModel 模型对象，是一种动态对象。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true

 */
var FMDynamicModel =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMDynamicModel, _FMNode);

  /**
   *   @param {object} map
   *   @param {json} param 
   *      @param {string} param.url DynamicModel路径
   *      @param {number} param.coord DynamicModel坐标
   *      @param {number} param.id DynamicModel唯一标识
   *      @param {number} param.color DynamicModel颜色
   *      @param {number} param.scale DynamicModel缩放比例
   *      @param {boolean} param.fadeIn DynamicModel是否开启淡入效果
   *      @param {boolean} param.fadeOut DynamicModel是否开启淡出效果
   *      @param {number} param.rotation DynamicModel旋转角度
   *      @param {function} param.callback model完成动画后的回调函数
   */
  function FMDynamicModel(map, param) {
    var _this;

    (0, _classCallCheck2.default)(this, FMDynamicModel);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMDynamicModel).call(this, param.id ? param.id : fm.Math.generateUUID(), _FMNodeType.default.DYNMODEL));
    _this._url = param.url;
    _this._url = _this._url + '?' + (_this.getRandomNumber() + '' + new Date().getTime()) + '' + _this.getRandomNumber();
    _this._loader = map.nodeManager.getDynLoader();
    _this._mixer = null;
    _this._renderNode = null;
    _this._gltf = null;
    _this._visible = true;
    _this._actions = {};
    _this._color = param.color;
    _this._scale = param.scale;
    _this._rotation = param.rotation;
    _this._moveAnimater = null;
    _this._isMoving = false;
    _this._map = map;
    _this._mapCenter = new fm.Vector2().copy(map.center);
    _this._meshes = [];
    _this._fadeIn = param.fadeIn;
    _this._fadeOut = param.fadeOut;

    _this.init(map, param.coord, param.callback);

    return _this;
  }

  (0, _createClass2.default)(FMDynamicModel, [{
    key: "init",
    value: function init(map, coord, callback) {
      var _this2 = this;

      if (!this._loader) {
        console.error("外部模型加载器缺失");
        return;
      }

      this._height = typeof coord.z === "number" ? coord.z : 5;

      this._loader.load(this._url, function (gltf) {
        if (_this2._fadeIn) _this2.fadeIn(gltf.scene);
        _this2._gltf = gltf;
        _this2._renderNode = gltf.scene;
        _this2._renderNode.name = "oneModel";

        _this2._getMeshes(_this2._renderNode, _this2._meshes);

        if (_this2._color) {
          _this2.setColor(_this2._color);
        }

        if (_this2._scale) {
          _this2.setScale(_this2._scale);
        }

        if (_this2._rotation) {
          _this2.setRotate(_this2._rotation);
        }

        _this2._renderNode.scale.z *= -1;
        _this2._renderNode.mapNode = _this2;
        _this2._mixer = new fm.AnimationMixer(_this2._renderNode);
        map.addAnimationMixer(_this2._mixer);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator2.default)(gltf.animations), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var clip = _step.value;
            _this2._actions[clip.name] = _this2._mixer.clipAction(clip);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        _this2.setPosition(coord.x, coord.y, 0, _this2._height);

        _this2.renderNodeInited = true;
        _this2.visible = true;
        callback && callback(_this2);
      });
    }
  }, {
    key: "lookAt",
    value: function lookAt(mapcoord) {
      if (!this.parent || !this.parent.parent) {
        console.warn("请将模型加载进入地图！");
        return;
      }

      var mcenter = this._map.center;
      var gheight = this.parent.parent.height;
      var pos = new fm.Vector3(mapcoord.x - mcenter.x, gheight + mapcoord.z, -mapcoord.y + mcenter.y);

      this._renderNode.lookAt(pos);
    }
    /**
     * 设置marker位置
     * @param {number} x 地图x坐标
     * @param {number} y 地图y坐标
     * @param {number} gid 楼层id
     * @param {number} height 偏移高度
     */

  }, {
    key: "setPosition",
    value: function setPosition(x, y, gid, height) {
      if (typeof gid === "number" && gid > 0) {
        this.moveToGroup(gid);
      }

      var center = this._mapCenter;
      this._height = height;
      this._x = x;
      this._y = y; // nodeManager.

      this._renderNode.position.set(this._x - center.x, this._height, center.y - this._y);
    }
    /**
     * 将locationMarker水平旋转至特定角度，带动画
     * @param {json} params 
     *      @param {number} params.to 角度
     *      @param {number} params.duration 动画持续时间
     *      @param {function} params.callback 移动到指定位置后的回调函数
     *      @param {function} params.update 动画执行过程中位置更新时的回调函数，返回更新后的位置信息。
     */

  }, {
    key: "rotateTo",
    value: function rotateTo(params) {
      var _this3 = this;

      var src = this._renderNode.rotation.y;
      var dest = params.to % 360 * fm.Math.DEG2RAD;

      if (this.rotateAnimater) {
        this.rotateAnimater.stop();

        this._map.removeAnimater(this.rotateAnimater);
      }

      var animater = new _Animater.default({
        angle: src
      }, {
        angle: dest
      }, params.duration ? params.duration * 1000 : 500, function () {
        _this3._map.removeAnimater(animater);

        _this3.rotateAnimater = null;
        params.callback && params.callback();
      }, function (cast) {
        _this3._renderNode.rotation.y = cast.angle;
        params.update && params.update();
      }).start();

      this._map.addAnimater(animater);

      this.rotateAnimater = animater;
    }
  }, {
    key: "setRotate",
    value: function setRotate(angle) {
      this._renderNode.rotation.y = angle % 360 * fm.Math.DEG2RAD;
    }
    /**
     * 设置模型显示比例
     * @param {number} scale 显示比例
     */

  }, {
    key: "setScale",
    value: function setScale(scale) {
      var children = this._renderNode.children;

      for (var i = 0; i < children.length; i++) {
        children[i].scale.x = scale;
        children[i].scale.y = scale;
        children[i].scale.z = scale;
      }
      /* let meshes = this._meshes;
      //console.log(meshes);
       for (let i = 0; i < meshes.length; i++) {
             let mesh = meshes[i];
           mesh.scale.x = mesh.scale.x*scale;
      mesh.scale.y = mesh.scale.y*scale;
      mesh.scale.z = mesh.scale.z*scale;
       }*/

    }
    /**
     * 设置模型着色颜色
     * @param {string|int} color 颜色值 
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      var colour = new fm.Color(color);
      var meshes = this._meshes;

      for (var i = 0; i < meshes.length; i++) {
        var mesh = meshes[i];
        mesh.material.color.r = colour.r;
        mesh.material.color.g = colour.g;
        mesh.material.color.b = colour.b;
      }
    }
  }, {
    key: "fadeIn",
    value: function fadeIn(scene) {
      scene.traverse(function (mesh) {
        if (mesh instanceof fm.Mesh) {
          mesh.material.transparent = true;
          mesh.material.opacity = 0;
          var interval = setInterval(function () {
            if (mesh.material.opacity < 1) {
              mesh.material.opacity += 0.05;
            } else {
              clearInterval(interval);
            }
          }, 200);
        }
      });
    }
  }, {
    key: "setHeight",
    value: function setHeight(h) {
      this.setPosition(this._x, this._y, 0, h);
    }
  }, {
    key: "setAngle",
    value: function setAngle(a) {
      this._renderNode && (this._renderNode.rotation.y = a * fm.Math.DEG2RAD);
    }
    /**
     * 开始播放模型对象的骨骼动画
     * @param {string} name 模型对象的骨骼动画name名称 
     * @param {number} duration 过渡时间 
     * @param {boolean} isState 是否只执行一次动画，默认是循环执行 
     */

  }, {
    key: "startAction",
    value: function startAction(name) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.2;
      var isState = arguments.length > 2 ? arguments[2] : undefined;
      var action = this._actions[name];

      if (action) {
        if (isState) {
          action.clampWhenFinished = true;
          action.loop = fm.LoopOnce;
        }

        action.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).play();
      }
    }
    /**
     * 停止播放模型对象的骨骼动画
     * @param {string} name 模型对象的骨骼动画name名称 
     * @param {number} duration 过渡时间 
     */

  }, {
    key: "stopAction",
    value: function stopAction(name) {
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.2;
      var action = this._actions[name];
      action && action.fadeOut(duration);
    }
  }, {
    key: "getActionList",
    value: function getActionList() {
      return (0, _keys.default)(this._actions);
    }
    /**
     * 以动画方式将marker到指定位置
     * @param {object} params 
     * @param {number} params.x 指定点x坐标
     * @param {number} params.y 指定点y坐标
     * @param {number} time 移动到指定点所需的时间 
     */

  }, {
    key: "moveTo",
    value: function moveTo(params) {
      var _this4 = this;

      if (this._isMoving) return;
      var nodeManager = this.findParent(_NodeManager.default);
      var destx = params.x;
      var desty = params.y;

      if (!params.time) {
        params.time = 0.5;
      }

      var animater = new _Animater.default({
        x: this.x,
        y: this.y
      }, {
        x: destx,
        y: desty
      }, params.time * 1000, function () {
        nodeManager.map.removeAnimater(animater);
        _this4._moveAnimater = null;
        _this4._isMoving = false;

        if (params.callback) {
          params.callback();
        }
      }, function (coord) {
        _this4.setPosition(coord.x, coord.y, 0, _this4._height);

        if (params.update) {
          params.update(coord);
        }
      }).start();
      this._isMoving = true;
      nodeManager.map.addAnimater(animater);
      this._moveAnimater = animater;
    }
    /**
      * 停止moveTo动画
      */

  }, {
    key: "stopMoveTo",
    value: function stopMoveTo() {
      var nodeManager = this.findParent(_NodeManager.default);
      this._moveAnimater && this._moveAnimater.stop();
      nodeManager.map.removeAnimater(this._moveAnimater);
      this._isMoving = false;
      this._moveAnimater = null;
    }
    /**
    * 将marker移动到另一楼层
    * @param {number} gid 楼层id
    */

  }, {
    key: "moveToGroup",
    value: function moveToGroup(gid) {
      var nodeManager = this.findParent(_NodeManager.default);
      var currGid = this.parent.parent.groupID;

      if (currGid === gid) {
        return;
      }

      if (!this.parent.parent.parent.groups["" + gid]) {
        console.warn(tileMessage.noGroup);
        return;
      }

      this._groupId = gid;
      var toLayer = this.parent.parent.parent.groups["" + gid].getOrCreateLayer("dynmodel");
      this.parent.untiedMarker(this);
      toLayer.addNodes(this);
    }
  }, {
    key: "_getMeshes",
    value: function _getMeshes(objec3D, meshes) {
      if (objec3D instanceof fm.Mesh) {
        objec3D.material = objec3D.material.clone();
        meshes.push(objec3D);
      } else if (objec3D.children) {
        for (var i = 0; i < objec3D.children.length; i++) {
          this._getMeshes(objec3D.children[i], meshes);
        }
      }
    }
  }, {
    key: "getRandomNumber",
    //避免url重复，制作一个生成随机数的方法，doublechang
    value: function getRandomNumber() {
      var count = 100;
      var randomnumber = new Array();

      for (var i = 0; i < count; i++) {
        randomnumber[i] = i + 1;
      }

      randomnumber.sort(function () {
        return 0.5 - Math.random();
      });
      return randomnumber[Math.floor(Math.random() * count)];
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._renderNode.mapNode = null;
    }
  }, {
    key: "visible",
    set: function set(bool) {
      if (bool) {
        if (this.parent && this.parent.scene.children.indexOf(this._renderNode) < 0) {
          this._renderNode && this.parent.scene.add(this._renderNode);
        }
      } else {
        this._renderNode && this.parent.scene.remove(this._renderNode);
        this._renderNode.parent = this.parent.scene;
      }

      this._visible = bool;
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    },
    set: function set(r) {
      this._renderNode = r;
      this._renderNode.mapNode = this;

      if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
        this._renderNode && this.parent.scene.add(this._renderNode);
      } // this._getMeshes(this._renderNode,this._meshes);

    }
  }, {
    key: "mapCoord",
    get: function get() {
      if (!this.parent || !this.parent.parent) {
        console.warn("请将模型加载进入地图！");
        return;
      }

      var mcenter = this._map.center;
      var gheight = this.parent.parent.height;
      var pos = this._renderNode.position;
      return new fm.Vector3(pos.x + mcenter.x, mcenter.y - pos.z, -gheight + pos.y);
    }
  }]);
  return FMDynamicModel;
}(_FMNode2.default);

var _default = FMDynamicModel;
exports.default = _default;

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

/**
 * 手势控制类，通过FMMap.gestureEnableController属性获取。
 * @class
 * @memberof fengmap
 * @hideconstructor true
 */
var FMMapGestureEnableController = function FMMapGestureEnableController() {
  (0, _classCallCheck2.default)(this, FMMapGestureEnableController);

  /**
   * 设置能否移动模型
   * @property  {boolean} value 【true】是可移动，【false】不可移动
   */
  this.enableMapPan = true;
  /**
   * 设置能否旋转模型
   * @property  {boolean} value 【true】是可旋转，【false】不可旋转
   */

  this.enableMapRotate = true;
  /**
   * 设置能否倾斜模型
   * @property  {boolean} value 【true】是可倾斜，【false】不可倾斜
   */

  this.enableMapIncline = true;
  /**
   * 设置能否缩放
   * @property  {boolean} value 【true】是可缩放，【false】不可缩放
   */

  this.enableMapPinch = true;
  /**
   * 设置能否拾取
   * @property  {boolean} value 【true】是可拾取，【false】不可拾取
   */

  this.enableMapSingleTap = true;
  /**
      * 设置能否悬停(PC)
      * @property  {boolean} value 【true】是可悬停，【false】不可悬停
      */

  this.enableMapHover = false;
};

var _default = FMMapGestureEnableController;
exports.default = _default;

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(13);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMAjax = _interopRequireDefault(__webpack_require__(202));

var _WKTReader = _interopRequireDefault(__webpack_require__(207));

var _ArrayReader = _interopRequireDefault(__webpack_require__(208));

/**
 *	NaviService 是对路径规划所用数据进行请求查询的服务模块
 * 	@class NaviService
 *	@constructor
 * 	@module NaviService
 */
'use strict';

var NaviService =
/*#__PURE__*/
function () {
  function NaviService(options) {
    (0, _classCallCheck2.default)(this, NaviService);
    this._options = options;
    this._staticNaviScene = null;
    this._wktReader = new _WKTReader.default();
    this._scene = null;
  }

  (0, _createClass2.default)(NaviService, [{
    key: "setScene",
    value: function setScene(scene) {
      this._scene = scene;
    }
  }, {
    key: "queryScene",
    value: function queryScene(sceneId, success, fail) {
      var url;
      var this_ = this;

      if (this._options.useStatic) {
        url = this._options.naviServerURL + '/' + sceneId + '.fmap';
        new _FMAjax.default(url, function (d) {
          var scene = this_._convertStatic1(d);

          success(scene.scene_data);
        }, true);
      } else {
        url = this._options.naviServerURL + '/' + sceneId; //访问多个 .fmap文件,从id.scene.fmap开始

        new _FMAjax.default(url, function (d) {
          var scene = this_._convertSite1(d); //					console.log(scene);


          success(scene.scene_data);
        }, true);
      }
    }
  }, {
    key: "queryNaviData",
    value: function queryNaviData(sceneId, groupId, success, fail) {
      var this_ = this;

      if (this._options.useStatic) {
        var group = this_._convertStatic2(groupId); //console.log(group);			


        success(group);
      } else {
        var geo = null;
        var biz = null;
        var nav = null;
        var this_ = this;
        new _FMAjax.default(this._options.naviServerURL + '/group_v2/' + sceneId + '/' + groupId + '/geo', function (d) {
          geo = d;

          if (geo != null && biz != null && nav != null) {
            var group = this_._convertSite2(groupId, geo, biz, nav);

            success(group);
          }
        }, true);
        new _FMAjax.default(this._options.naviServerURL + '/group_v2/' + sceneId + '/' + groupId + '/biz', function (d) {
          biz = d;

          if (geo != null && biz != null && nav != null) {
            var group = this_._convertSite2(groupId, geo, biz, nav);

            success(group);
          }
        }, true);
        new _FMAjax.default(this._options.naviServerURL + '/group_v2/' + sceneId + '/' + groupId + '/navi', function (d) {
          nav = d;

          if (geo != null && biz != null && nav != null) {
            var group = this_._convertSite2(groupId, geo, biz, nav);

            success(group);
          }
        }, true);
      }
    }
  }, {
    key: "convertToGroup",
    value: function convertToGroup(groupId, geo_s, biz_s, nav_s) {
      return this._convertToGroup(groupId, geo_s, biz_s, nav_s);
    }
  }, {
    key: "convertGeo2Geometry",
    value: function convertGeo2Geometry(data, extent) {
      return this._convertGeo2Geometry(data, extent);
    }
  }, {
    key: "convertArray2Geometry",
    value: function convertArray2Geometry(idxs, pts) {
      return this._convertArray2Geometry(idxs, pts);
    }
  }, {
    key: "_convertSite1",
    value: function _convertSite1(d) {
      var scene = fmSceneDecode(d);
      var d = {
        //sid:0,
        scene_data: scene
      };
      /*var layerGroups = scene.layerGroups; 
      for (var i=0; i<layerGroups.length; i++) {
          var lg = layerGroups[i];
          lg.elevation = lg.height;
      }*/

      return d;
    }
  }, {
    key: "_convertSite2",
    value: function _convertSite2(groupId, r_geo, r_biz, r_nav) {
      //			console.log(r_geo, r_biz, r_nav);
      var geo = fmFloorGeoDecode(r_geo);
      var biz = fmFloorBizDecode(r_biz);
      var nav = fmFloorNaviDecode(r_nav); //
      //console.log(geo,biz,nav);

      return this._convertToGroup(groupId, geo, biz, nav);
    }
  }, {
    key: "_convertGeo2Geometry",
    value: function _convertGeo2Geometry(data, extent) {
      //ArrayReader
      var gd = this._wktReader.parse(data);

      return {
        'points': gd._points,
        'holes': gd._holes
      };
    }
  }, {
    key: "_convertArray2Geometry",
    value: function _convertArray2Geometry(idxs, pts) {
      var gd = new _ArrayReader.default().parseGeometry(idxs, pts);
      /*console.log(132,idxs);
      console.log(133,pts);
      console.log(134,{'points':gd._points,'holes':gd._holes})*/

      return {
        'points': gd._points,
        'holes': gd._holes
      };
    } //#20160406,Samuel,Copy from v0.2

  }, {
    key: "_tempFlipX",
    value: function _tempFlipX(data) {
      if (data && typeof data != 'string') {
        //console.log(data, typeof(data)); 
        for (var k in data) {
          var d = data[k];

          if (k == 'vertices' || k == 'vertex') {
            for (var i in d) {
              if (i % 2 == 0) {
                d[i] = -d[i];
              }
            }
          } else if (k == 'scene_data') {
            d.x = -d.x;
            d.defCenX = -d.defCenX;
          } else {
            this._tempFlipX(d);
          }
        }
      }
    } //根据返回的结点关联楼层对象解析成数组。有中间有|分割的数组

  }, {
    key: "_convertStringToArray",
    value: function _convertStringToArray(str) {
      if (str == "" || !str) return [];
      var res = [];
      var tmp = str;
      var tmpArr = []; //tmp = tmp.replace(new RegExp(/(,)/g),'');

      if (tmp.indexOf('|') >= 0 || tmp.indexOf('-') >= 0 || tmp.indexOf(',') >= 0) {
        tmpArr = tmp.split(/[|,-]/);
        res.push.apply(res, tmpArr);
      } else res.push(tmp);

      return res;
    }
  }, {
    key: "_convertStatic1",
    value: function _convertStatic1(d) {
      this._staticNaviScene = fmMapDecode(d, false); //console.log(this.staticScene_);

      var d = {
        //sid:0,
        scene_data: this._staticNaviScene.scene
      };
      /*var layerGroups = d.scene_data.layerGroups; 
      for (var i=0; i<layerGroups.length; i++) {
          var lg = layerGroups[i];
          lg.elevation = lg.height;
      }*/
      //console.log(d);

      return d;
    }
  }, {
    key: "_convertStatic2",
    value: function _convertStatic2(groupId) {
      //			console.log('_convertStatic2', groupId);
      var floors = this._staticNaviScene.floors;

      for (var i = 0; i < floors.length; i++) {
        var floor = floors[i];

        if (floor.gid == groupId) {
          return this._convertToGroup(groupId, floor.geo[0], floor.biz[0], floor.navi[0]);
        }
      }

      return null;
    }
  }, {
    key: "_convertToGroup",
    value: function _convertToGroup(groupId, geo_s, biz_s, nav_s) {
      //biz, geo, navi
      var hash_labels = {};
      var models = [];
      var extents = [];
      var nodes = [];
      var roads = [];
      var zones = [];
      var file_ver = this._scene.scene.file_ver;

      for (var j = 0, jlen = geo_s.extentLayer.length; j < jlen; j++) {
        var extlayer = geo_s.extentLayer[j];
        var geo = null;

        if (file_ver === 1) {
          geo = this._convertGeo2Geometry(extlayer.geo); //doublechang	
        } else {
          geo = this._convertArray2Geometry(extlayer.idxs, extlayer.pts);
        }

        extlayer.geoArr = geo.points;
        extlayer.holes = geo.holes;
        extents.push(extlayer);
      }

      for (var i = 0, ilen = geo_s.labelLayer.length; i < ilen; i++) {
        hash_labels[geo_s.labelLayer[i].eid] = geo_s.labelLayer[i];
      }

      for (var k = 0, klen = geo_s.modelLayer.length; k < klen; k++) {
        var geoModel = geo_s.modelLayer[k];
        var bizModel = biz_s.modelLayer[k];
        var model = {};
        model.fid = bizModel.fid;
        model.eid = geoModel.eid;
        model.pass = bizModel.pass; //--useless 

        if (file_ver === 1) {
          model.center = this._convertGeo2Geometry(hash_labels[geoModel.eid].geo).points[0];
        } else {
          model.center = this._convertArray2Geometry(hash_labels[geoModel.eid].idxs, hash_labels[geoModel.eid].pts).points[0];
        }

        var _geo = null;

        if (file_ver === 1) {
          _geo = this._convertGeo2Geometry(geoModel.geo);
        } else {
          _geo = this._convertArray2Geometry(geoModel.idxs, geoModel.pts);
        }

        model.geoArr = _geo.points;
        model.holes = _geo.holes;
        models.push(model);
      }

      for (var m = 0, mlen = nav_s.naviNodes.length; m < mlen; m++) {
        var node = nav_s.naviNodes[m];

        if (file_ver === 1) {
          node.geoArr = this._convertGeo2Geometry(node.geo).points[0];
        } else {
          node.geoArr = this._convertArray2Geometry(node.idxs, node.pts).points[0];
        }

        node.linkSegArr = this._convertStringToArray(node.linkSeg);
        node.liftFloorArr = this._convertStringToArray(node.liftFloor);
        nodes.push(node);
      }

      for (var n = 0, nlen = nav_s.naviSegments.length; n < nlen; n++) {
        var road = nav_s.naviSegments[n];

        if (file_ver === 1) {
          road.geoArr = this._convertGeo2Geometry(road.geo).points;
        } else {
          road.geoArr = this._convertArray2Geometry(road.idxs, road.pts).points;
        }

        road.m_Id = nav_s.mid;
        roads.push(road);
      }

      if (nav_s.naviZones) {
        for (var o = 0, nlen = nav_s.naviZones.length; o < nlen; o++) {
          var zone = nav_s.naviZones[o];
          var _geo2 = null;

          if (file_ver === 1) {
            _geo2 = this._convertGeo2Geometry(zone.geo);
          } else {
            _geo2 = this._convertArray2Geometry(zone.idxs, zone.pts);
          }

          zone.geoArr = _geo2.points;
          zone.holes = _geo2.holes;
          zone.m_Id = nav_s.mid;
          zones.push(zone);
        }
      }

      var d = {
        gid: groupId,
        extentLayer: extents,
        modelLayer: models,
        naviSegments: roads,
        naviNodes: nodes,
        naviZones: zones
      };
      return d;
    }
  }]);
  return NaviService;
}();

var _default = NaviService;
exports.default = _default;

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(48);

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

__webpack_require__(53);

__webpack_require__(8);

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _Enum = __webpack_require__(109);

var _CompassGeometry = _interopRequireDefault(__webpack_require__(228));

var _WaterMaterial = _interopRequireDefault(__webpack_require__(417));

var _FMGlobal = _interopRequireDefault(__webpack_require__(110));

/**
 *
 *    FMRenderer 是对地图元素渲染器，根据地图元素生成图形
 *    @class FMRenderer
 *    @constructor
 *    @module FMRenderer
 *
 */
// import { EffectComposer } from './pass/EffectComposer.js';
// import { ShaderPass } from './pass/ShaderPass.js';
// import { RenderPass } from './pass/RenderPass.js';
// import { UnrealBloomPass } from './pass/UnrealBloomPass.js';
var waterMesh;
var aspect_;
/**
 * 绘制logo
 * @param aspect 宽高比
 * @param map 地图
 */

function drawWater(aspect, map) {
  if (!_FMGlobal.default.d) return;
  aspect_ = aspect;

  var texture = _FMGlobal.default.d();

  texture.minFilter = fm.LinearFilter;
  texture.generateMipmaps = false;
  var width = 0.4;
  var scale = new fm.Vector2(width, width * 0.12 / 0.5);
  var material = new _WaterMaterial.default();
  material.transparent = true;
  material.uniforms["scale"] = {
    value: scale
  };
  var offsetx = -1 * (0.5 * scale.x / aspect - 1.0);
  var offsety = -1 * (1.0 - 0.5 * scale.y);
  material.uniforms["offset"] = {
    value: new fm.Vector2(offsetx, offsety)
  };
  material.uniforms["mmap"] = {
    value: texture
  };
  material.needsUpdate = true;
  var geometry = new _CompassGeometry.default();
  var water = new fm.Mesh(geometry, material);
  water.frustumCulled = false;
  _FMGlobal.default[map.uuid]["f"] = water; // waterMesh = new fm.Mesh(geometry, material);
  // waterMesh.frustumCulled = false;;
}

var FMRenderer =
/*#__PURE__*/
function () {
  function FMRenderer(options, map) {
    (0, _classCallCheck2.default)(this, FMRenderer);
    this.container = options.container;
    this.renderer = null;
    this._map = map; // global[map.uuid] = {};

    this._clearColor = 0xffffff;
    this._clearAlpha = 1;
    this._viewMode = map._viewMode;
    this._w = this.container.clientWidth;
    this._h = this.container.clientHeight;
    this._spriteRenderHeight = 15; //labelSprite渲染一行设定高度

    this._poiSpriteHeight = 15;
    this._logarithmicDepthBuffer = typeof options.logarithmicDepthBuffer === "boolean" ? options.logarithmicDepthBuffer : false;
    this.init();
    this._envMap = null;
    this._renderList = [];
    this._showCompass = false;
    this._compassNode = null;
    this._lineMarkerScene = new fm.Scene(); // 最后一个渲染组

    this._backrenderScene = new fm.Scene();
    this.background = new fm.Scene();
    this._backrenderScene.userData.type = "lastScene";
    this._firstRender = false;
    this.particleEffect = null;
    this.isParticleEffect = false;
    this.isSkyEffect = false;
    this.SkyEffect = null;
    this.autoTime = false;
    this._time = new Date().getTime();
    this._delTime = new Date().getTime();
    this._sweep = {};
    this._sweep.startPoint = null;
    this._sweep.length = 0;
    this._sweep.min = 0;
    this._sweep.maxR = 10;
    this._sweep.minR = 0;
    this.reflectEffect = null;
    drawWater(this._w / this._h, map); // this.water = drawWater(this._w / this._h);
  }
  /**
   * 获取当前相机的视锥
   */


  (0, _createClass2.default)(FMRenderer, [{
    key: "getFrustumByViewMode",
    value: function getFrustumByViewMode(viewMode) {
      var camera = viewMode === "3d" ? this.perspectiveCamera : this.orthographicCamera;
      camera.updateMatrixWorld(true);
      return new fm.Frustum().setFromProjectionMatrix(new fm.Matrix4().multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse));
    }
    /**
     *
     * @param {*} srcHeight
     * @param {*} needHeight
     */

  }, {
    key: "getScaleByPixels",
    value: function getScaleByPixels(srcHeight, needHeight) {
      return needHeight / (srcHeight / 2 * this.domElementHeight);
    }
    /**
     * 添加图片背景方法
     * @param {str} src 图片路径
     */

  }, {
    key: "setBackground",
    value: function setBackground(src) {
      this.background.background = new fm.TextureLoader().load(src);
    }
  }, {
    key: "setParticleEffect",
    value: function setParticleEffect(particleEffect) {
      this.particleEffect = particleEffect;
    }
  }, {
    key: "setSkyEffect",
    value: function setSkyEffect(skyEffect) {
      this.skyEffect = skyEffect;
    }
  }, {
    key: "setReflectEffect",
    value: function setReflectEffect(reflectEffect) {
      this.reflectEffect = reflectEffect;
    }
  }, {
    key: "resetCompass",
    value: function resetCompass() {
      if (!this.compassNode) return;
      var aspect = this.getAspect();
      var scale = this.getScaleByPixels(1, this._map.MapOptions.compassSize);
      var otop = -this.getScaleByPixels(1, this._map.MapOptions.compassOffset[1]);
      var oleft = this.getScaleByPixels(1, this._map.MapOptions.compassOffset[0]) / aspect; // aspect,  ,oleft ,otop

      var offset = this.getCompassOffset(this._map.MapOptions.compassPosition, scale, aspect, oleft, otop);
      this.compassNode.material.uniforms["scale"] = {
        value: scale
      };
      this.compassNode.material.uniforms["offset"] = {
        value: new fm.Vector2(offset.ox, offset.oy)
      };
      this.compassNode.userData.coord = {
        x: offset.ox,
        y: offset.oy
      };
      this.compassNode.userData.width = 0.5 * scale;
    }
  }, {
    key: "getCompassOffset",
    value: function getCompassOffset(position, scale, aspect, left, top) {
      var flipx = 1;
      var flipy = 1;

      switch (position) {
        case 3:
          flipx = -1;
          break;

        case 2:
          flipy = -1;
          break;

        case 4:
          flipy = -1;
          flipx = -1;
          break;
      }

      var offsetx = flipx * (0.5 * scale / aspect - 1.0);
      var offsety = flipy * (1.0 - 0.5 * scale);
      return {
        ox: offsetx + left,
        oy: offsety + top
      };
    }
  }, {
    key: "resetLocationsSize",
    value: function resetLocationsSize() {
      var scenes = this.renderList;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(scenes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var scene = _step.value;

          if (scene.userData.type === "location") {
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = (0, _getIterator2.default)(scene.children), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var location = _step2.value;
                this.setLocationSize(location, location.mapNode.size);
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     *
     * @param {*} fa
     * @param {*} size
     */

  }, {
    key: "setLocationSize",
    value: function setLocationSize(fa, size) {
      if (this._viewMode === "3d") {
        var modelViewMatrix = new fm.Matrix4();
        modelViewMatrix.multiplyMatrices(this.perspectiveCamera.matrixWorldInverse, fa.matrixWorld);
        var center = new fm.Vector3().applyMatrix4(modelViewMatrix);
        var scale = size / (this.container.clientHeight / (2 * Math.tan(this.perspectiveCamera.fov * fm.Math.DEG2RAD / 2))) * Math.abs(center.z);
        fa.scale.set(scale, scale, scale); // fa.scale.multiplyScalar(fa.material.userData.mspriteScale);
        // fa.scale.setX(  fa.scale.x/fa.material.userData.scaleRatio );
      } else {
        var _scale = size * Math.abs(this.orthographicCamera.top - this.orthographicCamera.bottom) / this.orthographicCamera.zoom / this.container.clientHeight;

        fa.scale.set(_scale, _scale, _scale); // fa.scale.multiplyScalar(fa.material.userData.mspriteScale);
        // fa.scale.setX(  fa.scale.x/fa.material.userData.scaleRatio );
      }
    }
    /**
     *
     * @param {*} fa
     * @param {*} size
     */

  }, {
    key: "setLabelSize",
    value: function setLabelSize(fa, size) {
      if (this._viewMode === "3d") {
        var scale = size / (this.container.clientHeight / (2 * Math.tan(this.perspectiveCamera.fov * fm.Math.DEG2RAD / 2)));

        if (isNaN(scale)) {
          scale = 1;
        }

        fa.scale.set(scale, scale, scale);
        fa.scale.multiplyScalar(fa.material.userData.mspriteScale);
        fa.scale.setX(fa.scale.x / fa.material.userData.scaleRatio);
      } else {
        var _scale2 = size * Math.abs(this.orthographicCamera.top - this.orthographicCamera.bottom) / this.orthographicCamera.zoom / this.container.clientHeight;

        if (isNaN(_scale2)) {
          _scale2 = 1;
        }

        fa.scale.set(_scale2, _scale2, _scale2);
        fa.scale.multiplyScalar(fa.material.userData.mspriteScale);
        fa.scale.setX(fa.scale.x / fa.material.userData.scaleRatio);
      }
    }
    /**
     *
     */

  }, {
    key: "setFacilitySize",
    value: function setFacilitySize(fa, size) {
      var scale;
      var scaleRatio = 1;

      if (this._viewMode === "3d") {
        scale = size / (this.container.clientHeight / (2 * Math.tan(this.perspectiveCamera.fov * fm.Math.DEG2RAD / 2))); // fa.scale.set(scale, scale, scale);
      } else {
        scale = size * Math.abs(this.orthographicCamera.top - this.orthographicCamera.bottom) / this.orthographicCamera.zoom / this.container.clientHeight; // fa.scale.set(scale, scale, scale);
      }

      if (fa.material.userData.scaleRatio) {
        scaleRatio = fa.material.userData.scaleRatio;
      }

      fa.scale.set(scale, scale / scaleRatio, scale);
    }
    /**
     * 设置ImageMarker大小
     * @param imageMarker
     */

  }, {
    key: "setImageMarkerSize",
    value: function setImageMarkerSize(imageMarker) {
      var scale;
      var scaleRatio = 1;

      if (this._viewMode === "3d") {
        scale = imageMarker.material.userData.size / (this.container.clientHeight / (2 * Math.tan(this.perspectiveCamera.fov * fm.Math.DEG2RAD / 2)));
      } else {
        scale = imageMarker.material.userData.size * Math.abs(this.orthographicCamera.top - this.orthographicCamera.bottom) / this.orthographicCamera.zoom / this.container.clientHeight; // imageMarker.scale.set(scale, scale, scale);
      }

      if (imageMarker.material) {
        scaleRatio = imageMarker.material.userData.scaleRatio;
      }

      if (isNaN(scaleRatio)) {
        scaleRatio = 1;
      }

      imageMarker.scale.set(scale, scale / scaleRatio, scale);
    }
    /**
     *楼层解析
     */

  }, {
    key: "parseGroup",
    value: function parseGroup(group) {
      var renderGroup = [];

      var layers = group._getLayers(false);

      this.getShadowScene();
      var renderArray = this.shadowscene.children;

      for (var layerName in layers) {
        var ls = layers[layerName];

        if (this.needshadow) {
          if (layerName === "model" || layerName === "extent") {
            var _iteratorNormalCompletion3 = true;
            var _didIteratorError3 = false;
            var _iteratorError3 = undefined;

            try {
              for (var _iterator3 = (0, _getIterator2.default)(ls[0].children), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                var m = _step3.value;

                if (m instanceof fm.Mesh) {
                  renderArray.push(m);
                }
              }
            } catch (err) {
              _didIteratorError3 = true;
              _iteratorError3 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                  _iterator3.return();
                }
              } finally {
                if (_didIteratorError3) {
                  throw _iteratorError3;
                }
              }
            }

            continue;
          }
        }

        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = (0, _getIterator2.default)(ls), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var l = _step4.value;
            l.renderOrder = _Enum.LayerOrder[layerName];
            l.e_id = group.eid;
            renderGroup.push(l);
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      if (this.needshadow) {
        this.shadowscene.renderOrder = _Enum.LayerOrder["model"];
        renderGroup.push(this.shadowscene);
      }

      group.locationScene.renderOrder = _Enum.LayerOrder["location"];
      renderGroup.push(group.locationScene);
      group.lineScene.renderOrder = _Enum.LayerOrder["line"];
      renderGroup.push(group.lineScene);
      return renderGroup;
    }
  }, {
    key: "getShadowScene",
    value: function getShadowScene() {
      this.shadowscene = new fm.Scene();
      var ambientLight = new fm.AmbientLight(0x747474);
      var target = new fm.Object3D(); // target.position.set(10,-20,1);

      var mainLight = new fm.DirectionalLight(0x888888, 1.2);
      mainLight.position.set(-1, 1, 1);
      mainLight.target = target;
      mainLight.castShadow = true;
      mainLight.shadow.camera = new fm.OrthographicCamera(-100, 100, 100, -100, 0.5, 1000);
      mainLight.shadow.mapSize.width = 720 * window.devicePixelRatio;
      mainLight.shadow.mapSize.height = 610 * window.devicePixelRatio;
      var secondLight = new fm.DirectionalLight(0x333333);
      secondLight.position.set(-0.5, 1, -1).normalize();
      secondLight.target = target; // secondLight.castShadow = true;

      this.shadowscene.add(mainLight);
      this.shadowscene.add(ambientLight);
      this.shadowscene.add(secondLight);
      this.shadowscene.add(target);
    }
    /**
     * 解析待渲染的group
     * @param {*} renderList
     * @param {*} type
     */

  }, {
    key: "parseList",
    value: function parseList(renderList, type) {
      var _this = this;

      var sceneArray = []; // let backRenders = [];

      if (renderList) {
        var _iteratorNormalCompletion5 = true;
        var _didIteratorError5 = false;
        var _iteratorError5 = undefined;

        try {
          for (var _iterator5 = (0, _getIterator2.default)(renderList), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
            var scene = _step5.value;
            var _iteratorNormalCompletion6 = true;
            var _didIteratorError6 = false;
            var _iteratorError6 = undefined;

            try {
              var _loop = function _loop() {
                var group = _step6.value;

                var renderGroup = _this.parseGroup(group); // backRenders.push(...group.alwaysShowMarkers);


                var models = [];

                for (var i = 0; i < renderGroup.length; i++) {
                  if (renderGroup[i].name === "model") {
                    renderGroup[i].traverse(function (mesh) {
                      if (mesh.name === "oneModel") {
                        models.push(mesh);
                      }
                    });
                  } else if (renderGroup[i].name === "dynmodel") {
                    renderGroup[i].traverse(function (mesh) {
                      if (mesh.name === "oneModel") {
                        models.push(mesh);
                      }
                    });
                  } else if (renderGroup[i].name === "extent") {
                    renderGroup[i].traverse(function (mesh) {
                      if (mesh.name === "oneExtent") {
                        models.push(mesh);
                      }
                    });
                  }
                }

                for (var _i = 0; _i < renderGroup.length; _i++) {
                  if (renderGroup[_i].name === "waterMarker") {
                    var goon = false;

                    renderGroup[_i].traverse(function (mesh) {
                      if (mesh instanceof fm.Mesh && mesh.name === "water") return goon = true;
                    });

                    if (!!goon) {
                      for (var a = 0; a < models.length; a++) {
                        renderGroup[_i].add(models[a]);
                      }
                    }
                  }
                }

                renderGroup.sort(function (a, b) {
                  return a.renderOrder - b.renderOrder;
                });
                sceneArray = sceneArray.concat(renderGroup);
              };

              for (var _iterator6 = (0, _getIterator2.default)(scene), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
                _loop();
              }
            } catch (err) {
              _didIteratorError6 = true;
              _iteratorError6 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
                  _iterator6.return();
                }
              } finally {
                if (_didIteratorError6) {
                  throw _iteratorError6;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError5 = true;
          _iteratorError5 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
              _iterator5.return();
            }
          } finally {
            if (_didIteratorError5) {
              throw _iteratorError5;
            }
          }
        }
      } // this._backrenderScene.children = backRenders;
      // sceneArray.push(backrenderScene);


      return sceneArray;
    }
  }, {
    key: "setBackRender",
    value: function setBackRender(arr) {
      this._backrenderScene.children = arr;
    }
    /**
     * 初始化renderer
     */

  }, {
    key: "init",
    value: function init() {
      this.renderer = this._map.render;
      this.renderer.setClearColor(this._clearColor, this._clearAlpha);
      var w = this.container.clientWidth;
      var h = this.container.clientHeight;
      this.renderer.setSize(w, h);
      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.shadowMap.enabled = true;
      this.renderer.shadowMap.type = fm.PCFSoftShadowMap;
      this.renderer.autoClear = false;
      this.canvas = this._map.canvas;
      this.container.appendChild(this.canvas);
      this.orthographicCamera = this._map.orthographicCamera;
      this.perspectiveCamera = this._map.perspectiveCamera; // try {
      //   if (this._logarithmicDepthBuffer) {
      //     this.renderer = new fm.WebGLRenderer({
      //       antialias: true,
      //       alpha: true,
      //       logarithmicDepthBuffer: true
      //     });
      //   } else {
      //     this.renderer = new fm.WebGLRenderer({
      //       antialias: true,
      //       alpha: true
      //     });
      //   }
      // } catch (ex) {
      //   console.error('WebGLRenderer ERROR: ', ex);
      //   new fengmap.MapError().noWebGL(this.container);
      //   return false;
      // }
      // //camera3d
      // var w = this.container.clientWidth;
      // var h = this.container.clientHeight;
      // this.renderer.setClearColor(this._clearColor, this._clearAlpha);
      // this.renderer.setSize(w, h);
      // this.renderer.setPixelRatio(window.devicePixelRatio);
      // this.renderer.autoClear = false;
      // this.renderer.shadowMap.enabled = true;
      // this.renderer.shadowMap.type = fm.PCFSoftShadowMap;
      // //this.renderer.physicallyCorrectLights = true;
      // this.canvas = this.renderer.domElement;
      // this.container.appendChild(this.canvas);
      // this.perspectiveCamera = new fm.PerspectiveCamera(35, w / h, 2, 100000);
      // // this.perspectiveCamera2 = new fm.PerspectiveCamera(35, w / h, 2, 100000);
      // // this.perspectiveCamera2.position.set(0, 50, 100);
      // // this.perspectiveCamera2.lookAt(new fm.Vector3(0, 50, 0))
      // // //cameraTop
      // this.orthographicCamera = new fm.OrthographicCamera(-w / 2, w / 2, h / 2, -h / 2, 1, 100000);

      return true;
    }
    /**
     * 通过viewmode获取当前camera
     * @param {*} viewMode
     */

  }, {
    key: "getCameraByViewMode",
    value: function getCameraByViewMode(viewMode) {
      return viewMode === "3d" ? this.perspectiveCamera : this.orthographicCamera;
    }
  }, {
    key: "getCurrentCamera",
    value: function getCurrentCamera() {
      return this.getCameraByViewMode(this._viewMode);
    }
    /**
     *
     */

  }, {
    key: "resetSpriteSize",
    value: function resetSpriteSize() {
      var sceneArray = this.renderList;
      var _iteratorNormalCompletion7 = true;
      var _didIteratorError7 = false;
      var _iteratorError7 = undefined;

      try {
        for (var _iterator7 = (0, _getIterator2.default)(sceneArray), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
          var scene = _step7.value;

          if (scene.userData.type === "facility") {
            var _iteratorNormalCompletion8 = true;
            var _didIteratorError8 = false;
            var _iteratorError8 = undefined;

            try {
              for (var _iterator8 = (0, _getIterator2.default)(scene.children), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
                var fa = _step8.value;
                this.setFacilitySize(fa, fa.mapNode.size);
              }
            } catch (err) {
              _didIteratorError8 = true;
              _iteratorError8 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
                  _iterator8.return();
                }
              } finally {
                if (_didIteratorError8) {
                  throw _iteratorError8;
                }
              }
            }
          } else if (scene.userData.type === "label") {
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
              for (var _iterator9 = (0, _getIterator2.default)(scene.children), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var _fa = _step9.value;
                this.setLabelSize(_fa, _fa.mapNode.size);
              }
            } catch (err) {
              _didIteratorError9 = true;
              _iteratorError9 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                  _iterator9.return();
                }
              } finally {
                if (_didIteratorError9) {
                  throw _iteratorError9;
                }
              }
            }
          } else if (scene.userData.type === "imageMarker") {
            var _iteratorNormalCompletion10 = true;
            var _didIteratorError10 = false;
            var _iteratorError10 = undefined;

            try {
              for (var _iterator10 = (0, _getIterator2.default)(scene.children), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {
                var _fa2 = _step10.value;
                this.setImageMarkerSize(_fa2);
              }
            } catch (err) {
              _didIteratorError10 = true;
              _iteratorError10 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion10 && _iterator10.return != null) {
                  _iterator10.return();
                }
              } finally {
                if (_didIteratorError10) {
                  throw _iteratorError10;
                }
              }
            }
          } else if (scene.userData.type === "textMarker") {
            var _iteratorNormalCompletion11 = true;
            var _didIteratorError11 = false;
            var _iteratorError11 = undefined;

            try {
              for (var _iterator11 = (0, _getIterator2.default)(scene.children), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {
                var _fa3 = _step11.value;
                this.setLabelSize(_fa3, _fa3.mapNode.size);
              }
            } catch (err) {
              _didIteratorError11 = true;
              _iteratorError11 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion11 && _iterator11.return != null) {
                  _iterator11.return();
                }
              } finally {
                if (_didIteratorError11) {
                  throw _iteratorError11;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError7 = true;
        _iteratorError7 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
            _iterator7.return();
          }
        } finally {
          if (_didIteratorError7) {
            throw _iteratorError7;
          }
        }
      }
    }
  }, {
    key: "getAspect",
    value: function getAspect() {
      return this._w / this._h;
    }
    /**
     *
     */

  }, {
    key: "resize",
    value: function resize() {
      this.renderer.setSize(this._w, this._h);
      this.perspectiveCamera.aspect = this._w / this._h;
      this.resizeWater(this._w / this._h);
      this.perspectiveCamera.updateProjectionMatrix();
      this.orthographicCamera.left = -this._w / 2;
      this.orthographicCamera.right = this._w / 2;
      this.orthographicCamera.top = this._h / 2;
      this.orthographicCamera.bottom = -this._h / 2;
      this.orthographicCamera.updateProjectionMatrix();
    }
  }, {
    key: "resizeWater",
    value: function resizeWater(aspect) {
      // if (!waterMesh) return;
      if (!_FMGlobal.default[this._map.uuid]["f"]) return;
      var width = 0.4;
      var scale = new fm.Vector2(width, width * 0.12 / 0.5);
      _FMGlobal.default[this._map.uuid]["f"].material.uniforms["scale"] = {
        value: scale
      };

      if (isNaN(aspect)) {//aspect=aspect_;
      }

      var offsetx = -1 * (0.5 * scale.x / aspect - 1.0);
      var offsety = -1 * (1.0 - 0.5 * scale.y);
      _FMGlobal.default[this._map.uuid]["f"].material.uniforms["offset"] = {
        value: new fm.Vector2(offsetx, offsety)
      };
    }
  }, {
    key: "resizeLine",
    value: function resizeLine() {
      // for (let i = 0; i < this._lineMarkerScene.children.length; i++) {
      // 	this._lineMarkerScene.children[i].material.resolution.set(insetWidth, insetHeight)
      // }
      var sceneArray = this.renderList;
      var _iteratorNormalCompletion12 = true;
      var _didIteratorError12 = false;
      var _iteratorError12 = undefined;

      try {
        for (var _iterator12 = (0, _getIterator2.default)(sceneArray), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {
          var scene = _step12.value;

          if (scene.userData.type === "line") {
            var _iteratorNormalCompletion13 = true;
            var _didIteratorError13 = false;
            var _iteratorError13 = undefined;

            try {
              for (var _iterator13 = (0, _getIterator2.default)(scene.children), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {
                var fa = _step13.value;
                fa.material.resolution.set(this.domElementWidth, this.domElementHeight);
              }
            } catch (err) {
              _didIteratorError13 = true;
              _iteratorError13 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion13 && _iterator13.return != null) {
                  _iterator13.return();
                }
              } finally {
                if (_didIteratorError13) {
                  throw _iteratorError13;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError12 = true;
        _iteratorError12 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion12 && _iterator12.return != null) {
            _iterator12.return();
          }
        } finally {
          if (_didIteratorError12) {
            throw _iteratorError12;
          }
        }
      }
    }
    /**
     *
     */
    // resetLineMarkerUv() {
    // 	for(let line of this._lineMarkerScene.children) {
    // 	}
    // }

    /**
     * 渲染函数
     */

  }, {
    key: "update",
    value: function update() {
      var _this2 = this;

      if (!this._firstRender) {
        this._map.dispatchEvent({
          type: "firstRender"
        });

        this._firstRender = true;
      } // 重置


      if (Math.abs(this._w - this.container.clientWidth) > 5 || Math.abs(this._h - this.container.clientHeight) > 5) {
        this._w = this.container.clientWidth;
        this._h = this.container.clientHeight;
        this.resize();
        this.resetSpriteSize();
        this.resetLocationsSize();

        this._map.updatePopsPosition();

        this.resizeLine();
        this.resetCompass();
      }

      var camera = this._viewMode === "3d" ? this.perspectiveCamera : this.orthographicCamera; // 渲染列表

      var sceneArray = this.renderList;
      if (!sceneArray || !this.renderer) return; // 效果动态更新

      for (var i = 0; i < sceneArray.length; i++) {
        if (sceneArray[i].name === "waterMarker") {
          // 更新水泼纹动态效果
          sceneArray[i].traverse(function (mesh) {
            if (mesh.name === "water") {
              mesh.material.uniforms['time'].value += 1.0 / 60.0;
            }
          });
        }

        if (sceneArray[i].name === "flmMarker") {
          // 更新动态线效果
          for (var a = 0; a < sceneArray[i].children.length; a++) {
            if (!!sceneArray[i].children[a].userData.frustumUpdate) {
              this._map.nodeManager.checkNodeByFrustum(this._map.dataManager.getDecodeScene(this._map._currentSceneId), this._map.renderer.getFrustumByViewMode(this._map._viewMode), this._map.getVisibleGroups(), this._map.mapScaleLevel, this._map._currentSceneId);

              sceneArray[i].children[a].userData.frustumUpdate = false;
            }

            if (new Date().getTime() - sceneArray[i].children[a].userData.time > 20 / sceneArray[i].children[a].userData.speed) {
              var colors = sceneArray[i].children[a].userData.colors;
              var one = colors.pop();
              var two = colors.pop();
              var three = colors.pop();
              colors.splice(0, 0, one);
              colors.splice(0, 0, two);
              colors.splice(0, 0, three);
              sceneArray[i].children[a].geometry.setColors(colors);
              sceneArray[i].children[a].userData.time = new Date().getTime();
            }
          }
        }

        var speed = 1;

        if (this._map._sweep.speed) {
          speed = this._map._sweep.speed;
        }

        if (this._map.MapOptions.isNeedSweep) {
          //更新扫光效果
          if (this._map._sweep.se2N) {
            (function () {
              //更新矩形扫光
              var del = (new Date().getTime() - _this2._time) / 40 * speed;

              var length = _this2._map._sweep.se2N.clone().multiplyScalar(del);

              var moveP = void 0;

              if (!_this2._sweep.startPoint) {
                _this2._sweep.startPoint = _this2._map._sweep.startPoint.clone();
              }

              if (_this2._sweep.length <= _this2._map._sweep.length) {
                moveP = _this2._sweep.startPoint.add(length);
                _this2._sweep.length += length.length();
              } else {
                _this2._sweep.startPoint = _this2._map._sweep.startPoint.clone();
                moveP = _this2._map._sweep.startPoint;
                _this2._sweep.length = 0;
              }

              sceneArray[i].traverse(function (mesh) {
                if (mesh.name === "isNeedSweep") {
                  mesh.material.uniforms['moveP'].value = moveP;
                  mesh.material.uniforms['sweepW'].value = _this2._map._sweep.width;
                  mesh.material.uniforms['sweepH'].value = _this2._map._sweep.height;
                  mesh.material.uniforms['se2N'].value = _this2._map._sweep.se2N;
                  mesh.material.uniforms['se2RN'].value = _this2._map._sweep.se2RN;
                }
              });
            })();
          }

          if (this._sweep.maxR < this._map._sweep.maxRadius) {
            this._sweep.maxR += (new Date().getTime() - this._time) / 40;
            this._sweep.minR += (new Date().getTime() - this._time) / 40;
          } else {
            this._sweep.maxR = this._map._sweep.minRadius + this._map._sweep.widthR;
            this._sweep.minR = this._map._sweep.minRadius;
          }

          sceneArray[i].traverse(function (mesh) {
            if (mesh.name === "isNeedSweep") {
              mesh.material.uniforms['maxR'].value = _this2._sweep.maxR;
              mesh.material.uniforms['minR'].value = _this2._sweep.minR;
            }
          });
        }
      }

      this.renderer.clear();
      this.renderer.clearDepth();

      if (this._envMap) {
        this.renderer.render(this._envMap, camera);
      }

      if (this.skyEffect !== null && this.isSkyEffect) {
        this.skyEffect.render(camera);

        if (this.autoTime) {
          var date = new Date(); // 一整天的毫秒数

          var _a = 24 * 60 * 60 * 1000; // 当前的毫秒数


          var b = date.getHours() * 60 * 60 * 1000 + date.getMinutes() * 60 * 1000 + date.getSeconds() * 1000 + date.getMilliseconds(); // 一毫秒对应太阳需要转动的角度

          var c = 2 / _a; // 距离6时太阳升起时所经过的毫秒数

          var d = b - 6 * 60 * 60 * 1000; // 计算当前太阳的角度

          this.skyEffect._inclination = c * d;

          this.skyEffect._setPosition(this.skyEffect._inclination);
        }
      }

      if (this.lightEffects) {
        this.effectRender(camera);
      } else {
        if (typeof this.background.background != "undefined") {
          this.renderer.render(this.background, camera);
        }

        var rotationY = null;

        try {
          rotationY = this._map.nodeManager._scenes[this._map._currentSceneId].groups[this._map.focusGroupID]._layers.extent[0]._scene.rotation.y;
        } catch (e) {
          console.log(e);
        } // 渲染场景


        var _iteratorNormalCompletion14 = true;
        var _didIteratorError14 = false;
        var _iteratorError14 = undefined;

        try {
          for (var _iterator14 = (0, _getIterator2.default)(sceneArray), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {
            var scene = _step14.value;

            if (rotationY !== null) {
              this.rotateLeft(rotationY, scene);
            }

            this.renderer.render(scene, camera);
          }
        } catch (err) {
          _didIteratorError14 = true;
          _iteratorError14 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion14 && _iterator14.return != null) {
              _iterator14.return();
            }
          } finally {
            if (_didIteratorError14) {
              throw _iteratorError14;
            }
          }
        }

        if (this.isHeatMap) {
          this.renderer.render(this.heatMapEffect._scene, camera);
        }

        camera.layers.set(0);

        if (this._showCompass && this._compassNode) {
          this.renderer.render(this._compassNode, camera);
        }
      }

      if (_FMGlobal.default[this._map.uuid]["f"]) {
        this.renderer.render(_FMGlobal.default[this._map.uuid]["f"], camera);
      }

      if (this.particleEffect !== null && this.isParticleEffect) {
        this.particleEffect.render(camera);
      }

      if (this.reflectEffect !== null) {
        this.reflectEffect.render();
      }

      this._time = new Date().getTime();
    }
  }, {
    key: "rotateLeft",
    value: function rotateLeft(rotationY, scene) {
      if (this._map.autoRotateBymodel && !this._map.autoRotateBymodelPause) {
        scene.rotation.y = rotationY;
        scene.rotation.y -= 2 * Math.PI / 60 / 60 * this._map.autoRotateBymodelSpeed;
      }
    }
  }, {
    key: "setSceneNodeLayers",
    value: function setSceneNodeLayers(scene, i) {
      var _iteratorNormalCompletion15 = true;
      var _didIteratorError15 = false;
      var _iteratorError15 = undefined;

      try {
        for (var _iterator15 = (0, _getIterator2.default)(scene.children), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {
          var n = _step15.value;
          n.mapNode && !n.mapNode.picLoading && n.layers.set(i);
        }
      } catch (err) {
        _didIteratorError15 = true;
        _iteratorError15 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion15 && _iterator15.return != null) {
            _iterator15.return();
          }
        } finally {
          if (_didIteratorError15) {
            throw _iteratorError15;
          }
        }
      }
    } // 设置缓存颜色

  }, {
    key: "setClearColor",
    value: function setClearColor(color, alpha) {
      if (typeof color === "string") {
        if (color.indexOf("#") >= 0) {
          this._clearColor = (0, _parseInt2.default)(color.replace("#", "0x"));
        } else {
          this._clearColor = color;
        }
      } else {
        this._clearColor = color;
      }

      this._clearAlpha = typeof alpha === "number" ? alpha : 1;
      this.renderer.setClearColor(this._clearColor, this._clearAlpha);
    } //path--图片路径 format--图片格式 图片名称固定为 [nx ny nz px py pz]

  }, {
    key: "setEnvMap",
    value: function setEnvMap(param) {
      if (!param || !param.path || !param.format) {
        return;
      }

      var path = param.path;
      var format = param.format;
      var envMap = new fm.CubeTextureLoader().load([path + 'px' + format, path + 'nx' + format, path + 'py' + format, path + 'ny' + format, path + 'pz' + format, path + 'nz' + format]);

      if (!this._envMap) {
        this._envMap = new fm.Scene();
      }

      this._envMap.background = envMap;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this._envMap) {
        this._envMap = undefined;
      }

      var sceneArray = this.renderList;

      if (sceneArray) {
        var _iteratorNormalCompletion16 = true;
        var _didIteratorError16 = false;
        var _iteratorError16 = undefined;

        try {
          for (var _iterator16 = (0, _getIterator2.default)(sceneArray), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {
            var scene = _step16.value;

            if (scene) {
              for (var i = scene.children.length - 1; i > -1; i--) {
                scene.remove(scene.children[i]);
              }

              scene.children.length = 0;
              scene = undefined;
            }
          }
        } catch (err) {
          _didIteratorError16 = true;
          _iteratorError16 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion16 && _iterator16.return != null) {
              _iterator16.return();
            }
          } finally {
            if (_didIteratorError16) {
              throw _iteratorError16;
            }
          }
        }
      }

      if (this._compassNode) {
        this._compassNode.material.dispose();

        this._compassNode.geometry.dispose();
      }

      for (var _i2 = this._lineMarkerScene.children.length - 1; _i2 > -1; _i2--) {
        this._lineMarkerScene.remove(this._lineMarkerScene.children[_i2]);
      }

      this._map = undefined;
      this.renderer.dispose();
      this.renderer.forceContextLoss();
      this.container.removeChild(this.canvas);
      this.canvas = undefined;
      this.renderer = undefined;
      this.container = undefined;
    }
  }, {
    key: "renderList",
    set: function set(list) {
      this._renderList = this.parseList(list, undefined);
    },
    get: function get() {
      return this._renderList;
    }
  }, {
    key: "domElementHeight",
    get: function get() {
      return this.container.clientHeight;
    }
  }, {
    key: "domElementWidth",
    get: function get() {
      return this.container.clientWidth;
    }
  }, {
    key: "viewMode",
    set: function set(v) {
      this._viewMode = v;
    }
  }, {
    key: "showCompass",
    set: function set(bool) {
      this._showCompass = bool;
    },
    get: function get() {
      return this._showCompass;
    }
  }, {
    key: "compassNode",
    get: function get() {
      return this._compassNode;
    },
    set: function set(node) {
      this._compassNode = node;
    }
  }, {
    key: "lineMarkerScene",
    get: function get() {
      return this._lineMarkerScene;
    }
  }]);
  return FMRenderer;
}();

var _default = FMRenderer;
exports.default = _default;

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

/**
*   FMControlPositon 控件位置枚举
*   @class
*   @memberof fengmap
*   @hideconstructor true
*/
var FMControlPosition = {
  /**
   * 左上角
   * @property {number} LEFT_TOP 1
   * @final
   */
  LEFT_TOP: 1,

  /**
   * 左下角
   * @property  {number} LEFT_BOTTOM 2
   * @final
   */
  LEFT_BOTTOM: 2,

  /**
   * 右上角
   * @property  {number} RIGHT_TOP 3
   * @final
   */
  RIGHT_TOP: 3,

  /**
   * 右下角
   * @property  {number} RIGHT_BOTTOM 4
   * @final
   */
  RIGHT_BOTTOM: 4
};
var _default = FMControlPosition;
exports.default = _default;

/***/ }),
/* 241 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.LineGeometry = void 0;

__webpack_require__(25);

var _create = _interopRequireDefault(__webpack_require__(31));

var _assign = _interopRequireDefault(__webpack_require__(11));

var _LineSegmentsGeometry = __webpack_require__(242);

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */
var LineGeometry = function LineGeometry() {
  _LineSegmentsGeometry.LineSegmentsGeometry.call(this);

  this.type = 'LineGeometry';
};

exports.LineGeometry = LineGeometry;
LineGeometry.prototype = (0, _assign.default)((0, _create.default)(_LineSegmentsGeometry.LineSegmentsGeometry.prototype), {
  constructor: LineGeometry,
  isLineGeometry: true,
  setPositions: function setPositions(array) {
    // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format
    var length = array.length - 3;
    var points = new Float32Array(2 * length);

    for (var i = 0; i < length; i += 3) {
      points[2 * i] = array[i];
      points[2 * i + 1] = array[i + 1];
      points[2 * i + 2] = array[i + 2];
      points[2 * i + 3] = array[i + 3];
      points[2 * i + 4] = array[i + 4];
      points[2 * i + 5] = array[i + 5];
    }

    _LineSegmentsGeometry.LineSegmentsGeometry.prototype.setPositions.call(this, points);

    return this;
  },
  setColors: function setColors(array) {
    // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format
    var length = array.length - 3;
    var colors = new Float32Array(2 * length);

    for (var i = 0; i < length; i += 3) {
      colors[2 * i] = array[i];
      colors[2 * i + 1] = array[i + 1];
      colors[2 * i + 2] = array[i + 2];
      colors[2 * i + 3] = array[i + 3];
      colors[2 * i + 4] = array[i + 4];
      colors[2 * i + 5] = array[i + 5];
    }

    _LineSegmentsGeometry.LineSegmentsGeometry.prototype.setColors.call(this, colors);

    return this;
  },
  fromLine: function fromLine(line) {
    var geometry = line.geometry;

    if (geometry.isGeometry) {
      this.setPositions(geometry.vertices);
    } else if (geometry.isBufferGeometry) {
      this.setPositions(geometry.position.array); // assumes non-indexed
    } // set colors, maybe


    return this;
  },
  copy: function copy()
  /* source */
  {
    // todo
    return this;
  }
});

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.LineSegmentsGeometry = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(35));

__webpack_require__(25);

var _create = _interopRequireDefault(__webpack_require__(31));

var _assign = _interopRequireDefault(__webpack_require__(11));

var _three = __webpack_require__(81);

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */
var LineSegmentsGeometry = function LineSegmentsGeometry() {
  _three.InstancedBufferGeometry.call(this);

  this.type = 'LineSegmentsGeometry';
  var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
  var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
  var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
  this.setIndex(index);
  this.setAttribute('position', new _three.Float32BufferAttribute(positions, 3));
  this.setAttribute('uv', new _three.Float32BufferAttribute(uvs, 2));
};

exports.LineSegmentsGeometry = LineSegmentsGeometry;
LineSegmentsGeometry.prototype = (0, _assign.default)((0, _create.default)(_three.InstancedBufferGeometry.prototype), {
  constructor: LineSegmentsGeometry,
  isLineSegmentsGeometry: true,
  applyMatrix: function applyMatrix(matrix) {
    var start = this.attributes.instanceStart;
    var end = this.attributes.instanceEnd;

    if (start !== undefined) {
      start.applyMatrix4(matrix);
      end.applyMatrix4(matrix);
      start.data.needsUpdate = true;
    }

    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }

    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }

    return this;
  },
  setPositions: function setPositions(array) {
    var lineSegments;

    if (array instanceof Float32Array) {
      lineSegments = array;
    } else if ((0, _isArray.default)(array)) {
      lineSegments = new Float32Array(array);
    }

    var instanceBuffer = new _three.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz

    this.setAttribute('instanceStart', new _three.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz

    this.setAttribute('instanceEnd', new _three.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz
    //

    this.computeBoundingBox();
    this.computeBoundingSphere();
    return this;
  },
  setColors: function setColors(array) {
    var colors;

    if (array instanceof Float32Array) {
      colors = array;
    } else if ((0, _isArray.default)(array)) {
      colors = new Float32Array(array);
    }

    var instanceColorBuffer = new _three.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb

    this.setAttribute('instanceColorStart', new _three.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb

    this.setAttribute('instanceColorEnd', new _three.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb

    return this;
  },
  fromWireframeGeometry: function fromWireframeGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  },
  fromEdgesGeometry: function fromEdgesGeometry(geometry) {
    this.setPositions(geometry.attributes.position.array);
    return this;
  },
  fromMesh: function fromMesh(mesh) {
    this.fromWireframeGeometry(new _three.WireframeGeometry(mesh.geometry)); // set colors, maybe

    return this;
  },
  fromLineSegements: function fromLineSegements(lineSegments) {
    var geometry = lineSegments.geometry;

    if (geometry.isGeometry) {
      this.setPositions(geometry.vertices);
    } else if (geometry.isBufferGeometry) {
      this.setPositions(geometry.position.array); // assumes non-indexed
    } // set colors, maybe


    return this;
  },
  computeBoundingBox: function () {
    var box = new _three.Box3();
    return function computeBoundingBox() {
      if (this.boundingBox === null) {
        this.boundingBox = new _three.Box3();
      }

      var start = this.attributes.instanceStart;
      var end = this.attributes.instanceEnd;

      if (start !== undefined && end !== undefined) {
        this.boundingBox.setFromBufferAttribute(start);
        box.setFromBufferAttribute(end);
        this.boundingBox.union(box);
      }
    };
  }(),
  computeBoundingSphere: function () {
    var vector = new _three.Vector3();
    return function computeBoundingSphere() {
      if (this.boundingSphere === null) {
        this.boundingSphere = new _three.Sphere();
      }

      if (this.boundingBox === null) {
        this.computeBoundingBox();
      }

      var start = this.attributes.instanceStart;
      var end = this.attributes.instanceEnd;

      if (start !== undefined && end !== undefined) {
        var center = this.boundingSphere.center;
        this.boundingBox.getCenter(center);
        var maxRadiusSq = 0;

        for (var i = 0, il = start.count; i < il; i++) {
          vector.fromBufferAttribute(start, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
          vector.fromBufferAttribute(end, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }

        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(this.boundingSphere.radius)) {
          console.error('THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);
        }
      }
    };
  }(),
  toJSON: function toJSON() {// todo
  }
});

/***/ }),
/* 243 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

/**
 * FMLineType 线类型枚举
 * 	@class
 * 	@memberof fengmap
 *  @hideconstructor true
 */
var FMLineType = {
  /**
   * 全线。
   * @property {string} FULL -'full'
   * @final
   */
  FULL: 'full',

  /**
   * 点线。
   * @property {string} DOTTED -'dotted'
   * @final
   */
  DOTTED: 'dotted',

  /**
   * 点画线。
   * @property {string} DOT_DASH -'dotDash'
   * @final
   */
  DOT_DASH: 'dotDash',

  /**
   * 中心线。
   * @property {string} CENTER -'center'
   * @final
   */
  CENTER: 'center',

  /**
   * 虚线。
   * @property {string} DASH -'dash'
   * @final
   */
  DASH: 'dash',

  /**
   * 双点画线。
   * @property {string} DOUBLE_DOT_DASH -'doubleDotDash'
   * @final
   */
  DOUBLE_DOT_DASH: 'doubleDotDash',

  /**
   * 三点画线
   * @property {string} TRI_DOT_DASH -'triDotDash'
   * @final
   */
  TRI_DOT_DASH: 'triDotDash',
  NORMAL: 'normal',
  ARROW: 'arrow',
  RAW: 'raw',

  /**
   * 带有箭头样式的导航线样式
   * @property {string} FMARROW -'fmarrow'
   * @final
   */
  FMARROW: 'fmarrow',
  TEXTURE: 'texture'
};
var _default = FMLineType;
exports.default = _default;

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _create = _interopRequireDefault(__webpack_require__(31));

var _defineProperties = _interopRequireDefault(__webpack_require__(106));

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  linewidth: <float>,
 *  dashed: <boolean>,
 *  dashScale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *  resolution: <Vector2>, // to be set by renderer
 * }
 */
fm.UniformsLib.line = {
  linewidth: {
    value: 1
  },
  resolution: {
    value: new fm.Vector2(1, 1)
  },
  dashScale: {
    value: 1
  },
  dashSize: {
    value: 1
  },
  gapSize: {
    value: 1
  },
  // todo FIX - maybe change to totalSize
  mmap: {
    value: null
  },
  offset: {
    value: new fm.Vector2(0, 0)
  },
  repeat: {
    value: new fm.Vector2(1, 1)
  },
  miny: {
    value: 0
  },
  pcolor: {
    value: new fm.Color(0xaeaeae)
  }
};
fm.ShaderLib['line'] = {
  uniforms: fm.UniformsUtils.merge([fm.UniformsLib.common, fm.UniformsLib.fog, fm.UniformsLib.line]),
  vertexShader: "\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute float uvyStart;\n\t\tattribute float uvyEnd;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\t\tattribute vec2 uv2;\n\n\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vUv2;\n\t\tvarying float uvScale;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\t\t\t\n\t\t\tfloat duvy = uvyEnd - uvyStart;\n\t\t\tfloat uvy = uvyStart + duvy * uv2.y;\n\t\t\t// vUv2 = vec2(uv2.x ,uvy);\n\t\t\tvUv2 = ( position.y < 0.5 ) ? vec2(uv2.x ,uvyStart) : vec2(uv2.x ,uvyEnd);\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tfloat scaleDir = length(dir);\n\t\t\tuvScale = 0.05/scaleDir;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",
  fragmentShader: "\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\t\tuniform vec2 repeat;\n\t\tuniform vec2 offset;\n\t\tuniform float miny;\n\t\tuniform vec3 pcolor;\n\t\t\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\t\t\n\t\t\n\n\t\t\tuniform sampler2D mmap;\n\n\t\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying float uvScale;\n\t\tvarying vec2 vUv;\n\t\tvarying vec2 vUv2;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\t// if ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t// \tfloat a = vUv.x;\n\t\t\t// \tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t// \tfloat len2 = a * a + b * b;\n\n\t\t\t// \tif ( len2 > 1.0 ) discard;\n\n\t\t\t// }\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\n\t\t\t#ifdef USE_MMAP\n\t\t\t\n\t\t\t\tif(vUv2.y>miny){\t\t\t\t\n\t\t\t\t\tdiffuseColor = texture2D( mmap, vUv2 * repeat + offset );\n\t\t\t\t}else{\n\t\t\t\t\tdiffuseColor = vec4(pcolor,1.0);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t#endif\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\tgl_FragColor = diffuseColor;\n\n\t\t\t#include <premultiplied_alpha_fragment>\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\n\t\t}\n\t\t"
};

fm.LineMaterial = function (parameters) {
  fm.ShaderMaterial.call(this, {
    type: 'LineMaterial',
    uniforms: fm.UniformsUtils.clone(fm.ShaderLib['line'].uniforms),
    vertexShader: fm.ShaderLib['line'].vertexShader,
    fragmentShader: fm.ShaderLib['line'].fragmentShader
  });
  this.dashed = false;
  (0, _defineProperties.default)(this, {
    color: {
      enumerable: true,
      get: function get() {
        return this.uniforms.diffuse.value;
      },
      set: function set(value) {
        this.uniforms.diffuse.value = value;
      }
    },
    linewidth: {
      enumerable: true,
      get: function get() {
        return this.uniforms.linewidth.value;
      },
      set: function set(value) {
        this.uniforms.linewidth.value = value;
      }
    },
    dashScale: {
      enumerable: true,
      get: function get() {
        return this.uniforms.dashScale.value;
      },
      set: function set(value) {
        this.uniforms.dashScale.value = value;
      }
    },
    dashSize: {
      enumerable: true,
      get: function get() {
        return this.uniforms.dashSize.value;
      },
      set: function set(value) {
        this.uniforms.dashSize.value = value;
      }
    },
    gapSize: {
      enumerable: true,
      get: function get() {
        return this.uniforms.gapSize.value;
      },
      set: function set(value) {
        this.uniforms.gapSize.value = value;
      }
    },
    resolution: {
      enumerable: true,
      get: function get() {
        return this.uniforms.resolution.value;
      },
      set: function set(value) {
        this.uniforms.resolution.value.copy(value);
      }
    }
  });
  this.setValues(parameters);
};

fm.LineMaterial.prototype = (0, _create.default)(fm.ShaderMaterial.prototype);
fm.LineMaterial.prototype.constructor = fm.LineMaterial;
fm.LineMaterial.prototype.isLineMaterial = true;

fm.LineMaterial.prototype.copy = function (source) {
  fm.ShaderMaterial.prototype.copy.call(this, source);
  this.color.copy(source.color);
  this.linewidth = source.linewidth;
  this.resolution = source.resolution; // todo

  return this;
};

var _default = fm.LineMaterial;
exports.default = _default;

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(25);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _LineSegmentsGeometry2 = _interopRequireDefault(__webpack_require__(246));

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */
var LineGeometry =
/*#__PURE__*/
function (_LineSegmentsGeometry) {
  (0, _inherits2.default)(LineGeometry, _LineSegmentsGeometry);

  function LineGeometry() {
    var _this;

    (0, _classCallCheck2.default)(this, LineGeometry);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LineGeometry).call(this));
    _this.type = 'LineGeometry';
    _this.isLineGeometry = true;
    return _this;
  }

  (0, _createClass2.default)(LineGeometry, [{
    key: "setPositions",
    value: function setPositions(array) {
      // converts [ x1, y1, z1,  x2, y2, z2, ... ] to pairs format
      var length = array.length - 3;
      var points = new Float32Array(2 * length);

      for (var i = 0; i < length; i += 3) {
        points[2 * i] = array[i];
        points[2 * i + 1] = array[i + 1];
        points[2 * i + 2] = array[i + 2];
        points[2 * i + 3] = array[i + 3];
        points[2 * i + 4] = array[i + 4];
        points[2 * i + 5] = array[i + 5];
      }

      this.test = "ddd";
      new _LineSegmentsGeometry2.default().setPositions.call(this, points);
      return this;
    }
  }, {
    key: "setColors",
    value: function setColors(array) {
      // converts [ r1, g1, b1,  r2, g2, b2, ... ] to pairs format
      var length = array.length - 3;
      var colors = new Float32Array(2 * length);

      for (var i = 0; i < length; i += 3) {
        colors[2 * i] = array[i];
        colors[2 * i + 1] = array[i + 1];
        colors[2 * i + 2] = array[i + 2];
        colors[2 * i + 3] = array[i + 3];
        colors[2 * i + 4] = array[i + 4];
        colors[2 * i + 5] = array[i + 5];
      }

      new _LineSegmentsGeometry2.default().setColors.call(this, colors);
      return this;
    }
  }, {
    key: "fromLine",
    value: function fromLine(line) {
      var geometry = line.geometry;

      if (geometry.isGeometry) {
        this.setPositions(geometry.vertices);
      } else if (geometry.isBufferGeometry) {
        this.setPositions(geometry.position.array); // assumes non-indexed
      } // set colors, maybe


      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      // todo
      return this;
    }
  }]);
  return LineGeometry;
}(_LineSegmentsGeometry2.default);

;
var _default = LineGeometry;
exports.default = _default;

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _isArray = _interopRequireDefault(__webpack_require__(35));

__webpack_require__(25);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */
var LineSegmentsGeometry =
/*#__PURE__*/
function (_fm$InstancedBufferGe) {
  (0, _inherits2.default)(LineSegmentsGeometry, _fm$InstancedBufferGe);

  function LineSegmentsGeometry() {
    var _this;

    (0, _classCallCheck2.default)(this, LineSegmentsGeometry);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LineSegmentsGeometry).call(this));
    _this.type = 'LineSegmentsGeometry';
    var plane = new fm.BufferGeometry();
    var positions = [-1, 2, 0, 1, 2, 0, -1, 1, 0, 1, 1, 0, -1, 0, 0, 1, 0, 0, -1, -1, 0, 1, -1, 0];
    var uvs = [-1, 2, 1, 2, -1, 1, 1, 1, -1, -1, 1, -1, -1, -2, 1, -2];
    var uv2 = [0, 0, 1, 0, 0, 1 / 3, 1, 1 / 3, 0, 2 / 3, 1, 2 / 3, 0, 1, 1, 1];
    var index = [0, 2, 1, 2, 3, 1, 2, 4, 3, 4, 5, 3, 4, 6, 5, 6, 7, 5];
    _this.isLineSegmentsGeometry = true;

    _this.setIndex(index);

    _this.setAttribute('position', new fm.Float32BufferAttribute(positions, 3));

    _this.setAttribute('uv', new fm.Float32BufferAttribute(uvs, 2));

    _this.setAttribute('uv2', new fm.Float32BufferAttribute(uv2, 2));

    return _this;
  }

  (0, _createClass2.default)(LineSegmentsGeometry, [{
    key: "applyMatrix",
    value: function applyMatrix(matrix) {
      var start = this.attributes.instanceStart;
      var end = this.attributes.instanceEnd;

      if (start !== undefined) {
        matrix.applyToBufferAttribute(start);
        matrix.applyToBufferAttribute(end);
        start.data.needsUpdate = true;
      }

      if (this.boundingBox !== null) {
        this.computeBoundingBox();
      }

      if (this.boundingSphere !== null) {
        this.computeBoundingSphere();
      }

      return this;
    }
  }, {
    key: "setPositions",
    value: function setPositions(array) {
      var lineSegments;

      if (array instanceof Float32Array) {
        lineSegments = array;
      } else if ((0, _isArray.default)(array)) {
        lineSegments = new Float32Array(array);
      }

      var instanceBuffer = new fm.InstancedInterleavedBuffer(lineSegments, 6, 1); // xyz, xyz

      this.setAttribute('instanceStart', new fm.InterleavedBufferAttribute(instanceBuffer, 3, 0)); // xyz

      this.setAttribute('instanceEnd', new fm.InterleavedBufferAttribute(instanceBuffer, 3, 3)); // xyz
      //

      this.computeBoundingBox();
      this.computeBoundingSphere();
      return this;
    }
  }, {
    key: "setColors",
    value: function setColors(array) {
      var colors;

      if (array instanceof Float32Array) {
        colors = array;
      } else if ((0, _isArray.default)(array)) {
        colors = new Float32Array(array);
      }

      var instanceColorBuffer = new fm.InstancedInterleavedBuffer(colors, 6, 1); // rgb, rgb

      this.addAttribute('instanceColorStart', new fm.InterleavedBufferAttribute(instanceColorBuffer, 3, 0)); // rgb

      this.addAttribute('instanceColorEnd', new fm.InterleavedBufferAttribute(instanceColorBuffer, 3, 3)); // rgb

      return this;
    }
  }, {
    key: "setUvys",
    value: function setUvys(array) {
      var uvys;

      if (array instanceof Float32Array) {
        uvys = array;
      } else if ((0, _isArray.default)(array)) {
        uvys = new Float32Array(array);
      }

      var instanceColorBuffer = new fm.InstancedInterleavedBuffer(uvys, 2, 1); // rgb, rgb

      this.setAttribute('uvyStart', new fm.InterleavedBufferAttribute(instanceColorBuffer, 1, 0)); // rgb

      this.setAttribute('uvyEnd', new fm.InterleavedBufferAttribute(instanceColorBuffer, 1, 1)); // rgb

      return this;
    }
  }, {
    key: "fromWireframeGeometry",
    value: function fromWireframeGeometry(geometry) {
      this.setPositions(geometry.attributes.position.array);
      return this;
    }
  }, {
    key: "fromEdgesGeometry",
    value: function fromEdgesGeometry(geometry) {
      this.setPositions(geometry.attributes.position.array);
      return this;
    }
  }, {
    key: "fromMesh",
    value: function fromMesh(mesh) {
      this.fromWireframeGeometry(new fm.WireframeGeometry(mesh.geometry)); // set colors, maybe

      return this;
    }
  }, {
    key: "fromLineSegements",
    value: function fromLineSegements(lineSegments) {
      var geometry = lineSegments.geometry;

      if (geometry.isGeometry) {
        this.setPositions(geometry.vertices);
      } else if (geometry.isBufferGeometry) {
        this.setPositions(geometry.position.array); // assumes non-indexed
      } // set colors, maybe


      return this;
    }
  }, {
    key: "computeBoundingBox",
    value: function computeBoundingBox() {
      var box = new fm.Box3();

      if (this.boundingBox === null) {
        this.boundingBox = new fm.Box3();
      }

      var start = this.attributes.instanceStart;
      var end = this.attributes.instanceEnd;

      if (start !== undefined && end !== undefined) {
        this.boundingBox.setFromBufferAttribute(start);
        box.setFromBufferAttribute(end);
        this.boundingBox.union(box);
      }
    }
  }, {
    key: "computeBoundingSphere",
    value: function computeBoundingSphere() {
      var vector = new fm.Vector3();

      if (this.boundingSphere === null) {
        this.boundingSphere = new fm.Sphere();
      }

      if (this.boundingBox === null) {
        this.computeBoundingBox();
      }

      var start = this.attributes.instanceStart;
      var end = this.attributes.instanceEnd;

      if (start !== undefined && end !== undefined) {
        var center = this.boundingSphere.center;
        this.boundingBox.getCenter(center);
        var maxRadiusSq = 0;

        for (var i = 0, il = start.count; i < il; i++) {
          vector.fromBufferAttribute(start, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
          vector.fromBufferAttribute(end, i);
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(vector));
        }

        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);

        if (isNaN(this.boundingSphere.radius)) {
          console.error('fm.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.', this);
        }
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {// todo
    }
  }, {
    key: "clone",
    value: function clone() {// todo
    }
  }, {
    key: "copy",
    value: function copy(source) {
      // todo
      return this;
    }
  }]);
  return LineSegmentsGeometry;
}(fm.InstancedBufferGeometry);

var _default = LineSegmentsGeometry;
exports.default = _default;

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _GeometryMath = _interopRequireDefault(__webpack_require__(223));

var _Graphics = _interopRequireDefault(__webpack_require__(49));

/**
 * @class FMSegment点集，一个点集代表一条折线
 * @memberof fengmap
 * @constructor
 */
var FMSegment =
/*#__PURE__*/
function () {
  function FMSegment(points) {
    (0, _classCallCheck2.default)(this, FMSegment);
    this._points = points ? points : null;
    this._groupId = 0;
    this._lineDis = [];
    this._linePoints = null;
    this._screenPoints = [];
    this._screenDis = [];
    this._radiusPoint = [];
    this._radiuInit = false;
    this._uvys = null;
    this._minRadius = 1;
    this.needSmooth = true; // this._calcMinRadius();
  }

  (0, _createClass2.default)(FMSegment, [{
    key: "initSegement",
    value: function initSegement(center, radius) {
      if (typeof radius != 'number') {
        radius = this._minRadius;
      }

      this._linePoints = this.pointsToLinePnts(center, radius);
      this._uvys = this.computerUVY();
    }
  }, {
    key: "pointsToRadius",
    value: function pointsToRadius(radius) {
      var resultPoints = [];
      var gem = new _GeometryMath.default();

      for (var i = 0; i < this._points.length; i++) {
        if (i > 0 && i < this._points.length - 1) {
          // let ps = gem.computerArcLineByPoints(this._points[i - 1] ,this._points[i] ,this._points[i + 1] ,1 ,12);   
          var distance0 = _Graphics.default.distanceOfTwoPoints(resultPoints[resultPoints.length - 1], this._points[i]);

          var distance1 = _Graphics.default.distanceOfTwoPoints(this._points[i], this._points[i + 1]);

          var maxRaidus = (distance0 > distance1 ? distance1 : distance0) * 0.5;
          var arcRadius = radius;

          if (arcRadius > maxRaidus) {
            arcRadius = maxRaidus;
          }

          resultPoints.push.apply(resultPoints, (0, _toConsumableArray2.default)(gem.computerArcLineByPoints(resultPoints[resultPoints.length - 1], this._points[i], this._points[i + 1], arcRadius ? arcRadius : 1, 12)));
        } else {
          resultPoints.push(this._points[i]);
        }
      }

      this._radiusPoint = resultPoints;
      this._radiuInit = true;
    }
  }, {
    key: "pointsToLinePnts",
    value: function pointsToLinePnts(center, radius) {
      if (this.needSmooth) {
        if (!this._radiuInit) {
          this.pointsToRadius(radius);
        }
      } else {
        var rp = [];
        rp.push.apply(rp, (0, _toConsumableArray2.default)(this._points));
        this._radiusPoint = rp;
      }

      var line = [];

      for (var i = 0; i < this._radiusPoint.length; i++) {
        var x = this._radiusPoint[i].x - center.x;
        var y = this._radiusPoint[i].z;
        var z = -this._radiusPoint[i].y + center.y;
        line.push(x, y, z);

        if (i !== 0) {
          var posPrev = new fm.Vector3(this._radiusPoint[i].x, this._radiusPoint[i].y, this._radiusPoint[i].z);
          var posLast = new fm.Vector3(this._radiusPoint[i - 1].x, this._radiusPoint[i - 1].y, this._radiusPoint[i - 1].z);

          this._lineDis.push(posPrev.distanceTo(posLast));
        }
      }

      return line;
    }
  }, {
    key: "getIndexDis",
    value: function getIndexDis(index) {
      var d = 0;

      for (var i = 0; i < this._lineDis.length; i++) {
        if (i < index) {
          d += this._lineDis[i];
        }
      }

      return d;
    }
  }, {
    key: "computerUVY",
    value: function computerUVY() {
      var uvys = [];
      var allDistance = this.getIndexDis(this._lineDis.length);

      for (var i = 0; i < this._radiusPoint.length; i++) {
        if (i === 0) {
          uvys.push(0);
        } else if (i === this._radiusPoint.length - 1) {
          uvys.push(1);
        } else {
          var uvy = this.getIndexDis(i) / allDistance;
          uvys.push(uvy);
          uvys.push(uvy);
        }
      }

      return uvys;
    }
  }, {
    key: "computeScreenCoord",
    value: function computeScreenCoord(camera, cw, ch, pos) {
      var screenPoints = [];
      var allScreenDis = 0;
      var screenDis = [];
      var inverMatrix = camera.matrixWorldInverse;

      for (var i = 0; i < this._linePoints.length; i += 3) {
        var x = this._linePoints[i];
        var y = this._linePoints[i + 1];
        var z = this._linePoints[i + 2];
        var threePoint = new fm.Vector3(x + pos.x, y + pos.y, z + pos.z);
        var cameraPoint = threePoint.applyMatrix4(inverMatrix);

        if (cameraPoint.z >= -camera.near) {// cameraPoint.z =  -camera.near -camera.near - cameraPoint.z;
        }

        var ndcPoint = cameraPoint.applyMatrix4(camera.projectionMatrix);
        var screenPoint = new fm.Vector2(cw / 2 + cw / 2 * ndcPoint.x, ch / 2 - ch / 2 * ndcPoint.y);
        screenPoints.push(screenPoint);

        if (i > 2) {
          var disLast = screenPoint.distanceTo(screenPoints[Math.round(i / 3) - 1]);
          allScreenDis += disLast;
          screenDis.push(disLast);
        }
      }

      this._screenPoints = screenPoints;
      this._screenDis = screenDis;
      return allScreenDis;
    }
  }, {
    key: "_calcMinRadius",
    value: function _calcMinRadius() {
      if (!this.points) {
        return;
      }

      this._minRadius = 1;

      for (var i = 0; i < this._points.length - 1; i++) {
        var p0 = this._points[i];
        var p1 = this._points[i + 1];
        var distance = _Graphics.default.distanceOfTwoPoints(p0, p1) * 0.368;

        if (this._minRadius > distance) {
          this._minRadius = distance;
        }
      }
    }
    /**
     * 点集
     * @property {array<json>} points 点集,与groupId组合起来正确使用。 如：[{x: 12961626.00,y: 4861886.53,z: 1},...]
     * @property {number} points[].x x坐标
     * @property {number} points[].y y坐标
     * @property {number} points[].z z坐标，表示当前折线距离地面的高度。
     */

  }, {
    key: "points",
    get: function get() {
      return this._points;
    }
    /*
    *    points: [{
                                               x: 12961602.00,
                                               y: 4861851.50,
                                               z: 0
                                           },
                                           {
                                               x: 12961625.00,
                                               y: 4861850.50,
                                               z: 0
                                           },
                                           {
                                               x: 12961625.00,
                                               y: 4861825.00,
                                               z: 0
                                           },
                                           ]
                                       }]
    */
    ,
    set: function set(pnts) {
      this._points = pnts; // this._calcMinRadius();
    }
    /**
     * 楼层id
     * @property {number} groupId 楼层ID
     */

  }, {
    key: "groupId",
    get: function get() {
      return this._groupId;
    },
    set: function set(gid) {
      this._groupId = gid;
    }
    /**
     * 当前折线的长度
     * @property {number} allLength 长度
     */

  }, {
    key: "allLength",
    get: function get() {
      return this.getIndexDis(this._lineDis.length);
    }
  }, {
    key: "linePoints",
    get: function get() {
      return this._linePoints;
    }
  }, {
    key: "uvys",
    get: function get() {
      return this._uvys;
    }
  }]);
  return FMSegment;
}();

var _default = FMSegment;
exports.default = _default;

/***/ }),
/* 248 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(56);

var _TinyQueue = _interopRequireDefault(__webpack_require__(433));

var Queue = _TinyQueue.default;

function centroid(polygon, precision) {
  precision = precision || 1.0;
  var minX = Number.MAX_VALUE,
      minY = Number.MAX_VALUE,
      maxX = Number.MIN_VALUE,
      maxY = Number.MIN_VALUE;

  for (var i = 0; i < polygon[0].length; i++) {
    var p = polygon[0][i];
    if (p[0] < minX) minX = p[0];
    if (p[1] < minY) minY = p[1];
    if (p[0] > maxX) maxX = p[0];
    if (p[1] > maxY) maxY = p[1];
  }

  var width = maxX - minX;
  var height = maxY - minY;
  var cellSize = Math.min(width, height);
  var h = cellSize / 2;
  if (cellSize === 0) return [minX, minY];
  var cellQueue = new Queue(undefined, compareMax);

  for (var x = minX; x < maxX; x += cellSize) {
    for (var y = minY; y < maxY; y += cellSize) {
      cellQueue.push(new Cell(x + h, y + h, h, polygon));
    }
  } // 初始化多边形的重心点位最优点


  var bestCell = CentroidCell(polygon);
  var bboxCell = new Cell(minX + width / 2, minY + height / 2, 0, polygon);
  if (bboxCell.d > bestCell.d) bestCell = bboxCell;
  var numProbes = cellQueue.length;

  while (cellQueue.length > 0) {
    var cell = cellQueue.pop();

    if (cell.d > bestCell.d) {
      bestCell = cell;
    } // 确保极限情况的cell小于最佳网格的最大距离


    if (cell.max - bestCell.d <= precision) continue;
    h = cell.h / 2;
    cellQueue.push(new Cell(cell.x - h, cell.y - h, h, polygon));
    cellQueue.push(new Cell(cell.x + h, cell.y - h, h, polygon));
    cellQueue.push(new Cell(cell.x - h, cell.y + h, h, polygon));
    cellQueue.push(new Cell(cell.x + h, cell.y + h, h, polygon));
    numProbes += 4;
  }

  return [bestCell.x, bestCell.y];
}

function compareMax(a, b) {
  return b.max - a.max;
}

function Cell(x, y, h, polygon) {
  this.x = x;
  this.y = y;
  this.h = h;
  this.d = pointToPolygonDist(x, y, polygon);
  this.max = this.d + this.h * Math.SQRT2;
}

function pointToPolygonDist(x, y, polygon) {
  var inside = false;
  var minDistSq = Infinity;

  for (var k = 0; k < polygon.length; k++) {
    var ring = polygon[k];

    for (var i = 0, len = ring.length, j = len - 1; i < len; j = i++) {
      var a = ring[i];
      var b = ring[j]; // 快速排除

      if (a[1] > y !== b[1] > y && x < (b[0] - a[0]) * (y - a[1]) / (b[1] - a[1]) + a[0]) inside = !inside;
      minDistSq = Math.min(minDistSq, SegDistToSq(x, y, a, b));
    }
  }

  return (inside ? 1 : -1) * Math.sqrt(minDistSq);
}

function CentroidCell(polygon) {
  var area = 0;
  var x = 0;
  var y = 0;
  var points = polygon[0];

  for (var i = 0, len = points.length, j = len - 1; i < len; j = i++) {
    var a = points[i];
    var b = points[j];
    var f = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * f;
    y += (a[1] + b[1]) * f;
    area += f * 3;
  }

  if (area === 0) return new Cell(points[0][0], points[0][1], 0, polygon);
  return new Cell(x / area, y / area, 0, polygon);
}

function SegDistToSq(px, py, a, b) {
  var x = a[0];
  var y = a[1];
  var dx = b[0] - x;
  var dy = b[1] - y;
  var crsX = x,
      crsY = y;

  if (dx !== 0 || dy !== 0) {
    var t = ((px - x) * dx + (py - y) * dy) / (dx * dx + dy * dy);

    if (t > 1) {
      crsX = b[0];
      crsY = b[1];
    } else if (t > 0) {
      crsX += dx * t;
      crsY += dy * t;
    }
  }

  dx = px - crsX;
  dy = py - crsY;
  return dx * dx + dy * dy;
}

var _default = centroid;
exports.default = _default;

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

/**
 * @interface FMMarker marker基类
 * @memberof fengmap
 * @extends {fengmap.FMNode}
 * @hideconstructor true
 */
var FMMarker =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMMarker, _FMNode);

  /***
   * @constructor
   * @param id
   * @param nodeType
   */
  function FMMarker(id, nodeType) {
    var _this;

    (0, _classCallCheck2.default)(this, FMMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMMarker).call(this, id, nodeType));
    _this._renderNode = null; // 渲染节点

    _this._isInit = false; // 标记是否初始化

    return _this;
  }
  /***
   * 初始化
   */


  (0, _createClass2.default)(FMMarker, [{
    key: "init",
    value: function init() {}
    /**
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode) {
        this._renderNode.material.dispose();

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this._geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }
    }
    /**
     * 获取渲染节点
     * @returns {null}
     */

  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    }
  }, {
    key: "isInit",
    get: function get() {
      return this._isInit;
    }
  }]);
  return FMMarker;
}(_FMNode2.default);

var _default = FMMarker;
exports.default = _default;

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(__webpack_require__(11));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _Graphics = _interopRequireDefault(__webpack_require__(49));

var _Centroid = _interopRequireDefault(__webpack_require__(248));

var _FMMarker2 = _interopRequireDefault(__webpack_require__(249));

var _FMMathUtils = _interopRequireDefault(__webpack_require__(437));

var _FMGeometryUtils = _interopRequireDefault(__webpack_require__(114));

/**
 * @interface FMBasePolygonMarker 多边形标注基类
 * @memberof fengmap
 * @extends {fengmap.FMMarker}
 * @hideconstructor true
 */
var FMBasePolygonMarker =
/*#__PURE__*/
function (_FMMarker) {
  (0, _inherits2.default)(FMBasePolygonMarker, _FMMarker);

  /***
   * @constructor
   * @param id
   * @param nodeType
   * @param {json} param 参数
   * @param {number} param.alpha  多边形的透明度。0.0 - 1.0 之间取值, 默认为 1.0
   * @param {number} param.color  多边形的颜色
   * @param {number} param.height  多边形与楼层之间的高度, 默认为 1
   * @param {number} param.extrudeHeight  多边形高度
   * @param {number} param.lineColor  多边形边框线颜色。
   *
   * @param {array|json} param.points  1.array格式的为多边形的坐标点集数组。类似[{x: 12961583, y: 4861865, z: 56},{x: 12961644, y:
   *   4861874, z: 56}]数组。2.json格式的为圆形或矩形的设置，具体参数如下：
   * @param {number} param.points[].x x坐标
   * @param {number} param.points[].y y坐标
   * @param {string} param.points.type  多边形图层类型。'circle'表示圆形；'rectangle' 表示矩形。
   * @param {json} param.points.center  圆形或矩形的中心点设置。
   * @param {number} param.points.radius  圆形的半径。
   * @param {number} param.points.segments  组成圆形的段数，默认40。值越大越接近圆。通常设置为近似圆的最小值，这样可以节省资源。
   * @param {json} param.points.startPoint  矩形的起始点设置，代表矩形的左上角。如存在center设置时，则优先使用stratPoint的值绘制矩形。
   * @param {number} param.points.width  矩形的宽度。
   * @param {number} param.points.height  矩形的高度。
   */
  function FMBasePolygonMarker(id, nodeType, param) {
    var _this;

    (0, _classCallCheck2.default)(this, FMBasePolygonMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMBasePolygonMarker).call(this, id, nodeType));
    _this._alpha = param.alpha !== undefined ? param.alpha : 1.0; // 透明度

    _this._color = param.color !== undefined ? param.color : "#FF0000"; // 颜色

    _this._height = param.height !== undefined ? param.height : 1; // 离地高度

    _this._lineColor = param.lineColor || param.color || "#FF0000";
    _this._points = [];
    _this.position = {
      x: 0,
      y: 0
    }; // 位置

    if (_this._points.type) {
      _this._points = param.points !== undefined ? (0, _assign.default)(param.points) : [];

      if (_this._points.type === 'rectangle' && _this._points.startPoint && _this._points.startPoint.x && _this._points.startPoint.y) {
        _this.position.x = _this._points.startPoint.x + _this._points.width / 2;
        _this.position.y = _this._points.startPoint.y - _this._points.height / 2;
      } else {
        _this.position.x = _this._points.center.x;
        _this.position.y = _this._points.center.y;
      }
    } else {
      if (_this._points.constructor === Array) {
        if (param.points !== undefined) {
          (0, _assign.default)(_this._points, param.points);
        }

        _FMGeometryUtils.default.closedPoints(_this._points);

        if (_FMMathUtils.default.polygonArea(_this._points) < 0) {
          _this._points.reverse();
        }
      }
    }

    _this._edgesLine = null;
    return _this;
  }
  /**
   * 检查多边形是否包含某一点
   * @param {json} point 坐标数据
   * @param {float} point.x 坐标x数据
   * @param {float} point.y 坐标y数据
   */


  (0, _createClass2.default)(FMBasePolygonMarker, [{
    key: "contain",
    value: function contain(point) {
      if (!this._points) return false;
      if (!this.parent) return false;
      if (!this.parent.parent) return false;

      if (this._points.type === "circle") {
        var dis = Math.sqrt((point.x - this.position.x) * (point.x - this.position.x) + (point.y - this.position.y) * (point.y - this.position.y));
        if (dis < this._points.r) return true;
      } else if (this._points.type === "rectangle") {
        if (Math.abs(point.x - this.position.x) < this._points.width / 2 && Math.abs(point.y - this.position.y) < this._points.height / 2) {
          return true;
        }
      } else {
        return _Graphics.default.pointInPolygon2d(this._points, point, this._points.length);
      }

      return false;
    }
    /**
     * 修改颜色
     * @param {string} color 如：'#ff0000'
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      this._renderNode.material.color = new fm.Color(color);
      this._color = color;
    }
    /**
     * 修改多边形面的透明度
     * @param {number} val 透明度
     */

  }, {
    key: "setAlpha",
    value: function setAlpha(val) {
      this._renderNode.material.opacity = val;
      this._alpha = val;
    }
    /***
     * 修改边线颜色
     * @param {string} color 如：'#ff0000'
     */

  }, {
    key: "setLineColor",
    value: function setLineColor(color) {
      this._edgesLine.material.color = new fm.Color(color);
    }
    /**
     * 获取中心点坐标
     * @returns {{x: *, y: *, z: number}|{x: *, y: number, z: number}}
     */

  }, {
    key: "center",
    get: function get() {
      var group = this.parent.parent;
      var sceneCenter = group.parent.mapcenter;
      var poly = [];

      for (var i = 0; i < this._linePoints.length; i += 3) {
        poly.push([this._linePoints[i], this._linePoints[i + 1]]);
      }

      var center = null;
      center = (0, _Centroid.default)([poly], 0.01);

      if (this._points.type != "circle" && this._points.type != "rectangle") {
        return {
          x: this.position.x + center[0],
          y: this.position.y - center[1],
          z: this._height
        };
      }

      return {
        x: this.position.x + center[0],
        y: this.position.y + center[1],
        z: this._height
      };
    }
  }]);
  return FMBasePolygonMarker;
}(_FMMarker2.default);

var _default = FMBasePolygonMarker;
exports.default = _default;

/***/ }),
/* 251 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

/**
   * 查询实体对象
   * @class
   * @memberof fengmap
   */
var FMSearchRequest = function FMSearchRequest() {
  (0, _classCallCheck2.default)(this, FMSearchRequest);

  /**
   * 查询范围
   * @property {json} circle {center:{x:,y:},radius:}
   */
  this.circle;
  /**
   * 查询范围
   * @property {array<object>} polygon [{x0:,y0:},{x1:,y1:}...]
   */

  this.polygon;
  /**
   * 根据地图元素对象的ename属性返回模糊匹配结果集。
   * @property {string} eName 英文名查询
   */

  this.eName;
  /**
   * 元素地图内唯一标识ID，根据设置条件返回精确匹配结果
   * @property {string} FID 地图内唯一标识ID
   */

  this.FID;
  /**
   * 楼层id
   * @property {number} groupID 楼层id
   */

  this.groupID;
  /**
   * 地图元素对象ID，当前楼层内唯一。可组合groupID查询，获取到某一个的地图元素。根据设置条件返回精确匹配结果集，支持多个ID同时查询，如：[1,2]
   * @property {array<number>|number} ID
   */

  this.ID;
  /**
   * 关键字，根据地图元素对象的name和ename属性返回模糊匹配结果集。
   * @property {string} keyword 关键字
   */

  this.keyword;
  /**
   * 中文名。根据地图元素对象的name属性返回模糊匹配结果集。
   * @property {string} name
   */

  this.name;
  /**
   * 对应地图元素数据类型type。根据设置条件返回精确匹配结果集，支持多个typeID同时查询，如：[170000,200000]
   * @property {array<number>|number} typeID 
   */

  this.typeID;
  /**
   * 地图元素对象类型
   * @property {fengmap.FMNodeType} nodeType
   */

  this.nodeType;
  /**
   * 导航查询起点，用来计算与起点与目标距离
   * @property {vec2} startPoint
   */

  this.startPoint;
  /**
   * 导航查询路径线的点集，用来计算缓冲区
   * @property {array} pathPoints
   */

  this.pathPoints;
  /**
   * 缓冲区半径
   * @property {number} bufferRadius
   */

  this.bufferRadius;
};

var _default = FMSearchRequest;
exports.default = _default;

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(13);

__webpack_require__(107);

__webpack_require__(67);

var _isArray = _interopRequireDefault(__webpack_require__(35));

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var FMAttributeQuery =
/*#__PURE__*/
function () {
  function FMAttributeQuery(data) {
    (0, _classCallCheck2.default)(this, FMAttributeQuery);
    this._data = data;
    this.Graphics = new fengmap.inner.Graphics();
  }

  (0, _createClass2.default)(FMAttributeQuery, [{
    key: "check2",
    value: function check2(bdata, gdata, selector, dtype, geo, groupID, result) {
      var name = '';
      var ename = '';
      var typeId = 0;
      var keyword = '';
      var circle;
      var searchPolygon;
      var FID;
      var ID;

      if (selector.name) {
        name = selector.name;
      }

      if (selector.eName) {
        ename = selector.eName;
      }

      if (selector.keyword) {
        keyword = selector.keyword;
      }

      if (selector.circle) {
        circle = selector.circle;
      }

      if (selector.polygon) {
        searchPolygon = selector.polygon.length > 2 ? new SearchPolygon(selector.polygon, true) : null;
      }

      var dataName = bdata.name;
      var dataEname = bdata.ename;
      var type = bdata.type;
      var typeMatch;

      if (selector.typeID !== undefined) {
        if (selector.typeID && type) {
          var typeIDs;

          if (typeof selector.typeID === "number") {
            typeIDs = [selector.typeID];
          } else {
            typeIDs = selector.typeID;
          }

          typeMatch = typeIDs.indexOf((0, _parseInt2.default)(type)) > -1;
        } else {
          typeMatch = false;
        }
      } else {
        typeMatch = true;
      }

      var keyMathch = false;

      if (dataEname && ename && dataEname.toLowerCase().indexOf(ename.toLowerCase()) > -1) {
        keyMathch = true;
      }

      if (dataEname && keyword && dataEname.toLowerCase().indexOf(keyword.toLowerCase()) > -1) {
        keyMathch = true;
      }

      if (dataName && keyword && dataName.toLowerCase().indexOf(keyword.toLowerCase()) > -1) {
        keyMathch = true;
      }

      if (dataName && name && dataName.toLowerCase().indexOf(name.toLowerCase()) > -1) {
        keyMathch = true;
      } // if((keyword && (!dataEname || !dataName)) || (ename && !dataEname) || (name && !dataName )) {
      //     keyMathch = false;
      // } else 


      if (!keyword && !ename && !name) {
        keyMathch = true;
      } //console.log(keyMathch,ename,name,keyword);


      var fidMatch; //支持多个FID查询

      if (selector.FID !== undefined) {
        if (bdata.fid && selector.FID) {
          var _fids = selector.FID;

          if (!(0, _isArray.default)(_fids)) {
            _fids = [_fids.toString()];
          } else {
            _fids = _fids.map(function (a) {
              return a.toString();
            });
          }

          fidMatch = _fids.indexOf(bdata.fid.toString()) > -1;
        } else {
          fidMatch = false;
        }
      } else {
        fidMatch = true;
      }

      var idMatch; //支持多个ID查询

      if (selector.ID !== undefined) {
        if (bdata.eid && selector.ID) {
          var ids = selector.ID;

          if (!(0, _isArray.default)(ids)) {
            ids = [ids.toString()];
          } else {
            fids = fids.map(function (a) {
              return a.toString();
            });
          }

          idMatch = ids.indexOf(bdata.eid.toString()) > -1;
        } else {
          idMatch = false;
        }
      } else {
        idMatch = true;
      }

      var isMarch = keyMathch && typeMatch && fidMatch && idMatch;

      if (isMarch) {
        if (circle) {
          var geopos = gdata.geo;

          if (dtype === "model") {
            geo && (geopos = geo);
          }

          var pos = geopos.substring(6, geopos.length - 1).split(' ');
          var x = (0, _parseFloat2.default)(pos[0]);
          var y = (0, _parseFloat2.default)(pos[1]);
          var center = circle.center;
          var dis = Math.sqrt((x - center.x) * (x - center.x) + (y - center.y) * (y - center.y));

          if (dis < circle.radius) {
            if (result) {
              result.distance = dis;
            }

            return true;
          } else {
            if (dtype == "model") {
              var distance = 0;
              var vertices = null;

              var model = this._map.getFMGroup(groupID).getNodeByLayerId("model", bdata.eid);

              result.target = model;

              if (model && model._data) {
                vertices = model._data.vertices;
              }

              if (vertices == null) {
                vertices = DataManager.convertGeo2Geometry(gdata.geo).vertices;
              }

              var len = vertices.length / 2;

              for (var j = 0; j < len - 1; j++) {
                var index = 2 * j;
                distance = Graphics.pointDistanceToLine(center, {
                  'x': vertices[index],
                  'y': vertices[index + 1]
                }, {
                  'x': vertices[index + 2],
                  'y': vertices[index + 3]
                }, {});

                if (distance < circle.radius) {
                  if (result) {
                    result.distance = dis;
                  }

                  return true;
                }
              }

              if (Graphics.pointInPolygonVector2d(vertices, center, vertices.length)) {
                result.distance = dis;
                return true;
              }
            }

            return false;
          }
        } else if (searchPolygon) {
          var _geopos = gdata.geo;

          if (dtype === "model") {
            geo && (_geopos = geo);
          }

          var _pos = _geopos.substring(6, _geopos.length - 1).split(' ');

          var _center = {
            'x': (0, _parseFloat2.default)(_pos[0]),
            'y': (0, _parseFloat2.default)(_pos[1])
          };

          if (searchPolygon.contain(_center)) {
            result.distance = searchPolygon.distanceToPoint(_center);
            return true;
          }

          if (dtype == "model") {
            var _distance = 0;
            var _vertices = null;

            var _model = this._map.getFMGroup(groupID).getNodeByLayerId("model", bdata.eid);

            result.target = _model;

            if (_model && _model._data) {
              _vertices = _model._data.vertices;
            }

            if (_vertices == null) {
              _vertices = DataManager.convertGeo2Geometry(gdata.geo).vertices;
            }

            if (searchPolygon.containXYArray(_vertices)) {
              result.distance = searchPolygon.distanceToPoint(_center);
              return true;
            }
          }
        } else {
          return true;
        }
      }

      return false;
    }
  }, {
    key: "check",
    value: function check(bdata, gdata, selector, dtype, geo, gid) {
      //检查FID
      if (typeof selector.FID !== "undefined") {
        if (selector.FID !== bdata.fid) return false;
      } //检查groupID


      if (typeof selector.groupID !== "undefined") {
        if ('' + selector.groupID !== '' + gid) return false;
      } //检查ID


      if (typeof selector.ID !== "undefined") {
        if (selector.ID !== bdata.eid) return false;
      } //检查name


      if (typeof selector.name !== "undefined") {
        if (selector.name !== bdata.name) return false;
      } //检查eName


      if (typeof selector.eName !== "undefined") {
        if (selector.eName !== bdata.ename) return false;
      } //检查typeID


      if (typeof selector.typeID !== "undefined") {
        if (selector.typeID !== bdata.type) return false;
      } //检查keyword


      if (typeof selector.keyword !== "undefined") {
        if (bdata.name && bdata.ename) {
          if (bdata.name.toLowerCase().indexOf(selector.keyword.toLowerCase()) < 0) {
            if (bdata.ename && bdata.ename.toLowerCase().indexOf(selector.keyword.toLowerCase()) < 0) {
              return false;
            }
          }
        } else if (bdata.name && !bdata.ename) {
          if (bdata.name.toLowerCase().indexOf(selector.keyword.toLowerCase()) < 0) {
            return false;
          }
        } else if (!bdata.name && bdata.ename) {
          if (bdata.ename.toLowerCase().indexOf(selector.keyword.toLowerCase()) < 0) {
            return false;
          }
        } else if (!bdata.name && !bdata.ename) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "everyModel",
    value: function everyModel(group, back) {
      var len = group.biz[0].modelLayer.length;

      for (var i = 0; i < len; i++) {
        back(group.biz[0].modelLayer[i], group.geo[0].modelLayer[i], "model", group.geo[0].labelLayer[i]);
      }
    }
  }, {
    key: "everyExternalModel",
    value: function everyExternalModel(group, back) {
      var len = group.biz[0].externalModelLayer.length;
      var len2 = group.geo[0].externalModelLayer.length;
      var len3 = group.geo[0].labelLayer.length;

      if (len > len2) {
        len = len2;
      }

      for (var i = 0; i < len; i++) {
        console.log("len", len, group.gid);
        /*console.log(group.biz[0].externalModelLayer[i],318);
        console.log(group.geo[0].externalModelLayer[i],319);
        console.log(group.geo[0].labelLayer[i],320);*/

        back(group.biz[0].externalModelLayer[i], group.geo[0].externalModelLayer[i], "externalModel", group.geo[0].externalModelLayer[i]);
      }
    }
  }, {
    key: "everyFacility",
    value: function everyFacility(group, back) {
      var len = group.biz[0].poiLayer.length;

      for (var i = 0; i < len; i++) {
        back(group.biz[0].poiLayer[i], group.geo[0].poiLayer[i], "poi");
      }
    }
  }, {
    key: "everyLabel",
    value: function everyLabel(group, back) {
      var len = group.biz[0].labelLayer.length;

      for (var i = 0; i < len; i++) {
        back(group.biz[0].labelLayer[i], group.geo[0].labelLayer[i], "label");
      }
    }
  }]);
  return FMAttributeQuery;
}();

var _default = FMAttributeQuery;
exports.default = _default;

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var FMSpatialQuery = function FMSpatialQuery(data) {
  (0, _classCallCheck2.default)(this, FMSpatialQuery);
  this._data = data;
};

var _default = FMSpatialQuery;
exports.default = _default;

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMSpatialQuery2 = _interopRequireDefault(__webpack_require__(253));

/**
 * @author Mif /  Made on March 11, 2020/
 */
// import SearchPolygon from "../locationQuery/SearchPolygon";
var FMLocationQuery =
/*#__PURE__*/
function (_FMSpatialQuery) {
  (0, _inherits2.default)(FMLocationQuery, _FMSpatialQuery);

  function FMLocationQuery(data, map) {
    var _this;

    (0, _classCallCheck2.default)(this, FMLocationQuery);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMLocationQuery).call(this, data)); // this.searchPolygon = SearchPolygon;

    _this._map = map;
    _this.Graphics = fengmap.inner.Graphics;
    return _this;
  }

  return FMLocationQuery;
}(_FMSpatialQuery2.default);

var _default = FMLocationQuery;
exports.default = _default;

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(258);

__webpack_require__(363);

__webpack_require__(365);

__webpack_require__(366);

var _FMMap = _interopRequireDefault(__webpack_require__(200));

var _FMMapUtil = _interopRequireDefault(__webpack_require__(113));

var _FMExtentLayer = _interopRequireDefault(__webpack_require__(210));

var _FMControlPosition = _interopRequireDefault(__webpack_require__(240));

var _FMScrollGroupsControl = _interopRequireDefault(__webpack_require__(420));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _FMEdgesLinesType = _interopRequireDefault(__webpack_require__(152));

var _FMImageMarker = _interopRequireDefault(__webpack_require__(423));

var _FMImageMarkerLayer = _interopRequireDefault(__webpack_require__(217));

var _FMLabelLayer = _interopRequireDefault(__webpack_require__(213));

var _FMFacilityLayer = _interopRequireDefault(__webpack_require__(215));

var _FMTextMarker = _interopRequireDefault(__webpack_require__(424));

var _FMDynamicLineMarker = _interopRequireDefault(__webpack_require__(425));

var _FMDynamicLineMarkerLayer = _interopRequireDefault(__webpack_require__(226));

var _FMLocationMarker = _interopRequireDefault(__webpack_require__(428));

var _FMLineType = _interopRequireDefault(__webpack_require__(243));

var _FMLineMarker = _interopRequireDefault(__webpack_require__(155));

var _FMSegment = _interopRequireDefault(__webpack_require__(247));

var _FMPolygonMarker = _interopRequireDefault(__webpack_require__(432));

var _FMGradientPolygonMarker = _interopRequireDefault(__webpack_require__(434));

var _FMExtrudeMarker = _interopRequireDefault(__webpack_require__(438));

var _FMPolygonMarkerLayer = _interopRequireDefault(__webpack_require__(218));

var _FMGradientPolygonMarkerLayer = _interopRequireDefault(__webpack_require__(219));

var _FMExtrudeMarkerLayer = _interopRequireDefault(__webpack_require__(227));

var _FMDynamicModel = _interopRequireDefault(__webpack_require__(236));

var _FMDynamicModelLayer = _interopRequireDefault(__webpack_require__(225));

var _FMHeatMapLayer = _interopRequireDefault(__webpack_require__(222));

var _FMTextMarkerLayer = _interopRequireDefault(__webpack_require__(221));

var _FMDomMarkerLayer = _interopRequireDefault(__webpack_require__(224));

var _FMDomMarker = _interopRequireDefault(__webpack_require__(440));

var _HeatMap = _interopRequireDefault(__webpack_require__(441));

var _FMSearchAnalyser = _interopRequireDefault(__webpack_require__(442));

var _FMSearchRequest = _interopRequireDefault(__webpack_require__(251));

var _FMNaviMode = _interopRequireDefault(__webpack_require__(452));

var _FMTextAlign = _interopRequireDefault(__webpack_require__(453));

var _FMNaviPriority = _interopRequireDefault(__webpack_require__(454));

var _viewMode = _interopRequireDefault(__webpack_require__(455));

var _FMLanguageType = _interopRequireDefault(__webpack_require__(80));

var _FMDirection = _interopRequireDefault(__webpack_require__(203));

var _FMRouteCalcuResult = _interopRequireDefault(__webpack_require__(456));

var _FMMapCoord = _interopRequireDefault(__webpack_require__(457));

var _FMLabel = _interopRequireDefault(__webpack_require__(214));

var _FMModel = _interopRequireDefault(__webpack_require__(212));

var _FMPoi = _interopRequireDefault(__webpack_require__(216));

var _FMExternalModel = _interopRequireDefault(__webpack_require__(211));

var _FMGroup = _interopRequireDefault(__webpack_require__(209));

var _FMNode = _interopRequireDefault(__webpack_require__(7));

var _FMScreenCoord = _interopRequireDefault(__webpack_require__(458));

var _FMMapGestureEnableController = _interopRequireDefault(__webpack_require__(237));

var _FMMapCoordTransformer = _interopRequireDefault(__webpack_require__(459));

var _FMVersion = _interopRequireDefault(__webpack_require__(234));

var _FMMarkerAnchor = _interopRequireDefault(__webpack_require__(153));

var _FMRenderer = _interopRequireDefault(__webpack_require__(239));

var _Graphics = _interopRequireDefault(__webpack_require__(49));

var _EventDispatcher = _interopRequireDefault(__webpack_require__(235));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

var _FMUtil = _interopRequireDefault(__webpack_require__(57));

var _FMLineMarker2 = _interopRequireDefault(__webpack_require__(155));

var _NaviDataType = _interopRequireDefault(__webpack_require__(460));

var _NaviService = _interopRequireDefault(__webpack_require__(238));

var _BoundingBox = _interopRequireDefault(__webpack_require__(461));

var _Enum = __webpack_require__(109);

var _FMCalculator = _interopRequireDefault(__webpack_require__(462));

//import * as fm from "expose-loader?./lib/three.module.js";
//import '@babel/polyfill';
if (false) {}

var fengmap = {
  VERSION: _FMVersion.default.VERSION,
  BUILD: _FMVersion.default.BUILD,
  Map: _FMMap.default,
  FMMap: _FMMap.default,
  MapUtil: _FMMapUtil.default,
  //controlOptions: FMControlOptions, //v2.3.0 以后弃用
  //FMControlOptions: FMControlOptions,
  //zoomControl: FMZoomControl, //v2.3.0 以后弃用
  //FMZoomControl: FMZoomControl,
  controlPositon: _FMControlPosition.default,
  //v2.3.0 以后弃用
  FMControlPosition: _FMControlPosition.default,
  //scrollGroupsControl: FMScrollGroupsControl, //v2.3.0 以后弃用
  //FMScrollGroupsControl: FMScrollGroupsControl,
  //buttonGroupsControl: FMButtonGroupsControl, //v2.3.0 以后弃用
  //FMButtonGroupsControl: FMButtonGroupsControl,
  FMViewMode: _viewMode.default,
  FMDynamicModel: _FMDynamicModel.default,
  FMDynamicModelLayer: _FMDynamicModelLayer.default,
  FMLanguageType: _FMLanguageType.default,
  //toolControl: FMToolControl, //v2.3.0 以后弃用
  //FMToolControl: FMToolControl,
  FMNodeType: _FMNodeType.default,
  FMImageMarker: _FMImageMarker.default,
  //FMPopInfoWindow: FMPopInfoWindow,
  FMTextMarker: _FMTextMarker.default,
  FMLocationMarker: _FMLocationMarker.default,
  FMLineMarker: _FMLineMarker.default,
  FMExtentLayer: _FMExtentLayer.default,
  FMSegment: _FMSegment.default,
  FMPolygonMarker: _FMPolygonMarker.default,
  FMGradientPolygonMarker: _FMGradientPolygonMarker.default,
  FMExtrudeMarker: _FMExtrudeMarker.default,
  FMPolygonMarkerLayer: _FMPolygonMarkerLayer.default,
  FMGradientPolygonMarkerLayer: _FMGradientPolygonMarkerLayer.default,
  FMExtrudeMarkerLayer: _FMExtrudeMarkerLayer.default,
  FMImageMarkerLayer: _FMImageMarkerLayer.default,
  FMLabelLayer: _FMLabelLayer.default,
  FMFacilityLayer: _FMFacilityLayer.default,
  FMHeatMapLayer: _FMHeatMapLayer.default,
  FMHeatMap: _HeatMap.default,
  FMSearchRequest: _FMSearchRequest.default,
  FMSearchAnalyser: _FMSearchAnalyser.default,
  FMLineType: _FMLineType.default,
  FMNaviModule: _FMNaviMode.default,
  //兼容旧方法
  FMNaviMode: _FMNaviMode.default,
  FMTextAlign: _FMTextAlign.default,
  FMNaviPriority: _FMNaviPriority.default,
  FMRouteCalcuResult: _FMRouteCalcuResult.default,
  FMMapCoord: _FMMapCoord.default,
  FMGroup: _FMGroup.default,
  FMLabel: _FMLabel.default,
  FMStoreModel: _FMModel.default,
  FMElement: _FMExternalModel.default,
  FMExternalModel: _FMExternalModel.default,
  FMFacility: _FMPoi.default,
  FMNode: _FMNode.default,
  FMDirection: _FMDirection.default,
  FMScreenCoord: _FMScreenCoord.default,
  FMMapGestureEnableController: _FMMapGestureEnableController.default,
  FMTextMarkerLayer: _FMTextMarkerLayer.default,
  FMDomMarkerLayer: _FMDomMarkerLayer.default,
  FMDomMarker: _FMDomMarker.default,
  FMMapCoordTransformer: _FMMapCoordTransformer.default,
  MapCoordTransform: _FMMapCoordTransformer.default,
  FMMarkerAnchor: _FMMarkerAnchor.default,
  FMLayerOrder: _Enum.LayerOrder,
  FMRenderer: _FMRenderer.default,
  // FMWaterMarker: FMWaterMarker,
  // FMWaterMarkerLayer:FMWaterMarkerLayer,
  // FMDynamicLineMarker:FMDynamicLineMarker,
  // FMDynamicLineMarkerLayer:FMDynamicLineMarkerLayer,
  //SkyEffect:SkyEffect,
  //ReflectEffect:ReflectEffect,
  inner: {
    Graphics: _Graphics.default,
    FMSegment: _FMSegment.default,
    FMNaviMode: _FMNaviMode.default,
    FMNaviPriority: _FMNaviPriority.default,
    FMRouteCalcuResult: _FMRouteCalcuResult.default,
    EventDispatcher: _EventDispatcher.default,
    DataManager: _DataManager.default,
    FMUtil: _FMUtil.default,
    FMImageMarker: _FMImageMarker.default,
    FMLineMarker: _FMLineMarker2.default,
    FMLocationMarker: _FMLocationMarker.default,
    FMLanguageType: _FMLanguageType.default,
    NaviDataType: _NaviDataType.default,
    NaviService: _NaviService.default,
    FMMapCoord: _FMMapCoord.default,
    BoundingBox: _BoundingBox.default
  } // MapService:{}

};
fengmap["MercatorToWGS84"] = _FMCalculator.default.MercatorToWGS84;
fengmap["WGS84ToWebMercator"] = _FMCalculator.default.WGS84ToWebMercator;
fengmap["Contain"] = _FMCalculator.default.Contain;
fengmap["GetLength"] = _FMCalculator.default.GetLength;
fengmap["GetArea"] = _FMCalculator.default.GetArea;
window['fm'] = fm;
window['fengmap'] = fengmap;
var _default = fengmap;
exports.default = _default;

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(257);
var $Object = __webpack_require__(9).Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};


/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(10);
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !__webpack_require__(26), 'Object', { defineProperty: __webpack_require__(28).f });


/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["fm"] = __webpack_require__(81);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(157)))

/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(22);

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(117)('native-function-to-string', Function.toString);


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(24);
var inheritIfRequired = __webpack_require__(160);
var dP = __webpack_require__(33).f;
var gOPN = __webpack_require__(87).f;
var isRegExp = __webpack_require__(164);
var $flags = __webpack_require__(89);
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(23) && (!CORRECT_NEW || __webpack_require__(18)(function () {
  re2[__webpack_require__(15)('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  __webpack_require__(38)(global, 'RegExp', $RegExp);
}

__webpack_require__(165)('RegExp');


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(37);
var anObject = __webpack_require__(30);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(85)(Function.call, __webpack_require__(119).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 263 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(59);
__webpack_require__(268);
module.exports = __webpack_require__(9).Array.from;


/***/ }),
/* 264 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(123);
var defined = __webpack_require__(90);
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};


/***/ }),
/* 265 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(91);
var descriptor = __webpack_require__(71);
var setToStringTag = __webpack_require__(78);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(43)(IteratorPrototype, __webpack_require__(19)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 266 */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(61);
var toLength = __webpack_require__(92);
var toAbsoluteIndex = __webpack_require__(267);
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};


/***/ }),
/* 267 */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(123);
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};


/***/ }),
/* 268 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ctx = __webpack_require__(36);
var $export = __webpack_require__(10);
var toObject = __webpack_require__(52);
var call = __webpack_require__(171);
var isArrayIter = __webpack_require__(172);
var toLength = __webpack_require__(92);
var createProperty = __webpack_require__(269);
var getIterFn = __webpack_require__(130);

$export($export.S + $export.F * !__webpack_require__(173)(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});


/***/ }),
/* 269 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $defineProperty = __webpack_require__(28);
var createDesc = __webpack_require__(71);

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};


/***/ }),
/* 270 */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),
/* 271 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpExec = __webpack_require__(131);
__webpack_require__(22)({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});


/***/ }),
/* 272 */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return { value: value, done: !!done };
};


/***/ }),
/* 273 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var create = __webpack_require__(132);
var descriptor = __webpack_require__(83);
var setToStringTag = __webpack_require__(134);
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
__webpack_require__(32)(IteratorPrototype, __webpack_require__(15)('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};


/***/ }),
/* 274 */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(33);
var anObject = __webpack_require__(30);
var getKeys = __webpack_require__(133);

module.exports = __webpack_require__(23) ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};


/***/ }),
/* 275 */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(24).document;
module.exports = document && document.documentElement;


/***/ }),
/* 276 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(277);

/***/ }),
/* 277 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(278);
module.exports = __webpack_require__(9).Object.freeze;


/***/ }),
/* 278 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(17);
var meta = __webpack_require__(64).onFreeze;

__webpack_require__(135)('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});


/***/ }),
/* 279 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(280);

/***/ }),
/* 280 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(59);
__webpack_require__(65);
module.exports = __webpack_require__(136).f('iterator');


/***/ }),
/* 281 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var addToUnscopables = __webpack_require__(282);
var step = __webpack_require__(178);
var Iterators = __webpack_require__(60);
var toIObject = __webpack_require__(61);

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = __webpack_require__(124)(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),
/* 282 */
/***/ (function(module, exports) {

module.exports = function () { /* empty */ };


/***/ }),
/* 283 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(284);

/***/ }),
/* 284 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(285);
__webpack_require__(100);
__webpack_require__(288);
__webpack_require__(289);
module.exports = __webpack_require__(9).Symbol;


/***/ }),
/* 285 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// ECMAScript 6 symbols shim
var global = __webpack_require__(14);
var has = __webpack_require__(45);
var DESCRIPTORS = __webpack_require__(26);
var $export = __webpack_require__(10);
var redefine = __webpack_require__(125);
var META = __webpack_require__(64).KEY;
var $fails = __webpack_require__(44);
var shared = __webpack_require__(128);
var setToStringTag = __webpack_require__(78);
var uid = __webpack_require__(93);
var wks = __webpack_require__(19);
var wksExt = __webpack_require__(136);
var wksDefine = __webpack_require__(137);
var enumKeys = __webpack_require__(286);
var isArray = __webpack_require__(139);
var anObject = __webpack_require__(29);
var isObject = __webpack_require__(17);
var toObject = __webpack_require__(52);
var toIObject = __webpack_require__(61);
var toPrimitive = __webpack_require__(116);
var createDesc = __webpack_require__(71);
var _create = __webpack_require__(91);
var gOPNExt = __webpack_require__(287);
var $GOPD = __webpack_require__(180);
var $GOPS = __webpack_require__(138);
var $DP = __webpack_require__(28);
var $keys = __webpack_require__(76);
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(179).f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(99).f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(75)) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
var FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });

$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(43)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);


/***/ }),
/* 286 */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(76);
var gOPS = __webpack_require__(138);
var pIE = __webpack_require__(99);
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};


/***/ }),
/* 287 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(61);
var gOPN = __webpack_require__(179).f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};


/***/ }),
/* 288 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(137)('asyncIterator');


/***/ }),
/* 289 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(137)('observable');


/***/ }),
/* 290 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(100);
__webpack_require__(59);
__webpack_require__(65);
__webpack_require__(291);
__webpack_require__(295);
__webpack_require__(298);
__webpack_require__(299);
module.exports = __webpack_require__(9).Map;


/***/ }),
/* 291 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var strong = __webpack_require__(292);
var validate = __webpack_require__(79);
var MAP = 'Map';

// 23.1 Map Objects
module.exports = __webpack_require__(183)(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);


/***/ }),
/* 292 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var dP = __webpack_require__(28).f;
var create = __webpack_require__(91);
var redefineAll = __webpack_require__(101);
var ctx = __webpack_require__(36);
var anInstance = __webpack_require__(102);
var forOf = __webpack_require__(66);
var $iterDefine = __webpack_require__(124);
var step = __webpack_require__(178);
var setSpecies = __webpack_require__(182);
var DESCRIPTORS = __webpack_require__(26);
var fastKey = __webpack_require__(64).fastKey;
var validate = __webpack_require__(79);
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};


/***/ }),
/* 293 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(294);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 294 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(17);
var isArray = __webpack_require__(139);
var SPECIES = __webpack_require__(19)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 295 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = __webpack_require__(10);

$export($export.P + $export.R, 'Map', { toJSON: __webpack_require__(296)('Map') });


/***/ }),
/* 296 */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = __webpack_require__(94);
var from = __webpack_require__(297);
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};


/***/ }),
/* 297 */
/***/ (function(module, exports, __webpack_require__) {

var forOf = __webpack_require__(66);

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};


/***/ }),
/* 298 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
__webpack_require__(184)('Map');


/***/ }),
/* 299 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
__webpack_require__(185)('Map');


/***/ }),
/* 300 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(301);

/***/ }),
/* 301 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(100);
__webpack_require__(65);
__webpack_require__(302);
__webpack_require__(304);
__webpack_require__(305);
module.exports = __webpack_require__(9).WeakMap;


/***/ }),
/* 302 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(14);
var each = __webpack_require__(140)(0);
var redefine = __webpack_require__(125);
var meta = __webpack_require__(64);
var assign = __webpack_require__(189);
var weak = __webpack_require__(303);
var isObject = __webpack_require__(17);
var validate = __webpack_require__(79);
var NATIVE_WEAK_MAP = __webpack_require__(79);
var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = __webpack_require__(183)(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}


/***/ }),
/* 303 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(101);
var getWeak = __webpack_require__(64).getWeak;
var anObject = __webpack_require__(29);
var isObject = __webpack_require__(17);
var anInstance = __webpack_require__(102);
var forOf = __webpack_require__(66);
var createArrayMethod = __webpack_require__(140);
var $has = __webpack_require__(45);
var validate = __webpack_require__(79);
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};


/***/ }),
/* 304 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
__webpack_require__(184)('WeakMap');


/***/ }),
/* 305 */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
__webpack_require__(185)('WeakMap');


/***/ }),
/* 306 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(307);

/***/ }),
/* 307 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(308);
module.exports = __webpack_require__(9).Object.getPrototypeOf;


/***/ }),
/* 308 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(52);
var $getPrototypeOf = __webpack_require__(170);

__webpack_require__(135)('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});


/***/ }),
/* 309 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(310);
module.exports = __webpack_require__(9).Object.setPrototypeOf;


/***/ }),
/* 310 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(10);
$export($export.S, 'Object', { setPrototypeOf: __webpack_require__(311).set });


/***/ }),
/* 311 */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = __webpack_require__(17);
var anObject = __webpack_require__(29);
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = __webpack_require__(36)(Function.call, __webpack_require__(180).f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};


/***/ }),
/* 312 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(313);
var $Object = __webpack_require__(9).Object;
module.exports = function create(P, D) {
  return $Object.create(P, D);
};


/***/ }),
/* 313 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(10);
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: __webpack_require__(91) });


/***/ }),
/* 314 */
/***/ (function(module, exports, __webpack_require__) {

var _Object$setPrototypeOf = __webpack_require__(190);

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = _Object$setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),
/* 315 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(18);

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};


/***/ }),
/* 316 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(317);
module.exports = __webpack_require__(9).Object.keys;


/***/ }),
/* 317 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(52);
var $keys = __webpack_require__(76);

__webpack_require__(135)('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});


/***/ }),
/* 318 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 319 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(24);
var DESCRIPTORS = __webpack_require__(23);
var LIBRARY = __webpack_require__(84);
var $typed = __webpack_require__(191);
var hide = __webpack_require__(32);
var redefineAll = __webpack_require__(192);
var fails = __webpack_require__(18);
var anInstance = __webpack_require__(193);
var toInteger = __webpack_require__(46);
var toLength = __webpack_require__(34);
var toIndex = __webpack_require__(194);
var gOPN = __webpack_require__(87).f;
var dP = __webpack_require__(33).f;
var arrayFill = __webpack_require__(142);
var setToStringTag = __webpack_require__(134);
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),
/* 320 */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(63);
var ITERATOR = __webpack_require__(15)('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};


/***/ }),
/* 321 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(96);
var ITERATOR = __webpack_require__(15)('iterator');
var Iterators = __webpack_require__(63);
module.exports = __webpack_require__(82).getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),
/* 322 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(85);
var IObject = __webpack_require__(120);
var toObject = __webpack_require__(39);
var toLength = __webpack_require__(34);
var asc = __webpack_require__(323);
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};


/***/ }),
/* 323 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(324);

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};


/***/ }),
/* 324 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(37);
var isArray = __webpack_require__(325);
var SPECIES = __webpack_require__(15)('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};


/***/ }),
/* 325 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(74);
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};


/***/ }),
/* 326 */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(15)('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};


/***/ }),
/* 327 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)

var toObject = __webpack_require__(39);
var toAbsoluteIndex = __webpack_require__(88);
var toLength = __webpack_require__(34);

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),
/* 328 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),
/* 329 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(40)('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),
/* 330 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(331);
module.exports = __webpack_require__(9).parseInt;


/***/ }),
/* 331 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(10);
var $parseInt = __webpack_require__(332);
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });


/***/ }),
/* 332 */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(14).parseInt;
var $trim = __webpack_require__(198).trim;
var ws = __webpack_require__(145);
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;


/***/ }),
/* 333 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(334);
module.exports = __webpack_require__(9).parseFloat;


/***/ }),
/* 334 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(10);
var $parseFloat = __webpack_require__(335);
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });


/***/ }),
/* 335 */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(14).parseFloat;
var $trim = __webpack_require__(198).trim;

module.exports = 1 / $parseFloat(__webpack_require__(145) + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;


/***/ }),
/* 336 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $export = __webpack_require__(22);
var toObject = __webpack_require__(39);
var toPrimitive = __webpack_require__(72);

$export($export.P + $export.F * __webpack_require__(18)(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),
/* 337 */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(9);
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};


/***/ }),
/* 338 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(339);
module.exports = __webpack_require__(9).Array.isArray;


/***/ }),
/* 339 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(10);

$export($export.S, 'Array', { isArray: __webpack_require__(139) });


/***/ }),
/* 340 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(46);
var defined = __webpack_require__(51);

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};


/***/ }),
/* 341 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(342);
var $Object = __webpack_require__(9).Object;
module.exports = function defineProperties(T, D) {
  return $Object.defineProperties(T, D);
};


/***/ }),
/* 342 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(10);
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !__webpack_require__(26), 'Object', { defineProperties: __webpack_require__(167) });


/***/ }),
/* 343 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(22);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(344) });


/***/ }),
/* 344 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 19.1.2.1 Object.assign(target, source, ...)
var DESCRIPTORS = __webpack_require__(23);
var getKeys = __webpack_require__(133);
var gOPS = __webpack_require__(345);
var pIE = __webpack_require__(161);
var toObject = __webpack_require__(39);
var IObject = __webpack_require__(120);
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || __webpack_require__(18)(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  } return T;
} : $assign;


/***/ }),
/* 345 */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),
/* 346 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(347);
module.exports = __webpack_require__(9).Object.assign;


/***/ }),
/* 347 */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(10);

$export($export.S + $export.F, 'Object', { assign: __webpack_require__(189) });


/***/ }),
/* 348 */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(23) && /./g.flags != 'g') __webpack_require__(33).f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(89)
});


/***/ }),
/* 349 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(22);

$export($export.S, 'Math', { sign: __webpack_require__(350) });


/***/ }),
/* 350 */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),
/* 351 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(22);

$export($export.S, 'Number', { isInteger: __webpack_require__(352) });


/***/ }),
/* 352 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(37);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 353 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(354);

/***/ }),
/* 354 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(355);
module.exports = __webpack_require__(9).Number.isInteger;


/***/ }),
/* 355 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(10);

$export($export.S, 'Number', { isInteger: __webpack_require__(356) });


/***/ }),
/* 356 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(17);
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),
/* 357 */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(22);
var defined = __webpack_require__(51);
var fails = __webpack_require__(18);
var spaces = __webpack_require__(358);
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;


/***/ }),
/* 358 */
/***/ (function(module, exports) {

module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),
/* 359 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(22);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 360 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(361);

/***/ }),
/* 361 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(362);
module.exports = Math.pow(2, -52);


/***/ }),
/* 362 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(10);

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });


/***/ }),
/* 363 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["TWEEN"] = __webpack_require__(364);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(157)))

/***/ }),
/* 364 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 * Tween.js - Licensed under the MIT license
 * https://github.com/tweenjs/tween.js
 * ----------------------------------------------
 *
 * See https://github.com/tweenjs/tween.js/graphs/contributors for the full list of contributors.
 * Thank you all, you're awesome!
 */


var _Group = function () {
	this._tweens = {};
	this._tweensAddedDuringUpdate = {};
};

_Group.prototype = {
	getAll: function () {

		return Object.keys(this._tweens).map(function (tweenId) {
			return this._tweens[tweenId];
		}.bind(this));

	},

	removeAll: function () {

		this._tweens = {};

	},

	add: function (tween) {

		this._tweens[tween.getId()] = tween;
		this._tweensAddedDuringUpdate[tween.getId()] = tween;

	},

	remove: function (tween) {

		delete this._tweens[tween.getId()];
		delete this._tweensAddedDuringUpdate[tween.getId()];

	},

	update: function (time, preserve) {

		var tweenIds = Object.keys(this._tweens);

		if (tweenIds.length === 0) {
			return false;
		}

		time = time !== undefined ? time : TWEEN.now();

		// Tweens are updated in "batches". If you add a new tween during an update, then the
		// new tween will be updated in the next batch.
		// If you remove a tween during an update, it may or may not be updated. However,
		// if the removed tween was added during the current batch, then it will not be updated.
		while (tweenIds.length > 0) {
			this._tweensAddedDuringUpdate = {};

			for (var i = 0; i < tweenIds.length; i++) {

				var tween = this._tweens[tweenIds[i]];

				if (tween && tween.update(time) === false) {
					tween._isPlaying = false;

					if (!preserve) {
						delete this._tweens[tweenIds[i]];
					}
				}
			}

			tweenIds = Object.keys(this._tweensAddedDuringUpdate);
		}

		return true;

	}
};

var TWEEN = new _Group();

TWEEN.Group = _Group;
TWEEN._nextId = 0;
TWEEN.nextId = function () {
	return TWEEN._nextId++;
};


// Include a performance.now polyfill.
// In node.js, use process.hrtime.
if (typeof (self) === 'undefined' && typeof (process) !== 'undefined' && process.hrtime) {
	TWEEN.now = function () {
		var time = process.hrtime();

		// Convert [seconds, nanoseconds] to milliseconds.
		return time[0] * 1000 + time[1] / 1000000;
	};
}
// In a browser, use self.performance.now if it is available.
else if (typeof (self) !== 'undefined' &&
         self.performance !== undefined &&
		 self.performance.now !== undefined) {
	// This must be bound, because directly assigning this function
	// leads to an invocation exception in Chrome.
	TWEEN.now = self.performance.now.bind(self.performance);
}
// Use Date.now if it is available.
else if (Date.now !== undefined) {
	TWEEN.now = Date.now;
}
// Otherwise, use 'new Date().getTime()'.
else {
	TWEEN.now = function () {
		return new Date().getTime();
	};
}


TWEEN.Tween = function (object, group) {
	this._object = object;
	this._valuesStart = {};
	this._valuesEnd = {};
	this._valuesStartRepeat = {};
	this._duration = 1000;
	this._repeat = 0;
	this._repeatDelayTime = undefined;
	this._yoyo = false;
	this._isPlaying = false;
	this._reversed = false;
	this._delayTime = 0;
	this._startTime = null;
	this._easingFunction = TWEEN.Easing.Linear.None;
	this._interpolationFunction = TWEEN.Interpolation.Linear;
	this._chainedTweens = [];
	this._onStartCallback = null;
	this._onStartCallbackFired = false;
	this._onUpdateCallback = null;
	this._onRepeatCallback = null;
	this._onCompleteCallback = null;
	this._onStopCallback = null;
	this._group = group || TWEEN;
	this._id = TWEEN.nextId();

};

TWEEN.Tween.prototype = {
	getId: function () {
		return this._id;
	},

	isPlaying: function () {
		return this._isPlaying;
	},

	to: function (properties, duration) {

		this._valuesEnd = Object.create(properties);

		if (duration !== undefined) {
			this._duration = duration;
		}

		return this;

	},

	duration: function duration(d) {
		this._duration = d;
		return this;
	},

	start: function (time) {

		this._group.add(this);

		this._isPlaying = true;

		this._onStartCallbackFired = false;

		this._startTime = time !== undefined ? typeof time === 'string' ? TWEEN.now() + parseFloat(time) : time : TWEEN.now();
		this._startTime += this._delayTime;

		for (var property in this._valuesEnd) {

			// Check if an Array was provided as property value
			if (this._valuesEnd[property] instanceof Array) {

				if (this._valuesEnd[property].length === 0) {
					continue;
				}

				// Create a local copy of the Array with the start value at the front
				this._valuesEnd[property] = [this._object[property]].concat(this._valuesEnd[property]);

			}

			// If `to()` specifies a property that doesn't exist in the source object,
			// we should not set that property in the object
			if (this._object[property] === undefined) {
				continue;
			}

			// Save the starting value.
			this._valuesStart[property] = this._object[property];

			if ((this._valuesStart[property] instanceof Array) === false) {
				this._valuesStart[property] *= 1.0; // Ensures we're using numbers, not strings
			}

			this._valuesStartRepeat[property] = this._valuesStart[property] || 0;

		}

		return this;

	},

	stop: function () {

		if (!this._isPlaying) {
			return this;
		}

		this._group.remove(this);
		this._isPlaying = false;

		if (this._onStopCallback !== null) {
			this._onStopCallback(this._object);
		}

		this.stopChainedTweens();
		return this;

	},

	end: function () {

		this.update(Infinity);
		return this;

	},

	stopChainedTweens: function () {

		for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
			this._chainedTweens[i].stop();
		}

	},

	group: function (group) {
		this._group = group;
		return this;
	},

	delay: function (amount) {

		this._delayTime = amount;
		return this;

	},

	repeat: function (times) {

		this._repeat = times;
		return this;

	},

	repeatDelay: function (amount) {

		this._repeatDelayTime = amount;
		return this;

	},

	yoyo: function (yoyo) {

		this._yoyo = yoyo;
		return this;

	},

	easing: function (easingFunction) {

		this._easingFunction = easingFunction;
		return this;

	},

	interpolation: function (interpolationFunction) {

		this._interpolationFunction = interpolationFunction;
		return this;

	},

	chain: function () {

		this._chainedTweens = arguments;
		return this;

	},

	onStart: function (callback) {

		this._onStartCallback = callback;
		return this;

	},

	onUpdate: function (callback) {

		this._onUpdateCallback = callback;
		return this;

	},

	onRepeat: function onRepeat(callback) {

		this._onRepeatCallback = callback;
		return this;

	},

	onComplete: function (callback) {

		this._onCompleteCallback = callback;
		return this;

	},

	onStop: function (callback) {

		this._onStopCallback = callback;
		return this;

	},

	update: function (time) {

		var property;
		var elapsed;
		var value;

		if (time < this._startTime) {
			return true;
		}

		if (this._onStartCallbackFired === false) {

			if (this._onStartCallback !== null) {
				this._onStartCallback(this._object);
			}

			this._onStartCallbackFired = true;
		}

		elapsed = (time - this._startTime) / this._duration;
		elapsed = (this._duration === 0 || elapsed > 1) ? 1 : elapsed;

		value = this._easingFunction(elapsed);

		for (property in this._valuesEnd) {

			// Don't update properties that do not exist in the source object
			if (this._valuesStart[property] === undefined) {
				continue;
			}

			var start = this._valuesStart[property] || 0;
			var end = this._valuesEnd[property];

			if (end instanceof Array) {

				this._object[property] = this._interpolationFunction(end, value);

			} else {

				// Parses relative end values with start as base (e.g.: +10, -3)
				if (typeof (end) === 'string') {

					if (end.charAt(0) === '+' || end.charAt(0) === '-') {
						end = start + parseFloat(end);
					} else {
						end = parseFloat(end);
					}
				}

				// Protect against non numeric properties.
				if (typeof (end) === 'number') {
					this._object[property] = start + (end - start) * value;
				}

			}

		}

		if (this._onUpdateCallback !== null) {
			this._onUpdateCallback(this._object, elapsed);
		}

		if (elapsed === 1) {

			if (this._repeat > 0) {

				if (isFinite(this._repeat)) {
					this._repeat--;
				}

				// Reassign starting values, restart by making startTime = now
				for (property in this._valuesStartRepeat) {

					if (typeof (this._valuesEnd[property]) === 'string') {
						this._valuesStartRepeat[property] = this._valuesStartRepeat[property] + parseFloat(this._valuesEnd[property]);
					}

					if (this._yoyo) {
						var tmp = this._valuesStartRepeat[property];

						this._valuesStartRepeat[property] = this._valuesEnd[property];
						this._valuesEnd[property] = tmp;
					}

					this._valuesStart[property] = this._valuesStartRepeat[property];

				}

				if (this._yoyo) {
					this._reversed = !this._reversed;
				}

				if (this._repeatDelayTime !== undefined) {
					this._startTime = time + this._repeatDelayTime;
				} else {
					this._startTime = time + this._delayTime;
				}

				if (this._onRepeatCallback !== null) {
					this._onRepeatCallback(this._object);
				}

				return true;

			} else {

				if (this._onCompleteCallback !== null) {

					this._onCompleteCallback(this._object);
				}

				for (var i = 0, numChainedTweens = this._chainedTweens.length; i < numChainedTweens; i++) {
					// Make the chained tweens start exactly at the time they should,
					// even if the `update()` method was called way past the duration of the tween
					this._chainedTweens[i].start(this._startTime + this._duration);
				}

				return false;

			}

		}

		return true;

	}
};


TWEEN.Easing = {

	Linear: {

		None: function (k) {

			return k;

		}

	},

	Quadratic: {

		In: function (k) {

			return k * k;

		},

		Out: function (k) {

			return k * (2 - k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k;
			}

			return - 0.5 * (--k * (k - 2) - 1);

		}

	},

	Cubic: {

		In: function (k) {

			return k * k * k;

		},

		Out: function (k) {

			return --k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k + 2);

		}

	},

	Quartic: {

		In: function (k) {

			return k * k * k * k;

		},

		Out: function (k) {

			return 1 - (--k * k * k * k);

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k;
			}

			return - 0.5 * ((k -= 2) * k * k * k - 2);

		}

	},

	Quintic: {

		In: function (k) {

			return k * k * k * k * k;

		},

		Out: function (k) {

			return --k * k * k * k * k + 1;

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return 0.5 * k * k * k * k * k;
			}

			return 0.5 * ((k -= 2) * k * k * k * k + 2);

		}

	},

	Sinusoidal: {

		In: function (k) {

			return 1 - Math.cos(k * Math.PI / 2);

		},

		Out: function (k) {

			return Math.sin(k * Math.PI / 2);

		},

		InOut: function (k) {

			return 0.5 * (1 - Math.cos(Math.PI * k));

		}

	},

	Exponential: {

		In: function (k) {

			return k === 0 ? 0 : Math.pow(1024, k - 1);

		},

		Out: function (k) {

			return k === 1 ? 1 : 1 - Math.pow(2, - 10 * k);

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			if ((k *= 2) < 1) {
				return 0.5 * Math.pow(1024, k - 1);
			}

			return 0.5 * (- Math.pow(2, - 10 * (k - 1)) + 2);

		}

	},

	Circular: {

		In: function (k) {

			return 1 - Math.sqrt(1 - k * k);

		},

		Out: function (k) {

			return Math.sqrt(1 - (--k * k));

		},

		InOut: function (k) {

			if ((k *= 2) < 1) {
				return - 0.5 * (Math.sqrt(1 - k * k) - 1);
			}

			return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);

		}

	},

	Elastic: {

		In: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return -Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);

		},

		Out: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			return Math.pow(2, -10 * k) * Math.sin((k - 0.1) * 5 * Math.PI) + 1;

		},

		InOut: function (k) {

			if (k === 0) {
				return 0;
			}

			if (k === 1) {
				return 1;
			}

			k *= 2;

			if (k < 1) {
				return -0.5 * Math.pow(2, 10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI);
			}

			return 0.5 * Math.pow(2, -10 * (k - 1)) * Math.sin((k - 1.1) * 5 * Math.PI) + 1;

		}

	},

	Back: {

		In: function (k) {

			var s = 1.70158;

			return k * k * ((s + 1) * k - s);

		},

		Out: function (k) {

			var s = 1.70158;

			return --k * k * ((s + 1) * k + s) + 1;

		},

		InOut: function (k) {

			var s = 1.70158 * 1.525;

			if ((k *= 2) < 1) {
				return 0.5 * (k * k * ((s + 1) * k - s));
			}

			return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);

		}

	},

	Bounce: {

		In: function (k) {

			return 1 - TWEEN.Easing.Bounce.Out(1 - k);

		},

		Out: function (k) {

			if (k < (1 / 2.75)) {
				return 7.5625 * k * k;
			} else if (k < (2 / 2.75)) {
				return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
			} else if (k < (2.5 / 2.75)) {
				return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
			} else {
				return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
			}

		},

		InOut: function (k) {

			if (k < 0.5) {
				return TWEEN.Easing.Bounce.In(k * 2) * 0.5;
			}

			return TWEEN.Easing.Bounce.Out(k * 2 - 1) * 0.5 + 0.5;

		}

	}

};

TWEEN.Interpolation = {

	Linear: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.Linear;

		if (k < 0) {
			return fn(v[0], v[1], f);
		}

		if (k > 1) {
			return fn(v[m], v[m - 1], m - f);
		}

		return fn(v[i], v[i + 1 > m ? m : i + 1], f - i);

	},

	Bezier: function (v, k) {

		var b = 0;
		var n = v.length - 1;
		var pw = Math.pow;
		var bn = TWEEN.Interpolation.Utils.Bernstein;

		for (var i = 0; i <= n; i++) {
			b += pw(1 - k, n - i) * pw(k, i) * v[i] * bn(n, i);
		}

		return b;

	},

	CatmullRom: function (v, k) {

		var m = v.length - 1;
		var f = m * k;
		var i = Math.floor(f);
		var fn = TWEEN.Interpolation.Utils.CatmullRom;

		if (v[0] === v[m]) {

			if (k < 0) {
				i = Math.floor(f = m * (1 + k));
			}

			return fn(v[(i - 1 + m) % m], v[i], v[(i + 1) % m], v[(i + 2) % m], f - i);

		} else {

			if (k < 0) {
				return v[0] - (fn(v[0], v[0], v[1], v[1], -f) - v[0]);
			}

			if (k > 1) {
				return v[m] - (fn(v[m], v[m], v[m - 1], v[m - 1], f - m) - v[m]);
			}

			return fn(v[i ? i - 1 : 0], v[i], v[m < i + 1 ? m : i + 1], v[m < i + 2 ? m : i + 2], f - i);

		}

	},

	Utils: {

		Linear: function (p0, p1, t) {

			return (p1 - p0) * t + p0;

		},

		Bernstein: function (n, i) {

			var fc = TWEEN.Interpolation.Utils.Factorial;

			return fc(n) / fc(i) / fc(n - i);

		},

		Factorial: (function () {

			var a = [1];

			return function (n) {

				var s = 1;

				if (a[n]) {
					return a[n];
				}

				for (var i = n; i > 1; i--) {
					s *= i;
				}

				a[n] = s;
				return s;

			};

		})(),

		CatmullRom: function (p0, p1, p2, p3, t) {

			var v0 = (p2 - p0) * 0.5;
			var v1 = (p3 - p1) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;

			return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (- 3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;

		}

	}

};

// UMD (Universal Module Definition)
(function (root) {

	if (true) {

		// AMD
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return TWEEN;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));

	} else {}

})(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(147)))

/***/ }),
/* 365 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _defineProperties = _interopRequireDefault(__webpack_require__(106));

var _create = _interopRequireDefault(__webpack_require__(31));

__webpack_require__(55);

__webpack_require__(98);

__webpack_require__(62);

__webpack_require__(67);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */
// This set of controls performs orbiting, dollying (zooming), and panning.
// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
//
//    Orbit - left mouse / touch: one-finger move
//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axiz.
 */
var Spherical =
/*#__PURE__*/
function () {
  function Spherical(radius, phi, theta) {
    (0, _classCallCheck2.default)(this, Spherical);
    this.radius = radius !== undefined ? radius : 1.0;
    this.phi = phi !== undefined ? phi : 0; // polar angle

    this.theta = theta !== undefined ? theta : 0; // azimuthal angle
  }

  (0, _createClass2.default)(Spherical, [{
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this;
    } // restrict phi to be betwee EPS and PI-EPS

  }, {
    key: "makeSafe",
    value: function makeSafe() {
      var EPS = 0.000001;
      this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
      return this;
    }
  }, {
    key: "setFromVector3",
    value: function setFromVector3(v) {
      return this.setFromCartesianCoords(v.x, v.y, v.z);
    }
  }, {
    key: "setFromVector3Y_Z",
    value: function setFromVector3Y_Z(v) {
      this.radius = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);

      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(v.x, v.y);
        this.phi = Math.acos(fm.Math.clamp(v.z / this.radius, -1, 1));
      }

      return this;
    }
  }, {
    key: "setFromCartesianCoords",
    value: function setFromCartesianCoords(x, y, z) {
      this.radius = Math.sqrt(x * x + y * y + z * z);

      if (this.radius === 0) {
        this.theta = 0;
        this.phi = 0;
      } else {
        this.theta = Math.atan2(x, z);
        this.phi = Math.acos(fm.Math.clamp(y / this.radius, -1, 1));
      }

      return this;
    }
  }]);
  return Spherical;
}();

fm.OrbitControls = function (object, domElement, map) {
  this.object = object;
  this.map = map;
  this.domElement = domElement !== undefined ? domElement : document; // Set to false to disable this control

  this.enabled = true; // "target" sets the location of focus, where the object orbits around

  this.target = new fm.Vector3(); // How far you can dolly in and out ( PerspectiveCamera only )

  this.minDistance = 0;
  this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

  this.minZoom = 0;
  this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
  // Range is 0 to Math.PI radians.

  this.minPolarAngle = 0; // radians

  this.maxPolarAngle = Math.PI; // radians
  // How far you can orbit horizontally, upper and lower limits.
  // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].

  this.minAzimuthAngle = -Infinity; // radians

  this.maxAzimuthAngle = Infinity; // radians
  // Set to true to enable damping (inertia)
  // If damping is enabled, you must call controls.update() in your animation loop

  this.enableDamping = false;
  this.dampingFactor = 0.25; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
  // Set to false to disable zooming

  this.enableZoom = true;
  this.zoomSpeed = 1.0; // Set to false to disable rotating

  this.enableRotate = true;
  this.rotateSpeed = 1.0; // Set to false to disable panning

  this.enablePan = true;
  this.panSpeed = 1.0;
  this.screenSpacePanning = false; // if true, pan in screen-space

  this.keyPanSpeed = 7.0; // pixels moved per arrow key push
  // Set to true to automatically rotate around the target
  // If auto-rotate is enabled, you must call controls.update() in your animation loop

  this.autoRotate = false;
  this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
  // Set to false to disable use of the keys

  this.enableKeys = false; // The four arrow keys

  this.keys = {
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    BOTTOM: 40
  }; // Mouse buttons

  this.mouseButtons = {
    LEFT: fm.MOUSE.LEFT,
    MIDDLE: fm.MOUSE.MIDDLE,
    RIGHT: fm.MOUSE.RIGHT
  }; // for reset

  this.target0 = this.target.clone();
  this.position0 = this.object.position.clone();
  this.zoom0 = this.object.zoom; //
  // public methods
  //

  this.rangeCenter = new fm.Vector3();
  this.rangeRadius = 500;
  this.useRange = false;
  this.enterCtrl = null;

  this.setEnterCtrl = function (ect) {
    this.enterCtrl = ect;
  };

  this.getPolarAngle = function () {
    return spherical.phi;
  };

  this.getAzimuthalAngle = function () {
    return spherical.theta;
  };

  this.setPolarAngle = function (phi) {
    spherical.phi = phi;
  };

  this.setAzimuthalAngle = function (theta) {
    spherical.theta = theta;
  };

  this.addPolarAngle = function (phi) {
    spherical.phi += phi;
  };

  this.addAzimuthalAngle = function (theta) {
    spherical.theta += theta;
  };

  this.panAdd = function (offset) {
    panOffset.add(offset);
  };

  this.saveState = function () {
    scope.target0.copy(scope.target);
    scope.position0.copy(scope.object.position);
    scope.zoom0 = scope.object.zoom;
  };

  this.reset = function () {
    scope.target.copy(scope.target0);
    scope.object.position.copy(scope.position0);
    scope.object.zoom = scope.zoom0;
    scope.object.updateProjectionMatrix();
    scope.dispatchEvent(changeEvent);
    scope.update();
    state = STATE.NONE;
  };

  var ophi, otheta, moffset, toTheta, toPhi; // this method is exposed, but perhaps it would be better if we can make it private...

  this.setUpdate = function (oph, othet, moffse, toThet, toPh) {
    ophi = oph;
    otheta = othet;
    moffset = moffse;
    toTheta = toThet;

    if (!toPhi) {
      toPhi = toPh;
    }
  };

  this.update = function () {
    var offset = new fm.Vector3(); // so camera.up is the orbit axis

    var quat = new fm.Quaternion().setFromUnitVectors(object.up, new fm.Vector3(0, 1, 0));
    var quatInverse = quat.clone().inverse();
    var lastPosition = new fm.Vector3();
    var lastQuaternion = new fm.Quaternion();
    return function update() {
      var position = scope.object.position;
      offset.copy(position).sub(scope.target); // rotate offset to "y-axis-is-up" space

      offset.applyQuaternion(quat);
      var thet = spherical.theta; // angle from z-axis around y-axis

      spherical.setFromVector3(offset);
      spherical.theta = thet;

      if (state !== STATE.NONE) {
        scope.map.autoRotateBymodelPause = true;
      } else {
        scope.map.autoRotateBymodelPause = false;
      }

      if (scope.autoRotate && state === STATE.NONE) {
        rotateLeft(getAutoRotationAngle());
      }

      spherical.theta += sphericalDelta.theta;
      spherical.phi += sphericalDelta.phi;

      if (typeof toTheta == "number") {
        spherical.theta = toTheta;
      }

      if (typeof toPhi == "number") {
        spherical.phi = toPhi;
      }

      if (typeof ophi == "number") {
        spherical.phi += ophi;
      }

      if (otheta && typeof otheta == "number") {
        spherical.theta += otheta;
      } // restrict theta to be between desired limits


      spherical.theta = Math.max(scope.minAzimuthAngle, Math.min(scope.maxAzimuthAngle, spherical.theta)); // restrict phi to be between desired limits

      spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi));
      spherical.makeSafe();
      spherical.radius *= scale; // restrict radius to be between desired limits

      spherical.radius = Math.max(scope.minDistance, Math.min(scope.maxDistance, spherical.radius)); // move target to panned location

      if (this.useRange) {
        // let curr = new fm.Vector2();
        // curr.x = this.target.x + panOffset.x;
        // curr.y = this.target.z + panOffset.z;
        // // curr.add(panOffset);
        // console.log("dis",curr.distanceTo(this.rangeCenter));
        var pos = new fm.Vector3().setFromMatrixPosition(scope.object.matrixWorld);
        pos.add(panOffset);
        var m4 = new fm.Matrix4().copy(scope.object.matrixWorld).setPosition(pos);
        var inverse = new fm.Matrix4().getInverse(m4);
        var frustum = new fm.Frustum().setFromProjectionMatrix(new fm.Matrix4().multiplyMatrices(scope.object.projectionMatrix, inverse));

        if (frustum.intersectsBox(scope.viewBox)) {
          scope.target.add(panOffset);
        }
      } else {
        scope.target.add(panOffset);
      }

      offset.setFromSpherical(spherical); // rotate offset back to "camera-up-vector-is-up" space

      offset.applyQuaternion(quatInverse);

      if (moffset) {
        offset.add(moffset);
      }

      if (this.useRange) {
        var _pos = new fm.Vector3().setFromMatrixPosition(scope.object.matrixWorld);

        _pos.add(offset);

        var _m = new fm.Matrix4().copy(scope.object.matrixWorld).setPosition(_pos);

        var _inverse = new fm.Matrix4().getInverse(_m);

        var _frustum = new fm.Frustum().setFromProjectionMatrix(new fm.Matrix4().multiplyMatrices(scope.object.projectionMatrix, _inverse));

        if (_frustum.intersectsBox(scope.viewBox)) {
          position.copy(scope.target).add(offset);
        }
      } else {
        position.copy(scope.target).add(offset);
      }

      scope.object.lookAt(scope.target);

      if (scope.enableDamping === true) {
        sphericalDelta.theta *= 1 - scope.dampingFactor;
        sphericalDelta.phi *= 1 - scope.dampingFactor;
        panOffset.multiplyScalar(1 - scope.dampingFactor);
      } else {
        sphericalDelta.set(0, 0, 0);
        panOffset.set(0, 0, 0);
      }

      ophi = undefined;
      otheta = undefined;
      moffset = undefined;
      toTheta = undefined;
      toPhi = undefined;
      scale = 1; // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if (zoomChanged || lastPosition.distanceToSquared(scope.object.position) > EPS || 8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS) {
        scope.dispatchEvent(changeEvent);
        lastPosition.copy(scope.object.position);
        lastQuaternion.copy(scope.object.quaternion);
        zoomChanged = false;
        return true;
      }

      return false;
    };
  }();

  this.dispose = function () {
    scope.domElement.removeEventListener('contextmenu', onContextMenu, false);
    scope.domElement.removeEventListener('mousedown', onMouseDown, false);
    scope.domElement.removeEventListener('wheel', onMouseWheel, false);
    scope.domElement.removeEventListener('touchstart', onTouchStart, false);
    scope.domElement.removeEventListener('touchend', onTouchEnd, false);
    scope.domElement.removeEventListener('touchmove', onTouchMove, false);
    scope.domElement.removeEventListener('mouseup', onMyMouseUp, false);
    scope.domElement.removeEventListener('mousemove', onMyMouseMove, false); //IE11+ ,Edge

    if (window.PointerEvent && !window.TouchEvent) {
      scope.domElement.removeEventListener('pointerdown', onMyPointerDown, false);
      scope.domElement.removeEventListener('pointermove', onMyPointerMove, false);
      scope.domElement.removeEventListener('pointerup', onMyPointerUp, false);
    }

    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
    window.removeEventListener('keydown', onKeyDown, false);
    this.enterCtrl = undefined;
    this.domElement = undefined;
    this.object = undefined; //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?
  }; //
  // internals
  //


  var scope = this;
  var changeEvent = {
    type: 'change'
  };
  var startEvent = {
    type: 'start'
  };
  var endEvent = {
    type: 'end'
  };
  var STATE = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_DOLLY_PAN: 4,
    TOUCH_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
  };
  var state = STATE.NONE;
  var EPS = 0.000001; // current position in spherical coordinates

  var spherical = new fm.Spherical();
  var sphericalDelta = new fm.Spherical();
  var scale = 1;
  var panOffset = new fm.Vector3();
  var zoomChanged = false;
  var rotateStart = new fm.Vector2();
  var rotateEnd = new fm.Vector2();
  var rotateDelta = new fm.Vector2();
  var rotateLeftStart = new fm.Vector2();
  var rotateLeftEnd = new fm.Vector2();
  var rotateLeftDelta = new fm.Vector2();
  var panStart = new fm.Vector2();
  var panEnd = new fm.Vector2();
  var panDelta = new fm.Vector2();
  var dollyStart = new fm.Vector2();
  var dollyEnd = new fm.Vector2();
  var dollyDelta = new fm.Vector2();
  var mouseDownPos = new fm.Vector2();

  function getAutoRotationAngle() {
    return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;
  }

  function getZoomScale() {
    return Math.pow(0.95, scope.zoomSpeed);
  }

  function rotateLeft(angle) {
    if (scope.enterCtrl && !scope.enterCtrl.enableMapRotate) {
      return;
    }

    sphericalDelta.theta -= angle;
  }

  this.rotateLeft = function (angle) {
    rotateLeft(angle);
  };

  function rotateUp(angle) {
    if (scope.enterCtrl && !scope.enterCtrl.enableMapIncline) {
      return;
    }

    sphericalDelta.phi -= angle;
  }

  var panLeft = function () {
    var v = new fm.Vector3();
    return function panLeft(distance, objectMatrix) {
      v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

      v.multiplyScalar(-distance);
      panOffset.add(v);
    };
  }();

  var panUp = function () {
    var v = new fm.Vector3();
    return function panUp(distance, objectMatrix) {
      if (scope.screenSpacePanning === true) {
        v.setFromMatrixColumn(objectMatrix, 1);
      } else {
        v.setFromMatrixColumn(objectMatrix, 0);
        v.crossVectors(scope.object.up, v); // v.copy( scope.object.up );
      }

      v.multiplyScalar(distance);
      panOffset.add(v);
    };
  }();

  this.panUp = function (distance) {
    var v = new fm.Vector3();
    v.y = 1;
    v.multiplyScalar(distance);
    panOffset.add(v);
  }; // deltaX and deltaY are in pixels; right and down are positive


  var pan = function () {
    var offset = new fm.Vector3();
    return function pan(deltaX, deltaY) {
      if (scope.enterCtrl && !scope.enterCtrl.enableMapPan) {
        return;
      }

      var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

      if (scope.object.isPerspectiveCamera) {
        // perspective
        var position = scope.object.position;
        offset.copy(position).sub(scope.target);
        var targetDistance = offset.length(); // half of the fov is center to top of screen

        targetDistance *= Math.tan(scope.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

        panLeft(2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix);
        panUp(2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix);
      } else if (scope.object.isOrthographicCamera) {
        // orthographic
        panLeft(deltaX * (scope.object.right - scope.object.left) / scope.object.zoom / element.clientWidth, scope.object.matrix);
        panUp(deltaY * (scope.object.top - scope.object.bottom) / scope.object.zoom / element.clientHeight, scope.object.matrix);
      } else {
        // camera neither orthographic nor perspective
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
        scope.enablePan = false;
      }
    };
  }();

  function dollyIn(dollyScale) {
    if (scope.enterCtrl && !scope.enterCtrl.enableMapPinch) {
      return;
    }

    if (scope.object.isPerspectiveCamera) {
      scale /= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom * dollyScale));
      scope.object.updateProjectionMatrix();
      scale /= dollyScale;
      zoomChanged = true;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  }

  this.dollyIn = function (scale) {
    dollyIn(scale);
  };

  function dollyOut(dollyScale) {
    if (scope.enterCtrl && !scope.enterCtrl.enableMapPinch) {
      return;
    }

    if (scope.object.isPerspectiveCamera) {
      scale *= dollyScale;
    } else if (scope.object.isOrthographicCamera) {
      scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / dollyScale));
      scope.object.updateProjectionMatrix();
      zoomChanged = true;
      scale *= dollyScale;
    } else {
      console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
      scope.enableZoom = false;
    }
  }

  this.dollyOut = function (scale) {
    dollyOut(scale);
  }; //
  // event callbacks - update the object state
  //


  function handleMouseDownRotate(event) {
    //console.log( 'handleMouseDownRotate' );
    rotateStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownDolly(event) {
    //console.log( 'handleMouseDownDolly' );
    dollyStart.set(event.clientX, event.clientY);
  }

  function handleMouseDownPan(event) {
    //console.log( 'handleMouseDownPan' );
    panStart.set(event.clientX, event.clientY);
  }

  function handleMouseMoveRotate(event) {
    //console.log( 'handleMouseMoveRotate' );
    rotateEnd.set(event.clientX, event.clientY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd); // let time = new Date().getTime();
    // scope.update();
    // console.log(new Date().getTime() - time)
  }

  function handleMouseMoveDolly(event) {
    //console.log( 'handleMouseMoveDolly' );
    dollyEnd.set(event.clientX, event.clientY);
    dollyDelta.subVectors(dollyEnd, dollyStart);

    if (dollyDelta.y > 0) {
      dollyIn(getZoomScale());
    } else if (dollyDelta.y < 0) {
      dollyOut(getZoomScale());
    }

    dollyStart.copy(dollyEnd); // scope.update();
  }

  function handleMouseMovePan(event) {
    //console.log( 'handleMouseMovePan' );
    panEnd.set(event.clientX, event.clientY);
    panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
    pan(panDelta.x, panDelta.y);
    panStart.copy(panEnd); // scope.update();
  }

  function handleMouseUp(event) {// console.log( 'handleMouseUp' );
  }

  function handleMouseWheel(event) {
    // console.log( 'handleMouseWheel' );
    if (event.deltaY < 0) {
      dollyOut(getZoomScale());
    } else if (event.deltaY > 0) {
      dollyIn(getZoomScale());
    } // scope.update();

  }

  function handleKeyDown(event) {
    //console.log( 'handleKeyDown' );
    switch (event.keyCode) {
      case scope.keys.UP:
        pan(0, scope.keyPanSpeed);
        scope.update();
        break;

      case scope.keys.BOTTOM:
        pan(0, -scope.keyPanSpeed);
        scope.update();
        break;

      case scope.keys.LEFT:
        pan(scope.keyPanSpeed, 0);
        scope.update();
        break;

      case scope.keys.RIGHT:
        pan(-scope.keyPanSpeed, 0);
        scope.update();
        break;
    }
  }

  function handleTouchStartRotate(event) {
    //console.log( 'handleTouchStartRotate' );
    rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
  }

  function handleTouchStartDollyPan(event) {
    //console.log( 'handleTouchStartDollyPan' );
    if (scope.enableZoom) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyStart.set(0, distance);
    }
  }

  function handleTouchMoveRotate(event) {
    //console.log( 'handleTouchMoveRotate' );
    rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
    rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
    var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
    rotateLeft(2 * Math.PI * rotateDelta.x / element.clientHeight); // yes, height

    rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    rotateStart.copy(rotateEnd);
    scope.update();
  }

  function handleTouchMoveDollyPan(event) {
    //console.log( 'handleTouchMoveDollyPan' );
    if (scope.enableZoom) {
      var dx = event.touches[0].pageX - event.touches[1].pageX;
      var dy = event.touches[0].pageY - event.touches[1].pageY;
      var distance = Math.sqrt(dx * dx + dy * dy);
      dollyEnd.set(0, distance);
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
      dollyIn(dollyDelta.y);
      dollyStart.copy(dollyEnd);
    }

    if (scope.enablePan) {
      var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
      var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);
      panEnd.set(x, y);
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
      pan(panDelta.x, panDelta.y);
      panStart.copy(panEnd);
    }

    scope.update();
  }

  function handleTouchEnd(event) {} //console.log( 'handleTouchEnd' );
  //
  // event handlers - FSM: listen for events and reset state
  //


  this.mapMouseDown = onMouseDown;

  function onMouseDown(event) {
    // console.log('mouse down');
    mouseDownPos.set(event.clientX, event.clientY, scope.enabled);
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (event.button) {
      case scope.mouseButtons.LEFT:
        if (scope.enablePan === false) return;
        handleMouseDownPan(event);
        state = STATE.PAN;
        break;

      case scope.mouseButtons.MIDDLE:
        if (scope.enableZoom === false) return;
        handleMouseDownDolly(event);
        state = STATE.DOLLY;
        break;

      case scope.mouseButtons.RIGHT:
        if (event.ctrlKey || event.metaKey || event.shiftKey) {
          if (scope.enablePan === false) return;
          handleMouseDownPan(event);
          state = STATE.PAN;
        } else {
          if (scope.enableRotate === false) return;
          handleMouseDownRotate(event);
          state = STATE.ROTATE;
        }

        break;
    }

    if (state !== STATE.NONE) {
      document.addEventListener('mousemove', onMouseMove, false);
      document.addEventListener('mouseup', onMouseUp, false);
      scope.dispatchEvent(startEvent);
    }
  }

  function onMouseMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    switch (state) {
      case STATE.ROTATE:
        if (scope.enableRotate === false) return;
        handleMouseMoveRotate(event);
        break;

      case STATE.DOLLY:
        if (scope.enableZoom === false) return;
        handleMouseMoveDolly(event);
        break;

      case STATE.PAN:
        if (scope.enablePan === false) return;
        handleMouseMovePan(event);
        break;
    }
  }

  function onMyMouseUp(event) {
    var clickdis = mouseDownPos.distanceTo(new fm.Vector2(event.clientX, event.clientY));

    if (clickdis < 5) {
      scope.dispatchEvent({
        type: "mouseup",
        mousePoint: {
          x: event.offsetX,
          y: event.offsetY,
          w: scope.domElement.clientWidth,
          h: scope.domElement.clientHeight
        },
        event: event,
        mouseButton: event.button
      });
    }
  }

  this.mapMouseUp = onMyMouseUp;

  function onMyMouseMove(event) {
    scope.dispatchEvent({
      type: "mousemove",
      mousePoint: {
        x: event.offsetX,
        y: event.offsetY,
        w: scope.domElement.clientWidth,
        h: scope.domElement.clientHeight
      },
      event: event
    });
  }

  function onMouseUp(event) {
    if (scope.enabled === false) return;
    handleMouseUp(event);
    document.removeEventListener('mousemove', onMouseMove, false);
    document.removeEventListener('mouseup', onMouseUp, false);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onMouseWheel(event) {
    if (scope.enabled === false || scope.enableZoom === false || state !== STATE.NONE && state !== STATE.ROTATE) return;
    event.preventDefault();
    event.stopPropagation();
    scope.dispatchEvent(startEvent);
    handleMouseWheel(event);
    scope.dispatchEvent(endEvent);
  }

  function onKeyDown(event) {
    if (scope.enabled === false || scope.enableKeys === false || scope.enablePan === false) return;
    handleKeyDown(event);
  }

  function onTouchStart(event) {
    if (scope.enabled === false) return;
    event.preventDefault();

    if (scope.map && scope.map.eventTransform) {
      event = scope.map.eventTransform(event);
    } //console.log('touch start');


    mouseDownPos.set(event.changedTouches[0].pageX, event.changedTouches[0].pageY);

    switch (event.touches.length) {
      case 1:
        // one-fingered touch: rotate
        if (scope.enablePan) {
          var x = event.touches[0].pageX;
          var y = event.touches[0].pageY;
          panStart.set(x, y);
        }

        state = STATE.TOUCH_PAN;
        break;

      case 2:
        // two-fingered touch: dolly-pan
        if (scope.enableZoom === false && scope.enableRotate === false) return;
        state = STATE.TOUCH_DOLLY_ROTATE; // handleTouchStartDollyPan( event );

        if (scope.enableZoom) {
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          var distance = Math.sqrt(dx * dx + dy * dy); // console.log("startd", distance);

          dollyStart.set(0, distance);
        }

        if (scope.enableRotate) {
          var x = (event.touches[0].pageX + event.touches[1].pageX) * 0.5;
          var y = (event.touches[0].pageY + event.touches[1].pageY) * 0.5;
          rotateStart.set(x, y);
          var dlx = event.touches[0].pageX - event.touches[1].pageX;
          var dly = event.touches[0].pageY - event.touches[1].pageY;
          rotateLeftStart.set(dlx, dly);
        }

        break;

      default:
        state = STATE.NONE;
    }

    if (state !== STATE.NONE) {
      scope.dispatchEvent(startEvent);
    }
  }

  function onTouchMove(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
    event.stopPropagation();

    if (scope.map && scope.map.eventTransform) {
      event = scope.map.eventTransform(event);
    }

    switch (event.touches.length) {
      case 1:
        // one-fingered touch: rotate
        if (state !== STATE.TOUCH_PAN) return; // is this needed?

        if (scope.enablePan) {
          var x = event.touches[0].pageX;
          var y = event.touches[0].pageY;
          panEnd.set(x, y);
          panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed);
          pan(panDelta.x, panDelta.y);
          panStart.copy(panEnd);
        } // scope.update();


        break;

      case 2:
        // two-fingered touch: dolly-pan
        if (scope.enableRotate === false && scope.enableZoom === false) return;
        if (state !== STATE.TOUCH_DOLLY_ROTATE) return; // is this needed?

        if (scope.enableZoom) {
          var dx = event.touches[0].pageX - event.touches[1].pageX;
          var dy = event.touches[0].pageY - event.touches[1].pageY;
          var distance = Math.sqrt(dx * dx + dy * dy); // console.log("moved",distance)

          dollyEnd.set(0, distance);
          dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed));
          dollyIn(dollyDelta.y);
          dollyStart.copy(dollyEnd);
        }

        if (scope.enableRotate) {
          // rotateLeftStart
          var dlx = event.touches[0].pageX - event.touches[1].pageX;
          var dly = event.touches[0].pageY - event.touches[1].pageY;
          rotateLeftEnd.set(dlx, dly);
          var anglestart = rotateLeftStart.angle();
          var angleend = rotateLeftEnd.angle();
          rotateEnd.set((event.touches[0].pageX + event.touches[1].pageX) * 0.5, (event.touches[0].pageY + event.touches[1].pageY) * 0.5);
          rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed);
          var element = scope.domElement === document ? scope.domElement.body : scope.domElement;
          rotateLeft((-angleend + anglestart) * scope.rotateSpeed); // yes, height

          rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
          rotateStart.copy(rotateEnd);
          rotateLeftStart.copy(rotateLeftEnd); // console.log('touch angle',-angleend + anglestart,2 * Math.PI * rotateDelta.y / element.clientHeight);
        } // scope.update();
        // handleTouchMoveRotate( event );
        // handleTouchMoveDollyPan( event );


        break;

      default:
        state = STATE.NONE;
    }
  }

  function onTouchEnd(event) {
    if (scope.enabled === false) return;

    if (scope.map && scope.map.eventTransform) {
      event = scope.map.eventTransform(event);
    }

    var clickdis = mouseDownPos.distanceTo(new fm.Vector2(event.changedTouches[0].pageX, event.changedTouches[0].pageY)); //console.log('touchend',clickdis,event);

    var br = scope.domElement.getBoundingClientRect();

    if (clickdis < 5) {
      scope.dispatchEvent({
        type: "mouseup",
        mousePoint: {
          x: event.changedTouches[0].pageX - br.left,
          y: event.changedTouches[0].pageY - br.top,
          w: scope.domElement.clientWidth,
          h: scope.domElement.clientHeight
        },
        event: event,
        mouseButton: fm.MOUSE.LEFT
      });
    }

    handleTouchEnd(event);
    scope.dispatchEvent(endEvent);
    state = STATE.NONE;
  }

  function onContextMenu(event) {
    if (scope.enabled === false) return;
    event.preventDefault();
  } //


  scope.domElement.addEventListener('contextmenu', onContextMenu, false);
  scope.domElement.addEventListener('mouseup', onMyMouseUp, false);
  scope.domElement.addEventListener('mousemove', onMyMouseMove, false);
  scope.domElement.addEventListener('mousedown', onMouseDown, false);
  scope.domElement.addEventListener('wheel', onMouseWheel, false);
  var _gestrueChangeStartTime = 0,
      isRotate = false,
      _scaleStart = 1,
      _rotateStart = 0,
      _longTouch = 0;

  function handlegesture(e) {
    if (state !== STATE.ROTATE) return; //不是双指操作时不处理

    if (scope.enableZoom === false && scope.enableRotate === false) return;

    if (_gestrueChangeStartTime == 0) {
      _scaleStart = e.scale;
      _rotateStart = e.rotation;
      _gestrueChangeStartTime = e.timeStamp;
      _longTouch = 0;
    }

    if (e.timeStamp - _gestrueChangeStartTime < 80) {
      return;
    }

    if (_longTouch == 0) {
      var _scaleDelta = Math.abs(e.scale - _scaleStart),
          _rotateDelta = Math.abs(e.rotation - _rotateStart);

      if (_scaleDelta < _rotateDelta) {
        isRotate = true;
      }

      _longTouch = 1;
    } // console.log('rotate',e.scale,e.rotation,isRotate,state,STATE.ROTATE,scope.rotateSpeed, e.velocityX , e.velocityY);
    //放大、缩小


    if (scope.enableZoom && e.scale != 1 && !isRotate) {
      //直接通过scale信息判断pinch
      scope.dispatchEvent(startEvent);

      if (e.scale > 1) {
        //放大
        //if(Math.abs(e.scale - 1) < 0.01) return; 
        dollyOut(getZoomScale());
      } else if (e.scale < 1) {
        //缩小
        //if(Math.abs(1 - e.scale) < 0.01) return;
        dollyIn(getZoomScale());
      }

      scope.dispatchEvent(endEvent);
    } //倾斜


    if (scope.enterCtrl && scope.enterCtrl.enableMapIncline && isRotate == true) {
      //if(Math.abs(e.rotation) < 0.1) return; //角度太小的时候不处理
      rotateEnd.set(e.clientX, e.clientY);
      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed * e.velocityX * e.velocityY);
      var element = scope.domElement;
      rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight);
    } //旋转


    if (scope.enableRotate && isRotate == true) {
      //if(Math.abs(e.rotation) < 0.05) return; //角度太小的时候不处理
      rotateEnd.set(e.clientX, e.clientY);
      var rotate = e.rotation * 180 / Math.PI; //旋转

      rotateLeft(-rotate * scope.rotateSpeed * e.velocityX * e.velocityY); // yes, height

      rotateStart.copy(rotateEnd);
    }
  } //手势对象在手势识别期间处理哪些指针
  //let _pointerTime = 0;


  var _curentPointer = {
    touches: [],
    changedTouches: [],
    preventDefault: function preventDefault() {},
    stopPropagation: function stopPropagation() {}
  };

  function getPointerEventObj(evt) {
    return {
      pointerId: evt.pointerId,
      clientX: evt.clientX,
      clientY: evt.clientY,
      pageX: evt.clientX,
      pageY: evt.clientY
    };
  }

  function onMyPointerDown(evt) {
    if (evt.pointerType != 'touch') {
      _curentPointer = {
        touches: [],
        changedTouches: [],
        preventDefault: function preventDefault() {},
        stopPropagation: function stopPropagation() {}
      };
      return;
    } // console.log('onPointerDown',evt);


    switch (_curentPointer.touches.length) {
      case 0:
        var _sEvt = {
          startClientX: evt.clientX,
          startClientY: evt.clientY,
          clientX: evt.clientX,
          clientY: evt.clientY,
          pageY: evt.clientY,
          pageX: evt.clientX,
          pointerId: evt.pointerId
        };

        _curentPointer.touches.push(getPointerEventObj(_sEvt));

        _curentPointer.changedTouches.push(getPointerEventObj(_sEvt));

        state = STATE.TOUCH_PAN;
        break;

      case 1:
        var _endEvt = {
          startClientX: evt.clientX,
          startClientY: evt.clientY,
          clientX: evt.clientX,
          clientY: evt.clientY,
          pageY: evt.clientY,
          pageX: evt.clientX,
          pointerId: evt.pointerId
        };

        _curentPointer.touches.push(getPointerEventObj(_endEvt));

        _curentPointer.changedTouches.push(getPointerEventObj(_endEvt));

        state = STATE.TOUCH_DOLLY_ROTATE;
        break;

      default:
        //>= 2个手指头
        state = STATE.NONE;
        break;
    } //只处理双指操作的情况


    if (_curentPointer.touches.length > 1) {
      onTouchStart(_curentPointer, true);
    }
  }

  function onMyPointerMove(evt) {
    if (evt.pointerType != 'touch' && _curentPointer.touches.length < 2) {
      return;
    }

    var _movePointerIndex = -1; // console.log("move",_curentPointer.touches[0].clientX,_curentPointer.touches[0].clientY,_curentPointer.touches[1].clientX,_curentPointer.touches[1].clientY)


    for (var i = 0, ilen = _curentPointer.touches.length; i < ilen; i++) {
      if (_curentPointer.touches[i].pointerId == evt.pointerId) {
        _curentPointer.touches[i].clientX = evt.clientX;
        _curentPointer.touches[i].clientY = evt.clientY;
        _curentPointer.touches[i].pageY = evt.clientY;
        _curentPointer.touches[i].pageX = evt.clientX;
        _curentPointer.changedTouches[i].clientX = evt.clientX;
        _curentPointer.changedTouches[i].clientY = evt.clientY;
        _curentPointer.changedTouches[i].pageY = evt.clientY;
        _curentPointer.changedTouches[i].pageX = evt.clientX;
      }
    } //只处理双指操作的情况


    if (_curentPointer.touches.length > 1) {
      onTouchMove(_curentPointer);
    }
  }

  function onMyPointerUp(evt) {
    if (evt.pointerType != 'touch') {
      _curentPointer = {
        touches: [],
        changedTouches: [],
        preventDefault: function preventDefault() {},
        stopPropagation: function stopPropagation() {}
      };
      return;
    }

    if (_curentPointer.touches.length > 1) {
      onTouchEnd(_curentPointer);
    }

    for (var i = _curentPointer.touches.length - 1; i > -1; i--) {
      if (_curentPointer.touches[i].pointerId == evt.pointerId) {
        _curentPointer.touches.splice(i, 1);

        _curentPointer.changedTouches.splice(i, 1);
      }
    }
  } //IE11, edge，在Ie浏览器没有开启触屏模式时（about:flags 页面中查看配置）添加pointer事件。


  if (window.PointerEvent && !window.TouchEvent) {
    //实例化一个手势对象
    scope.domElement.addEventListener("pointerdown", onMyPointerDown, false); //点击事件

    scope.domElement.addEventListener("pointermove", onMyPointerMove, false); //移动事件

    scope.domElement.addEventListener("pointerup", onMyPointerUp, false); //移动事件
  }

  scope.domElement.addEventListener('touchstart', onTouchStart, false);
  scope.domElement.addEventListener('touchend', onTouchEnd, false);
  scope.domElement.addEventListener('touchmove', onTouchMove, false);
  window.addEventListener('keydown', onKeyDown, false); // force an update at start

  this.update();
};

fm.OrbitControls.prototype = (0, _create.default)(fm.EventDispatcher.prototype);
fm.OrbitControls.prototype.constructor = fm.OrbitControls;
(0, _defineProperties.default)(fm.OrbitControls.prototype, {
  center: {
    get: function get() {
      console.warn('fm.OrbitControls: .center has been renamed to .target');
      return this.target;
    }
  },
  // backward compatibility
  noZoom: {
    get: function get() {
      console.warn('fm.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      return !this.enableZoom;
    },
    set: function set(value) {
      console.warn('fm.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead.');
      this.enableZoom = !value;
    }
  },
  noRotate: {
    get: function get() {
      console.warn('fm.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      return !this.enableRotate;
    },
    set: function set(value) {
      console.warn('fm.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead.');
      this.enableRotate = !value;
    }
  },
  noPan: {
    get: function get() {
      console.warn('fm.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      return !this.enablePan;
    },
    set: function set(value) {
      console.warn('fm.OrbitControls: .noPan has been deprecated. Use .enablePan instead.');
      this.enablePan = !value;
    }
  },
  noKeys: {
    get: function get() {
      console.warn('fm.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      return !this.enableKeys;
    },
    set: function set(value) {
      console.warn('fm.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead.');
      this.enableKeys = !value;
    }
  },
  staticMoving: {
    get: function get() {
      console.warn('fm.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      return !this.enableDamping;
    },
    set: function set(value) {
      console.warn('fm.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead.');
      this.enableDamping = !value;
    }
  },
  dynamicDampingFactor: {
    get: function get() {
      console.warn('fm.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      return this.dampingFactor;
    },
    set: function set(value) {
      console.warn('fm.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead.');
      this.dampingFactor = value;
    }
  }
});

/***/ }),
/* 366 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * smokesignals
 */
fm.Evento = {
  convert: function convert(obj, handlers) {
    // we store the list of handlers as a local variable inside the scope
    // so that we don't have to add random properties to the object we are
    // converting. (prefixing variables in the object with an underscore or
    // two is an ugly solution)
    //      we declare the variable in the function definition to use two less
    //      characters (as opposed to using 'var ').  I consider this an inelegant
    //      solution since smokesignals.convert.length now returns 2 when it is
    //      really 1, but doing this doesn't otherwise change the functionallity of
    //      this module, so we'll go with it for now
    handlers = handlers || {}; // add a listener

    obj.on = function (eventName, handler) {
      // either use the existing array or create a new one for this event
      //      this isn't the most efficient way to do this, but is the shorter
      //      than other more efficient ways, so we'll go with it for now.
      (handlers[eventName] = handlers[eventName] || []). // add the handler to the array
      push(handler);
      return obj;
    }; // get handlers by eventName


    obj.getHandlers = function (eventName) {
      return handlers[eventName];
    }; // add a listener that will only be called once


    obj.once = function (eventName, handler) {
      // create a wrapper listener, that will remove itself after it is called
      function wrappedHandler() {
        // remove ourself, and then call the real handler with the args
        // passed to this wrapper
        handler.apply(obj.off(eventName, wrappedHandler), arguments);
      } // in order to allow that these wrapped handlers can be removed by
      // removing the original function, we save a reference to the original
      // function


      wrappedHandler.h = handler; // call the regular add listener function with our new wrapper

      return obj.on(eventName, wrappedHandler);
    }; // remove a listener


    obj.off = function (eventName, handler) {
      // loop through all handlers for this eventName, assuming a handler
      // was passed in, to see if the handler passed in was any of them so
      // we can remove it
      //      it would be more efficient to stash the length and compare i
      //      to that, but that is longer so we'll go with this.
      for (var list = handlers[eventName], i = 0; handler && list && list[i]; i++) {
        // either this item is the handler passed in, or this item is a
        // wrapper for the handler passed in.  See the 'once' function
        list[i] != handler && list[i].h != handler || // remove it!
        list.splice(i--, 1);
      } // if i is 0 (i.e. falsy), then there are no items in the array for this
      // event name (or the array doesn't exist)
      // if (!i) {


      if (!handler) {
        // remove the array for this eventname (if it doesn't exist then
        // this isn't really hurting anything)
        delete handlers[eventName];
      }

      return obj;
    };

    obj.emit = function (eventName) {
      // loop through all handlers for this event name and call them all
      //      it would be more efficient to stash the length and compare i
      //      to that, but that is longer so we'll go with this.
      for (var list = handlers[eventName], i = 0; list && list[i];) {
        list[i++].apply(obj, list.slice.call(arguments, 1));
      }

      return obj;
    };

    obj.offAll = function () {
      for (var evName in handlers) {
        handlers[evName] = [];
        delete handlers[evName];
      }

      handlers = undefined;
    };

    return obj;
  }
}; //for window resize event!
// fm.addEvent = function(object, type, callback) {
//     if (object == null || typeof(object) == 'undefined') return;
//     if (object.addEventListener) {
//         object.addEventListener(type, callback, false);
//     } else if (object.attachEvent) {
//         object.attachEvent("on" + type, callback);
//     } else {
//         object["on"+type] = callback;
//     }
// };

/***/ }),
/* 367 */
/***/ (function(module, exports, __webpack_require__) {

var _Array$isArray = __webpack_require__(35);

function _arrayWithoutHoles(arr) {
  if (_Array$isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

module.exports = _arrayWithoutHoles;

/***/ }),
/* 368 */
/***/ (function(module, exports, __webpack_require__) {

var _Array$from = __webpack_require__(166);

var _isIterable = __webpack_require__(369);

function _iterableToArray(iter) {
  if (_isIterable(Object(iter)) || Object.prototype.toString.call(iter) === "[object Arguments]") return _Array$from(iter);
}

module.exports = _iterableToArray;

/***/ }),
/* 369 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(370);

/***/ }),
/* 370 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(65);
__webpack_require__(59);
module.exports = __webpack_require__(371);


/***/ }),
/* 371 */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(94);
var ITERATOR = __webpack_require__(19)('iterator');
var Iterators = __webpack_require__(60);
module.exports = __webpack_require__(9).isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};


/***/ }),
/* 372 */
/***/ (function(module, exports) {

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

module.exports = _nonIterableSpread;

/***/ }),
/* 373 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(65);
__webpack_require__(59);
module.exports = __webpack_require__(374);


/***/ }),
/* 374 */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(29);
var get = __webpack_require__(130);
module.exports = __webpack_require__(9).getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};


/***/ }),
/* 375 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(__webpack_require__(11));

__webpack_require__(48);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMLanguageType = _interopRequireDefault(__webpack_require__(80));

var _FMDirection = _interopRequireDefault(__webpack_require__(203));

var _NetArea = _interopRequireDefault(__webpack_require__(108));

var MapOptions =
/*#__PURE__*/
function () {
  function MapOptions(options) {
    (0, _classCallCheck2.default)(this, MapOptions);
    var protocol = window.location.protocol === 'https:' ? 'https://' : 'http://';
    var DEFAULT_MAPSERVERURL = protocol + 'source.fengmap.com/newmap'; // fengmap的服务器地址!
    // var DEFAULT_MAPSERVERURL = 'http://192.168.1.222:18081/FMCloud/sdk/auth/downMaps';   // fengmap的服务器地址!

    var DEFAULT_MAPTHEMEURL = _NetArea.default.replace("FMCloud/", "").replace("www.fengmap.com", "source.fengmap.com") + 'webtheme'; // fengmap的服务器地址!
    // key & appName

    this._key = null;
    this._appName = null; // 全局设置

    this._mapServerURL = "fengmap";
    this._mapThemeURL = DEFAULT_MAPTHEMEURL;
    this._container = document.body; //指南针位置偏移量,左 + 上

    this._compassOffset = [28, 20];
    this._compassSize = 50; // 指南针的自定义背景/前景图

    this._compassFg = null;
    this._compassBg = null;
    this.compassPosition = 1; // theme

    this._defaultThemeName = '2001'; // 焦点层相关设置

    this._focusAnimateMode = true;
    this._focusAnimateTime = .3;
    this._focusAlphaMode = true;
    this._focusAlpha = .1; // 2D / 3D 视图切换相关设置

    this._viewModeAnimateMode = true;
    this._viewModeAnimateTime = .3; // Move To 相关设置

    this._moveToAnimateMode = true;
    this._moveToAnimateTime = .3;
    this._scaleToAnimateMode = true; // 合并每一层的"模型线", 20180309 ztc 这个先默认为false吧。 因为合并了，就不支持storeApply的自定义颜色了
    //this.mergeModelLines = false;
    // 合并每一层的Model,提升效率
    // this.mergeModels = true;
    // 模型选择时的反馈(颜色与闪烁)

    this._modelSelectedEffect = true; // 模型悬停时的反馈(颜色与闪烁)

    this._modelHoverEffect = false;
    this._modelHoverTime = 1000; // 缩放级别 0 ~ 6

    this.minScaleLevel = 0;
    this.maxScaleLevel = 6;
    this.defaultScaleLevel = 3; // 比例尺缩放级别 1 ~ 29

    this.mapScaleLevelRange = [16, 23];
    this.mapScaleRange = null; // [200, 4000];

    this.defaultMapScaleLevel = 20;
    this.defaultMapScale = null; // 相机的最小距离(米), 此方法可以突破ScaleLevel的限制,因为他的最小0.2,
    // 在某些大场景的情况下,最小的相机距离还是很远,不够合适

    this.minViewDistance = 2000; // 20161117 在没有mapScale之前使用的值是 20
    // 默认可见层及聚焦层

    this.defaultVisibleGroups = [1];
    this.defaultFocusGroup = 1; // 默认显示模式

    this.defaultViewMode = '3d'; // 阴影

    this.shadowEnabled = false;
    this.lightAngleX = 45;
    this.lightAngleY = 45;
    this.shadowSize = 2048;
    this.shadowAlpha = .6; // Store Image Angle DEG

    this.storeImageAngle = 0; // 导航线动画开关

    this.naviLineAnimation = true; // 控制器灵敏度相关

    this.controlsRotateThreshold = .03; // 越小越灵敏

    this.controlsScaleThreshold = .03; // 越小越灵敏
    // 默认的层间距,设置为null从数据中读取.

    this.defaultGroupSpace = 50; // 被动渲染模式

    this.passiveMode = false; // 主题版本(在Label POI)等的大小计算上有不同.

    this.themeVersion = null; // 主题中图片文件的类型: image | base64

    this.themeFileType = null;
    this.cornerRoundLimit = 1;
    /*
     * 楼梯的配置参数:
     * 		steps: 15,			// 台阶的级数
     * 		stepHeight: .2,		// 台阶高度
     * 		stepDepth: .3,		// 台阶深度
     * 		width: 1.5,			// 楼梯宽度
     * 		color: 0x4EE996,	// 颜色
     * 		inverse: true,		// 反向
     * 		halfSpace: 2,		// 休息平台宽度
     * 	 	depth: true 		// shader 深度
     */

    this.stairsConfig = {};
    /*
     * 设置默认的相机控制器的位置及目标点的位置
     * 此值,可以能过 fengmap.MapUtil.getControlInfo() 得到
     * 3种方式:
     *  1. fengmap.FMDirection
     *  2. 角度值 number
     *
     *  默认地图旋转-15度
     */

    this.defaultControlsPose = -15; // 默认的倾斜角度

    this.defaultTiltAngle = 30; // 默认的最大的倾斜角度

    this.defaultMaxTiltAngle = 90;
    this.defaultMinTiltAngle = 30; // 可以设置 extent 高度, 默认为 -.5 : MapConfiguration
    // this.extentHeight = undefined;

    this.extentHeight = 0; // label POI 渐隐渐现

    this.poiLabelFadeMode = false;
    this.poiLabelFadeSpeed = 5;
    this.defaultBackgroundColor = null;
    this.defaultBackgroundAlpha = null;
    this.storeImageDistanceEnabled = false;
    this.storeImageDistance = 500;
    this.useStoreApply = true; // frame rate 无操作时,每秒钟渲染的帧数 FPS 1 ~ 60

    this.frameRate = 12; // 默认的中心点

    this.defaultViewCenter = null; // 点击事件,自动得到当前的地图坐标, 所用到的height属性

    this.pickCoordHeight = 1; // 模型文件后缀

    this.modelFileSuffix = 'js'; // 开启 FXAA 抗锯齿

    this.enabledFXAA = false;
    this.dynamicTextureScale = 1.0; // 开启 平移地图范围限制

    this.enabledPanRange = false;
    this.tile = false; // level show 

    this.levelShowOffset = 0;
    this.lightEffects = false;
    this.defaultLabelLanguage = _FMLanguageType.default.ZH;
    this.font = {
      family: '"Microsoft Yahei","微软雅黑",Tahoma,Arial'
    };
    (0, _assign.default)(this, options);
  }

  (0, _createClass2.default)(MapOptions, [{
    key: "computePoseToAngle",
    value: function computePoseToAngle() {
      if (typeof this.defaultControlsPose === "number") {
        return this.defaultControlsPose;
      }

      if (this.defaultControlsPose) {
        var angle = _FMDirection.default[this.defaultControlsPose];
        return angle ? angle : -15;
      }
    }
  }, {
    key: "key",
    set: function set(k) {
      this._key = k;
    },
    get: function get() {
      return this._key;
    }
  }, {
    key: "appName",
    set: function set(n) {
      this._appName = n;
    },
    get: function get() {
      return this._appName;
    }
  }, {
    key: "mapServerURL",
    get: function get() {
      return this._mapServerURL;
    },
    set: function set(u) {
      this._mapServerURL = u;
    }
  }, {
    key: "mapThemeURL",
    get: function get() {
      return this._mapThemeURL;
    },
    set: function set(m) {
      this._mapThemeURL = m;
    }
  }, {
    key: "container",
    get: function get() {
      return this._container;
    },
    set: function set(c) {
      this._container = c;
    }
  }, {
    key: "compassOffset",
    get: function get() {
      return this._compassOffset;
    },
    set: function set(c) {
      this._compassOffset = c;
    }
  }, {
    key: "compassSize",
    get: function get() {
      return this._compassSize;
    },
    set: function set(c) {
      this._compassSize = c;
    }
  }, {
    key: "compassFg",
    set: function set(c) {
      this._compassFg = c;
    },
    get: function get() {
      return this._compassFg;
    }
  }, {
    key: "compassBg",
    set: function set(b) {
      this._compassBg = b;
    },
    get: function get() {
      return this._compassBg;
    }
  }, {
    key: "defaultThemeName",
    get: function get() {
      return this._defaultThemeName;
    },
    set: function set(d) {
      this._defaultThemeName = d;
    }
  }, {
    key: "focusAnimateMode",
    get: function get() {
      return this._focusAnimateMode;
    },
    set: function set(f) {
      this._focusAnimateMode = f;
    }
  }, {
    key: "focusAnimateTime",
    get: function get() {
      return this._focusAnimateTime;
    },
    set: function set(f) {
      this._focusAnimateTime = f;
    }
  }, {
    key: "focusAlphaMode",
    get: function get() {
      this._focusAlphaMode;
    },
    set: function set(f) {
      this._focusAlphaMode = f;
    }
  }, {
    key: "focusAlpha",
    set: function set(f) {
      this._focusAlpha = f;
    },
    get: function get() {
      return this._focusAlpha;
    }
  }, {
    key: "viewModeAnimateMode",
    set: function set(v) {
      this._viewModeAnimateMode = v;
    },
    get: function get() {
      return this._viewModeAnimateMode;
    }
  }, {
    key: "moveToAnimateMode",
    set: function set(m) {
      this._moveToAnimateMode = m;
    },
    get: function get() {
      return this._moveToAnimateMode;
    }
  }, {
    key: "scaleToAnimateMode",
    set: function set(m) {
      this._scaleToAnimateMode = m;
    },
    get: function get() {
      return this._scaleToAnimateMode;
    }
  }, {
    key: "viewModeAnimateTime",
    set: function set(v) {
      this._viewModeAnimateTime = v;
    },
    get: function get() {
      return this._viewModeAnimateTime;
    }
  }, {
    key: "modelHoverTime",
    get: function get() {
      return this._modelHoverTime;
    },
    set: function set(t) {
      if (t < 300) {
        t = 300;
      }

      this._modelHoverTime = t;
    }
  }, {
    key: "modelHoverEffect",
    get: function get() {
      return this._modelHoverEffect;
    },
    set: function set(bool) {
      this._modelHoverEffect = bool;
    }
  }, {
    key: "modelSelectedEffect",
    get: function get() {
      return this._modelSelectedEffect;
    },
    set: function set(bool) {
      this._modelSelectedEffect = bool;
    }
  }]);
  return MapOptions;
}();

var _default = MapOptions;
exports.default = _default;

/***/ }),
/* 376 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _MapReader = _interopRequireDefault(__webpack_require__(377));

var _FloorReader = _interopRequireDefault(__webpack_require__(379));

var _SceneReader = _interopRequireDefault(__webpack_require__(380));

var _Cerity = _interopRequireDefault(__webpack_require__(205));

/**
 * Created by CastingJ on 16/3/10.
 * copy by ywt on 19/1/24.
 */

/**
 *	FileReader 是对地图进行数据解析模块
 * 	@class FileReader
 *	@constructor
 * 	@module FileReader
 */
// 反序列化*.fmap文件
var FileReader =
/*#__PURE__*/
function () {
  function FileReader() {
    (0, _classCallCheck2.default)(this, FileReader);
  }

  (0, _createClass2.default)(FileReader, [{
    key: "mapDecode",
    value: function mapDecode(data, license, mid) {
      var map = _MapReader.default.build("Map").decode(data);

      var str = '%E8%AF%B7%E8%BE%93%E5%85%A5%E6%AD%A3%E7%A1%AE%E7%9A%84license.';

      if (_Cerity.default.ls && !_Cerity.default.checkLicense(map.key, license, mid)) {
        console.warn(decodeURIComponent(str));
        return null;
      }

      var mapObj = {};
      mapObj.scene = null;
      mapObj.floors = [];

      for (var i = 0, length = map.buffers.length; i < length; i++) {
        var buffer = map.buffers[i];
        var len = buffer.len;
        var start = buffer.data.offset;
        var end = buffer.data.offset + len.low;
        var bufferData = buffer.data.buffer;

        if (buffer.btype == 1) {
          var scene = _SceneReader.default.build("Scene").decode(bufferData.slice(start, end));

          mapObj.scene = scene;
        } else {
          var gid = buffer.gid;
          var existfloor = this.containsFloor(gid, mapObj.floors);
          var floor = existfloor.floor;

          if (existfloor.index < 0) {
            floor.gid = gid;
            floor.biz = [];
            floor.navi = [];
            floor.geo = [];
          }

          if (buffer.btype == 2) {
            var floorGeo = _FloorReader.default.build("FloorGeo").decode(bufferData.slice(start, end));

            floor.geo.push(floorGeo);
          }

          if (buffer.btype == 3) {
            var floorBiz = _FloorReader.default.build("FloorBiz").decode(bufferData.slice(start, end));

            floor.biz.push(floorBiz);
          }

          if (buffer.btype == 4) {
            var floorNavi = _FloorReader.default.build("FloorNavi").decode(bufferData.slice(start, end));

            floor.navi.push(floorNavi);
          }

          if (existfloor.index < 0) mapObj.floors.push(floor);else mapObj.floors[existfloor.index] = floor;
        }
      }

      return mapObj;
    }
  }, {
    key: "containsFloor",
    value: function containsFloor(gid, floors) {
      for (var i = 0, len = floors.length; i < len; i++) {
        if (floors[i].gid == gid) return {
          index: i,
          floor: floors[i]
        };
      }

      return {
        index: -1,
        floor: {}
      };
    } // 反序列化*.scene.fmap文件

  }, {
    key: "sceneDecode",
    value: function sceneDecode(data, license, mid) {
      var scene = _SceneReader.default.build("Scene").decode(data);

      var str = '%E8%AF%B7%E8%BE%93%E5%85%A5%E6%AD%A3%E7%A1%AE%E7%9A%84license.';

      if (_Cerity.default.ls && !_Cerity.default.checkLicense(scene.key, license, mid)) {
        console.warn(decodeURIComponent(str));
        return null;
      }

      return scene;
    } // 反序列化*.floor.geo.fmap文件

  }, {
    key: "floorGeoDecode",
    value: function floorGeoDecode(data) {
      var floorGeo = _FloorReader.default.build("FloorGeo").decode(data);

      return floorGeo;
    } // 反序列化*.floor.biz.fmap文件

  }, {
    key: "floorBizDecode",
    value: function floorBizDecode(data) {
      var floorBiz = _FloorReader.default.build("FloorBiz").decode(data);

      return floorBiz;
    } // 反序列化*.floor.navi.fmap文件

  }, {
    key: "floorNaviDecode",
    value: function floorNaviDecode(data) {
      var floorNavi = _FloorReader.default.build("FloorNavi").decode(data);

      return floorNavi;
    }
  }, {
    key: "disposeRoot",
    value: function disposeRoot(root) {
      var ns = root.ns;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(ns.children), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var message = _step.value;
          message.builder = undefined;
          message.parent = undefined;
          message.children.length = 0;
          message._fields.length = 0;
          message._fieldsById = undefined;
          message._fieldsByName = undefined;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      ns.children.length = 0;
      root.ns = undefined;
      root.ptr = undefined;
    }
  }, {
    key: "dispose",
    value: function dispose() {// this.disposeRoot(rootFloor);
      // this.disposeRoot(rootMap);
      // this.disposeRoot(rootScene);
    }
  }]);
  return FileReader;
}();

var _default = FileReader;
exports.default = _default;

/***/ }),
/* 377 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _protobuf = __webpack_require__(148);

/**
 * Created by CastingJ on 16/3/11.
 * copy by ywt on 19/1/24
 */
// let ProtoBuf = require("protobufjs");
var _default =
/*dcodeIO.*/
_protobuf.ProtoBuf.newBuilder({})['import']({
  // "package": "protobuf",
  // "options": {
  //     "java_package": "com.fengmap.platform.protobuf",
  //     "java_outer_classname": "MapProtoBuf"
  // },
  "messages": [{
    "name": "Map",
    "fields": [{
      "rule": "required",
      "type": "string",
      "name": "mid",
      "id": 1
    }, {
      "rule": "required",
      "type": "int32",
      "name": "file_ver",
      "id": 2
    }, {
      "rule": "required",
      "type": "uint64",
      "name": "date_ver",
      "id": 3
    }, {
      "rule": "required",
      "type": "string",
      "name": "mname",
      "id": 4
    }, {
      "rule": "required",
      "type": "string",
      "name": "hash_code",
      "id": 5
    }, {
      "rule": "optional",
      "type": "string",
      "name": "key",
      "id": 6
    }, {
      "rule": "optional",
      "type": "string",
      "name": "file_date",
      "id": 7
    }, {
      "rule": "optional",
      "type": "string",
      "name": "desc",
      "id": 8
    }, {
      "rule": "optional",
      "type": "bool",
      "name": "read_only",
      "id": 9,
      "options": {
        "default": false
      }
    }, {
      "rule": "repeated",
      "type": "Buffer",
      "name": "buffers",
      "id": 10
    }],
    "messages": [{
      "name": "Buffer",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "gid",
        "id": 1
      }, {
        "rule": "required",
        "type": "int32",
        "name": "file_ver",
        "id": 2
      }, {
        "rule": "required",
        "type": "int32",
        "name": "btype",
        "id": 3
      }, {
        "rule": "required",
        "type": "uint64",
        "name": "len",
        "id": 4
      }, {
        "rule": "required",
        "type": "bytes",
        "name": "data",
        "id": 5
      }]
    }]
  }]
});

exports.default = _default;

/***/ }),
/* 378 */
/***/ (function(module, exports) {



/***/ }),
/* 379 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _protobuf = __webpack_require__(148);

// let ProtoBuf = require("protobufjs");
var _default =
/*dcodeIO.*/
_protobuf.ProtoBuf.newBuilder({})['import']({
  // "package": "protobuf",
  // "syntax": "proto2",
  // "options": {
  //     "java_package": "com.fengmap.platform.protobuf",
  //     "java_outer_classname": "FloorConfigProtoBuf"
  // },
  "messages": [{
    "name": "FloorGeo",
    "syntax": "proto2",
    "fields": [{
      "rule": "required",
      "type": "string",
      "name": "mid",
      "id": 1
    }, {
      "rule": "required",
      "type": "int32",
      "name": "gid",
      "id": 2
    }, {
      "rule": "optional",
      "type": "float",
      "name": "height",
      "id": 3
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "extentLayer",
      "id": 4
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "modelLayer",
      "id": 5
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "labelLayer",
      "id": 6
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "poiLayer",
      "id": 7
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "polygonLayer",
      "id": 8
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "polygonLabelLayer",
      "id": 9
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "liftLayer",
      "id": 10
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "stairLayer",
      "id": 11
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "escalatorLayer",
      "id": 12
    }, {
      "rule": "repeated",
      "type": "GeneralGeoInfo",
      "name": "externalModelLayer",
      "id": 13
    }],
    "messages": [{
      "name": "GeneralGeoInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "geo",
        "id": 2
      }, {
        "rule": "optional",
        "type": "float",
        "name": "height",
        "id": 3
      }, {
        "rule": "optional",
        "type": "float",
        "name": "area",
        "id": 4
      }, {
        "rule": "repeated",
        "type": "Indexinfo",
        "name": "idxs",
        "id": 5
      }, {
        "rule": "repeated",
        "type": "double",
        "name": "pts",
        "id": 6
      }],
      "messages": [{
        "name": "Indexinfo",
        "syntax": "proto2",
        "fields": [{
          "rule": "repeated",
          "type": "int32",
          "name": "idxs",
          "id": 1
        }]
      }]
    }]
  }, {
    "name": "FloorBiz",
    "syntax": "proto2",
    "fields": [{
      "rule": "required",
      "type": "string",
      "name": "mid",
      "id": 1
    }, {
      "rule": "required",
      "type": "int32",
      "name": "gid",
      "id": 2
    }, {
      "rule": "repeated",
      "type": "ExtentBizInfo",
      "name": "extentLayer",
      "id": 3
    }, {
      "rule": "repeated",
      "type": "ModelBizInfo",
      "name": "modelLayer",
      "id": 4
    }, {
      "rule": "repeated",
      "type": "LabelBizInfo",
      "name": "labelLayer",
      "id": 5
    }, {
      "rule": "repeated",
      "type": "POIBizInfo",
      "name": "poiLayer",
      "id": 6
    }, {
      "rule": "repeated",
      "type": "PolygonBizInfo",
      "name": "polygonLayer",
      "id": 7
    }, {
      "rule": "repeated",
      "type": "LiftBizInfo",
      "name": "liftLayer",
      "id": 8
    }, {
      "rule": "repeated",
      "type": "StairBizInfo",
      "name": "stairLayer",
      "id": 9
    }, {
      "rule": "repeated",
      "type": "PolygonLabelBizInfo",
      "name": "polygonLabelLayer",
      "id": 10
    }, {
      "rule": "repeated",
      "type": "ExternalModelBizInfo",
      "name": "externalModelLayer",
      "id": 11
    }],
    "messages": [{
      "name": "ExtentBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "string",
        "name": "name",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "ename",
        "id": 5
      }]
    }, {
      "name": "ModelBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "string",
        "name": "name",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "ename",
        "id": 5
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "minlevel",
        "id": 6
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "maxlevel",
        "id": 7
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "pass",
        "id": 8
      }]
    }, {
      "name": "LabelBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "string",
        "name": "name",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "ename",
        "id": 5
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "minlevel",
        "id": 6
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "maxlevel",
        "id": 7
      }]
    }, {
      "name": "PolygonBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "string",
        "name": "name",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "ename",
        "id": 5
      }]
    }, {
      "name": "POIBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "string",
        "name": "name",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "ename",
        "id": 5
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "minlevel",
        "id": 6
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "maxlevel",
        "id": 7
      }]
    }, {
      "name": "LiftBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "flag",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "floor",
        "id": 5
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "minlevel",
        "id": 6
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "maxlevel",
        "id": 7
      }]
    }, {
      "name": "StairBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "flag",
        "id": 4
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "minlevel",
        "id": 5
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "maxlevel",
        "id": 6
      }]
    }, {
      "name": "PolygonLabelBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "float",
        "name": "width",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "name",
        "id": 5
      }, {
        "rule": "optional",
        "type": "string",
        "name": "ename",
        "id": 6
      }, {
        "rule": "optional",
        "type": "float",
        "name": "angle",
        "id": 7
      }]
    }, {
      "name": "ExternalModelBizInfo",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "eid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "fid",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "type",
        "id": 3
      }, {
        "rule": "optional",
        "type": "string",
        "name": "name",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "ename",
        "id": 5
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "minlevel",
        "id": 6
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "maxlevel",
        "id": 7
      }]
    }]
  }, {
    "name": "FloorNavi",
    "syntax": "proto2",
    "fields": [{
      "rule": "required",
      "type": "string",
      "name": "mid",
      "id": 1
    }, {
      "rule": "required",
      "type": "int32",
      "name": "gid",
      "id": 2
    }, {
      "rule": "repeated",
      "type": "NaviNode",
      "name": "naviNodes",
      "id": 3
    }, {
      "rule": "repeated",
      "type": "NaviSegment",
      "name": "naviSegments",
      "id": 4
    }, {
      "rule": "repeated",
      "type": "NaviZone",
      "name": "naviZones",
      "id": 5
    }, {
      "rule": "repeated",
      "type": "NaviModel",
      "name": "naviModels",
      "id": 6
    }, {
      "rule": "repeated",
      "type": "int32",
      "name": "nextFloors",
      "id": 7
    }],
    "messages": [{
      "name": "NaviNode",
      "syntax": "proto2",
      "fields": [{
        "rule": "optional",
        "type": "int32",
        "name": "nodeId",
        "id": 1
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "nodeType",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "liftType",
        "id": 3
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "liftFlag",
        "id": 4
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "liftEntry",
        "id": 5
      }, {
        "rule": "optional",
        "type": "string",
        "name": "liftFloor",
        "id": 6
      }, {
        "rule": "optional",
        "type": "string",
        "name": "linkSeg",
        "id": 7
      }, {
        "rule": "optional",
        "type": "string",
        "name": "geo",
        "id": 8
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "entranceType",
        "id": 9
      }, {
        "rule": "optional",
        "type": "string",
        "name": "entranceFloor",
        "id": 10
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "doortype",
        "id": 11
      }, {
        "rule": "repeated",
        "type": "int32",
        "name": "idxs",
        "id": 12
      }, {
        "rule": "repeated",
        "type": "double",
        "name": "pts",
        "id": 13
      }]
    }, {
      "name": "NaviSegment",
      "syntax": "proto2",
      "fields": [{
        "rule": "optional",
        "type": "int32",
        "name": "segmentId",
        "id": 1
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "snode",
        "id": 2
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "enode",
        "id": 3
      }, {
        "rule": "optional",
        "type": "double",
        "name": "length",
        "id": 4
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "rank",
        "id": 5
      }, {
        "rule": "optional",
        "type": "string",
        "name": "name",
        "id": 6
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "entry",
        "id": 7
      }, {
        "rule": "optional",
        "type": "string",
        "name": "desc",
        "id": 8
      }, {
        "rule": "optional",
        "type": "string",
        "name": "geo",
        "id": 9
      }, {
        "rule": "optional",
        "type": "int32",
        "name": "through",
        "id": 10
      }, {
        "rule": "repeated",
        "type": "int32",
        "name": "idxs",
        "id": 11
      }, {
        "rule": "repeated",
        "type": "double",
        "name": "pts",
        "id": 12
      }]
    }, {
      "name": "NaviZone",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "id",
        "id": 1
      }, {
        "rule": "required",
        "type": "int32",
        "name": "type",
        "id": 2,
        "options": {
          "default": 0
        }
      }, {
        "rule": "optional",
        "type": "string",
        "name": "geo",
        "id": 3
      }, {
        "rule": "repeated",
        "type": "int32",
        "name": "rejects",
        "id": 4
      }, {
        "rule": "repeated",
        "type": "int32",
        "name": "idxs",
        "id": 5
      }, {
        "rule": "repeated",
        "type": "double",
        "name": "pts",
        "id": 6
      }]
    }, {
      "name": "NaviModel",
      "syntax": "proto2",
      "fields": [{
        "rule": "required",
        "type": "int32",
        "name": "id",
        "id": 1
      }, {
        "rule": "repeated",
        "type": "int32",
        "name": "doorids",
        "id": 2
      }, {
        "rule": "repeated",
        "type": "int32",
        "name": "nodetypes",
        "id": 3
      }, {
        "rule": "repeated",
        "type": "int32",
        "name": "entrytypes",
        "id": 4
      }]
    }]
  }] // "isNamespace": true

});

exports.default = _default;

/***/ }),
/* 380 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _protobuf = __webpack_require__(148);

// let ProtoBuf = require("protobufjs");
var _default =
/*dcodeIO.*/
_protobuf.ProtoBuf.newBuilder({})['import']({
  //"package": "protobuf",
  //"options": {
  //"java_package": "com.fengmap.platform.protobuf",
  //"java_outer_classname": "SceneConfigProtoBuf"
  //},
  "messages": [{
    "name": "Scene",
    "fields": [{
      "rule": "required",
      "type": "string",
      "name": "mid",
      "id": 19
    }, {
      "rule": "required",
      "type": "int32",
      "name": "file_ver",
      "id": 20
    }, {
      "rule": "required",
      "type": "uint64",
      "name": "date_ver",
      "id": 21
    }, {
      "rule": "required",
      "type": "string",
      "name": "mname",
      "id": 22
    }, {
      "rule": "required",
      "type": "string",
      "name": "hash_code",
      "id": 23
    }, {
      "rule": "optional",
      "type": "string",
      "name": "key",
      "id": 24
    }, {
      "rule": "optional",
      "type": "string",
      "name": "desc",
      "id": 25
    }, {
      "rule": "optional",
      "type": "bool",
      "name": "read_only",
      "id": 26,
      "options": {
        "default": false
      }
    }, {
      "rule": "optional",
      "type": "float",
      "name": "x",
      "id": 1
    }, {
      "rule": "optional",
      "type": "float",
      "name": "y",
      "id": 2
    }, {
      "rule": "optional",
      "type": "float",
      "name": "z",
      "id": 3
    }, {
      "rule": "optional",
      "type": "float",
      "name": "minX",
      "id": 4
    }, {
      "rule": "optional",
      "type": "float",
      "name": "minY",
      "id": 5
    }, {
      "rule": "optional",
      "type": "float",
      "name": "maxX",
      "id": 6
    }, {
      "rule": "optional",
      "type": "float",
      "name": "maxY",
      "id": 7
    }, {
      "rule": "optional",
      "type": "string",
      "name": "defGid",
      "id": 8
    }, {
      "rule": "optional",
      "type": "float",
      "name": "defCenX",
      "id": 9
    }, {
      "rule": "optional",
      "type": "float",
      "name": "defCenY",
      "id": 10
    }, {
      "rule": "optional",
      "type": "float",
      "name": "defCenZ",
      "id": 11
    }, {
      "rule": "optional",
      "type": "float",
      "name": "height",
      "id": 12
    }, {
      "rule": "optional",
      "type": "float",
      "name": "rotateAngleX",
      "id": 13
    }, {
      "rule": "optional",
      "type": "float",
      "name": "rotateAngleY",
      "id": 14
    }, {
      "rule": "optional",
      "type": "float",
      "name": "rotateAngleZ",
      "id": 15
    }, {
      "rule": "optional",
      "type": "float",
      "name": "scale",
      "id": 16
    }, {
      "rule": "optional",
      "type": "string",
      "name": "scaleLevel",
      "id": 17
    }, {
      "rule": "repeated",
      "type": "LayerGroup",
      "name": "layerGroups",
      "id": 18
    }],
    "messages": [{
      "name": "Layer",
      "fields": [{
        "rule": "optional",
        "type": "int32",
        "name": "lid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "lname",
        "id": 2
      }, {
        "rule": "optional",
        "type": "string",
        "name": "alias",
        "id": 3
      }, {
        "rule": "optional",
        "type": "Type",
        "name": "ltype",
        "id": 4
      }, {
        "rule": "optional",
        "type": "float",
        "name": "offsetX",
        "id": 5
      }, {
        "rule": "optional",
        "type": "float",
        "name": "offsetY",
        "id": 6
      }, {
        "rule": "optional",
        "type": "float",
        "name": "height",
        "id": 7
      }, {
        "rule": "optional",
        "type": "float",
        "name": "rotateAngleX",
        "id": 8
      }, {
        "rule": "optional",
        "type": "float",
        "name": "rotateAngleY",
        "id": 9
      }, {
        "rule": "optional",
        "type": "float",
        "name": "rotateAngleZ",
        "id": 10
      }, {
        "rule": "optional",
        "type": "float",
        "name": "minScaleLevel",
        "id": 11
      }, {
        "rule": "optional",
        "type": "float",
        "name": "maxScaleLevel",
        "id": 12
      }, {
        "rule": "optional",
        "type": "bool",
        "name": "isVisible",
        "id": 13
      }, {
        "rule": "optional",
        "type": "bool",
        "name": "isSelectable",
        "id": 14
      }, {
        "rule": "optional",
        "type": "bool",
        "name": "isEditable",
        "id": 15
      }, {
        "rule": "optional",
        "type": "string",
        "name": "desc",
        "id": 16
      }],
      "enums": [{
        "name": "Type",
        "values": [{
          "name": "GEOPOINT",
          "id": 1
        }, {
          "name": "GEOPOINT_ESCALATOR",
          "id": 2
        }, {
          "name": "GEOPOINT_LIFT",
          "id": 3
        }, {
          "name": "GEOPOINT_STAIR",
          "id": 4
        }, {
          "name": "GEOPOINT_PANORAMA",
          "id": 5
        }, {
          "name": "GEOPOINT_POI",
          "id": 6
        }, {
          "name": "GEOPOINT_STORELABEL",
          "id": 7
        }, {
          "name": "GEOPOINT_NAVINODE",
          "id": 8
        }, {
          "name": "GEOPOINT_MODEL",
          "id": 9
        }, {
          "name": "GEOLINE",
          "id": 20
        }, {
          "name": "GEOLINE_NAVISEGMENT",
          "id": 21
        }, {
          "name": "GEOLINE_BORDER",
          "id": 22
        }, {
          "name": "GEOPOLYGON",
          "id": 30
        }, {
          "name": "GEOPOLYGON_EXTENT",
          "id": 31
        }, {
          "name": "GEOPOLYGON_STORE",
          "id": 32
        }, {
          "name": "GEOPOLYGON_LABEL",
          "id": 33
        }, {
          "name": "RASTERATA",
          "id": 40
        }, {
          "name": "OVERLAYDATA",
          "id": 50
        }]
      }]
    }, {
      "name": "LayerGroup",
      "fields": [{
        "rule": "optional",
        "type": "int32",
        "name": "gid",
        "id": 1
      }, {
        "rule": "optional",
        "type": "string",
        "name": "gname",
        "id": 2
      }, {
        "rule": "optional",
        "type": "string",
        "name": "alias",
        "id": 3
      }, {
        "rule": "optional",
        "type": "float",
        "name": "height",
        "id": 4
      }, {
        "rule": "optional",
        "type": "string",
        "name": "desc",
        "id": 5
      }, {
        "rule": "repeated",
        "type": "Layer",
        "name": "layers",
        "id": 6
      }]
    }]
  }]
});

exports.default = _default;

/***/ }),
/* 381 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var FMMD5 = function () {
  function safeAdd(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
  }

  function bitRotateLeft(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }

  function md5cmn(q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
  }

  function md5ff(a, b, c, d, x, s, t) {
    return md5cmn(b & c | ~b & d, a, b, x, s, t);
  }

  function md5gg(a, b, c, d, x, s, t) {
    return md5cmn(b & d | c & ~d, a, b, x, s, t);
  }

  function md5hh(a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t);
  }

  function md5ii(a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t);
  }

  function binlMD5(x, len) {
    x[len >> 5] |= 0x80 << len % 32;
    x[(len + 64 >>> 9 << 4) + 14] = len;
    var i;
    var olda;
    var oldb;
    var oldc;
    var oldd;
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;

    for (i = 0; i < x.length; i += 16) {
      olda = a;
      oldb = b;
      oldc = c;
      oldd = d;
      a = md5ff(a, b, c, d, x[i], 7, -680876936);
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
      b = md5gg(b, c, d, a, x[i], 20, -373897302);
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
      d = md5hh(d, a, b, c, x[i], 11, -358537222);
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
      a = md5ii(a, b, c, d, x[i], 6, -198630844);
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
      a = safeAdd(a, olda);
      b = safeAdd(b, oldb);
      c = safeAdd(c, oldc);
      d = safeAdd(d, oldd);
    }

    return [a, b, c, d];
  }

  function binl2rstr(input) {
    var i;
    var output = '';
    var length32 = input.length * 32;

    for (i = 0; i < length32; i += 8) {
      output += String.fromCharCode(input[i >> 5] >>> i % 32 & 0xFF);
    }

    return output;
  }

  function rstr2binl(input) {
    var i;
    var output = [];
    output[(input.length >> 2) - 1] = undefined;

    for (i = 0; i < output.length; i += 1) {
      output[i] = 0;
    }

    var length8 = input.length * 8;

    for (i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << i % 32;
    }

    return output;
  }

  function rstrMD5(s) {
    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
  }

  function rstrHMACMD5(key, data) {
    var i;
    var bkey = rstr2binl(key);
    var ipad = [];
    var opad = [];
    var hash;
    ipad[15] = opad[15] = undefined;

    if (bkey.length > 16) {
      bkey = binlMD5(bkey, key.length * 8);
    }

    for (i = 0; i < 16; i += 1) {
      ipad[i] = bkey[i] ^ 0x36363636;
      opad[i] = bkey[i] ^ 0x5C5C5C5C;
    }

    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
  }

  function rstr2hex(input) {
    var hexTab = '0123456789abcdef';
    var output = '';
    var x;
    var i;

    for (i = 0; i < input.length; i += 1) {
      x = input.charCodeAt(i);
      output += hexTab.charAt(x >>> 4 & 0x0F) + hexTab.charAt(x & 0x0F);
    }

    return output;
  }

  function str2rstrUTF8(input) {
    return unescape(encodeURIComponent(input));
  }

  function rawMD5(s) {
    return rstrMD5(str2rstrUTF8(s));
  }

  function hexMD5(s) {
    return rstr2hex(rawMD5(s));
  }

  function rawHMACMD5(k, d) {
    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
  }

  function hexHMACMD5(k, d) {
    return rstr2hex(rawHMACMD5(k, d));
  }

  function md5(string, key, raw) {
    if (!key) {
      if (!raw) {
        return hexMD5(string);
      }

      return rawMD5(string);
    }

    if (!raw) {
      return hexHMACMD5(key, string);
    }

    return rawHMACMD5(key, string);
  }

  var encode = function encode(info) {
    return md5(info);
  };

  return {
    encryption: function encryption(info) {
      return encode(info);
    }
  };
}();

var _default = FMMD5;
exports.default = _default;

/***/ }),
/* 382 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

/**
 *  FMExtent 地板，是一种地图内置地板图层中的对象，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMExtent =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMExtent, _FMNode);

  function FMExtent(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMExtent);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMExtent).call(this, bdata.eid, _FMNodeType.default.FLOOR));
    _this._parseData = null;
    _this._isInitMesh = true;
    _this._visible = true;
    _this._renderNode = null;
    _this._geometry = undefined; // this._storeGeo = new fm.Geometry();

    _this.bdata = bdata;
    _this.gdata = gdata;
    return _this;
  }

  (0, _createClass2.default)(FMExtent, [{
    key: "initMesh",
    value: function initMesh(material, pos, color, opacity) {
      //  var geometry = new fm.BoxBufferGeometry( 200, 200, 200 );
      if (!this._geometry) return;
      this._renderNode = new fm.Mesh(this._geometry.geometry, material);
      this._renderNode.mapNode = this;
      material.color = new fm.Color(color);
      opacity = (0, _parseFloat2.default)(opacity);
      material.opacity = opacity;
      material.userData.opacity = opacity;
      material.transparent = true;

      this._renderNode.scale.set(1, -1, 1);

      this._renderNode.rotation.set(Math.PI / 2, 0, 0, 'XYZ');

      this._renderNode.position.copy(pos);

      this._renderNode.frustumCulled = false;
      this._renderNode.parent = this.parent.scene;
      this._renderNode.visible = this.show; // this._renderNode.castShadow = true;

      this._renderNode.receiveShadow = true;
      this.renderNodeInited = true;
      this._renderNode.name = "oneExtent"; // this._renderNode.matrixAutoUpdate = false;

      this._geometry = null;
    }
  }, {
    key: "setByTheme",
    value: function setByTheme(theme) {
      if (!this._renderNode) {
        return;
      }

      this._renderNode.material.color = new fm.Color(theme.floorColor);
      this._renderNode.material.alpha = theme.floorOpacity;
      this._renderNode.material.userData.opacity = theme.floorOpacity;
    }
  }, {
    key: "checkByFrustum",
    value: function checkByFrustum(frustum) {
      var visible = true;

      if (this._renderNode) {
        // console.log(frustum);
        this._renderNode.updateMatrixWorld(true); // console.log(this.renderNode.matrixWorld);
        // visible = frustum.intersectsObject(this._renderNode);

      }

      this.visible = visible;
    }
  }, {
    key: "releaseGpuMemory",
    value: function releaseGpuMemory() {
      if (this.renderNode) {
        // let g = this.renderNode.geometry;
        // g.dispose();
        this._geometry = null;
        this.renderNodeInited = false;
        this.renderNode.parent.remove(this.renderNode);
        this.dispose(); // this._storeGeo.copy(this.renderNode.geometry);
        // this._sgstat = true;
        // let g = this.renderNode.geometry;
        // g.vertices = [];
        // g.colors = [];
        // g.faces = [];
        // g.faceVertexUvs = [[]];
        // g.morphTargets = [];
        // g.morphNormals = [];
        // g.skinWeights = [];
        // g.skinIndices = [];
        // g.lineDistances = [];
        // g.elementsNeedUpdate = true;
        // g.verticesNeedUpdate = true;
        // g.uvsNeedUpdate = true;
        // g.normalsNeedUpdate = true;
        // g.colorsNeedUpdate = true;
        // g.lineDistancesNeedUpdate = true;
        // g.groupsNeedUpdate = true;
      }
    }
  }, {
    key: "restoreGpuMemeory",
    value: function restoreGpuMemeory() {// if(!this._sgstat ) return;
      // this.renderNode.geometry.copy( this._storeGeo);
      // let g = this.renderNode.geometry;
      // g.elementsNeedUpdate = true;
      // g.verticesNeedUpdate = true;
      // g.uvsNeedUpdate = true;
      // g.normalsNeedUpdate = true;
      // g.colorsNeedUpdate = true;
      // g.lineDistancesNeedUpdate = true;
      // g.groupsNeedUpdate = true;
    }
  }, {
    key: "getBbox",
    value: function getBbox() {}
  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode) {
        this._renderNode.material.dispose();

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this._geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }
    }
  }, {
    key: "isInitMesh",
    set: function set(bool) {
      this._isInitMesh = bool;
    },
    get: function get() {
      return this._isInitMesh;
    }
  }, {
    key: "visible",
    set: function set(bool) {
      if (bool) {
        if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
          // this.restoreGpuMemeory();
          this._renderNode && this.parent.scene.add(this._renderNode);
        }
      } else {
        // this.releaseGpuMemory();
        this._renderNode && this.parent.scene.remove(this._renderNode);
        this._renderNode.parent = this.parent.scene;
      }

      this._visible = bool;
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    },
    set: function set(r) {
      this._renderNode = r;
    }
  }]);
  return FMExtent;
}(_FMNode2.default);

var _default = FMExtent;
exports.default = _default;

/***/ }),
/* 383 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMExternalModel = _interopRequireDefault(__webpack_require__(211));

var _FMGlobal = _interopRequireDefault(__webpack_require__(110));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

/**
 *  FMExternalModelLayer 外部模型图层，是一种地图内置图层，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMExternalModelLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMExternalModelLayer, _FMNode);

  function FMExternalModelLayer(gdata, bdata, _this) {
    var _this2;

    (0, _classCallCheck2.default)(this, FMExternalModelLayer);
    _this2 = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMExternalModelLayer).call(this, "externalModelLayer"));
    _this2._scene = new fm.Scene();
    console.log(_this2._scene);
    _this2._scene.userData.type = "externalModel";
    _this2.alias = "externalModel";
    _this2._models = {};

    _this2.initNode(gdata, bdata);

    _this2._visible = true;

    _this2.initLight();

    _this2.putLight();

    return _this2;
  }

  (0, _createClass2.default)(FMExternalModelLayer, [{
    key: "initNode",
    value: function initNode(gdata, bdata) {
      for (var i = 0; i < gdata.length; i++) {
        this.createNode(gdata[i], bdata[i]);
      }
    }
  }, {
    key: "createNode",
    value: function createNode(geo, biz) {
      var node = new _FMExternalModel.default(geo, biz);
      node.parent = this;
      this._models["" + node.eid] = node;
    }
  }, {
    key: "addNodes",
    value: function addNodes(node) {
      node.parent = this;
      node.renderNode && this._scene.add(node.renderNode);
      this._models["" + node.eid] = node;
    }
  }, {
    key: "traverse",
    value: function traverse(back) {
      for (var n in this._models) {
        back && back(this._models[n]);
      }
    }
  }, {
    key: "initLight",
    value: function initLight() {
      this._target = new fm.Object3D();
      this._mainLight = new fm.DirectionalLight(0x888888, 1.2);

      this._mainLight.position.set(-1, 1, 1).normalize();

      this._mainLight.target = this._target;
      this._secondLight = new fm.DirectionalLight(0x333333);

      this._secondLight.position.set(-0.5, 1, -1).normalize();

      this._secondLight.target = this._target;
    }
  }, {
    key: "putLight",
    value: function putLight() {
      if (!_FMGlobal.default["light"]) {
        this._ambientLight = new fm.AmbientLight(0xffffff, 0.46);
        this.scene.add(this._mainLight);
        this.scene.add(this._secondLight);
        this.scene.add(this._target);
      } else {
        this._ambientLight = new fm.AmbientLight(0x404040); // this.scene.add(new fm.DirectionalLight(0xffffff, 0.3));
        // this.scene.add(this._target);
      }

      this.scene.add(this._ambientLight);

      this.scene.removeLight = function () {// this.removeLight();
      };
    }
  }, {
    key: "removeLight",
    value: function removeLight() {
      this.scene.remove(this._mainLight);
      this.scene.remove(this._ambientLight);
      this.scene.remove(this._secondLight);
      this.scene.add(this._target);
    }
  }, {
    key: "disposeLight",
    value: function disposeLight() {
      this._mainLight = undefined;
      this._ambientLight = undefined;
    }
  }, {
    key: "getNodeById",
    value: function getNodeById(id) {
      return this._models["" + id];
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;

      for (var n in this._models) {
        if (this._models[n].visible) {
          this._models[n].renderNode && this._scene.add(this._models[n].renderNode);
        }
      }

      this.putLight();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var n in this._models) {
        this._models[n].dispose();

        this._scene.remove(this._models[n].renderNode);

        this._models[n].parent = undefined;
        this._models[n] = undefined;
      }

      this.removeLight();
      this.disposeLight();
      this._scene.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }]);
  return FMExternalModelLayer;
}(_FMNode2.default);

var _default = FMExternalModelLayer;
exports.default = _default;

/***/ }),
/* 384 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMModel = _interopRequireDefault(__webpack_require__(212));

/**
 *  FMModelLayer 模型图层，是一种地图内置图层，只读，不可实例化。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @hideconstructor true
 */
var FMModelLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMModelLayer, _FMNode);

  function FMModelLayer(gdata, bdata) {
    var _this;

    (0, _classCallCheck2.default)(this, FMModelLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMModelLayer).call(this, "modelLayer"));
    _this._scene = new fm.Scene();
    _this._scene.name = "model";
    _this._scene.userData.type = "model";
    _this.alias = "model";
    _this._models = {};

    _this.initNode(gdata, bdata);

    _this._visible = true;

    _this.initLight();

    _this.putLight();

    return _this;
  }

  (0, _createClass2.default)(FMModelLayer, [{
    key: "initNode",
    value: function initNode(gdata, bdata) {
      for (var i = 0; i < gdata.length; i++) {
        this.createNode(gdata[i], bdata[i]);
      }
    }
  }, {
    key: "createNode",
    value: function createNode(geo, biz) {
      var node = new _FMModel.default(geo, biz);
      node.parent = this;
      this._models["" + node.eid] = node;
    }
  }, {
    key: "addNodes",
    value: function addNodes(node) {
      node.parent = this;
      node.renderNode && this._scene.add(node.renderNode);
      this._models["" + node.eid] = node;
    }
  }, {
    key: "removeNode",
    value: function removeNode(node) {
      // node.parent = undefined;
      node.renderNode && this._scene.remove(node.renderNode); // this._models["" + node.eid] = node;
    }
  }, {
    key: "traverse",
    value: function traverse(back) {
      for (var n in this._models) {
        back && back(this._models[n]);
      }
    }
  }, {
    key: "initLight",
    value: function initLight() {
      this._ambientLight = new fm.AmbientLight(0x747474);
      this._target = new fm.Object3D();
      this._mainLight = new fm.DirectionalLight(0x888888, 1.2);
      this._mainLight.name = "directionalLight";

      this._mainLight.position.set(-1, 1, 1).normalize();

      this._mainLight.target = this._target;
      this._secondLight = new fm.DirectionalLight(0x333333);

      this._secondLight.position.set(-0.5, 1, -1).normalize();

      this._secondLight.target = this._target; // this._mainLight = new fm.DirectionalLight(0x888888, 1.2);
      // this._mainLight.position.set(-50, 30, 20);
      // this._mainLight.target = this._target;
      // this._secondLight = new fm.DirectionalLight(0x333333);
      // this._secondLight.position.set(-0.5, 1, -1).normalize();
      // this._secondLight.target = this._target;
      // this._mainLight = new fm.DirectionalLight(0x888888, 0.8);
      // this._mainLight.position.set(-50, 100, 20);
      // this._mainLight.target = this._target;
      // this._mainLight.castShadow = true;
      // this._mainLight.shadow.camera = new fm.OrthographicCamera(-100, 100, 100, -100, 0.5, 1000);
      // this._mainLight.name = 'DirectionalLight';
      // this._mainLight.shadow.mapSize.width = 4096 //1024 * window.devicePixelRatio;
      // this._mainLight.shadow.mapSize.height = 4096 //768 * window.devicePixelRatio;   
    }
  }, {
    key: "putLight",
    value: function putLight() {
      var _this2 = this;

      this.scene.add(this._mainLight);
      this.scene.add(this._secondLight);
      this.scene.add(this._ambientLight);
      this.scene.add(this._target);

      this.scene.removeLight = function () {
        _this2.removeLight();
      };
    }
  }, {
    key: "removeLight",
    value: function removeLight() {
      this.scene.remove(this._mainLight);
      this.scene.remove(this._ambientLight);
      this.scene.remove(this._secondLight);
    }
  }, {
    key: "disposeLight",
    value: function disposeLight() {
      this._mainLight = undefined;
      this._ambientLight = undefined;
    }
  }, {
    key: "getNodeById",
    value: function getNodeById(id) {
      return this._models["" + id];
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;

      for (var n in this._models) {
        if (this._models[n].visible) {
          this._models[n].renderNode && this._scene.add(this._models[n].renderNode);
        }
      }

      this.putLight();
    }
  }, {
    key: "getAllMesh",
    value: function getAllMesh() {
      var meshs = [];

      for (var n in this._models) {
        this._models[n].renderNode && meshs.push(this._models[n].renderNode);
      }

      return meshs;
    }
  }, {
    key: "getVideoMemoryAmount",
    value: function getVideoMemoryAmount() {
      var videoMemoryAmount = null;
      this.traverse(function (model) {
        if (!model._renderNode) return;

        if (model._renderNode.geometry) {
          if (model._renderNode.geometry._bufferGeometry) {
            videoMemoryAmount += model._renderNode.geometry._bufferGeometry.attributes.position.array.byteLength;
            videoMemoryAmount += model._renderNode.geometry._bufferGeometry.attributes.color.array.byteLength;
            videoMemoryAmount += model._renderNode.geometry._bufferGeometry.attributes.normal.array.byteLength;
            videoMemoryAmount += model._renderNode.geometry._bufferGeometry.attributes.uv.array.byteLength;
          }
        }
      });
      return videoMemoryAmount;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var n in this._models) {
        this._models[n].dispose();

        this._scene.remove(this._models[n].renderNode);

        this._models[n].parent = undefined;
        this._models[n] = undefined;
      }

      this.removeLight();
      this.disposeLight();
      this._scene.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    },
    set: function set(v) {
      this._visible = v;

      if (this.parent && this.parent.parent && this.parent.parent.parent) {
        this.parent.parent.parent.map.setRenderList();
      }
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }]);
  return FMModelLayer;
}(_FMNode2.default);

var _default = FMModelLayer;
exports.default = _default;

/***/ }),
/* 385 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(386);

/***/ }),
/* 386 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(387);
module.exports = 0x1fffffffffffff;


/***/ }),
/* 387 */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(10);

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });


/***/ }),
/* 388 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

/**
 * FMLayer 渲染层基类
 * @interface
 * @memberof fengmap
 * @extends {fengmap.FMNode}
 * @hideconstructor true
 */
var FMLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMLayer, _FMNode);

  function FMLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMLayer).call(this));
    _this._scene = new fm.Scene();
    return _this;
  }

  (0, _createClass2.default)(FMLayer, [{
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "show",
    get: function get() {
      return this.visible;
    },
    set: function set(visible) {
      this.visible = visible;
    }
  }]);
  return FMLayer;
}(_FMNode2.default);

var _default = FMLayer;
exports.default = _default;

/***/ }),
/* 389 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var FMStairLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMStairLayer, _FMNode);

  function FMStairLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMStairLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMStairLayer).call(this));
    _this._scene = new fm.Scene();
    return _this;
  }

  (0, _createClass2.default)(FMStairLayer, [{
    key: "checkSceneNode",
    value: function checkSceneNode() {}
  }, {
    key: "dispose",
    value: function dispose() {}
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }]);
  return FMStairLayer;
}(_FMNode2.default);

var _default = FMStairLayer;
exports.default = _default;

/***/ }),
/* 390 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _GeometryMath = _interopRequireDefault(__webpack_require__(223));

var ThreeHeatMap =
/*#__PURE__*/
function (_fm$Mesh) {
  (0, _inherits2.default)(ThreeHeatMap, _fm$Mesh);

  function ThreeHeatMap(g, m, map) {
    var _this;

    (0, _classCallCheck2.default)(this, ThreeHeatMap);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ThreeHeatMap).call(this, g, m));

    if (map) {
      var geomath = new _GeometryMath.default();
      var geo = geomath.createGeometry(1.5, 20, 24, 0.5);
      var bgeometry = new fm.BufferGeometry();
      bgeometry.addAttribute("position", new fm.Float32BufferAttribute(geo.vertice, 3));
      bgeometry.addAttribute("uv", new fm.Float32BufferAttribute(geo.uv, 2));
      bgeometry.setIndex(new fm.Uint16BufferAttribute(geo.index, 1));
      _this.geometry = bgeometry;
      _this.material = new fm.MeshBasicMaterial({
        map: map,
        depthTest: false // color : new fm.Color(1, 0, 0)

      });
      _this.material.side = 2;
      _this.material.transparent = true;
    }

    return _this;
  }

  return ThreeHeatMap;
}(fm.Mesh);

var _default = ThreeHeatMap;
exports.default = _default;

/***/ }),
/* 391 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var FMSymbolLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMSymbolLayer, _FMNode);

  function FMSymbolLayer() {
    (0, _classCallCheck2.default)(this, FMSymbolLayer);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMSymbolLayer).call(this));
  }

  return FMSymbolLayer;
}(_FMNode2.default);

var _default = FMSymbolLayer;
exports.default = _default;

/***/ }),
/* 392 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

/**
 * @author Mif / Made on May 6, 2020/
 */

/**
 * @class
 * @memberof fengmap
 */
var FMWaterMarkerLayer =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMWaterMarkerLayer, _FMNode);

  /**
   * FMWaterMarkerLayer 是水波纹标注的图层，用于管理水波纹标注。
   */
  function FMWaterMarkerLayer() {
    var _this;

    (0, _classCallCheck2.default)(this, FMWaterMarkerLayer);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMWaterMarkerLayer).call(this));
    _this._scene = new fm.Scene();
    _this._scene.name = "waterMarker";
    _this._scene.userData.type = "waterMarker";
    _this._visible = true;
    _this.waters = [];

    _this.initLight();

    _this.putLight();

    return _this;
  }
  /**
   * 添加marker
   * @param {Object} marker 水波纹marker
   */


  (0, _createClass2.default)(FMWaterMarkerLayer, [{
    key: "addMarker",
    value: function addMarker(marker) {
      marker.parent = this;

      if (!marker.isInitWater) {
        marker.initWater();

        if (marker.renderNode) {
          this.waters.push(marker);

          this._scene.add(marker.renderNode);

          if (!!marker.floorNode) this._scene.add(marker.floorNode);
        }
      }
    }
    /**
     * 移除marker
     * @param {Object} marker 水波纹marker
     * @returns {boolean}
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(marker) {
      if (!marker.renderNode) return false;

      for (var i = 0; i < this.waters.length; i++) {
        if (this.waters[i].renderNode.uuid === marker.renderNode.uuid) {
          this.waters.splice(i, 1);
          break;
        }
      }

      this._scene.remove(marker.renderNode);
    }
    /**
     * 移除所有marker
     */

  }, {
    key: "removeAll",
    value: function removeAll() {
      for (var i = 0; i < this.waters.length; i++) {
        this._scene.remove(this.waters[i].renderNode);
      }

      this.waters = [];
    }
  }, {
    key: "checkSceneNode",
    value: function checkSceneNode() {
      this._scene.children.length = 0;

      for (var i = 0; i < this.waters.length; i++) {
        if (this.waters[i].visible) {
          this.waters[i].renderNode && this._scene.add(this.waters[i].renderNode);
        }
      }
    }
  }, {
    key: "initLight",
    value: function initLight() {
      this._ambientLight = new fm.AmbientLight(0x747474);
      this._target = new fm.Object3D();
      this._mainLight = new fm.DirectionalLight(0x888888, 1.2);

      this._mainLight.position.set(-1, 1, 1).normalize();

      this._mainLight.target = this._target;
      this._secondLight = new fm.DirectionalLight(0x333333);

      this._secondLight.position.set(-0.5, 1, -1).normalize();

      this._secondLight.target = this._target;
    }
  }, {
    key: "putLight",
    value: function putLight() {
      var _this2 = this;

      this.scene.add(this._mainLight);
      this.scene.add(this._ambientLight);
      this.scene.add(this._secondLight); // var helper1 = new fm.DirectionalLightHelper( this._mainLight, 100 ,0xff0000 );
      // var helper2 = new fm.DirectionalLightHelper( this._secondLight, 100 ,0xff0000);
      // this.scene.add(helper1);
      // this.scene.add(helper2);

      this.scene.add(this._target);

      this.scene.removeLight = function () {
        _this2.removeLight();
      };
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var i = 0; i < this.waters.length; i++) {
        this._scene.remove(this.waters[i].renderNode);

        this.waters[i].parent = undefined;
        this.waters[i] = undefined;
      }

      this._scene.length = 0;
      this._scene = undefined;
    }
  }, {
    key: "scene",
    get: function get() {
      return this._scene;
    }
  }, {
    key: "visible",
    get: function get() {
      return this._visible;
    }
  }]);
  return FMWaterMarkerLayer;
}(_FMNode2.default);

var _default = FMWaterMarkerLayer;
exports.default = _default;

/***/ }),
/* 393 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(55);

var _typeof2 = _interopRequireDefault(__webpack_require__(47));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var EPSILON = 1e-5,
    COPLANAR = 0,
    FRONT = 1,
    BACK = 2,
    SPANNING = 3;

var ThreeBSP =
/*#__PURE__*/
function () {
  function ThreeBSP(geometry) {
    (0, _classCallCheck2.default)(this, ThreeBSP);

    // Convert fm.Geometry to ThreeBSP
    var i,
        _length_i,
        face,
        vertex,
        faceVertexUvs,
        uvs,
        polygon,
        polygons = [],
        tree;

    this.Polygon = Polygon;
    this.Vertex = Vertex;
    this.Node = Node;

    if (geometry instanceof fm.Geometry) {
      this.matrix = new fm.Matrix4();
    } else if (geometry instanceof fm.Mesh) {
      // #todo: add hierarchy support
      geometry.updateMatrix();
      this.matrix = geometry.matrix.clone();
      geometry = geometry.geometry;
    } else if (geometry instanceof Node) {
      this.tree = geometry;
      this.matrix = new fm.Matrix4();
      return this;
    } else {
      throw 'ThreeBSP: Given geometry is unsupported';
    }

    for (i = 0, _length_i = geometry.faces.length; i < _length_i; i++) {
      face = geometry.faces[i];
      faceVertexUvs = geometry.faceVertexUvs[0][i];
      polygon = new Polygon();

      if (face instanceof fm.Face3) {
        vertex = geometry.vertices[face.a];
        uvs = faceVertexUvs ? new fm.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y) : null;
        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], uvs);
        vertex.applyMatrix4(this.matrix);
        polygon.vertices.push(vertex);
        vertex = geometry.vertices[face.b];
        uvs = faceVertexUvs ? new fm.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y) : null;
        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[1], uvs);
        vertex.applyMatrix4(this.matrix);
        polygon.vertices.push(vertex);
        vertex = geometry.vertices[face.c];
        uvs = faceVertexUvs ? new fm.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y) : null;
        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[2], uvs);
        vertex.applyMatrix4(this.matrix);
        polygon.vertices.push(vertex);
      } else if ((0, _typeof2.default)(fm.Face4)) {
        vertex = geometry.vertices[face.a];
        uvs = faceVertexUvs ? new fm.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y) : null;
        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], uvs);
        vertex.applyMatrix4(this.matrix);
        polygon.vertices.push(vertex);
        vertex = geometry.vertices[face.b];
        uvs = faceVertexUvs ? new fm.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y) : null;
        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[1], uvs);
        vertex.applyMatrix4(this.matrix);
        polygon.vertices.push(vertex);
        vertex = geometry.vertices[face.c];
        uvs = faceVertexUvs ? new fm.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y) : null;
        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[2], uvs);
        vertex.applyMatrix4(this.matrix);
        polygon.vertices.push(vertex);
        vertex = geometry.vertices[face.d];
        uvs = faceVertexUvs ? new fm.Vector2(faceVertexUvs[3].x, faceVertexUvs[3].y) : null;
        vertex = new Vertex(vertex.x, vertex.y, vertex.z, face.vertexNormals[3], uvs);
        vertex.applyMatrix4(this.matrix);
        polygon.vertices.push(vertex);
      } else {
        throw 'Invalid face type at index ' + i;
      }

      polygon.calculateProperties();
      polygons.push(polygon);
    }

    this.tree = new Node(polygons);
  }

  (0, _createClass2.default)(ThreeBSP, [{
    key: "subtract",
    value: function subtract(other_tree) {
      var a = this.tree.clone(),
          b = other_tree.tree.clone();
      a.invert();
      a.clipTo(b);
      b.clipTo(a);
      b.invert();
      b.clipTo(a);
      b.invert();
      a.build(b.allPolygons());
      a.invert();
      a = new ThreeBSP(a);
      a.matrix = this.matrix;
      return a;
    }
  }, {
    key: "union",
    value: function union(other_tree) {
      var a = this.tree.clone(),
          b = other_tree.tree.clone();
      a.clipTo(b);
      b.clipTo(a);
      b.invert();
      b.clipTo(a);
      b.invert();
      a.build(b.allPolygons());
      a = new ThreeBSP(a);
      a.matrix = this.matrix;
      return a;
    }
  }, {
    key: "intersect",
    value: function intersect(other_tree) {
      var a = this.tree.clone(),
          b = other_tree.tree.clone();
      a.invert();
      b.clipTo(a);
      b.invert();
      a.clipTo(b);
      b.clipTo(a);
      a.build(b.allPolygons());
      a.invert();
      a = new ThreeBSP(a);
      a.matrix = this.matrix;
      return a;
    }
  }, {
    key: "toGeometry",
    value: function toGeometry() {
      var i,
          j,
          matrix = new fm.Matrix4().getInverse(this.matrix),
          geometry = new fm.Geometry(),
          polygons = this.tree.allPolygons(),
          polygon_count = polygons.length,
          polygon,
          polygon_vertice_count,
          vertice_dict = {},
          vertex_idx_a,
          vertex_idx_b,
          vertex_idx_c,
          vertex,
          face,
          verticeUvs;

      for (i = 0; i < polygon_count; i++) {
        polygon = polygons[i];
        polygon_vertice_count = polygon.vertices.length;

        for (j = 2; j < polygon_vertice_count; j++) {
          verticeUvs = [];
          vertex = polygon.vertices[0];
          verticeUvs.push(new fm.Vector2(vertex.uv.x, vertex.uv.y));
          vertex = new fm.Vector3(vertex.x, vertex.y, vertex.z);
          vertex.applyMatrix4(matrix);

          if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {
            vertex_idx_a = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];
          } else {
            geometry.vertices.push(vertex);
            vertex_idx_a = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;
          }

          vertex = polygon.vertices[j - 1];
          verticeUvs.push(new fm.Vector2(vertex.uv.x, vertex.uv.y));
          vertex = new fm.Vector3(vertex.x, vertex.y, vertex.z);
          vertex.applyMatrix4(matrix);

          if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {
            vertex_idx_b = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];
          } else {
            geometry.vertices.push(vertex);
            vertex_idx_b = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;
          }

          vertex = polygon.vertices[j];
          verticeUvs.push(new fm.Vector2(vertex.uv.x, vertex.uv.y));
          vertex = new fm.Vector3(vertex.x, vertex.y, vertex.z);
          vertex.applyMatrix4(matrix);

          if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {
            vertex_idx_c = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];
          } else {
            geometry.vertices.push(vertex);
            vertex_idx_c = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;
          }

          face = new fm.Face3(vertex_idx_a, vertex_idx_b, vertex_idx_c, new fm.Vector3(polygon.normal.x, polygon.normal.y, polygon.normal.z));
          geometry.faces.push(face);
          geometry.faceVertexUvs[0].push(verticeUvs);
        }
      }

      return geometry;
    }
  }, {
    key: "toMesh",
    value: function toMesh(material) {
      var geometry = this.toGeometry(),
          mesh = new fm.Mesh(geometry, material);
      mesh.position.setFromMatrixPosition(this.matrix);
      mesh.rotation.setFromRotationMatrix(this.matrix);
      return mesh;
    }
  }]);
  return ThreeBSP;
}();

exports.default = ThreeBSP;

var Polygon =
/*#__PURE__*/
function () {
  function Polygon(vertices, normal, w) {
    (0, _classCallCheck2.default)(this, Polygon);

    if (!(vertices instanceof Array)) {
      vertices = [];
    }

    this.vertices = vertices;

    if (vertices.length > 0) {
      this.calculateProperties();
    } else {
      this.normal = this.w = undefined;
    }
  }

  (0, _createClass2.default)(Polygon, [{
    key: "calculateProperties",
    value: function calculateProperties() {
      var a = this.vertices[0],
          b = this.vertices[1],
          c = this.vertices[2];
      this.normal = b.clone().subtract(a).cross(c.clone().subtract(a)).normalize();
      this.w = this.normal.clone().dot(a);
      return this;
    }
  }, {
    key: "clone",
    value: function clone() {
      var i,
          vertice_count,
          polygon = new Polygon();

      for (i = 0, vertice_count = this.vertices.length; i < vertice_count; i++) {
        polygon.vertices.push(this.vertices[i].clone());
      }

      polygon.calculateProperties();
      return polygon;
    }
  }, {
    key: "flip",
    value: function flip() {
      var i,
          vertices = [];
      this.normal.multiplyScalar(-1);
      this.w *= -1;

      for (i = this.vertices.length - 1; i >= 0; i--) {
        vertices.push(this.vertices[i]);
      }

      this.vertices = vertices;
      return this;
    }
  }, {
    key: "classifyVertex",
    value: function classifyVertex(vertex) {
      var side_value = this.normal.dot(vertex) - this.w;

      if (side_value < -EPSILON) {
        return BACK;
      } else if (side_value > EPSILON) {
        return FRONT;
      } else {
        return COPLANAR;
      }
    }
  }, {
    key: "classifySide",
    value: function classifySide(polygon) {
      var i,
          vertex,
          classification,
          num_positive = 0,
          num_negative = 0,
          vertice_count = polygon.vertices.length;

      for (i = 0; i < vertice_count; i++) {
        vertex = polygon.vertices[i];
        classification = this.classifyVertex(vertex);

        if (classification === FRONT) {
          num_positive++;
        } else if (classification === BACK) {
          num_negative++;
        }
      }

      if (num_positive === vertice_count && num_negative === 0) {
        return FRONT;
      } else if (num_positive === 0 && num_negative === vertice_count) {
        return BACK;
      } else if (num_positive > 0 && num_negative > 0) {
        return SPANNING;
      } else {
        return COPLANAR;
      }
    }
  }, {
    key: "splitPolygon",
    value: function splitPolygon(polygon, coplanar_front, coplanar_back, front, back) {
      var classification = this.classifySide(polygon);

      if (classification === COPLANAR) {
        (this.normal.dot(polygon.normal) > 0 ? coplanar_front : coplanar_back).push(polygon);
      } else if (classification === FRONT) {
        front.push(polygon);
      } else if (classification === BACK) {
        back.push(polygon);
      } else {
        var vertice_count,
            i,
            j,
            ti,
            tj,
            vi,
            vj,
            t,
            v,
            f = [],
            b = [];

        for (i = 0, vertice_count = polygon.vertices.length; i < vertice_count; i++) {
          j = (i + 1) % vertice_count;
          vi = polygon.vertices[i];
          vj = polygon.vertices[j];
          ti = this.classifyVertex(vi);
          tj = this.classifyVertex(vj);
          if (ti != BACK) f.push(vi);
          if (ti != FRONT) b.push(vi);

          if ((ti | tj) === SPANNING) {
            t = (this.w - this.normal.dot(vi)) / this.normal.dot(vj.clone().subtract(vi));
            v = vi.interpolate(vj, t);
            f.push(v);
            b.push(v);
          }
        }

        if (f.length >= 3) front.push(new Polygon(f).calculateProperties());
        if (b.length >= 3) back.push(new Polygon(b).calculateProperties());
      }
    }
  }]);
  return Polygon;
}();

var Vertex =
/*#__PURE__*/
function () {
  function Vertex(x, y, z, normal, uv) {
    (0, _classCallCheck2.default)(this, Vertex);
    this.x = x;
    this.y = y;
    this.z = z;
    this.normal = normal || new fm.Vector3();
    this.uv = uv || new fm.Vector2();
  }

  (0, _createClass2.default)(Vertex, [{
    key: "clone",
    value: function clone() {
      return new Vertex(this.x, this.y, this.z, this.normal.clone(), this.uv.clone());
    }
  }, {
    key: "add",
    value: function add(vertex) {
      this.x += vertex.x;
      this.y += vertex.y;
      this.z += vertex.z;
      return this;
    }
  }, {
    key: "subtract",
    value: function subtract(vertex) {
      this.x -= vertex.x;
      this.y -= vertex.y;
      this.z -= vertex.z;
      return this;
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      this.x *= scalar;
      this.y *= scalar;
      this.z *= scalar;
      return this;
    }
  }, {
    key: "cross",
    value: function cross(vertex) {
      var x = this.x,
          y = this.y,
          z = this.z;
      this.x = y * vertex.z - z * vertex.y;
      this.y = z * vertex.x - x * vertex.z;
      this.z = x * vertex.y - y * vertex.x;
      return this;
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      this.x /= length;
      this.y /= length;
      this.z /= length;
      return this;
    }
  }, {
    key: "dot",
    value: function dot(vertex) {
      return this.x * vertex.x + this.y * vertex.y + this.z * vertex.z;
    }
  }, {
    key: "lerp",
    value: function lerp(a, t) {
      this.add(a.clone().subtract(this).multiplyScalar(t));
      this.normal.add(a.normal.clone().sub(this.normal).multiplyScalar(t));
      this.uv.add(a.uv.clone().sub(this.uv).multiplyScalar(t));
      return this;
    }
  }, {
    key: "interpolate",
    value: function interpolate(other, t) {
      return this.clone().lerp(other, t);
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      // input: fm.Matrix4 affine matrix
      var x = this.x,
          y = this.y,
          z = this.z;
      var e = m.elements;
      this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
      this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
      this.z = e[2] * x + e[6] * y + e[10] * z + e[14];
      return this;
    }
  }]);
  return Vertex;
}();

var Node =
/*#__PURE__*/
function () {
  function Node(polygons) {
    (0, _classCallCheck2.default)(this, Node);
    var i,
        polygon_count,
        front = [],
        back = [];
    this.polygons = [];
    this.front = this.back = undefined;
    if (!(polygons instanceof Array) || polygons.length === 0) return;
    this.divider = polygons[0].clone();

    for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {
      this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
    }

    if (front.length > 0) {
      this.front = new Node(front);
    }

    if (back.length > 0) {
      this.back = new Node(back);
    }
  }

  (0, _createClass2.default)(Node, [{
    key: "isConvex",
    value: function isConvex(polygons) {
      var i, j;

      for (i = 0; i < polygons.length; i++) {
        for (j = 0; j < polygons.length; j++) {
          if (i !== j && polygons[i].classifySide(polygons[j]) !== BACK) {
            return false;
          }
        }
      }

      return true;
    }
  }, {
    key: "build",
    value: function build(polygons) {
      var i,
          polygon_count,
          front = [],
          back = [];

      if (!this.divider) {
        this.divider = polygons[0].clone();
      }

      for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {
        this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
      }

      if (front.length > 0) {
        if (!this.front) this.front = new Node();
        this.front.build(front);
      }

      if (back.length > 0) {
        if (!this.back) this.back = new Node();
        this.back.build(back);
      }
    }
  }, {
    key: "allPolygons",
    value: function allPolygons() {
      var polygons = this.polygons.slice();
      if (this.front) polygons = polygons.concat(this.front.allPolygons());
      if (this.back) polygons = polygons.concat(this.back.allPolygons());
      return polygons;
    }
  }, {
    key: "clone",
    value: function clone() {
      var node = new Node();
      node.divider = this.divider.clone();
      node.polygons = this.polygons.map(function (polygon) {
        return polygon.clone();
      });
      node.front = this.front && this.front.clone();
      node.back = this.back && this.back.clone();
      return node;
    }
  }, {
    key: "invert",
    value: function invert() {
      var i, polygon_count, temp;

      for (i = 0, polygon_count = this.polygons.length; i < polygon_count; i++) {
        this.polygons[i].flip();
      }

      this.divider.flip();
      if (this.front) this.front.invert();
      if (this.back) this.back.invert();
      temp = this.front;
      this.front = this.back;
      this.back = temp;
      return this;
    }
  }, {
    key: "clipPolygons",
    value: function clipPolygons(polygons) {
      var i, polygon_count, front, back;
      if (!this.divider) return polygons.slice();
      front = [];
      back = [];

      for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {
        this.divider.splitPolygon(polygons[i], front, back, front, back);
      }

      if (this.front) front = this.front.clipPolygons(front);
      if (this.back) back = this.back.clipPolygons(back);else back = [];
      return front.concat(back);
    }
  }, {
    key: "clipTo",
    value: function clipTo(node) {
      this.polygons = node.clipPolygons(this.polygons);
      if (this.front) this.front.clipTo(node);
      if (this.back) this.back.clipTo(node);
    }
  }]);
  return Node;
}();

/***/ }),
/* 394 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(395);

__webpack_require__(68);

var _assign = _interopRequireDefault(__webpack_require__(11));

__webpack_require__(199);

__webpack_require__(149);

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

__webpack_require__(13);

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMUtil = _interopRequireDefault(__webpack_require__(57));

var _RawExtrudeVertShader = __webpack_require__(396);

var _RawExtrudeFragShader = __webpack_require__(397);

/**
 *	MaterialManager 是一个材质管理类，对地图所有元素进行材质管理
 * 	@class MaterialManager
 *	@constructor
 * 	@module MaterialManager
 */
var MaterialManager =
/*#__PURE__*/
function () {
  /***
   * @constructor
   * @param options {MapOptions}
   * @param map {FMMap}
   */
  function MaterialManager(font) {
    (0, _classCallCheck2.default)(this, MaterialManager);
    this._data = {}; // 保存图片信息，buffer

    this._textureData = {}; //textureBuffer

    this._textureArray = []; //存储所有的texture地址便于dispose

    this.font = font;
    this._textData = {}; // let ajax = new FMAjax();
    // ajax.getFile("simkai.json", (data)=>{
    //     this._textData = data;
    // });

    this.extrudeMaterial = {}; // 存储拉伸几何体材质
  } //基本颜色材质


  (0, _createClass2.default)(MaterialManager, [{
    key: "createBasicMaterial",
    value: function createBasicMaterial(theme) {
      var material = new fm.MeshBasicMaterial();

      if (theme) {
        material.color = new fm.Color(theme.color);
        material.transparent = true;
        material.depthWrite = true; //对于不会发生物体交叉的情况 不关闭depthmask 为了使其他半透明物体进行深度测试

        material.opacity = (0, _parseFloat2.default)(theme.alpha);
        material.userData.opacity = (0, _parseFloat2.default)(theme.alpha);
      } else {
        material.userData.opacity = 1;
      }

      return material;
    }
    /***
     * 创建法线材质
     * @param theme {object} 主题样式
     * @param theme.color 颜色
     * @param theme.alpha 透明度
     * @returns {*}
     */

  }, {
    key: "createNormalMaterial",
    value: function createNormalMaterial(theme) {
      var material = new fm.MeshLambertMaterial();

      if (theme) {
        material.color = new fm.Color(theme.color); //   material.emissive = new fm.Color(theme.color);

        material.transparent = true; // material.depthTest = true;//开启true深度测试

        material.depthWrite = true; //对于不会发生物体交叉的情况 不关闭depthmask 为了使其他半透明物体进行深度测试

        material.opacity = (0, _parseFloat2.default)(theme.alpha);
        material.userData.opacity = (0, _parseFloat2.default)(theme.alpha);
      } else {
        material.userData.opacity = 1;
      }

      return material;
    } //物理材质

  }, {
    key: "createPhysicMaterial",
    value: function createPhysicMaterial(theme) {
      var material = new fm.MeshStandardMaterial({
        roughness: 0.5,
        metalness: 0.5
      });

      if (theme) {
        material.color = new fm.Color(theme.color);
        material.transparent = true; // material.depthTest = true;//开启深度测试

        material.depthWrite = true; //对于不会发生物体交叉的情况 不关闭depthmask 为了使其他半透明物体进行深度测试

        material.opacity = (0, _parseFloat2.default)(theme.alpha);
        material.userData.opacity = (0, _parseFloat2.default)(theme.alpha);
      } else {
        material.userData.opacity = 1;
      }

      return material;
    } //phong材质

  }, {
    key: "createMeshPhongMaterial",
    value: function createMeshPhongMaterial(theme) {
      var material = new fm.MeshPhongMaterial({
        shininess: 50,
        specular: 0xffffff
      });

      if (theme) {
        material.color = new fm.Color(theme.color);
        material.transparent = true; // material.depthTest = true;//开启深度测试

        material.depthWrite = true; //对于不会发生物体交叉的情况 不关闭depthmask 为了使其他半透明物体进行深度测试

        material.opacity = (0, _parseFloat2.default)(theme.alpha);
        material.userData.opacity = (0, _parseFloat2.default)(theme.alpha);
      } else {
        material.userData.opacity = 1;
      }

      return material;
    } //线材质

  }, {
    key: "createLineMaterial",
    value: function createLineMaterial(theme) {
      if (!theme) {
        return new fm.LineBasicMaterial({
          color: "#ff0000",
          linewidth: 1,
          transparent: true,
          opacity: 1
        });
      }

      var strokeColor = "#ff0000";

      if (typeof theme.strokeColor == "number") {
        strokeColor = theme.strokeColor;
      } else {
        strokeColor = theme.strokeColor ? theme.strokeColor : "#ff0000";
      }

      var lineBasicStyle = {
        color: strokeColor,
        linewidth: 1,
        transparent: true,
        // color : theme.color,
        opacity: (0, _parseFloat2.default)(theme.alpha)
      };
      var material = new fm.LineBasicMaterial(lineBasicStyle);
      material.userData.opacity = (0, _parseFloat2.default)(theme.alpha);
      return material;
    }
    /***
     * 创建poi
     * @param theme {json} 主题数据
     * @param node {FMFacility}
     * @param back
     * @param needDepth
     * @param priority
     * @returns {fm.SpriteMaterial}
     */

  }, {
    key: "createPoiMaterial",
    value: function createPoiMaterial(theme, back, needDepth, priority) {
      var me = this;
      var material = new fm.SpriteMaterial();
      material.sizeAttenuation = false;
      material.opacity = 1;
      material.userData.opacity = 1;
      material.depthTest = !!needDepth;
      material.depthWrite = !!needDepth;
      material.transparent = true;
      material.side = 2;
      material.priority = priority;

      if (this._textureData[theme.imageUrl]) {
        var texture = this._textureData[theme.imageUrl];
        texture.minFilter = fm.LinearFilter;
        texture.generateMipmaps = false;
        texture.needsUpdate = true;
        material.map = texture;
        material.needsUpdate = true;
        material.userData.scaleRatio = texture.scaleRatio;
        back && back();
      } else {
        var img = new Image();
        img.crossOrigin = "Anonymous";
        var userAgent = navigator.userAgent;
        var rMsie = /(msie\s|trident.*rv:)([\w.]+)/;
        var match = rMsie.exec(userAgent.toLowerCase()); //判断浏览器是否是ie11

        if (match !== null) {
          img.onload = new function () {
            var texture = new fm.Texture(img);
            texture.minFilter = fm.LinearFilter;
            texture.generateMipmaps = false;
            texture.needsUpdate = true;
            texture.scaleRatio = img.width / img.height;
            material.userData.scaleRatio = texture.scaleRatio;
            material.map = texture;
            material.needsUpdate = true;
            me._textureData[theme.imageUrl] = texture; //存起来多次利用

            me._textureArray.push(texture);

            back && back();
          }();
        } else {
          img.onload = function () {
            var texture = new fm.Texture(img);
            texture.minFilter = fm.LinearFilter;
            texture.generateMipmaps = false;
            texture.needsUpdate = true;
            texture.scaleRatio = img.width / img.height;
            material.userData.scaleRatio = texture.scaleRatio;
            material.map = texture;
            material.needsUpdate = true;
            me._textureData[theme.imageUrl] = texture; //存起来多次利用

            me._textureArray.push(texture);

            back && back();
          };
        }

        img.src = theme.imageSrc;
      }

      return material;
    }
    /***
     * 创建label材质
     * @param name {string} 文字内容
     * @param theme {Object} 主题数据
     * @param needDepth
     * @param node 节点
     * @returns {*}
     */

  }, {
    key: "createLabelMaterial",
    value: function createLabelMaterial(name, theme, needDepth) {
      var me = this;
      var material = new fm.SpriteMaterial();
      material.sizeAttenuation = false;
      material.opacity = (0, _parseFloat2.default)(theme.alpha);
      material.userData.opacity = (0, _parseFloat2.default)(theme.alpha);
      material.depthTest = !!needDepth;
      material.depthWrite = !!needDepth;
      material.transparent = true;
      material.side = 2;
      material.opacity = 1; // material.platecolor = FMUtil.toColor(theme.platecolor);
      // material.platestrokecolor = FMUtil.toColor(theme.platestrokecolor) ;
      // material.fillcolor = FMUtil.toColor(theme.fillcolor);
      // material.strokecolor = FMUtil.toColor(theme.strokecolor);

      if (theme.imageSrc) {
        if (this._data[theme.imageUrl]) {
          var img = this._data[theme.imageUrl];
          var texture = this.excuteLabelTexture(name, img, theme);
          material.map = texture;

          this._textureArray.push(texture);

          material.userData.scaleRatio = material.map.scaleRatio;
          material.userData.mspriteScale = material.map.mspriteScale;
          material.needsUpdate = true;
        } else {
          var _img = new Image();

          var scaler = me.excuteLabelTexture(name, true, theme, true);
          _img.crossOrigin = "Anonymous";
          material.userData.scaleRatio = scaler.scaleRatio;
          material.userData.mspriteScale = scaler.mspriteScale;
          var userAgent = navigator.userAgent;
          var rMsie = /(msie\s|trident.*rv:)([\w.]+)/;
          var match = rMsie.exec(userAgent.toLowerCase()); //判断浏览器是否是ie11

          if (match !== null) {
            _img.onload = new function () {
              var texture = me.excuteLabelTexture(name, _img, theme);
              material.map = texture;

              me._textureArray.push(texture);

              material.needsUpdate = true;
              me._data[theme.imageUrl] = _img; //存起来多次利用
            }();
          } else {
            _img.onload = function () {
              var texture = me.excuteLabelTexture(name, _img, theme);
              material.map = texture;

              me._textureArray.push(texture);

              material.needsUpdate = true;
              me._data[theme.imageUrl] = _img; //存起来多次利用
            };
          }

          _img.src = theme.imageSrc;
        }
      } else {
        var _texture = this.excuteLabelTexture(name, false, theme);

        material.map = _texture;

        this._textureArray.push(_texture);

        material.userData.scaleRatio = material.map.scaleRatio;
        material.userData.mspriteScale = material.map.mspriteScale;
        material.needsUpdate = true;
      }

      return material;
    }
  }, {
    key: "excuteSDFLabelTexture",
    value: function excuteSDFLabelTexture(name, img, theme, getScaleRatio) {
      var scale = 1;
      var textOffset = 1.5 * scale;
      var imageSize = 12 * scale;
      var space = 2 * scale;

      if (!img) {
        imageSize = 0;
        space = 0;
      }

      var lineSpace = 2 * scale;
      var marginTB = 3 * scale;
      var marginLR = 3 * scale;
      var fontsize = 14 * scale;
      var spriteScale = 1;
      var borderThickness = 2 * scale;
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      var style = this.font.family;
      context.font = fontsize + "px" + " " + style;
      var isMultiLine = name.indexOf("%rn%") > -1; //计算canvas宽高

      var w, h, names;

      if (!isMultiLine) {
        var textWidth = context.measureText(name).width;
        w = textWidth + space + imageSize + 2 * marginLR;
        h = Math.max(fontsize, imageSize) + marginTB * 2;
      } else {
        //多行时计算宽高
        names = name.split("%rn%");
        var _textWidth = 0;
        var fontHeight = 0;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator2.default)(names), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var n = _step.value;
            _textWidth = Math.max(context.measureText(n).width, _textWidth);
            fontHeight += fontsize;
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        fontHeight += (names.length - 1) * lineSpace;
        spriteScale = names.length;
        w = _textWidth + space + imageSize + 2 * marginLR;
        h = Math.max(fontHeight, imageSize) + marginTB * 2;
      }

      if (getScaleRatio) {
        return {
          scaleRatio: h / w,
          mspriteScale: spriteScale
        };
      }

      canvas.width = w;
      canvas.height = h;
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";

      if (theme.platecolor || theme.platestrokecolor) {
        var colors = theme.platecolor.split(",");

        if (theme.platecolor) {
          context.fillStyle = "rgb(".concat((0, _parseInt2.default)(colors[0]), ",").concat((0, _parseInt2.default)(colors[1]), ",").concat((0, _parseInt2.default)(colors[2]), ")");
        }

        context.lineWidth = scale;
        this.drawRadiuRect(context, w, h, 5 * scale, {
          x: 0,
          y: 0
        });

        if (theme.platecolor) {
          context.fill();
        }

        if (theme.platestrokecolor) {
          var colors2 = theme.platestrokecolor.split(",");
          context.strokeStyle = "rgb(".concat((0, _parseInt2.default)(colors2[0]), ",").concat((0, _parseInt2.default)(colors2[1]), ",").concat((0, _parseInt2.default)(colors2[2]), ")");
          context.stroke();
        }

        context.beginPath();
      } //图文绘制


      var left = imageSize + space; //图片margin - top

      var imgTop = (h - imageSize) / 2;
      var textTop = (h - fontsize) / 2; //文字绘制

      context.font = fontsize + "px" + " " + style;
      context.textBaseline = 'top';
      context.strokeStyle = _FMUtil.default.toRgba(theme.strokecolor);
      context.lineWidth = borderThickness;
      var offset = 0;
      var isiOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
      var is_iOS = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;

      if (navigator.userAgent.indexOf("Edge") > -1 || isiOS || is_iOS) {
        offset = -4;
      }

      offset *= scale;

      if (!isMultiLine) {
        context.strokeText(name, left, textTop + textOffset + offset);
      } else {
        //多行
        var top = marginTB;

        for (var i = 0; i < names.length; i++) {
          if (i) {
            top += fontsize + lineSpace;
          }

          context.strokeText(names[i], left, top);
        }
      }

      context.fillStyle = _FMUtil.default.toRgba(theme.fillcolor);

      if (!isMultiLine) {
        context.fillText(name, left, textTop + textOffset + offset);
      } else {
        //多行
        var _top = marginTB;

        for (var _i = 0; _i < names.length; _i++) {
          if (_i) {
            _top += fontsize + lineSpace;
          }

          context.fillText(names[_i], left, _top);
        }
      } //图片绘制


      img && context.drawImage(img, 0, imgTop, imageSize, imageSize); //texture
      // document.body.appendChild(canvas);

      var texture = new fm.CanvasTexture(canvas);
      texture.minFilter = fm.LinearFilter;
      texture.generateMipmaps = false;
      texture.scaleRatio = canvas.height / canvas.width;
      texture.mspriteScale = spriteScale;
      return texture;
    }
    /**
     * 创建带图片的文字贴图
     * @param str {string} 文字内容
     * @param theme {Object} 主题数据
     * @param onload {function | undefined}
     * @returns {Texture}
     */

  }, {
    key: "excuteLabelTexture",
    value: function excuteLabelTexture(name, img, theme, getScaleRatio) {
      theme = (0, _assign.default)({}, theme); // theme.platecolor = "180,0,0";
      // theme.platestrokecolor = "255,0,0";
      // theme.fillcolor = "0,0,0";
      // theme.strokecolor = "100,0,0";

      var scale = 2;
      var textOffset = 1.5 * scale;
      var imageSize = theme.fontsize * 1.2 * scale; //12 * scale;

      var space = 2 * scale;

      if (!img) {
        imageSize = 0; //space = 0;

        space = 5 * scale;
      }

      var lineSpace = 2 * scale;
      var marginTB = 3 * scale;
      var marginLR = 3 * scale;
      var fontsize = theme.fontsize * scale * 1.2;
      var spriteScale = 1;
      var borderThickness = 2 * scale;
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      var style = this.font.family;
      context.font = fontsize + "px" + " " + style;
      var isMultiLine = name.indexOf("%rn%") > -1; //计算canvas宽高

      var w, h, names;

      if (!isMultiLine) {
        var textWidth = context.measureText(name).width;
        w = textWidth + space + imageSize + 2 * marginLR;
        h = Math.max(fontsize, imageSize) + marginTB * 2;
      } else {
        //多行时计算宽高
        names = name.split("%rn%");
        var _textWidth2 = 0;
        var fontHeight = 0;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator2.default)(names), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var n = _step2.value;
            _textWidth2 = Math.max(context.measureText(n).width, _textWidth2);
            fontHeight += fontsize;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        fontHeight += (names.length - 1) * lineSpace;
        w = _textWidth2 + space + imageSize + 2 * marginLR;
        h = Math.max(fontHeight, imageSize) + marginTB * 2;
        spriteScale = h / (fontsize + marginTB * 2);
      }

      if (getScaleRatio) {
        return {
          scaleRatio: h / w,
          mspriteScale: spriteScale
        };
      }

      canvas.width = w;
      canvas.height = h;
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";

      if (theme.platecolor || theme.platestrokecolor) {
        //let colors = theme.platecolor.split(",");
        if (theme.platecolor) {
          context.fillStyle = _FMUtil.default.toRgba(theme.platecolor);
        } //`rgb(${parseInt(colors[0])},${parseInt(colors[1])},${parseInt(colors[2])})`;


        context.lineWidth = scale;
        this.drawRadiuRect(context, w - imageSize, h, 5 * scale, {
          x: 0 + imageSize,
          y: 0
        });

        if (theme.platecolor) {
          context.fill();
        }

        if (theme.platestrokecolor) {
          //let colors2 = theme.platestrokecolor.split(",");
          context.strokeStyle = _FMUtil.default.toRgba(theme.platestrokecolor); //`rgb(${parseInt(colors2[0])},${parseInt(colors2[1])},${parseInt(colors2[2])})`;

          context.stroke();
        }

        context.beginPath();
      } //图文绘制


      var left = imageSize + space; //图片margin - top

      var imgTop = (h - imageSize) / 2;
      var textTop = (h - fontsize) / 2; //文字绘制

      context.font = fontsize + "px" + " " + style;
      context.textBaseline = 'top';
      context.lineWidth = borderThickness * (theme.strokewidth ? theme.strokewidth : 1);
      var s_width = 1;

      if (theme.strokewidth) {
        s_width = (0, _parseFloat2.default)(theme.strokewidth);
      } //context.lineWidth = borderThickness * s_width;*/


      var offset = 0;
      var Is360 = false;
      var mimeTypes = navigator.mimeTypes;

      for (var mt in mimeTypes) {
        if (mimeTypes[mt]["type"] == "application/vnd.chromium.remoting-viewer") {
          Is360 = true;
        }
      }

      if (Is360) {
        //offset = -4;
        offset = -4 - (fontsize - 28) / 6;
      }

      var isiOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
      var is_iOS = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;

      if (navigator.userAgent.indexOf("Edge") > -1 || isiOS || is_iOS) {
        //offset = -4;
        offset = -4 - (fontsize - 28) / 6;
      }

      if (navigator.userAgent.indexOf("QQBrowser") > -1 || isiOS || is_iOS) {
        offset = -4 - (fontsize - 28) / 6;
      }

      if (navigator.userAgent.indexOf(".NET4.0C") > -1 || isiOS || is_iOS) {
        offset = -4 - (fontsize - 28) / 6;
      }

      offset *= scale;

      if (theme.strokecolor && s_width !== 0) {
        context.strokeStyle = _FMUtil.default.toRgba(theme.strokecolor);

        if (!isMultiLine) {
          if (!img) {
            if (theme.textAlign == 'left') {
              context.strokeText(name, 0, textTop + textOffset + offset);
            } else if (theme.textAlign == 'right') {
              context.textAlign = 'right';
              context.strokeText(name, w, textTop + textOffset + offset);
            } else {
              context.textAlign = 'center';
              context.strokeText(name, w / 2, textTop + textOffset + offset);
            }
          } else {
            context.strokeText(name, left, textTop + textOffset + offset);
          }
        } else {
          //多行
          var top = marginTB;

          for (var i = 0; i < names.length; i++) {
            if (i) {
              top += fontsize + lineSpace; //(h - fontsize * names.length) / 2 + fontsize * i)?
            }

            if (!img) {
              if (theme.textAlign == 'left') {
                context.textAlign = 'left';
                context.strokeText(names[i], 0, top);
              } else if (theme.textAlign == 'right') {
                context.textAlign = 'right';
                context.strokeText(names[i], w, top);
              } else {
                context.textAlign = 'center';
                context.strokeText(names[i], w / 2, top);
              }
            } else {
              context.strokeText(names[i], left, top);
            }
          }
        }
      }

      context.fillStyle = _FMUtil.default.toRgba(theme.fillcolor);

      if (!isMultiLine) {
        if (!img) {
          if (theme.textAlign == 'left') {
            context.textAlign = 'left';
            context.fillText(name, 0, textTop + textOffset + offset);
          } else if (theme.textAlign == 'right') {
            context.textAlign = 'right';
            context.fillText(name, w, textTop + textOffset + offset);
          } else {
            context.textAlign = 'center';
            context.fillText(name, w / 2, textTop + textOffset + offset);
          }
        } else {
          context.fillText(name, left, textTop + textOffset + offset);
        }
      } else {
        //多行
        var _top2 = marginTB;

        for (var _i2 = 0; _i2 < names.length; _i2++) {
          if (_i2) {
            _top2 += fontsize + lineSpace;
          }

          if (!img) {
            if (theme.textAlign === 'left') {
              context.textAlign = 'left';
              context.fillText(names[_i2], 0, _top2);
            } else if (theme.textAlign === 'right') {
              context.textAlign = 'right';
              context.fillText(names[_i2], w, _top2);
            } else {
              context.textAlign = 'center';
              context.fillText(names[_i2], w / 2, _top2);
            }
          } else {
            context.fillText(names[_i2], left, _top2);
          }
        }
      } //图片绘制


      img && context.drawImage(img, 0, imgTop, imageSize, imageSize); //texture
      // document.body.appendChild(canvas);

      var texture = new fm.CanvasTexture(canvas);
      texture.minFilter = fm.LinearFilter;
      texture.generateMipmaps = false;
      texture.scaleRatio = canvas.height / canvas.width;
      texture.mspriteScale = spriteScale;
      return texture;
    }
    /***
     * 创建文字精灵
     * @param texts
     * @param theme
     * @returns {*}
     */

  }, {
    key: "createTextMaterial",
    value: function createTextMaterial(texts, theme) {
      var material = new fm.SpriteMaterial();
      material.sizeAttenuation = false;
      material.opacity = (0, _parseFloat2.default)(1);
      material.userData.opacity = (0, _parseFloat2.default)(1);
      material.depthTest = false;
      material.depthWrite = false;
      material.transparent = true;
      material.side = 2;
      var texture = this.executeTexTexture(texts, theme);
      material.map = texture;
      material.size = texture.size;
      material.userData.scaleRatio = material.map.scaleRatio;
      material.userData.mspriteScale = material.map.mspriteScale;
      material.needsUpdate = true;
      return material;
    }
  }, {
    key: "executeTexTexture",
    value: function executeTexTexture(texts, theme, img, getScaleRatio) {
      console.log(this.parent);
      var scale = 2;
      var textOffset = 1.5 * scale;
      var imageSize = 12 * scale;
      var space = 2 * scale;

      if (!img) {
        imageSize = 0;
        space = 0;
      }

      var lineSpace = 2 * scale;
      var marginTB = 3 * scale;
      var marginLR = 3 * scale; // let fontsize = theme.fontsize * scale;

      var spriteScale = 1;
      var borderThickness = 2 * scale;
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      var style = this.font.family; // let isMultiLine = name.indexOf("|") > -1;
      //计算canvas宽高

      var w, h, names; //多行时计算宽高
      // names = name.split("|");

      var textWidth = 0;
      var fontHeight = 0;
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = (0, _getIterator2.default)(texts), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var tcontent = _step3.value;

          var _fontsize2 = tcontent.fontsize * scale;

          context.font = _fontsize2 + "px" + " " + style;
          textWidth = Math.max(context.measureText(tcontent.text).width, textWidth);
          fontHeight += _fontsize2;
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      fontHeight += (texts.length - 1) * lineSpace;
      spriteScale = texts.length;
      w = textWidth + space + imageSize + 2 * marginLR;
      h = Math.max(fontHeight, imageSize) + marginTB * 2;

      if (getScaleRatio) {
        return {
          scaleRatio: h / w,
          mspriteScale: spriteScale
        };
      }

      canvas.width = w;
      canvas.height = h;
      canvas.style.width = w + "px";
      canvas.style.height = h + "px";

      if (theme.platecolor) {
        context.fillStyle = _FMUtil.default.toRgba(theme.platecolor);
        context.lineWidth = scale;
        this.drawRadiuRect(context, w, h, 5 * scale, {
          x: 0,
          y: 0
        });
        context.fill();

        if (theme.platestrokecolor) {
          context.strokeStyle = _FMUtil.default.toRgba(theme.platestrokecolor);
          context.stroke();
        }

        context.beginPath();
      } //图文绘制


      var left = imageSize + space; //图片margin - top
      // let imgTop = (h - imageSize ) / 2;
      // let textTop = (h - fontsize ) / 2;
      //文字绘制

      var offset = 4;
      var Is360 = false;
      var mimeTypes = navigator.mimeTypes;

      for (var mt in mimeTypes) {
        if (mimeTypes[mt]["type"] == "application/vnd.chromium.remoting-viewer") {
          Is360 = true;
        }
      }

      var offset_value = -6;
      offset_value = offset_value + 8 * (texts.length - 1);

      if (Is360) {
        //offset = -4;
        offset = offset_value - (fontHeight - 28) / 6;
      }

      var isiOS = !!navigator.userAgent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/);
      var is_iOS = navigator.vendor && navigator.vendor.indexOf('Apple') > -1 && navigator.userAgent && navigator.userAgent.indexOf('CriOS') == -1 && navigator.userAgent.indexOf('FxiOS') == -1;

      if (navigator.userAgent.indexOf("Edge") > -1 || isiOS || is_iOS) {
        //offset = -4;
        offset = offset_value - (fontHeight - 28) / 6;
      }

      if (navigator.userAgent.indexOf("QQBrowser") > -1 || isiOS || is_iOS) {
        offset = offset_value - (fontHeight - 28) / 6;
      }

      if (navigator.userAgent.indexOf(".NET4.0C") > -1 || isiOS || is_iOS) {
        offset = offset_value - (fontHeight - 28) / 6;
      } // offset *= scale;


      context.textBaseline = 'top';
      var top = marginTB; //console.log(749,top);
      //console.log(750,offset);

      for (var i = 0; i < texts.length; i++) {
        if (texts[i].strokecolor) {
          context.lineWidth = borderThickness;
          var fontsize = texts[i].fontsize * scale;
          context.font = fontsize + "px" + " " + style;
          context.strokeStyle = _FMUtil.default.toRgba(texts[i].strokecolor);

          if (i) {
            top += texts[i - 1].fontsize * scale + lineSpace;
          }

          if (theme.textAlign == 0) {
            context.textAlign = 'left';
            context.strokeText(texts[i].text, 0, top + offset);
          } else if (theme.textAlign == 2) {
            context.textAlign = 'right';
            context.strokeText(texts[i].text, w, top + offset);
          } else {
            context.textAlign = 'center';
            context.strokeText(texts[i].text, w / 2, top + offset);
          } // context.strokeText(texts[i].text, left, top);

        }
      }

      top = marginTB;

      for (var _i3 = 0; _i3 < texts.length; _i3++) {
        var _fontsize = texts[_i3].fontsize * scale;

        context.font = _fontsize + "px" + " " + style;
        context.fillStyle = _FMUtil.default.toRgba(texts[_i3].fontcolor);

        if (_i3) {
          top += texts[_i3 - 1].fontsize * scale + lineSpace;
        }

        if (theme.textAlign == 0) {
          context.textAlign = 'left';
          context.fillText(texts[_i3].text, 0, top + offset);
        } else if (theme.textAlign == 2) {
          context.textAlign = 'right';
          context.fillText(texts[_i3].text, w, top + offset);
        } else {
          context.textAlign = 'center';
          context.fillText(texts[_i3].text, w / 2, top + offset);
        } // context.fillText(texts[i].text, left, top);

      } //texture
      // document.body.appendChild(canvas);


      var texture = new fm.CanvasTexture(canvas);
      texture.minFilter = fm.LinearFilter;
      texture.generateMipmaps = false;
      texture.scaleRatio = canvas.height / canvas.width;
      texture.mspriteScale = spriteScale;
      var n = 0;
      var size = null;

      for (var _i4 = 0; _i4 < texts.length; _i4++) {
        n += texts[_i4].fontsize;
      }

      if (texts.length > 1) {
        size = (n + lineSpace * (texts.length - 1) + marginTB) / texts.length;
      } else {
        size = n + marginTB;
      }

      texture.size = size;
      return texture;
    }
    /***
     *
     * @param ctx
     * @param width
     * @param height
     * @param radiu
     * @param start
     * @deprecated
     * @see FMCanvasUtils.drawRadiusRect
     */

  }, {
    key: "drawRadiuRect",
    value: function drawRadiuRect(ctx, width, height, radiu, start) {
      var lefttop = start;
      var righttop = {
        x: start.x + width,
        y: start.y
      };
      var leftdown = {
        x: start.x,
        y: start.y + height
      };
      var rightdown = {
        x: start.x + width,
        y: start.y + height
      };
      var tlf = {
        x: lefttop.x + radiu,
        y: lefttop.y
      };
      var tle = {
        x: righttop.x - radiu,
        y: righttop.y
      };
      var rlf = {
        x: righttop.x,
        y: righttop.y + radiu
      };
      var rle = {
        x: rightdown.x,
        y: rightdown.y - radiu
      };
      var dlf = {
        x: rightdown.x - radiu,
        y: rightdown.y
      };
      var dle = {
        x: leftdown.x + radiu,
        y: leftdown.y
      };
      var llf = {
        x: leftdown.x,
        y: leftdown.y - radiu
      };
      var lle = {
        x: lefttop.x,
        y: lefttop.y + radiu
      };
      ctx.beginPath();
      ctx.moveTo(tlf.x, tlf.y);
      ctx.lineTo(tle.x, tle.y); //topline

      ctx.arcTo(righttop.x, righttop.y, rlf.x, rlf.y, radiu); //tr arc

      ctx.lineTo(rle.x, rle.y); //rightline

      ctx.arcTo(rightdown.x, rightdown.y, dlf.x, dlf.y, radiu); //rd arc

      ctx.lineTo(dle.x, dle.y); //downline

      ctx.arcTo(leftdown.x, leftdown.y, llf.x, llf.y, radiu);
      ctx.lineTo(lle.x, lle.y);
      ctx.arcTo(lefttop.x, lefttop.y, tlf.x, tlf.y, radiu);
      ctx.closePath();
    }
  }, {
    key: "measureText",
    value: function measureText(style, text, pFontSize) {
      var lDiv = document.createElement('div'); // document.body.appendChild(lDiv);

      lDiv.style.fontSize = "" + pFontSize + "px";
      lDiv.style.position = "absolute"; // lDiv.style.visibility  = 'hidden';

      lDiv.style.fontStyle = style;
      lDiv.style.whiteSpace = "nowrap";
      lDiv.innerHTML = text;
      var lResult = {
        width: lDiv.clientWidth,
        height: lDiv.clientHeight
      };
      document.body.removeChild(lDiv); // lDiv = null;

      return lResult;
    }
    /***
     * 加载贴图
     * @param url
     * @param back
     * @returns {Texture|Hi|Fr|Xn|Xn|*}
     */

  }, {
    key: "loadTexture",
    value: function loadTexture(url, back) {
      var _this = this;

      var texture = new fm.Texture();

      if (typeof url !== "string") {
        texture.image = url;
        texture.needsUpdate = true;
        back(texture);
        return texture;
      } // 从内存中拿


      if (url.substring(0, 4) !== "data" && this._textureData[url]) {
        back(this._textureData[url]);
      }

      var img = new Image();
      img.crossOrigin = "Anonymous";

      this._textureArray.push(texture);

      img.onload = function () {
        texture.image = img;

        if (url.substring(0, 4) !== "data") {
          _this._textureData[url] = texture; //存起来多次利用
        }

        texture.needsUpdate = true;
        back(texture);
      }; // + Math.random()


      img.src = url;
      return texture;
    }
  }, {
    key: "getHeatMapGradient",
    value: function getHeatMapGradient(colorMap) {
      var can = document.createElement('canvas');
      var ctx = can.getContext('2d');
      var w = 8;
      var h = 128;
      can.width = w;
      can.height = h;
      can.style.width = w + "px";
      can.style.height = h + "px";
      var grad = ctx.createLinearGradient(0, 0, 8, 128);

      for (var x in colorMap) {
        grad.addColorStop(x, colorMap[x]);
      }

      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 8, 128); // document.body.appendChild(can);

      var texture = new fm.CanvasTexture(can);

      this._textureArray.push(texture);

      return texture;
    }
  }, {
    key: "createNormalLineTexture",
    value: function createNormalLineTexture(param) {
      var can = document.createElement('canvas');
      var ctx = can.getContext('2d');
      var w = param.width;
      var h = param.height;
      can.width = w;
      can.height = h;
      can.style.width = w + "px";
      can.style.height = h + "px";
      var x = 0;
      var dashArray = param.dashArray;
      var all = dashArray.reduce(function (p, n) {
        return p + n;
      });
      var matix1 = new fm.Matrix3();
      matix1.set(Math.cos(Math.PI / 2), -Math.sin(Math.PI / 2), +w / 2, Math.sin(Math.PI / 2), Math.cos(Math.PI / 2), +h / 2, 0, 0, 1);
      console.log(matix1);
      var matix2 = new fm.Matrix3();
      matix2.set(1, 0, -w / 2, 0, 1, -h / 2, 0, 0, 1);
      matix1.multiply(matix2);
      var te = matix1.elements;
      ctx.transform(te[0], te[3], te[1], te[4], te[2], te[6]);
      dashArray.forEach(function (i, index) {
        if (index % 2 == 0) {
          ctx.fillStyle = param.color;
          ctx.fillRect(x / all * param.width, 0, i / all * param.width, param.height);
        }

        x += i;
      }); // document.body.appendChild(can);

      var texture = new fm.CanvasTexture(can);
      return texture;
    }
  }, {
    key: "createArrowLineTexture",
    value: function createArrowLineTexture(param) {
      var s = param;
      var can = document.createElement('canvas');
      var ctx = can.getContext('2d');
      var w = param.width;
      var h = param.height;
      can.width = w;
      can.height = h;
      can.style.width = w + "px";
      can.style.height = h + "px";
      var sy = (1 - s.arrowHeightPercent) * s.height / 2;
      var hp = s.height * s.arrowHeightPercent;
      var matix1 = new fm.Matrix3();
      matix1.set(Math.cos(Math.PI / 2), -Math.sin(Math.PI / 2), +w / 2, Math.sin(Math.PI / 2), Math.cos(Math.PI / 2), +h / 2, 0, 0, 1);
      console.log(matix1);
      var matix2 = new fm.Matrix3();
      matix2.set(1, 0, -w / 2, 0, 1, -h / 2, 0, 0, 1);
      matix1.multiply(matix2);
      var te = matix1.elements;
      ctx.transform(te[0], te[3], te[1], te[4], te[2], te[6]);
      ctx.beginPath();
      ctx.moveTo(0, sy);

      var _p = s.width * (s.arrowWidthPercent - s.arrowPercent);

      ctx.lineTo(_p, sy);
      ctx.lineTo(s.width * s.arrowWidthPercent, sy + hp / 2);
      ctx.lineTo(_p, sy + hp);
      ctx.lineTo(0, sy + hp);
      ctx.lineTo(s.width * s.arrowPercent, sy + hp / 2);
      ctx.closePath();
      ctx.fillStyle = s.color;
      ctx.fill(); // document.body.appendChild(can);

      var texture = new fm.CanvasTexture(can);
      return texture;
    }
  }, {
    key: "createArrowWidthBackTexture",
    value: function createArrowWidthBackTexture(param) {
      var s = param;
      var can = document.createElement('canvas');
      var ctx = can.getContext('2d');
      var w = param.width;
      var h = param.height;
      can.width = w;
      can.height = h;
      can.style.width = w + "px";
      can.style.height = h + "px";
      ctx.fillStyle = s.godEdgeColor;
      ctx.fillRect(0, 0, s.width, s.height); // // ctx.ra

      var lwidth = s.width * (1 - s.godEdgePercent); // draw god rect

      ctx.fillStyle = s.godColor;
      ctx.fillRect((s.width - lwidth) / 2, 0, lwidth, s.height); // draw arrow

      ctx.fillStyle = '#ffffff';
      ctx.shadowOffsetX = -2;
      ctx.shadowOffsetY = 2;
      ctx.shadowBlur = 4;
      ctx.shadowColor = "rgba(0,0,0,0.5)";
      var center = {
        x: s.width / 2,
        y: s.height / 2
      };
      var ah = s.height * s.godArrowPercent;
      var aw = lwidth * s.godArrowWidthPercent;
      var aadd = s.arrawWidth || 10;
      var a_startX = center.x - aw / 2;
      var a_startY = center.y + ah / 2;
      ctx.beginPath();
      ctx.moveTo(a_startX, a_startY);
      ctx.lineTo(a_startX, a_startY + aadd);
      ctx.lineTo(a_startX + aw / 2, a_startY - ah + aadd);
      ctx.lineTo(a_startX + aw, a_startY + aadd);
      ctx.lineTo(a_startX + aw, a_startY);
      ctx.lineTo(a_startX + aw / 2, a_startY - ah);
      ctx.closePath();
      ctx.fillStyle = s.godArrowColor;
      ctx.fill(); // document.body.appendChild(can);z

      var texture = new fm.CanvasTexture(can);
      return texture;
    }
  }, {
    key: "rotateCanvas",
    value: function rotateCanvas(canvas, angle, w, h) {
      var can = document.createElement('canvas');
      var ctx = can.getContext('2d');
      can.width = w;
      can.height = h;
      can.style.width = w + "px";
      can.style.height = h + "px";
      ctx.drawImage(canvas, 0, 0, w, h);
    } //释放

  }, {
    key: "dispose",
    value: function dispose() {
      var _iteratorNormalCompletion4 = true;
      var _didIteratorError4 = false;
      var _iteratorError4 = undefined;

      try {
        for (var _iterator4 = (0, _getIterator2.default)(this._textureArray), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
          var texture = _step4.value;
          texture.dispose();
        }
      } catch (err) {
        _didIteratorError4 = true;
        _iteratorError4 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
            _iterator4.return();
          }
        } finally {
          if (_didIteratorError4) {
            throw _iteratorError4;
          }
        }
      }

      this._textureArray.length = 0;

      for (var t in this._textureData) {
        this._textureData[t] = undefined;
      }

      for (var img in this.data) {
        this._data[img] = undefined;
      }

      for (var lm in this.extrudeMaterial) {
        this.extrudeMaterial[lm].dispose();
      }
    }
  }, {
    key: "getExtrudeMaterial",

    /**
     * 获取材质
     * @param color {string} 颜色
     * @param alpha {number} 透明度
     * @returns {*}
     */
    value: function getExtrudeMaterial(color, alpha) {
      if (this.extrudeMaterial[color + alpha]) {
        return this.extrudeMaterial[color + alpha];
      } else {
        var material = new fm.RawShaderMaterial({
          uniforms: {
            "color": {
              value: new fm.Color(color)
            },
            "alpha": {
              value: alpha
            }
          },
          vertexShader: _RawExtrudeVertShader.RawExtrudeVertShader,
          fragmentShader: _RawExtrudeFragShader.RawExtrudeFragShader
        });
        material.transparent = true;
        this.extrudeMaterial[color + alpha] = material;
        return material;
      }
    }
  }, {
    key: "data",
    get: function get() {
      return this._data;
    },
    set: function set(d) {
      this._data = d;
    }
  }, {
    key: "textureData",
    get: function get() {
      return this._textureData;
    },
    set: function set(d) {
      this._textureData = d;
    }
  }, {
    key: "textureArray",
    get: function get() {
      return this._textureArray;
    },
    set: function set(t) {
      this._textureArray = t;
    }
  }]);
  return MaterialManager;
}();

var _default = MaterialManager;
exports.default = _default;

/***/ }),
/* 395 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// B.2.3.7 String.prototype.fontcolor(color)
__webpack_require__(105)('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});


/***/ }),
/* 396 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.RawExtrudeVertShader = void 0;

/**
 * @author Mif /  Made on September 25, 2020/
 */
var RawExtrudeVertShader = "\nprecision mediump float;\nprecision mediump int;\n\nattribute vec3 position;\n\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n ";
exports.RawExtrudeVertShader = RawExtrudeVertShader;

/***/ }),
/* 397 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.RawExtrudeFragShader = void 0;

/**
 * @author Mif /  Made on September 25, 2020/
 */
var RawExtrudeFragShader = "\nprecision mediump float;\nprecision mediump int;\n\nuniform vec3 color;\nuniform float alpha;\n\nvoid main() {\n    gl_FragColor = vec4(color,alpha);\n}\n ";
exports.RawExtrudeFragShader = RawExtrudeFragShader;

/***/ }),
/* 398 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _compassShader = _interopRequireDefault(__webpack_require__(399));

/***
 * @class CompassMaterial 指南针材质
 */
var CompassMaterial =
/*#__PURE__*/
function (_fm$ShaderMaterial) {
  (0, _inherits2.default)(CompassMaterial, _fm$ShaderMaterial);

  /***
   * @constructor
   */
  function CompassMaterial() {
    var _this;

    (0, _classCallCheck2.default)(this, CompassMaterial);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CompassMaterial).call(this, {
      uniforms: {
        diffuse: {
          value: new fm.Vector3(1, 1, 1)
        },
        offset: {
          value: new fm.Vector2()
        },
        rotation: {
          value: 0
        },
        scale: {
          value: 1
        }
      },
      vertexShader: _compassShader.default.vert,
      fragmentShader: _compassShader.default.frag
    }));
    _this.depthTest = false;
    return _this;
  }

  return CompassMaterial;
}(fm.ShaderMaterial);

var _default = CompassMaterial;
exports.default = _default;

/***/ }),
/* 399 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var compassShader = {};
compassShader.vert = "     \nuniform vec2 offset;    // \u4F4D\u7F6E\u504F\u79FB\nuniform float rotation; // \u7528\u5F27\u5EA6\u8868\u793A\u7684\u5F53\u524D\u6C34\u5E73\u65CB\u8F6C\u89D2\u5EA6\nuniform float scale;    // \u7F29\u653E\n\nvarying vec2 vUv;\n\nvoid main() {\n\n  vUv = uv;\n  vec2 rotatedPosition;\n  rotatedPosition.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\n  rotatedPosition.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n\n  rotatedPosition.x *= scale * abs(projectionMatrix[0][0] / projectionMatrix[1][1]);\n  rotatedPosition.y *= scale;\n  \n  rotatedPosition.xy += offset;\n  gl_Position = vec4(rotatedPosition,0.0,1.0);\n}\n";
compassShader.frag = "\n\nuniform vec3 diffuse;\nuniform sampler2D mapBack;\nuniform sampler2D mapfront;\n\n#include <common>\n\nvarying vec2 vUv;\n\nvoid main() {\n    vec4 diffuseColor = vec4( diffuse, 1.0 );\n    diffuseColor = texture2D( mapfront, vUv );\n   \n    vec4 backColor = vec4(1.0 , 0.0 ,0.0 ,1.0);\n    backColor = texture2D( mapBack, vUv );\n\n    float alphacomp = backColor.a + diffuseColor.a * (1.0 - backColor.a);\n    vec3 resultColor = diffuseColor.rgb *  diffuseColor.a + backColor.rgb * (1.0 - diffuseColor.a);\n    gl_FragColor = vec4(resultColor , alphacomp);\n}\n";
var _default = compassShader;
exports.default = _default;

/***/ }),
/* 400 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

__webpack_require__(13);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _JSONLoader = _interopRequireDefault(__webpack_require__(401));

var _GLTFLoader = _interopRequireDefault(__webpack_require__(229));

var _NetArea = _interopRequireDefault(__webpack_require__(108));

var FMExternalLoader =
/*#__PURE__*/
function () {
  function FMExternalLoader(path, isRemote, key) {
    (0, _classCallCheck2.default)(this, FMExternalLoader);
    this.preLoadModels = {};
    this.waitingBacks = {};
    this.waitingNodes = [];
    this._path = path;
    this.isRemote = isRemote;
    this.key = key;
    this.externalLoadingCount = 0;
  }

  (0, _createClass2.default)(FMExternalLoader, [{
    key: "load",
    value: function load(normalId) {
      var _this = this;

      this.externalLoadingCount++;
      var loader;
      var url, lpath;

      if (this.isRemote) {
        lpath = _NetArea.default + "webmodel/";
      } else {
        lpath = this._path;
      }

      var urls = this.preLoadModels[normalId].modelUrl.split('.');

      if (urls[1] === "js") {
        loader = new _JSONLoader.default();
        url = urls[0] + ".js" + "?keyValue=" + this.key;
      } else if (urls[1] === "gltf") {
        loader = new _GLTFLoader.default();
        url = urls[0] + ".gltf" + "?keyValue=" + this.key;
      } else {
        loader = new _GLTFLoader.default();
        url = urls[0] + ".glb" + "?keyValue=" + this.key;
      }

      if (this.isRemote) {
        url = urls[0] + "/" + url;
      }

      loader.setPath(lpath);
      this.preLoadModels[normalId].isLoading = true;
      loader.load(url, function (geometry, material) {
        // console.log(this,this.externalLoadingCount);
        for (var fid in _this.waitingBacks[normalId]) {
          var back = _this.waitingBacks[normalId][fid];
          back(geometry, material, urls[1]);
        }

        _this.externalLoadingCount--;

        if (_this.externalLoadingCount < 1) {
          _this.loaded && _this.loaded();
        }

        _this.preLoadModels[normalId].isGltf = urls[1] !== "js";
        _this.preLoadModels[normalId]["geometry"] = geometry;
        _this.preLoadModels[normalId]["material"] = material;
        _this.waitingBacks[normalId].length = 0;
        _this.preLoadModels[normalId].isLoading = false;
        _this.preLoadModels[normalId].loaded = true;
      }, function (xhr) {// console.log(xhr);
        // console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
      }, function (e) {
        console.error(e);
        _this.externalLoadingCount--;

        if (_this.externalLoadingCount < 1) {
          _this.loaded && _this.loaded();
        }

        _this.preLoadModels[normalId].isLoading = false;
      });
    }
  }, {
    key: "addWaitingBacks",
    value: function addWaitingBacks(normalId, back, fid) {
      if (!this.waitingBacks[normalId]) {
        this.waitingBacks[normalId] = {};
      }

      if (!this.waitingBacks[normalId][fid]) {
        this.waitingBacks[normalId][fid] = back;
      }
    }
  }, {
    key: "setLoadedBack",
    value: function setLoadedBack(back) {
      this.loaded = back;
    }
  }, {
    key: "checkAndLoadwaiting",
    value: function checkAndLoadwaiting() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this.waitingNodes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }]);
  return FMExternalLoader;
}();

var _default = FMExternalLoader;
exports.default = _default;

/***/ }),
/* 401 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _assign = _interopRequireDefault(__webpack_require__(11));

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
function LegacyJSONLoader(manager) {
  if (typeof manager === 'boolean') {
    console.warn('fm.JSONLoader: showStatus parameter has been removed from constructor.');
    manager = undefined;
  }

  this.manager = manager !== undefined ? manager : fm.DefaultLoadingManager;
  this.withCredentials = false;
}

(0, _assign.default)(LegacyJSONLoader.prototype, {
  crossOrigin: 'anonymous',
  load: function load(url, onLoad, onProgress, onError) {
    var scope = this;
    var path = this.path === undefined ? fm.LoaderUtils.extractUrlBase(url) : this.path;
    this.resourcePath = path + "maps/";
    var loader = new fm.FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function (text) {
      var json = JSON.parse(text);
      var metadata = json.metadata;

      if (metadata !== undefined) {
        var type = metadata.type;

        if (type !== undefined) {
          if (type.toLowerCase() === 'object') {
            console.error('fm.JSONLoader: ' + url + ' should be loaded with fm.ObjectLoader instead.');
            return;
          }
        }
      }

      var object = scope.parse(json, path);
      onLoad(object.geometry, object.materials);
    }, onProgress, onError);
  },
  setPath: function setPath(value) {
    this.path = value;
    return this;
  },
  setResourcePath: function setResourcePath(value) {
    this.resourcePath = value;
    return this;
  },
  setCrossOrigin: function setCrossOrigin(value) {
    this.crossOrigin = value;
    return this;
  },
  parse: function () {
    function parseModel(json, geometry) {
      function isBitSet(value, position) {
        return value & 1 << position;
      }

      var i,
          j,
          fi,
          offset,
          zLength,
          colorIndex,
          normalIndex,
          uvIndex,
          materialIndex,
          type,
          isQuad,
          hasMaterial,
          hasFaceVertexUv,
          hasFaceNormal,
          hasFaceVertexNormal,
          hasFaceColor,
          hasFaceVertexColor,
          vertex,
          face,
          faceA,
          faceB,
          hex,
          normal,
          uvLayer,
          uv,
          u,
          v,
          faces = json.faces,
          vertices = json.vertices,
          normals = json.normals,
          colors = json.colors,
          scale = json.scale,
          nUvLayers = 0;

      if (json.uvs !== undefined) {
        // disregard empty arrays
        for (i = 0; i < json.uvs.length; i++) {
          if (json.uvs[i].length) nUvLayers++;
        }

        for (i = 0; i < nUvLayers; i++) {
          geometry.faceVertexUvs[i] = [];
        }
      }

      offset = 0;
      zLength = vertices.length;

      while (offset < zLength) {
        vertex = new fm.Vector3();
        vertex.x = vertices[offset++] * scale;
        vertex.y = vertices[offset++] * scale;
        vertex.z = vertices[offset++] * scale;
        geometry.vertices.push(vertex);
      }

      offset = 0;
      zLength = faces.length;

      while (offset < zLength) {
        type = faces[offset++];
        isQuad = isBitSet(type, 0);
        hasMaterial = isBitSet(type, 1);
        hasFaceVertexUv = isBitSet(type, 3);
        hasFaceNormal = isBitSet(type, 4);
        hasFaceVertexNormal = isBitSet(type, 5);
        hasFaceColor = isBitSet(type, 6);
        hasFaceVertexColor = isBitSet(type, 7); // console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

        if (isQuad) {
          faceA = new fm.Face3();
          faceA.a = faces[offset];
          faceA.b = faces[offset + 1];
          faceA.c = faces[offset + 3];
          faceB = new fm.Face3();
          faceB.a = faces[offset + 1];
          faceB.b = faces[offset + 2];
          faceB.c = faces[offset + 3];
          offset += 4;

          if (hasMaterial) {
            materialIndex = faces[offset++];
            faceA.materialIndex = materialIndex;
            faceB.materialIndex = materialIndex;
          } // to get face <=> uv index correspondence


          fi = geometry.faces.length;

          if (hasFaceVertexUv) {
            for (i = 0; i < nUvLayers; i++) {
              uvLayer = json.uvs[i];
              geometry.faceVertexUvs[i][fi] = [];
              geometry.faceVertexUvs[i][fi + 1] = [];

              for (j = 0; j < 4; j++) {
                uvIndex = faces[offset++];
                u = uvLayer[uvIndex * 2];
                v = uvLayer[uvIndex * 2 + 1];
                uv = new fm.Vector2(u, v);
                if (j !== 2) geometry.faceVertexUvs[i][fi].push(uv);
                if (j !== 0) geometry.faceVertexUvs[i][fi + 1].push(uv);
              }
            }
          }

          if (hasFaceNormal) {
            normalIndex = faces[offset++] * 3;
            faceA.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
            faceB.normal.copy(faceA.normal);
          }

          if (hasFaceVertexNormal) {
            for (i = 0; i < 4; i++) {
              normalIndex = faces[offset++] * 3;
              normal = new fm.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              if (i !== 2) faceA.vertexNormals.push(normal);
              if (i !== 0) faceB.vertexNormals.push(normal);
            }
          }

          if (hasFaceColor) {
            colorIndex = faces[offset++];
            hex = colors[colorIndex];
            faceA.color.setHex(hex);
            faceB.color.setHex(hex);
          }

          if (hasFaceVertexColor) {
            for (i = 0; i < 4; i++) {
              colorIndex = faces[offset++];
              hex = colors[colorIndex];
              if (i !== 2) faceA.vertexColors.push(new fm.Color(hex));
              if (i !== 0) faceB.vertexColors.push(new fm.Color(hex));
            }
          }

          geometry.faces.push(faceA);
          geometry.faces.push(faceB);
        } else {
          face = new fm.Face3();
          face.a = faces[offset++];
          face.b = faces[offset++];
          face.c = faces[offset++];

          if (hasMaterial) {
            materialIndex = faces[offset++];
            face.materialIndex = materialIndex;
          } // to get face <=> uv index correspondence


          fi = geometry.faces.length;

          if (hasFaceVertexUv) {
            for (i = 0; i < nUvLayers; i++) {
              uvLayer = json.uvs[i];
              geometry.faceVertexUvs[i][fi] = [];

              for (j = 0; j < 3; j++) {
                uvIndex = faces[offset++];
                u = uvLayer[uvIndex * 2];
                v = uvLayer[uvIndex * 2 + 1];
                uv = new fm.Vector2(u, v);
                geometry.faceVertexUvs[i][fi].push(uv);
              }
            }
          }

          if (hasFaceNormal) {
            normalIndex = faces[offset++] * 3;
            face.normal.set(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
          }

          if (hasFaceVertexNormal) {
            for (i = 0; i < 3; i++) {
              normalIndex = faces[offset++] * 3;
              normal = new fm.Vector3(normals[normalIndex++], normals[normalIndex++], normals[normalIndex]);
              face.vertexNormals.push(normal);
            }
          }

          if (hasFaceColor) {
            colorIndex = faces[offset++];
            face.color.setHex(colors[colorIndex]);
          }

          if (hasFaceVertexColor) {
            for (i = 0; i < 3; i++) {
              colorIndex = faces[offset++];
              face.vertexColors.push(new fm.Color(colors[colorIndex]));
            }
          }

          geometry.faces.push(face);
        }
      }
    }

    function parseSkin(json, geometry) {
      var influencesPerVertex = json.influencesPerVertex !== undefined ? json.influencesPerVertex : 2;

      if (json.skinWeights) {
        for (var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex) {
          var x = json.skinWeights[i];
          var y = influencesPerVertex > 1 ? json.skinWeights[i + 1] : 0;
          var z = influencesPerVertex > 2 ? json.skinWeights[i + 2] : 0;
          var w = influencesPerVertex > 3 ? json.skinWeights[i + 3] : 0;
          geometry.skinWeights.push(new fm.Vector4(x, y, z, w));
        }
      }

      if (json.skinIndices) {
        for (var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex) {
          var a = json.skinIndices[i];
          var b = influencesPerVertex > 1 ? json.skinIndices[i + 1] : 0;
          var c = influencesPerVertex > 2 ? json.skinIndices[i + 2] : 0;
          var d = influencesPerVertex > 3 ? json.skinIndices[i + 3] : 0;
          geometry.skinIndices.push(new fm.Vector4(a, b, c, d));
        }
      }

      geometry.bones = json.bones;

      if (geometry.bones && geometry.bones.length > 0 && (geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length)) {
        console.warn('When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' + geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.');
      }
    }

    function parseMorphing(json, geometry) {
      var scale = json.scale;

      if (json.morphTargets !== undefined) {
        for (var i = 0, l = json.morphTargets.length; i < l; i++) {
          geometry.morphTargets[i] = {};
          geometry.morphTargets[i].name = json.morphTargets[i].name;
          geometry.morphTargets[i].vertices = [];
          var dstVertices = geometry.morphTargets[i].vertices;
          var srcVertices = json.morphTargets[i].vertices;

          for (var v = 0, vl = srcVertices.length; v < vl; v += 3) {
            var vertex = new fm.Vector3();
            vertex.x = srcVertices[v] * scale;
            vertex.y = srcVertices[v + 1] * scale;
            vertex.z = srcVertices[v + 2] * scale;
            dstVertices.push(vertex);
          }
        }
      }

      if (json.morphColors !== undefined && json.morphColors.length > 0) {
        console.warn('fm.JSONLoader: "morphColors" no longer supported. Using them as face colors.');
        var faces = geometry.faces;
        var morphColors = json.morphColors[0].colors;

        for (var i = 0, l = faces.length; i < l; i++) {
          faces[i].color.fromArray(morphColors, i * 3);
        }
      }
    }

    function parseAnimations(json, geometry) {
      var outputAnimations = []; // parse old style Bone/Hierarchy animations

      var animations = [];

      if (json.animation !== undefined) {
        animations.push(json.animation);
      }

      if (json.animations !== undefined) {
        if (json.animations.length) {
          animations = animations.concat(json.animations);
        } else {
          animations.push(json.animations);
        }
      }

      for (var i = 0; i < animations.length; i++) {
        var clip = fm.AnimationClip.parseAnimation(animations[i], geometry.bones);
        if (clip) outputAnimations.push(clip);
      } // parse implicit morph animations


      if (geometry.morphTargets) {
        // TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
        var morphAnimationClips = fm.AnimationClip.CreateClipsFromMorphTargetSequences(geometry.morphTargets, 10);
        outputAnimations = outputAnimations.concat(morphAnimationClips);
      }

      if (outputAnimations.length > 0) geometry.animations = outputAnimations;
    }

    return function parse(json, path) {
      if (json.data !== undefined) {
        // Geometry 4.0 spec
        json = json.data;
      }

      if (json.scale !== undefined) {
        json.scale = 1.0 / json.scale;
      } else {
        json.scale = 1.0;
      }

      var geometry = new fm.Geometry();
      parseModel(json, geometry);
      parseSkin(json, geometry);
      parseMorphing(json, geometry);
      parseAnimations(json, geometry);
      geometry.computeFaceNormals();
      geometry.computeBoundingSphere();

      if (json.materials === undefined || json.materials.length === 0) {
        return {
          geometry: geometry
        };
      } else {
        var materials = fm.Loader.prototype.initMaterials(json.materials, this.resourcePath || path, this.crossOrigin);
        return {
          geometry: geometry,
          materials: materials
        };
      }
    };
  }()
});
var _default = LegacyJSONLoader;
exports.default = _default;

/***/ }),
/* 402 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $at = __webpack_require__(187)(true);

// 21.1.3.27 String.prototype[@@iterator]()
__webpack_require__(176)(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});


/***/ }),
/* 403 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(404);

/***/ }),
/* 404 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(100);
__webpack_require__(59);
__webpack_require__(65);
__webpack_require__(405);
__webpack_require__(409);
__webpack_require__(410);
module.exports = __webpack_require__(9).Promise;


/***/ }),
/* 405 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var LIBRARY = __webpack_require__(75);
var global = __webpack_require__(14);
var ctx = __webpack_require__(36);
var classof = __webpack_require__(94);
var $export = __webpack_require__(10);
var isObject = __webpack_require__(17);
var aFunction = __webpack_require__(70);
var anInstance = __webpack_require__(102);
var forOf = __webpack_require__(66);
var speciesConstructor = __webpack_require__(230);
var task = __webpack_require__(231).set;
var microtask = __webpack_require__(407)();
var newPromiseCapabilityModule = __webpack_require__(151);
var perform = __webpack_require__(232);
var userAgent = __webpack_require__(408);
var promiseResolve = __webpack_require__(233);
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[__webpack_require__(19)('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function')
      && promise.then(empty) instanceof FakePromise
      // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
      // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
      // we can't detect it synchronously, so just check versions
      && v8.indexOf('6.6') !== 0
      && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // may throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = __webpack_require__(101)($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
__webpack_require__(78)($Promise, PROMISE);
__webpack_require__(182)(PROMISE);
Wrapper = __webpack_require__(9)[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(173)(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});


/***/ }),
/* 406 */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};


/***/ }),
/* 407 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(14);
var macrotask = __webpack_require__(231).set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(77)(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};


/***/ }),
/* 408 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(14);
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';


/***/ }),
/* 409 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally

var $export = __webpack_require__(10);
var core = __webpack_require__(9);
var global = __webpack_require__(14);
var speciesConstructor = __webpack_require__(230);
var promiseResolve = __webpack_require__(233);

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });


/***/ }),
/* 410 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// https://github.com/tc39/proposal-promise-try
var $export = __webpack_require__(10);
var newPromiseCapability = __webpack_require__(151);
var perform = __webpack_require__(232);

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });


/***/ }),
/* 411 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _GLTFLoader = _interopRequireDefault(__webpack_require__(229));

var FMDynamicLoader =
/*#__PURE__*/
function () {
  function FMDynamicLoader() {
    (0, _classCallCheck2.default)(this, FMDynamicLoader);
    this.dynamicModel = {};
    this.loader = new _GLTFLoader.default();
  }

  (0, _createClass2.default)(FMDynamicLoader, [{
    key: "load",
    value: function load(url, success, fail) {
      var _this = this;

      if (this.dynamicModel[url]) {
        if (this.dynamicModel[url].loadComplete == false) {
          this.dynamicModel[url].scbs.push(success);
          this.dynamicModel[url].fcbs.push(fail);
        } else {
          if (this.dynamicModel[url].error) {
            if (fail) {
              fail(this.dynamicModel[url].error); //copy
            }
          } else {
            if (success) {
              // success(this.dynamicModel[url].gltf);//copy
              this.loader.parse(this.dynamicModel[url].data, fm.LoaderUtils.extractUrlBase(url), function (gltf) {
                success(gltf); // scope.manager.itemEnd( url );
              }, function () {});
            }
          }
        }

        return;
      } else {
        this.dynamicModel[url] = {
          'gltf': null,
          'loadComplete': false,
          'error': null,
          'scbs': [],
          'fcbs': []
        };
        this.dynamicModel[url].scbs.push(success);
        this.dynamicModel[url].fcbs.push(fail);
      }

      this.loader.load(url, function (gltf, data) {
        // console.log(url);
        _this.dynamicModel[url].gltf = gltf;
        _this.dynamicModel[url]['data'] = data;
        _this.dynamicModel[url].loadComplete = true;
        var scbs = _this.dynamicModel[url].scbs;

        for (var i = 0; i < scbs.length; i++) {
          if (scbs[i]) {
            scbs[i](gltf);
          }
        }
      }, undefined, function (e) {
        _this.dynamicModel[url].error = e;
        _this.dynamicModel[url].loadComplete = true;
        var fcbs = _this.dynamicModel[url].fcbs;

        for (var i = 0; i < fcbs.length; i++) {
          if (fcbs[i]) {
            fcbs[i](e);
          }
        }
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.dynamicModel = {};
      this.loader = null;
    }
  }]);
  return FMDynamicLoader;
}();

var _default = FMDynamicLoader;
exports.default = _default;

/***/ }),
/* 412 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.vertexShader = void 0;
var vertexShader = "\n varying vec4 v_position;\n//  varying vec3 vReflect;\n uniform mat4 relativeModelMatrix;\n//  uniform vec3 cameraPosition2;\n\n #define STANDARD\n varying vec3 vViewPosition;\n #ifndef FLAT_SHADED\n \tvarying vec3 vNormal;\n \t#ifdef USE_TANGENT\n \t\tvarying vec3 vTangent;\n \t\tvarying vec3 vBitangent;\n \t#endif\n #endif\n #define PI 3.14159265359\n #define PI2 6.28318530718\n #define PI_HALF 1.5707963267949\n #define RECIPROCAL_PI 0.31830988618\n #define RECIPROCAL_PI2 0.15915494\n #define LOG2 1.442695\n #define EPSILON 1e-6\n #ifndef saturate\n #define saturate(a) clamp( a, 0.0, 1.0 )\n #endif\n #define whiteComplement(a) ( 1.0 - saturate( a ) )\n float pow2( const in float x ) { return x*x; }\n float pow3( const in float x ) { return x*x*x; }\n float pow4( const in float x ) { float x2 = x*x; return x2*x2; }\n float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n highp float rand( const in vec2 uv ) {\n \tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n \thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n \treturn fract(sin(sn) * c);\n }\n #ifdef HIGH_PRECISION\n \tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n #else\n \tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n \tfloat precisionSafeLength( vec3 v ) {\n \t\tfloat maxComponent = max3( abs( v ) );\n \t\treturn length( v / maxComponent ) * maxComponent;\n \t}\n #endif\n struct IncidentLight {\n \tvec3 color;\n \tvec3 direction;\n \tbool visible;\n };\n struct ReflectedLight {\n \tvec3 directDiffuse;\n \tvec3 directSpecular;\n \tvec3 indirectDiffuse;\n \tvec3 indirectSpecular;\n };\n struct GeometricContext {\n \tvec3 position;\n \tvec3 normal;\n \tvec3 viewDir;\n #ifdef CLEARCOAT\n \tvec3 clearcoatNormal;\n #endif\n };\n vec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n \treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n }\n vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n \treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n }\n vec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n \tfloat distance = dot( planeNormal, point - pointOnPlane );\n \treturn - distance * planeNormal + point;\n }\n float sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n \treturn sign( dot( point - pointOnPlane, planeNormal ) );\n }\n vec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n \treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n }\n mat3 transposeMat3( const in mat3 m ) {\n \tmat3 tmp;\n \ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n \ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n \ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n \treturn tmp;\n }\n float linearToRelativeLuminance( const in vec3 color ) {\n \tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n \treturn dot( weights, color.rgb );\n }\n bool isPerspectiveMatrix( mat4 m ) {\n   return m[ 2 ][ 3 ] == - 1.0;\n }\n #ifdef USE_UV\n \t#ifdef UVS_VERTEX_ONLY\n \t\tvec2 vUv;\n \t#else\n \t\tvarying vec2 vUv;\n \t#endif\n \tuniform mat3 uvTransform;\n #endif\n #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n \tattribute vec2 uv2;\n \tvarying vec2 vUv2;\n \tuniform mat3 uv2Transform;\n #endif\n #ifdef USE_DISPLACEMENTMAP\n \tuniform sampler2D displacementMap;\n \tuniform float displacementScale;\n \tuniform float displacementBias;\n #endif\n #ifdef USE_COLOR\n \tvarying vec3 vColor;\n #endif\n #ifdef USE_FOG\n \tvarying float fogDepth;\n #endif\n #ifdef USE_MORPHTARGETS\n \tuniform float morphTargetBaseInfluence;\n \t#ifndef USE_MORPHNORMALS\n \tuniform float morphTargetInfluences[ 8 ];\n \t#else\n \tuniform float morphTargetInfluences[ 4 ];\n \t#endif\n #endif\n #ifdef USE_SKINNING\n \tuniform mat4 bindMatrix;\n \tuniform mat4 bindMatrixInverse;\n \t#ifdef BONE_TEXTURE\n \t\tuniform highp sampler2D boneTexture;\n \t\tuniform int boneTextureSize;\n \t\tmat4 getBoneMatrix( const in float i ) {\n \t\t\tfloat j = i * 4.0;\n \t\t\tfloat x = mod( j, float( boneTextureSize ) );\n \t\t\tfloat y = floor( j / float( boneTextureSize ) );\n \t\t\tfloat dx = 1.0 / float( boneTextureSize );\n \t\t\tfloat dy = 1.0 / float( boneTextureSize );\n \t\t\ty = dy * ( y + 0.5 );\n \t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n \t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n \t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n \t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n \t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n \t\t\treturn bone;\n \t\t}\n \t#else\n \t\tuniform mat4 boneMatrices[ MAX_BONES ];\n \t\tmat4 getBoneMatrix( const in float i ) {\n \t\t\tmat4 bone = boneMatrices[ int(i) ];\n \t\t\treturn bone;\n \t\t}\n \t#endif\n #endif\n #ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): uniforms for area light shadows\n\n\t#endif\n\t*/\n\n#endif\n #ifdef USE_LOGDEPTHBUF\n \t#ifdef USE_LOGDEPTHBUF_EXT\n \t\tvarying float vFragDepth;\n \t\tvarying float vIsPerspective;\n \t#else\n \t\tuniform float logDepthBufFC;\n \t#endif\n #endif\n #if 0 > 0\n \tvarying vec3 vClipPosition;\n #endif\n void main() {\n    // vec3 worldPosition2 = ( modelMatrix * vec4( position, 1.0 )).xyz;\n    // vec3 cameraToVertex = normalize( worldPosition2 - cameraPosition2 );\n    // vReflect = reflect( cameraToVertex, normal );\n \tvec4 pos = vec4(position, 1.0);\n \tv_position = relativeModelMatrix * pos;\n\n #ifdef USE_UV\n \tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n #endif\n #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n \tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n #endif\n #ifdef USE_COLOR\n \tvColor.xyz = color.xyz;\n #endif\n vec3 objectNormal = vec3( normal );\n #ifdef USE_TANGENT\n \tvec3 objectTangent = vec3( tangent.xyz );\n #endif\n #ifdef USE_MORPHNORMALS\n \tobjectNormal *= morphTargetBaseInfluence;\n \tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n \tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n \tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n \tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n #endif\n #ifdef USE_SKINNING\n \tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n \tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n \tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n \tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n #endif\n #ifdef USE_SKINNING\n \tmat4 skinMatrix = mat4( 0.0 );\n \tskinMatrix += skinWeight.x * boneMatX;\n \tskinMatrix += skinWeight.y * boneMatY;\n \tskinMatrix += skinWeight.z * boneMatZ;\n \tskinMatrix += skinWeight.w * boneMatW;\n \tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n \tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n \t#ifdef USE_TANGENT\n \t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n \t#endif\n #endif\n vec3 transformedNormal = objectNormal;\n #ifdef USE_INSTANCING\n \tmat3 m = mat3( instanceMatrix );\n \ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n \ttransformedNormal = m * transformedNormal;\n #endif\n transformedNormal = normalMatrix * transformedNormal;\n #ifdef FLIP_SIDED\n \ttransformedNormal = - transformedNormal;\n #endif\n #ifdef USE_TANGENT\n \tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n \t#ifdef FLIP_SIDED\n \t\ttransformedTangent = - transformedTangent;\n \t#endif\n #endif\n #ifndef FLAT_SHADED\n \tvNormal = normalize( transformedNormal );\n \t#ifdef USE_TANGENT\n \t\tvTangent = normalize( transformedTangent );\n \t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n \t#endif\n #endif\n vec3 transformed = vec3( position );\n #ifdef USE_MORPHTARGETS\n \ttransformed *= morphTargetBaseInfluence;\n \ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n \ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n \ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n \ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n \t#ifndef USE_MORPHNORMALS\n \ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n \ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n \ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n \ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n \t#endif\n #endif\n #ifdef USE_SKINNING\n \tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n \tvec4 skinned = vec4( 0.0 );\n \tskinned += boneMatX * skinVertex * skinWeight.x;\n \tskinned += boneMatY * skinVertex * skinWeight.y;\n \tskinned += boneMatZ * skinVertex * skinWeight.z;\n \tskinned += boneMatW * skinVertex * skinWeight.w;\n \ttransformed = ( bindMatrixInverse * skinned ).xyz;\n #endif\n #ifdef USE_DISPLACEMENTMAP\n \ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n #endif\n vec4 mvPosition = vec4( transformed, 1.0 );\n #ifdef USE_INSTANCING\n \tmvPosition = instanceMatrix * mvPosition;\n #endif\n mvPosition = modelViewMatrix * mvPosition;\n gl_Position = projectionMatrix * mvPosition;\n #ifdef USE_LOGDEPTHBUF\n \t#ifdef USE_LOGDEPTHBUF_EXT\n \t\tvFragDepth = 1.0 + gl_Position.w;\n \t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n \t#else\n \t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n \t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n \t\t\tgl_Position.z *= gl_Position.w;\n \t\t}\n \t#endif\n #endif\n #if 0 > 0\n \tvClipPosition = - mvPosition.xyz;\n #endif\n \tvViewPosition = - mvPosition.xyz;\n #if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n \tvec4 worldPosition = vec4( transformed, 1.0 );\n \t#ifdef USE_INSTANCING\n \t\tworldPosition = instanceMatrix * worldPosition;\n \t#endif\n \tworldPosition = modelMatrix * worldPosition;\n #endif\n #ifdef USE_SHADOWMAP\n\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n\t}\n\n\t#endif\n\n\t/*\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\n\t\t// TODO (abelnation): update vAreaShadowCoord with area light info\n\n\t#endif\n\t*/\n\n#endif\n #ifdef USE_FOG\n \tfogDepth = -mvPosition.z;\n #endif\n }\n ";
exports.vertexShader = vertexShader;

/***/ }),
/* 413 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.fragmentShader = void 0;
var fragmentShader = "\n    \nuniform bool isNeedSweep;\nuniform bool isRect;\nuniform bool isAnnulus;\n\nuniform float sweepW;\nuniform float sweepH;\nuniform vec2 se2N;\nuniform vec2 se2RN;\nuniform vec2 moveP;\n\nbool isInRectW(vec2 v, vec2 a, float w){\n    float a1 = abs(dot(v,a));\n    return a1 < w;\n}\nbool isInRectH(vec2 v, vec2 a, float h){\n    float a1 = abs(dot(v,a));\n    return a1 < h;\n}\n\nvarying vec2 v_Uv;\nvarying vec4 v_position;\n\n\nuniform vec2 circleC;\nuniform float maxR;\nuniform float minR;\nbool isMaxCircle(vec3 a, vec2 b, float r){\n    float c = sqrt(pow((a.x-b.x),2.0)+pow((a.z-b.y),2.0));\n    return c <= r;\n}\n\nbool isMinCircle(vec3 a, vec2 b, float r){\n    float c = sqrt(pow((a.x-b.x),2.0)+pow((a.z-b.y),2.0));\n    return c > r;\n}\n\n#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\n\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\n    if(isRect){\n            \n        vec2 v = vec2(v_position.x-moveP.x,v_position.z-moveP.y);\n        if(float(isInRectW(v,se2N,sweepW) && isInRectH(v,se2RN,sweepH)) != 0.0 && isNeedSweep){\n            gl_FragColor = vec4(mix(vec3(1.0, 1.0, 0.36)*0.8, gl_FragColor.rgb, 0.5), 1.0);\n            gl_FragColor.rgb = toneMapping( gl_FragColor.rgb ); \n        }\n        \n    }\n    \n    if(isAnnulus){\n    \n        if(float(isMaxCircle(v_position.xyz,circleC,maxR) && isMinCircle(v_position.xyz,circleC,minR) ) != 0.0 && isNeedSweep){\n            gl_FragColor = vec4(mix(vec3(0.3, 1.0, 0.86),gl_FragColor.rgb,0.91), 1.0);\n            gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n        }\n        // gl_FragColor = vec4(1.0,0.1,0.1,1.0);\n    }\n    \n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}\n";
exports.fragmentShader = fragmentShader;

/***/ }),
/* 414 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(68);

__webpack_require__(8);

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

var _assign = _interopRequireDefault(__webpack_require__(11));

__webpack_require__(13);

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMUtil = _interopRequireDefault(__webpack_require__(57));

var _ThemeNode = _interopRequireDefault(__webpack_require__(415));

//TODO复制了一部分过来 仍需要重构

/**ThemeManager 主要对场景主题管理 所以它被放在FMScene对象
 * 
 */
var ThemeManager =
/*#__PURE__*/
function () {
  function ThemeManager(themeUrl, themeName) {
    (0, _classCallCheck2.default)(this, ThemeManager);
    // http://developers.fengmap.com/theme.html
    this._themeName = themeName;
    this._themeUrl = themeUrl;
    this._data = null;
    this._type2theme = {};
    this._poiimagetheme = {};
    this._storePoiThemes = {};
    this._storeLabelTypeDic = {};
    this._storeLabelThemeDic = {};
    this._storethemes = {};
    this._externalModelTheme = {};
    this._defaultTheme = {
      color: 0xffffff,
      alpha: 1,
      strokeColor: 0xffffff,
      strokeWidth: 2
    };
    this._labelDefaultTheme = {
      alpha: "0.9",
      fillcolor: "30,30,30",
      fontsize: "14.0",
      id: "109",
      image: false,
      strokecolor: "255,255,255"
    };
    this.clearColor = 0xffffff;
    this.clearAlpha = 1;
    this._modelOpacity = 0.875;
    this._floorColor = 0xffff00;
    this._floorOpacity = 0.875;
    this._selectedColor = 0xff9966; //"fillcolor": "0,0,0",    "strokecolor": "255,255,255",     "alpha": "1.0",     "fontsize": "12.0" 

    this._labelStyle;
    this._labelSelectedStyle;
    this._facilitySize;
    this._poiMatClones = {};
    this._storeApply = {}; // 路径线样式

    this.navigateStyle_ = {
      color: 0xff0000,
      lineWidth: 8,
      alpha: 0.8,
      dash: {
        size: 1,
        gap: 1
      }
    };
  }
  /**
   * 外部模型theme
   */


  (0, _createClass2.default)(ThemeManager, [{
    key: "initExteralModelTheme",
    value: function initExteralModelTheme() {
      if (!this._data.externalmodelapply) return;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this._data.externalmodelapply), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var emodelApply = _step.value;
          var fids = emodelApply.fids.split(',');
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = (0, _getIterator2.default)(fids), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var fid = _step2.value;
              var modelTheme = void 0;
              var _iteratorNormalCompletion3 = true;
              var _didIteratorError3 = false;
              var _iteratorError3 = undefined;

              try {
                for (var _iterator3 = (0, _getIterator2.default)(this._data.externalmodeltheme), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                  var mThmee = _step3.value;

                  if (mThmee.id === emodelApply.normalid) {
                    modelTheme = mThmee;
                    break;
                  }
                }
              } catch (err) {
                _didIteratorError3 = true;
                _iteratorError3 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                    _iterator3.return();
                  }
                } finally {
                  if (_didIteratorError3) {
                    throw _iteratorError3;
                  }
                }
              }

              this._externalModelTheme[fid] = (0, _assign.default)({
                color: modelTheme.color,
                model: modelTheme.model
              }, emodelApply);
              this._externalModelTheme[fid]["fids"] = undefined;
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
    /**
     * 初始化商店模型主题
     */

  }, {
    key: "initStoreTheme",
    value: function initStoreTheme() {
      var storethemes = {}; // set default store theme

      this._defaultTheme = this._data.storetheme[0];
      this.storeThemes = storethemes; // for (var i in this._data.storetheme) {

      for (var i = 0; i < this._data.storetheme.length; i++) {
        var st = this._data.storetheme[i];
        st.color = _FMUtil.default.toColor(st['color']);
        st.strokeColor = _FMUtil.default.toColor(st['strokecolor']);
        st.strokeWidth = st['strokewidth'];
        st.alpha = st['alpha'];
        storethemes[st['id']] = st;
      }

      var floorapply = this._data['floorapply'];

      for (var i in floorapply) {
        var fa = floorapply[i];

        if (!fa.typeapply) {
          continue;
        }

        for (var j in fa['typeapply']) {
          var ta = fa['typeapply'][j];

          if (!ta.normalid) {
            continue;
          } // store theme


          var st = storethemes[ta['normalid']]; //selectedid

          var std = storethemes[ta['selectedid']];
          if (std) this._selectedColor = _FMUtil.default.toColor(std['color']);
          var types = ta['type'].split(',');

          for (var k in types) {
            this._type2theme[types[k]] = st;
          }
        }
      } // if (floorapply.length>0 && floorapply[0].floorid !== undefined) {


      var dextt = this._data['extenttheme']; // for (var i = 0; i<dextt.length; i++) {
      // 	var v = dextt[i];
      // 	if (v.id == floorapply[0]['floorid']) {

      this._floorColor = _FMUtil.default.toColor(dextt[0]['color']);
      this._floorOpacity = (0, _parseFloat2.default)(dextt[0]['alpha']); // 		break;
      // 	}
      // }
      // }
    }
    /**
     * 初始化store label主题
     */

  }, {
    key: "initLabelTheme",
    value: function initLabelTheme() {
      // store label
      var dslt = this._data['storelabeltheme'];
      this.storeLabelThemeDic = {};
      this.storeLabelTypeDic = {};

      if (dslt) {
        if (dslt.length > 0) {
          this._labelStyle = dslt[0];

          if (dslt.length > 1) {
            this._labelSelectedStyle = dslt[1];
          }
        } // store label load image


        for (var i = 0; i < dslt.length; i++) {
          this.storeLabelThemeDic[dslt[i]['id']] = dslt[i];
        }

        var fa = this._data['floorstorelabelapply'];

        if (fa) {
          for (var i = 0; i < fa.length; i++) {
            var ta = fa[i].typeapply; // 就用全部

            if (fa[i].floorid == '0') {
              for (var j = 0; j < ta.length; j++) {
                var t = ta[j];
                var ts = t.type.split(',');

                for (var k = 0; k < ts.length; k++) {
                  this.storeLabelTypeDic[ts[k]] = t;
                }
              }
            }
          }
        }

        var storelabelapply = this.data['storelabelapply'];
        this._labelFidTheme = {};
        var labelFidTheme = this._labelFidTheme;
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = (0, _getIterator2.default)(storelabelapply), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var apply = _step4.value;
            if (!apply.fids) continue;
            var fids = apply.fids.split(',');
            var _iteratorNormalCompletion5 = true;
            var _didIteratorError5 = false;
            var _iteratorError5 = undefined;

            try {
              for (var _iterator5 = (0, _getIterator2.default)(fids), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                var fid = _step5.value;
                labelFidTheme[fid] = this.storeLabelThemeDic[apply['normalid']];
              }
            } catch (err) {
              _didIteratorError5 = true;
              _iteratorError5 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
                  _iterator5.return();
                }
              } finally {
                if (_didIteratorError5) {
                  throw _iteratorError5;
                }
              }
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    }
    /**
     * 初始化公共设施主题
     */

  }, {
    key: "initPoiTheme",
    value: function initPoiTheme() {
      this._poiimagetheme = {};
      var dpit = this._data['poiimagetheme'];
      var storePoiThemes = {};
      this.storePoiThemes = storePoiThemes;

      for (var _i in dpit) {
        var d = dpit[_i];

        if (!d.imagename) {
          continue;
        }

        storePoiThemes[d['id']] = d;
      }

      var floorpoiapply = this.data['floorpoiimageapply'];

      for (var i in floorpoiapply) {
        var fa = floorpoiapply[i];

        if (!fa.typeapply) {
          continue;
        }

        for (var j in fa['typeapply']) {
          var ta = fa['typeapply'][j];

          if (!ta.normalid) {
            continue;
          }

          var st = storePoiThemes[ta['normalid']];
          var types = ta['type'].split(',');

          for (var k in types) {
            this._poiimagetheme[types[k]] = st;
          }
        }
      }

      var poiimageapply = this.data['poiimageapply'];
      this._poiFidTheme = {};
      var poifidtheme = this._poiFidTheme;
      var _iteratorNormalCompletion6 = true;
      var _didIteratorError6 = false;
      var _iteratorError6 = undefined;

      try {
        for (var _iterator6 = (0, _getIterator2.default)(poiimageapply), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
          var apply = _step6.value;
          if (!apply.fids) continue;
          var fids = apply.fids.split(',');
          var _iteratorNormalCompletion7 = true;
          var _didIteratorError7 = false;
          var _iteratorError7 = undefined;

          try {
            for (var _iterator7 = (0, _getIterator2.default)(fids), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
              var fid = _step7.value;
              poifidtheme[fid] = storePoiThemes[apply['normalid']];
            }
          } catch (err) {
            _didIteratorError7 = true;
            _iteratorError7 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion7 && _iterator7.return != null) {
                _iterator7.return();
              }
            } finally {
              if (_didIteratorError7) {
                throw _iteratorError7;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError6 = true;
        _iteratorError6 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion6 && _iterator6.return != null) {
            _iterator6.return();
          }
        } finally {
          if (_didIteratorError6) {
            throw _iteratorError6;
          }
        }
      }
    }
  }, {
    key: "getStoreApplyTheme",
    value: function getStoreApplyTheme(fid) {
      var reuslt;
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = undefined;

      try {
        for (var _iterator8 = (0, _getIterator2.default)(this._data.storeapply), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var t = _step8.value;

          if (t.fids === fid) {
            var _iteratorNormalCompletion9 = true;
            var _didIteratorError9 = false;
            var _iteratorError9 = undefined;

            try {
              for (var _iterator9 = (0, _getIterator2.default)(this._data.storetheme), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {
                var st = _step9.value;

                if (st.id == t.normalid) {
                  reuslt = (0, _assign.default)({}, st, t); // reuslt.sizes = t.sizes;

                  return reuslt;
                }
              }
            } catch (err) {
              _didIteratorError9 = true;
              _iteratorError9 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion9 && _iterator9.return != null) {
                  _iterator9.return();
                }
              } finally {
                if (_didIteratorError9) {
                  throw _iteratorError9;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return != null) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }

      return null;
    }
  }, {
    key: "getRThemeTexture",

    /**
     * 按名称得到rtheme中的base64数据
     */
    value: function getRThemeTexture(name) {
      if (this.rtheme) {
        var d;

        for (var i = 0; i < this.rtheme.fmis.length; i++) {
          d = this.rtheme.fmis[i];

          if (d.name == name) {
            return d.content;
          }
        }
      }

      return null;
    }
  }, {
    key: "getModelSelectColor",
    value: function getModelSelectColor() {
      var theme = this._data.storetheme[1];
      var color = theme.color;
      var alpha = (0, _parseFloat2.default)(theme.alpha);
      return {
        r: (color >> 16 & 255) / 255,
        g: (color >> 8 & 255) / 255,
        b: (color & 255) / 255,
        a: alpha
      };
    }
    /**
     * 获得模型对应theme
     * @param {*} meta 
     */

  }, {
    key: "getModelTheme",
    value: function getModelTheme(meta) {
      if (!meta) {
        return this._defaultTheme;
      }

      var theme = this._type2theme[meta.type];

      if (theme) {
        return theme;
      } else {
        return this._defaultTheme;
      }
    }
    /**
     * 获得公共设施对应theme
     * @param {*} type 
     */

  }, {
    key: "getPoiTheme",
    value: function getPoiTheme(info) {
      var theme;
      var type = info.type;
      var fid = info.fid; // type = this.storeLabelTypeDic[type];

      theme = this._poiFidTheme[fid];

      if (!theme) {
        theme = this._poiimagetheme[type];
      }

      theme = (0, _assign.default)(theme || this._poiimagetheme[0], {});

      if (this.fileType == 'rtheme') {
        theme.imageSrc = this.getRThemeTexture(theme.imagename);
      } else {
        theme.imageSrc = this._themeUrl + '/' + this.themeName + '/' + theme.imagename;
      }

      theme.imageUrl = this._themeUrl + '/' + this.themeName + '/' + theme.imagename; //给个虚拟路径 便于材质管理

      theme.imagehead = this._themeUrl + '/' + this.themeName + '/';
      return theme;
    }
    /**
     * 获取store Label theme
     * @param {*} type 
     */

  }, {
    key: "getLabelTheme",
    value: function getLabelTheme(info) {
      var type = info.type;
      var fid = info.fid;
      var stype = this.storeLabelTypeDic[type];
      var theme;

      if (fid) {
        theme = this._labelFidTheme[fid];
      }

      if (!stype && !theme) {
        theme = this._labelStyle;
      } else {
        if (stype) {
          if (!theme) {
            if (this.storeLabelThemeDic[stype.normalid]) {
              theme = this.storeLabelThemeDic[stype.normalid];
            } else {
              theme = this._labelStyle;
            }
          }
        }
      }

      if (!theme) {
        theme = this._labelDefaultTheme;
      }

      if (!theme.fillcolor || !theme.alpha || !theme.fontsize) {
        var td = {
          "fillcolor": "0,0,0",
          "alpha": "1.0",
          "fontsize": "12.0"
        };
        theme = (0, _assign.default)(theme, td);
      }

      if (!theme.image) {
        theme.imageSrc = false;
      } else {
        if (this.fileType == 'rtheme') {
          theme.imageSrc = this.getRThemeTexture(theme.image);
        } else {
          theme.imageSrc = this._themeUrl + '/' + this.themeName + '/' + theme.image;
        }

        theme.imageUrl = this._themeUrl + '/' + this.themeName + '/' + theme.image; //给个虚拟路径 便于材质管理
      }

      return theme;
    }
  }, {
    key: "getExteralModelTheme",
    value: function getExteralModelTheme(fid) {
      return this._externalModelTheme[fid];
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this._type2theme = undefined;
      this._poiimagetheme = undefined;
      this._storePoiThemes = undefined;
      this._storeLabelTypeDic = undefined;
      this._storeLabelThemeDic = undefined;
      this._storethemes = undefined;
      this._data = undefined;
    }
  }, {
    key: "themeName",
    get: function get() {
      return this._themeName;
    }
  }, {
    key: "data",
    set: function set(data) {
      this._data = data;
      this.initStoreTheme();
      this.initLabelTheme();
      this.initPoiTheme();
      this.initExteralModelTheme();
      this.clearColor = _FMUtil.default.toColor(this._data['viewtheme']['clearcolor']);
      this.clearAlpha = (0, _parseFloat2.default)(this._data.viewtheme.clearalpha);
      return;
    },
    get: function get() {
      return this._data;
    }
  }, {
    key: "storeLabelTypeDic",
    get: function get() {
      return this._storeLabelTypeDic;
    },
    set: function set(s) {
      this._storeLabelTypeDic = s;
    }
  }, {
    key: "storeLabelThemeDic",
    get: function get() {
      return this._storeLabelThemeDic;
    },
    set: function set(s) {
      this._storeLabelThemeDic = s;
    }
  }, {
    key: "storePoiThemes",
    get: function get() {
      return this._storePoiThemes;
    },
    set: function set(s) {
      this._storePoiThemes = s;
    }
  }, {
    key: "storethemes",
    get: function get() {
      return this._storethemes;
    },
    set: function set(s) {
      this._storethemes = s;
    }
  }, {
    key: "themeUrl",
    get: function get() {
      return this._themeUrl;
    },
    set: function set(t) {
      this.themeUrl = t;
    }
  }, {
    key: "floorColor",
    set: function set(f) {
      this._floorColor = f;
    },
    get: function get() {
      return this._floorColor;
    }
  }, {
    key: "floorOpacity",
    set: function set(f) {
      this._floorOpacity = f;
    },
    get: function get() {
      return this._floorOpacity;
    }
  }, {
    key: "selectedColor",
    get: function get() {
      return this._selectedColor;
    }
  }]);
  return ThemeManager;
}();

var _default = ThemeManager;
exports.default = _default;

/***/ }),
/* 415 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(__webpack_require__(11));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var ThemeNode =
/*#__PURE__*/
function () {
  function ThemeNode(tdata) {
    (0, _classCallCheck2.default)(this, ThemeNode);
    this._data = tdata;
    this._Nodes = [];
  }

  (0, _createClass2.default)(ThemeNode, [{
    key: "updateNodes",
    value: function updateNodes() {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this._Nodes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var n = _step.value;
          n.setByTheme(this._data);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: "addNodes",
    value: function addNodes(node) {
      this._Nodes.push(node);
    }
  }, {
    key: "removeNodes",
    value: function removeNodes(node) {
      var index = this._Nodes.indexOf(node);

      if (index > -1) {
        this._Nodes.splice(index, 1);
      }
    }
  }, {
    key: "changeData",
    value: function changeData(data) {
      (0, _assign.default)(this._data, data);
    }
  }]);
  return ThemeNode;
}();

var _default = ThemeNode;
exports.default = _default;

/***/ }),
/* 416 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _interopRequireDefault = __webpack_require__(1);

var _typeof2 = _interopRequireDefault(__webpack_require__(47));

(function (global, factory) {
  ( false ? undefined : (0, _typeof2.default)(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(void 0, function () {
  'use strict';
  /**
   * @author mrdoob / http://mrdoob.com/
   */

  var Stats = function Stats() {
    var mode = 0;
    var container = document.createElement('div');
    container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000';
    container.addEventListener('click', function (event) {
      event.preventDefault();
      showPanel(++mode % container.children.length);
    }, false); //

    function addPanel(panel) {
      container.appendChild(panel.dom);
      return panel;
    }

    function showPanel(id) {
      for (var i = 0; i < container.children.length; i++) {
        container.children[i].style.display = i === id ? 'block' : 'none';
      }

      mode = id;
    } //


    var beginTime = (performance || Date).now(),
        prevTime = beginTime,
        frames = 0;
    var fpsPanel = addPanel(new Stats.Panel('FPS', '#0ff', '#002'));
    var msPanel = addPanel(new Stats.Panel('MS', '#0f0', '#020'));

    if (self.performance && self.performance.memory) {
      var memPanel = addPanel(new Stats.Panel('MB', '#f08', '#201'));
    }

    showPanel(0);
    return {
      REVISION: 16,
      dom: container,
      addPanel: addPanel,
      showPanel: showPanel,
      begin: function begin() {
        beginTime = (performance || Date).now();
      },
      end: function end() {
        frames++;
        var time = (performance || Date).now();
        msPanel.update(time - beginTime, 200);

        if (time >= prevTime + 1000) {
          fpsPanel.update(frames * 1000 / (time - prevTime), 100);
          prevTime = time;
          frames = 0;

          if (memPanel) {
            var memory = performance.memory;
            memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
          }
        }

        return time;
      },
      update: function update() {
        beginTime = this.end();
      },
      // Backwards Compatibility
      domElement: container,
      setMode: showPanel
    };
  };

  Stats.Panel = function (name, fg, bg) {
    var min = Infinity,
        max = 0,
        round = Math.round;
    var PR = round(window.devicePixelRatio || 1);
    var WIDTH = 80 * PR,
        HEIGHT = 48 * PR,
        TEXT_X = 3 * PR,
        TEXT_Y = 2 * PR,
        GRAPH_X = 3 * PR,
        GRAPH_Y = 15 * PR,
        GRAPH_WIDTH = 74 * PR,
        GRAPH_HEIGHT = 30 * PR;
    var canvas = document.createElement('canvas');
    canvas.width = WIDTH;
    canvas.height = HEIGHT;
    canvas.style.cssText = 'width:80px;height:48px';
    var context = canvas.getContext('2d');
    context.font = 'bold ' + 9 * PR + 'px Helvetica,Arial,sans-serif';
    context.textBaseline = 'top';
    context.fillStyle = bg;
    context.fillRect(0, 0, WIDTH, HEIGHT);
    context.fillStyle = fg;
    context.fillText(name, TEXT_X, TEXT_Y);
    context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
    context.fillStyle = bg;
    context.globalAlpha = 0.9;
    context.fillRect(GRAPH_X, GRAPH_Y, GRAPH_WIDTH, GRAPH_HEIGHT);
    return {
      dom: canvas,
      update: function update(value, maxValue) {
        min = Math.min(min, value);
        max = Math.max(max, value);
        context.fillStyle = bg;
        context.globalAlpha = 1;
        context.fillRect(0, 0, WIDTH, GRAPH_Y);
        context.fillStyle = fg;
        context.fillText(round(value) + ' ' + name + ' (' + round(min) + '-' + round(max) + ')', TEXT_X, TEXT_Y);
        context.drawImage(canvas, GRAPH_X + PR, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT, GRAPH_X, GRAPH_Y, GRAPH_WIDTH - PR, GRAPH_HEIGHT);
        context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, GRAPH_HEIGHT);
        context.fillStyle = bg;
        context.globalAlpha = 0.9;
        context.fillRect(GRAPH_X + GRAPH_WIDTH - PR, GRAPH_Y, PR, round((1 - value / maxValue) * GRAPH_HEIGHT));
      }
    };
  };

  return Stats;
});

/***/ }),
/* 417 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _waterShader = _interopRequireDefault(__webpack_require__(418));

var WaterMaterial =
/*#__PURE__*/
function (_fm$ShaderMaterial) {
  (0, _inherits2.default)(WaterMaterial, _fm$ShaderMaterial);

  function WaterMaterial(materialParams) {
    var _this;

    (0, _classCallCheck2.default)(this, WaterMaterial);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(WaterMaterial).call(this, materialParams));
    _this.uniforms["offset"] = {
      value: new fm.Vector2()
    };
    _this.uniforms["rotation"] = {
      value: 0
    };
    _this.uniforms["scale"] = {
      value: new fm.Vector2(1, 1)
    };
    _this.depthTest = false;
    _this.vertexShader = _waterShader.default.vert;
    _this.fragmentShader = _waterShader.default.frag;
    return _this;
  }

  return WaterMaterial;
}(fm.ShaderMaterial);

var _default = WaterMaterial;
exports.default = _default;

/***/ }),
/* 418 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var waterShader = {};
waterShader.vert = "\n                      \n                        uniform vec2 offset;\n                        uniform float rotation;\n                        uniform vec2 scale;\n                        varying vec2 vUv;\n                        void main() {\n                          vUv = uv;\n                  \n                          \n                          vec2 rotatedPosition;\n                            rotatedPosition.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\n                            rotatedPosition.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n                      \n        \n                            rotatedPosition.x *= scale.x * abs(projectionMatrix[0][0] / projectionMatrix[1][1]);\n                            rotatedPosition.y *= scale.y;\n                          \n                          rotatedPosition.xy += offset;\n                          gl_Position = vec4(rotatedPosition,0.0,1.0);\n                        }\n                        ";
waterShader.frag = "\n                    uniform vec3 diffuse;\n                    uniform sampler2D mmap;\n                    #include <common>\n                    varying vec2 vUv;\n               \n                    void main() {\n                \n                        // vec2 muv = vec2(vUv.x , 1.0 - vUv.y);\n                        vec4 diffuseColor = texture2D( mmap, vUv );\n                       \n                        \n                        gl_FragColor = diffuseColor;\n                    }\n                    "; //texture2D( mapBack, vUv )
//gl_FragColor = vec4(resultColor , alphacomp);
//

var _default = waterShader;
exports.default = _default;

/***/ }),
/* 419 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 * @author Mif / Made on March 28, 2020/
 * @class VideoMemoryManager
 * @constructor
 */
var VideoMemoryManager =
/*#__PURE__*/
function () {
  /**
   * VideoMemoryManager是sdk内存管理类，用于计算sdk当前显存占用量
   */
  function VideoMemoryManager(map) {
    (0, _classCallCheck2.default)(this, VideoMemoryManager);
    this.videoMemoryAmount = null;
    this._map = map;
  }

  (0, _createClass2.default)(VideoMemoryManager, [{
    key: "getVideoMemoryAmount",
    value: function getVideoMemoryAmount(scenesId) {
      if (!this._map.nodeManager) return;
      var groups = this._map.nodeManager._scenes["" + scenesId].groups;

      for (var i in groups) {
        this.videoMemoryAmount += groups["" + i].layers.facility[0].getVideoMemoryAmount();
        this.videoMemoryAmount += groups["" + i].layers.model[0].getVideoMemoryAmount();
        this.videoMemoryAmount += groups["" + i].layers.extent[0].getVideoMemoryAmount();
        this.videoMemoryAmount += groups["" + i].layers.label[0].getVideoMemoryAmount();
      }

      return this.videoMemoryAmount;
    }
  }, {
    key: "_addAmount",
    value: function _addAmount(byte) {
      this.videoMemoryAmount += byte;
    }
  }, {
    key: "_subtractAmount",
    value: function _subtractAmount(byte) {
      this.videoMemoryAmount -= byte;
    }
  }]);
  return VideoMemoryManager;
}();

var _default = VideoMemoryManager;
exports.default = _default;

/***/ }),
/* 420 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

__webpack_require__(48);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMUtil = _interopRequireDefault(__webpack_require__(57));

var _FMControlPosition = _interopRequireDefault(__webpack_require__(240));

var _FMControlOptions = _interopRequireDefault(__webpack_require__(421));

var changeBack; // let my_throttled_timeout = null,
//     prev_time = null;

/**
 * FMScrollGroupsControl 滚动型型楼层控件
 * @class
 * @memberof fengmap
 * @param {fengmap.FMMap} map FMMap的实例
 * @param {json} ctlOpt 控制器参数
 *           @param {boolean} ctlOpt.allLayer  初始显示多层还是单层，默认值false,单层显示。
 *           @param {number} ctlOpt.showBtnCount  初始楼层按钮显示个数配置。默认显示5层,其他的隐藏，可滚动查看
 *           @param {boolean} ctlOpt.needAllLayerBtn  是否显示多层/单层切换按钮。
 *           @param {fengmap.FMControlPosition} ctlOpt.position  控件位置。分为左上、左下、右上、右下。 
 *           @param {json} ctlOpt.offset  控件位置偏移。{x:0,y:0},基于原始位置的x,y方向的偏移。
 *           @param {string} ctlOpt.imgURL  配置组件引用图片资源的路径地址。默认在页面的'resource/style/wedgets/img/'路径下
 */

var FMScrollGroupsControl =
/*#__PURE__*/
function () {
  function FMScrollGroupsControl(map, ctlOpt) {
    (0, _classCallCheck2.default)(this, FMScrollGroupsControl);
    this._map = map;
    this._ctlOpt = new _FMControlOptions.default(ctlOpt);
    this._btnWidth = 42;
    this._showBtnCount = this._ctlOpt.showBtnCount || 5;
    this._foucusId = this._map.currentFocusGroup;
    this._scrollSpeed = 10;
    this._btnPanel = null;
    this._mainPanel = null;

    if (!this._ctlOpt.offset) {
      this._ctlOpt.offset = {
        x: 0,
        y: 0
      };
    }

    this._ctlOpt.needAllLayerBtn = this._ctlOpt.needAllLayerBtn != undefined ? this._ctlOpt.needAllLayerBtn : true;
    this._allLayer = this._ctlOpt.allLayer ? this._ctlOpt.allLayer : false;

    if (this._allLayer) {
      this._map.showSingerOrMultiGroup(this._allLayer);
    }

    this.uuid = null;
    this.init();
    this.scrollTopAn_ = new _FMUtil.default.scrollTopAnFun();
  }

  (0, _createClass2.default)(FMScrollGroupsControl, [{
    key: "init",
    value: function init() {
      var _this = this;

      var date = new Date();
      var year = date.getFullYear();
      var month = date.getMonth();
      var day = date.getDate();
      var hour = date.getHours();
      var minute = date.getMinutes();
      var second = date.getSeconds(); //这样写显示时间在1~9会挤占空间；所以要在1~9的数字前补零;

      if (hour < 10) {
        hour = '0' + hour;
      }

      if (minute < 10) {
        minute = '0' + minute;
      }

      if (second < 10) {
        second = '0' + second;
      }

      var time = year + '/' + month + '/' + day + '/' + hour + ':' + minute + ':' + second;
      this.uuid = String(Math.random() * 5).replace(/^(.*\..{4}).*$/, "$1") + time;
      var panelDiv = this.createPanel(this._btnWidth);
      this._mainPanel = panelDiv;
      this.checkPosition(this._ctlOpt.position, this._ctlOpt.offset, panelDiv);

      this._map.getContainer().appendChild(panelDiv);

      var gids = this._map.listGroups.map(function (a) {
        return a.gid;
      });

      var glen = gids.length;
      var showLen = this._showBtnCount;
      var needScroll = true;

      if (glen <= this._showBtnCount) {
        showLen = glen;
        needScroll = false;
      }

      var switchBtn = this.createMultiSwitchButton(this._ctlOpt.imgURL + (this._ctlOpt.allLayer ? "layers.png" : "layer.png"));

      if (this._ctlOpt.needAllLayerBtn) {
        panelDiv.appendChild(switchBtn); //
      }

      this._switchBtn = switchBtn;
      needScroll && panelDiv.appendChild(this.createScrollButton(this._ctlOpt.imgURL + "arrow1.png", "top")); //滚动按钮

      var gbtnPanel = this.createGroupBtnPanel(showLen * this._btnWidth + (showLen - 1) * 2);
      panelDiv.appendChild(gbtnPanel);
      this._btnPanel = gbtnPanel;
      var _listGroup = this._map.listGroups;

      for (var i = _listGroup.length - 1; i > -1; i--) {
        gbtnPanel.appendChild(this.createGroupButton(_listGroup[i], this._btnWidth));

        if (i > 0) {
          gbtnPanel.appendChild(this.createHr());
        }
      }

      needScroll && panelDiv.appendChild(this.createScrollButton(this._ctlOpt.imgURL + "arrow2.png", "buttom")); //滚动按钮

      gbtnPanel.scrollTop = this.getCenterScrolltopById(this._foucusId, gids.length);
      document.getElementById("gid_" + this._foucusId + this.uuid).style.color = "rgb(30, 130, 250)";
      this.eventBtnPanelInit(gbtnPanel);
      this.eventPanelInit(panelDiv, gbtnPanel, gids);
      this.eventSwitchBtn(switchBtn);

      var gidchange = function gidchange(e) {
        var _cgids = _this._map.listGroups.map(function (a) {
          return a.gid;
        });

        if (e.gid < _cgids[0] || e.gid > _cgids[_cgids.length - 1]) return;
        gbtnPanel.scrollTop = _this.getCenterScrolltopById(e.gid, _cgids.length);

        _this.setFocusStaus(e.gid);
      };

      var vidchange = function vidchange(e) {
        if (!(e.gids.length > 1)) {
          _this.setLayerStatus(false);
        } else {
          _this.setLayerStatus(true);
        }
      };

      this._map.on("focusGroupIDChanged", gidchange);

      this._map.on("visibleGroupIDsChanged", vidchange);

      this._map.on("dispose", function (e) {
        _this._map.off("focusGroupIDChanged", gidchange);

        _this._map.off("visibleGroupIDsChanged", vidchange);

        _this._map.getContainer().removeChild(panelDiv);
      });

      this._$ = function (cssname) {
        if (_this.map) return _this.map.mapView.container_.querySelector(cssname);else return document.querySelector(cssname);
      };
    }
  }, {
    key: "eventSwitchBtn",
    value: function eventSwitchBtn(swbtn) {
      var me = this;
      swbtn.addEventListener("click", function (e) {
        me._allLayer = !me._allLayer;

        if (me._allLayer) {
          swbtn.firstElementChild.src = me._ctlOpt.imgURL + "layers.png";
        } else {
          swbtn.firstElementChild.src = me._ctlOpt.imgURL + "layer.png";
        }

        me._map.showSingerOrMultiGroup(me._allLayer);
      });
    }
  }, {
    key: "eventBtnPanelInit",
    value: function eventBtnPanelInit(btnPanel) {
      var _this2 = this;

      var me = this;
      me.changeScrollBtnPic(); //初始化控件的样式

      _FMUtil.default.bindEvent(btnPanel, "label", "click", function () {
        me.foucusId = (0, _parseInt2.default)(this.dataset.gid);
        me.setFocusStaus(this.dataset.gid);
      }); // my_throttled_timeout = null,
      // prev_time = null;


      var handleScrollEvent = function handleScrollEvent(e) {
        //if (my_throttled_timeout) return;
        // let remaining = new Date().getTime() - prev_time;
        me.changeScrollBtnPic(); //let scrollTop = btnPanel.scrollTop;

        var scrollTop = 0;

        if (e.wheelDelta) {
          //判断浏览器IE，谷歌滑轮事件
          scrollTop = scrollTop + -e.wheelDelta;
        } else if (e.detail) {
          //Firefox滑轮事件
          scrollTop = scrollTop + e.detail;
        } //btnPanel.scrollTop += scrollTop;


        _this2.scrollTopAn_({
          el: btnPanel,
          to: btnPanel.scrollTop,
          // 开始位置
          form: btnPanel.scrollTop + scrollTop // 结束位置
          // time: 1e3 * .5, // 所需时间

        }); //FMUtil.scrollToView(btnPanel, scrollTop);
        // if (remaining <= 0) {
        //     FMUtil.scrollToView(btnPanel, scrollTop);
        //     prev_time = new Date().getTime();
        //     my_throttled_timeout = null;
        // } else {
        //     my_throttled_timeout = setTimeout(function() {
        //         my_throttled_timeout = null;
        //         prev_time = new Date().getTime();
        //         FMUtil.scrollToView(btnPanel, scrollTop);
        //     }, remaining)
        // }

      };

      btnPanel.addEventListener("mousewheel", handleScrollEvent, {
        passive: true
      });
      btnPanel.addEventListener('MozMousePixelScroll', handleScrollEvent, false); //firefox
      //如果是移动端ios andriod添加touch事件,电脑端绑定点击事件

      btnPanel.addEventListener('touchstart', this.touchstart.bind(this), false);
      btnPanel.addEventListener('touchmove', this.touchmove.bind(this), false);
      btnPanel.addEventListener('touchend', this.touchend.bind(this), true);
    }
  }, {
    key: "touchstart",
    value: function touchstart(e) {
      e.preventDefault();
      this.touchStartPointY = e.touches[0].pageY; //一次触屏事件开启时的坐标

      this.touchPointX = e.touches[0].pageX;
      this.touchPointY = e.touches[0].pageY;
    }
  }, {
    key: "touchmove",
    value: function touchmove(e) {
      e.preventDefault();
      this.touchEndPointX = e.touches[0].pageX;
      this.touchEndPointY = e.touches[0].pageY;
      this.handleTouchEnd(e); //移动时就能滑动
    }
  }, {
    key: "handleTouchEnd",
    value: function handleTouchEnd(e) {
      e = e || window.event;

      var _scope = this;

      var labelObj = null;
      var scrollTop = 0;

      if (e.changedTouches.length > 0) {
        _scope.touchEndPointX = e.changedTouches[0].pageX;
        _scope.touchEndPointY = e.changedTouches[0].pageY;
      }

      labelObj = e.target;

      if (labelObj instanceof HTMLSpanElement === true) {
        labelObj = labelObj.parentElement;
      }

      var delphaY = _scope.touchEndPointY - _scope.touchPointY; // if (delphaY > 0 && delphaY > 5 ) {
      //     scrollTop = scrollTop - delphaY;
      // } else if (delphaY < 0 && -delphaY > 5 ) {
      //     scrollTop = scrollTop + (-delphaY);
      // }

      scrollTop = -delphaY;

      if (scrollTop != 0) {
        _scope.touchPointX = _scope.touchEndPointX;
        _scope.touchPointY = _scope.touchEndPointY;

        var el = _scope._$(".fm-layer-list"); //el.scrollTop += scrollTop;


        this.scrollTopAn_({
          el: el,
          to: el.scrollTop,
          // 开始位置
          form: el.scrollTop + scrollTop // 结束位置
          //time: 1e3 * .5, // 所需时间

        });
      }
    }
  }, {
    key: "touchend",
    value: function touchend(e) {
      e = e || window.event;

      var _scope = this;

      var labelObj = null;

      if (e.changedTouches.length > 0) {
        _scope.touchEndPointX = e.changedTouches[0].pageX;
        _scope.touchEndPointY = e.changedTouches[0].pageY;
      }

      labelObj = e.target;

      if (labelObj instanceof HTMLSpanElement === true) {
        labelObj = labelObj.parentElement;
      }

      var delphaY = Math.abs(_scope.touchEndPointY - _scope.touchStartPointY);

      if (delphaY < 5 && delphaY >= 0 && labelObj) {
        //点击事件
        var focusId = (0, _parseInt2.default)(labelObj.dataset.gid);

        if (!isNaN(focusId)) {
          _scope.foucusId = focusId;

          _scope.setFocusStaus(focusId);
        }
      }
    }
  }, {
    key: "eventPanelInit",
    value: function eventPanelInit(panel, btnPanel, gids) {
      var me = this; //avoid select word content

      panel.onselectstart = function () {
        return false;
      };

      panel.style.MozUserSelect = "none";

      _FMUtil.default.bindEvent(panel, ".scroll", "click", function (e) {
        var underGroup = gids.length - Math.floor(btnPanel.scrollTop / 44) - (me._showBtnCount - 1);
        var groupDiff = btnPanel.scrollTop % 44;
        var topGroup = underGroup + me._showBtnCount - 1 + (groupDiff > 0 ? 1 : 0);
        var _scrollTo = 0;

        if (this.id === "scroll_top" + me.uuid) {
          var _focusId = me._foucusId + 1;

          _focusId = Math.min(gids[gids.length - 1], _focusId);
          if (me.foucusId == _focusId) return;
          me.foucusId = _focusId;

          if (_focusId < underGroup) {
            _scrollTo -= groupDiff > 0 ? 44 - groupDiff : 0; //btnPanel.scrollTop -= (groupDiff > 0 ? 44 - groupDiff : 0);
          } else if (_focusId <= topGroup + 1) {
            if (_focusId === topGroup + 1) {
              _scrollTo -= 44 + (groupDiff > 0 ? 44 - groupDiff : 0); //btnPanel.scrollTop -= 44 + (groupDiff > 0 ? 44 - groupDiff : 0);
            }
          }
        } else {
          var _focusId2 = me._foucusId - 1;

          _focusId2 = Math.max(gids[0], _focusId2);
          if (me.foucusId == _focusId2) return;
          me.foucusId = _focusId2;

          if (_focusId2 > topGroup) {
            _scrollTo += groupDiff > 0 ? groupDiff : 0; //btnPanel.scrollTop += (groupDiff > 0 ? groupDiff : 0);
          } else if (_focusId2 >= underGroup - 1) {
            if (_focusId2 === underGroup - 1) {
              _scrollTo += 44 + (groupDiff > 0 ? groupDiff : 0); //btnPanel.scrollTop += 44 + (groupDiff > 0 ? groupDiff : 0);
            }
          }
        }

        if (_scrollTo != 0) {
          me.scrollTopAn_({
            el: btnPanel,
            to: btnPanel.scrollTop,
            // 开始位置
            form: btnPanel.scrollTop + _scrollTo // 结束位置
            // time: 1e3 * .5, // 所需时间

          }); //FMUtil.scrollToView(btnPanel, _scrollTo + btnPanel.scrollTop);
        }
      });
    }
  }, {
    key: "getCenterScrolltopById",
    value: function getCenterScrolltopById(id, glen) {
      var detalId = glen - id - Math.floor(this._showBtnCount / 2);
      return detalId * (this._btnWidth + 2);
    }
  }, {
    key: "createPanel",
    value: function createPanel(width) {
      var template = document.createElement('div');
      var html = "\n            <div class=\"fm-control-groups\" style =\"width: 42px; position: absolute; background-color: white; box-shadow: rgba(0, 0, 0, 0.3) 2px 2px 3px; border-radius: 2px; top: 30px; right: 30px;\"></div>\n        ";
      template.innerHTML = html.trim();
      return template.firstChild;
    }
  }, {
    key: "createGroupBtnPanel",
    value: function createGroupBtnPanel(height) {
      var template = document.createElement('div');
      var html = "\n            <div style = \"overflow: hidden; height: ".concat(height, "px;\" class=\"fm-layer-list\"> </div\n        ");
      template.innerHTML = html.trim();
      return template.firstChild;
    }
  }, {
    key: "createMultiSwitchButton",
    value: function createMultiSwitchButton(btnUrl) {
      var template = document.createElement('div');
      var html = "\n            <div class=\"fm-control-groups-layer fm-btn-layer\" style=\"padding: 10px; cursor: pointer;\">\n                <img src=\"".concat(btnUrl, "\" style=\"width: 22px; height: 22px;\">\n            </div>\n            ");
      template.innerHTML = html.trim();
      return template.firstChild;
    }
  }, {
    key: "createHr",
    value: function createHr() {
      var template = document.createElement('div');
      var html = "\n            <hr style=\"height: 1px; border-top: 1px solid rgba(153, 153, 153, 0.45); border-right: none; border-bottom: none; border-left: none; border-image: initial; width: 60%; margin: 0px 20%;\">\n        ";
      template.innerHTML = html.trim();
      return template.firstChild;
    }
  }, {
    key: "createScrollButton",
    value: function createScrollButton(bturl, type) {
      var template = document.createElement('div');
      var html = "\n            <div class=\"scroll\" id=\"scroll_".concat(type + this.uuid, "\" style=\"height: 18px; background: url(&quot;").concat(bturl, "&quot;) 50% 50% no-repeat; cursor: pointer;\"></div>\n        ");
      template.innerHTML = html.trim();
      return template.firstChild;
    }
  }, {
    key: "createGroupButton",
    value: function createGroupButton(group, width) {
      var template = document.createElement('div');
      var html = "<label  data-gid=".concat(group.gid, " id=\"gid_").concat(group.gid + this.uuid, "\" style=\"display: inline-block; text-align: center; width: ").concat(width, "px; height: ").concat(width, "px; line-height: ").concat(width, "px; margin: 0px; cursor: pointer; font-size: 0.8em; font-weight: bold; color: rgb(102, 102, 102);\">\n                        <span>").concat(group.alias && group.alias.toUpperCase() || group.gname.toUpperCase(), "</span>\n                    </label>");
      template.innerHTML = html.trim();
      return template.firstChild;
    } //当前处于可见楼层的最小和最大时不能点击

  }, {
    key: "changeScrollBtnPic",
    value: function changeScrollBtnPic() {
      var _curId = this._foucusId,
          _curVisibleIds = this._map.listGroups.map(function (a) {
        return a.gid;
      });

      var botBtn = document.getElementById("scroll_buttom" + this.uuid);
      var topBtn = document.getElementById("scroll_top" + this.uuid);

      if (_curId == _curVisibleIds[0]) {
        botBtn && (botBtn.style.backgroundImage = "url(" + this._ctlOpt.imgURL + "arrow4.png)");
      } else {
        botBtn && (botBtn.style.backgroundImage = "url(" + this._ctlOpt.imgURL + "arrow2.png)");
      }

      if (_curId == _curVisibleIds[_curVisibleIds.length - 1]) {
        topBtn && (topBtn.style.backgroundImage = "url(" + this._ctlOpt.imgURL + "arrow3.png)");
      } else {
        topBtn && (topBtn.style.backgroundImage = "url(" + this._ctlOpt.imgURL + "arrow1.png)");
      }
    }
    /**
     * 楼层切换
     * @param {number} gid 楼层id
     * 
     */

  }, {
    key: "changeFocusGroup",
    value: function changeFocusGroup(gid) {
      this.foucusId = gid; //this.setFocusStaus(this.foucusId);
    }
    /**
     * 选择是否多楼层
     * @param {bool} all 【true】为多楼层，【false】为单楼层
     */

  }, {
    key: "changeGroupsSelect",
    value: function changeGroupsSelect(all) {
      this.setLayerStatus(all);

      this._map.showSingerOrMultiGroup(all);
    }
  }, {
    key: "setLayerStatus",
    value: function setLayerStatus(all) {
      this._allLayer = all;

      if (this._allLayer) {
        this._switchBtn.firstElementChild.src = this._ctlOpt.imgURL + "layers.png";
      } else {
        this._switchBtn.firstElementChild.src = this._ctlOpt.imgURL + "layer.png";
      }
    }
  }, {
    key: "checkPosition",
    value: function checkPosition(direct, offset, dom) {
      dom.style.left = "";
      dom.style.right = "";
      dom.style.top = "";
      dom.style.bottom = "";

      switch (direct) {
        case _FMControlPosition.default.LEFT_TOP:
          dom.style.left = offset.x + "px";
          dom.style.top = offset.y + "px";
          break;

        case _FMControlPosition.default.RIGHT_TOP:
          dom.style.right = -offset.x + "px";
          dom.style.top = offset.y + "px";
          break;

        case _FMControlPosition.default.LEFT_BOTTOM:
          dom.style.left = offset.x + "px";
          dom.style.bottom = -offset.y + "px";
          break;

        case _FMControlPosition.default.RIGHT_BOTTOM:
          dom.style.right = -offset.x + "px";
          dom.style.bottom = -offset.y + "px";
          break;

        default:
          dom.style.left = offset.x + "px";
          dom.style.top = offset.y + "px";
          break;
      }
    }
    /**
     * 注册楼层change事件
     * @param {Function} cb 回调函数
     */

  }, {
    key: "onChange",
    value: function onChange(tchangeBack) {
      changeBack = tchangeBack;
    }
  }, {
    key: "setFocusStaus",
    value: function setFocusStaus(gid) {
      document.getElementById("gid_" + this._foucusId + this.uuid).style.color = "rgb(102, 102, 102)";
      this._foucusId = (0, _parseInt2.default)(gid);
      document.getElementById("gid_" + this._foucusId + this.uuid).style.color = "rgb(30, 130, 250)";
      this.changeScrollBtnPic();
    }
    /**
     * 返回当前是否展示多层
     * @property {bool}
     * @readonly
     */

  }, {
    key: "foucusId",
    set: function set(v) {
      var vgs = [];
      vgs.push.apply(vgs, (0, _toConsumableArray2.default)(this._map.visibleGroupIDs));

      if (vgs.length == 1) {
        this._map.visibleGroupIDs = [v];
      } else {
        if (this._map.visibleGroupIDs.indexOf(v) > -1) {} else {
          vgs.push(v);
          this._map.visibleGroupIDs = vgs;
        }
      }

      this._map.changeFocusToGroup({
        gid: v
      });

      if (changeBack) {
        changeBack([v], this._map.visibleGroupIDs.length > 1);
      }
    },
    get: function get() {
      return this._map.currentFocusGroup;
    }
  }, {
    key: "allLayer",
    get: function get() {
      return this._map.showAllGroup;
    }
  }]);
  return FMScrollGroupsControl;
}();

var _default = FMScrollGroupsControl;
exports.default = _default;

/***/ }),
/* 421 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(__webpack_require__(11));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _controlSize = _interopRequireDefault(__webpack_require__(422));

var FMControlOptions = function FMControlOptions(opt) {
  (0, _classCallCheck2.default)(this, FMControlOptions);
  this.size = _controlSize.default.FMMap_CONTROL_NORMAL;
  this.position = null;
  this.offset = new fm.Vector2(0, 0);
  this.imgURL = 'resource/style/wedgets/img/'; //组件内部引用图片地址

  (0, _assign.default)(this, opt);
};

var _default = FMControlOptions;
exports.default = _default;

/***/ }),
/* 422 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var controlSize = {
  "FMMap_CONTROL_SMALL": 'small',
  "FMMap_CONTROL_NORMAL": 'normal'
};
var _default = controlSize;
exports.default = _default;

/***/ }),
/* 423 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(__webpack_require__(11));

__webpack_require__(8);

__webpack_require__(112);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _FMScene = _interopRequireDefault(__webpack_require__(150));

var _Animater = _interopRequireDefault(__webpack_require__(58));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _Sprite = _interopRequireDefault(__webpack_require__(111));

var _FMMarkerAnchor = _interopRequireDefault(__webpack_require__(153));

var _warnMessage = __webpack_require__(69);

var jumpEvent = null;
/**
 *  FMImageMarker 自定义图片标注对象，为自定义图层。
 *  @class
 *  @memberof fengmap
 *  @extends {fengmap.FMNode}
 *  @param {json} option 
 *         @param {float} option.x  图片地图位置x值
 *         @param {float} option.y 图片地图位置y值
 *         @param {int} option.size  图片尺寸
 *         @param {int} option.height  标注高度
 *         @param {string} option.url    图片地址
 *         @param {string} option.anchor  锚点位置
 *         @param {bool} option.depth    文本渲染深度 【true】：开启深度；【false】：关闭深度
 */

var FMImageMarker =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMImageMarker, _FMNode);

  function FMImageMarker(option) {
    var _this;

    (0, _classCallCheck2.default)(this, FMImageMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMImageMarker).call(this, 0, _FMNodeType.default.IMAGE_MARKER));
    _this.isInitSprite = false;
    _this._url = option.url;
    _this._size = option.size;
    _this._height = 0;
    _this._offsetHeight = option.height ? option.height : 0;
    _this._renderNode = null;
    _this._visible = true;
    _this._opx = option.x || 0;
    _this._opy = option.y || 0; //this._popWindow = null;

    _this._callBack = option.callback;
    _this._moveAnimater = null;
    _this._isMoving = false;
    _this._depth = option.depth;
    _this._isJumping = false;
    _this._origonY = 0;
    _this.center = _this.getCenterByAnchor(option.anchor);
    _this.picLoading = false;
    _this.needAvoid = true;
    _this.markername = option.name;
    return _this;
  }

  (0, _createClass2.default)(FMImageMarker, [{
    key: "initSprite",
    value: function initSprite() {
      var _this2 = this;

      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;
      var hidden = true;
      var material = nodeManager.materialManager.createPoiMaterial({
        imageUrl: this._url,
        imageSrc: this._url,
        alpha: 1
      }, function () {
        if (_this2._renderNode) {
          _this2.picLoading = false;

          _this2._renderNode.layers.set(0);

          _this2._renderNode.frustumCulled = false;
          nodeManager.map.renderer.setImageMarkerSize(_this2._renderNode);
        } else {
          hidden = false;
        }
      }, this._depth, this._priority);
      material.userData.size = this._size;
      this._renderNode = new _Sprite.default(material);
      this._renderNode.markername = this.markername;

      if (hidden) {
        this.picLoading = true;

        this._renderNode.layers.set(2);
      }

      this._renderNode.mapNode = this;
      this._renderNode.parent = this.parent.scene;

      this._renderNode.center.set(this.center.x, this.center.y);

      nodeManager.map.renderer.setImageMarkerSize(this._renderNode);
      this._renderNode.visible = this.show;
      this._renderNode.name = "spirit"; //this._renderNode.frustumCulled = false; //由于sizeAttenuation属性的设置，导致由透视相机切换到正交相机时出现物体在视锥外的不正确剔除，所以关掉此属性让视锥外的物体不剔除

      this.isInitSprite = true;
      var gid = this.parent.parent.groupID;
      var center = this.parent.parent.parent.mapcenter;

      if (this._opx && this._opy) {
        this._x = this._opx;
        this._y = this._opy;
      } else {
        this._x = center.x;
        this._y = center.y;
      }

      this.setPosition(this.x, this.y, gid, this._offsetHeight);
      this._callBack && this._callBack(this);
      return true;
    } //根据楼层ID 以及对中心点的偏移量移动marker

    /**
     * 设置marker位置
     * @param {number} x 地图x坐标
     * @param {number} y 地图y坐标
     * @param {number} gid 楼层id
     * @param {number} height 偏移高度
     */

  }, {
    key: "setPosition",
    value: function setPosition(x, y, gid, hoffset) {
      var scene = this.findParent(_FMScene.default);

      if (!scene) {
        console.error("Can't change position before map init Marker");
        return;
      }

      if (typeof gid === "number" && gid > 0) {
        this.moveToGroup(gid);
      }

      var center = scene.center;
      var mcenter = scene.mapcenter;
      this._height = hoffset;
      this._x = x;
      this._y = y; // nodeManager.

      this._renderNode.position.set(this._x - mcenter.x, center.y + this._height, center.y - this._y + mcenter.y);
    }
    /*
     * 获取marker的地图坐标
     * @returns {json} {x:, y:, z:, groupID:}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return {
        x: this._y,
        y: this._y,
        z: this._height,
        groupID: this.parent.parent.groupID
      };
    }
    /**
     * 动画移动marker到指定位置
     * @param {json} params 
     *      @param {number} params.x 地图x坐标
     *      @param {number} params.y 地图y坐标
     *      @param {number} params.time 移动到指定位置所用的时间（秒）
     *      @param {function} params.callback 移动到指定位置后的回调函数
     *      @param {function} params.update 动画执行过程中位置更新时的回调函数，返回更新后的位置信息。
     */

  }, {
    key: "moveTo",
    value: function moveTo(params) {
      var _this3 = this;

      if (this._isMoving) return;
      var nodeManager = this.findParent(_NodeManager.default);
      var destx = params.x;
      var desty = params.y;
      var desth = null;

      if (!params.height) {
        desth = this._height;
      } else {
        desth = params.height;
      }

      var animater = new _Animater.default({
        x: this.x,
        y: this.y,
        height: this._height
      }, {
        x: destx,
        y: desty,
        height: desth
      }, params.time * 1000, function () {
        nodeManager.map.removeAnimater(animater);
        _this3._moveAnimater = null;
        _this3._isMoving = false;
        params.callback();
      }, function (coord) {
        _this3.setPosition(coord.x, coord.y, 0, coord.height);

        params.update(coord);
      }).start();
      this._isMoving = true;
      nodeManager.map.addAnimater(animater);
      this._moveAnimater = animater;
    }
    /**
     * 将marker移动到另一楼层
     * @param {number} gid 楼层id
     */

  }, {
    key: "moveToGroup",
    value: function moveToGroup(gid) {
      var nodeManager = this.findParent(_NodeManager.default);
      var currGid = this.parent.parent.groupID;

      if (currGid === gid) {
        return;
      }

      if (!this.parent.parent.parent.groups["" + gid]) {
        console.warn(_warnMessage.tileMessage.noGroup);
        return;
      }

      this._groupId = gid;
      var toLayer = this.parent.parent.parent.groups["" + gid].getOrCreateLayer("imageMarker");
      this.parent.untiedMarker(this);
      toLayer.addMarker(this);
      this._renderNode.material.opacity = 0.9;
      nodeManager.map.renderer.setImageMarkerSize(this._renderNode);
    }
    /**
     * 停止moveTo动画
     */

  }, {
    key: "stopMoveTo",
    value: function stopMoveTo() {
      var nodeManager = this.findParent(_NodeManager.default);
      this._moveAnimater && this._moveAnimater.stop();
      nodeManager.map.removeAnimater(this._moveAnimater);
      this._isMoving = false;
      this._moveAnimater = null;
    }
    /**
     * 图标标注跳动动画。
     * @param {json} params 
     *      @param {number} params.height 图标跳动的高度。
     *      @param {number} params.times 图标跳动次数。不设置该参数或设置为0时, 一直跳动。 
     *      @param {number} params.duration 单次跳动动画的持续时长（秒）。
     *      @param {number} params.delay 一次跳动完成到下次跳动开始的等待时长（秒）。
     */

  }, {
    key: "jump",
    value: function jump(params) {
      var _this4 = this;

      if (!this._renderNode || this._isJumping) {
        return;
      }

      this._isJumping = true;
      var option = (0, _assign.default)({
        'height': 8,
        'times': 0,
        'duration': 1,
        'delay': 0
      }, params);

      if (typeof option.height != 'number' || typeof option.times != 'number' || typeof option.duration != 'number' || typeof option.delay != 'number') {
        return;
      }

      option.duration *= 1000;
      option.delay *= 1000;
      option.all = option.duration + option.delay;
      option.halfDuration = option.duration / 2;
      var heightOffset = option.height - this._height;
      this._origonY = this._renderNode.position.y;
      var time = new Date().getTime();
      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;

      this.jumpEvent = function (event) {
        if (!_this4._renderNode) {
          map.off("frameLoop", _this4.jumpEvent);
          return;
        }

        var deltaTime = new Date().getTime() - time;

        if (option.times != 0 && deltaTime / option.all > option.times) {
          _this4.stopJump();

          return;
        }

        deltaTime = deltaTime % option.all;

        if (deltaTime > option.duration) {
          if (_this4._renderNode.position.y != _this4._origonY) {
            _this4._renderNode.position.y = _this4._origonY;
          }
        } else {
          var ratio = deltaTime / option.halfDuration - 1;
          ratio = 1.0 - ratio * ratio;
          _this4._renderNode.position.y = _this4._origonY + heightOffset * ratio;
        }
      };

      map.on("frameLoop", this.jumpEvent);
    }
    /**
     * 停止图标标注jump动画。
     */

  }, {
    key: "stopJump",
    value: function stopJump() {
      if (!this._renderNode || !this.jumpEvent) {
        return;
      }

      this._renderNode.position.y = this._origonY;
      this._isJumping = false;
      var nodeManager = this.findParent(_NodeManager.default);
      var map = nodeManager.map;
      map.off("frameLoop", this.jumpEvent);
    }
    /**
     * marker图片路径
     * @property {string} url 图片路径
     */

  }, {
    key: "setSize",
    value: function setSize() {
      var nodeManager = this.findParent(_NodeManager.default);
      nodeManager.map.renderer.setFacilitySize(this._renderNode, this._size);
    }
    /*
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.parent) {
        this.parent.removeMarker(this);
      }

      if (this._renderNode) {
        this._renderNode.material.dispose();

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      } // if (this._popWindow) {
      //     this._popWindow.close();
      //     this._popWindow = undefined;
      // }

    } // set popWindow(w) {
    //     this._popWindow = w;
    // }
    // get popWindow() {
    //     return this._popWindow;
    // }

  }, {
    key: "getCenterByAnchor",
    value: function getCenterByAnchor(anchor) {
      var center = new fm.Vector2(0.5, 0.5);

      switch (anchor) {
        case _FMMarkerAnchor.default.LEFT:
          center.setX(0.0);
          break;

        case _FMMarkerAnchor.default.RIGHT:
          center.setX(1.0);
          break;

        case _FMMarkerAnchor.default.TOP:
          center.setY(1.0);
          break;

        case _FMMarkerAnchor.default.BOTTOM:
          center.setY(0.0);
          break;

        case _FMMarkerAnchor.default.LEFT_TOP:
          center.set(0.0, 1.0);
          break;

        case _FMMarkerAnchor.default.RIGHT_TOP:
          center.set(1.0, 1.0);
          break;

        case _FMMarkerAnchor.default.LEFT_BOTTOM:
          center.set(0.0, 0.0);
          break;

        case _FMMarkerAnchor.default.RIGHT_BOTTOM:
          center.set(1.0, 0.0);
          break;
      }

      return center;
    }
  }, {
    key: "url",
    set: function set(url) {
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;
      var material = nodeManager.materialManager.createPoiMaterial({
        imageUrl: url,
        imageSrc: url,
        alpha: 1
      });
      material.userData.size = this._size;

      this._renderNode.material.dispose();

      this._renderNode.material = material;
      this._url = url;
    },
    get: function get() {
      return this._url;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    }
  }, {
    key: "visible",
    set: function set(bool) {
      if (bool) {
        if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
          this._renderNode && this.parent.scene.add(this._renderNode);
        }
      } else {
        this._renderNode && this.parent.scene.remove(this._renderNode);
      }

      this._visible = bool;
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    },
    set: function set(v) {
      this._size = v;
    }
  }, {
    key: "height",
    set: function set(height) {
      this._height = height;
      this._renderNode.position.y = this._height;
    }
  }]);
  return FMImageMarker;
}(_FMNode2.default);

var _default = FMImageMarker;
exports.default = _default;

/***/ }),
/* 424 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _assign = _interopRequireDefault(__webpack_require__(11));

__webpack_require__(112);

__webpack_require__(13);

__webpack_require__(68);

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _Sprite = _interopRequireDefault(__webpack_require__(111));

var _FMScene = _interopRequireDefault(__webpack_require__(150));

var _Animater = _interopRequireDefault(__webpack_require__(58));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _FMMarkerAnchor = _interopRequireDefault(__webpack_require__(153));

var _warnMessage = __webpack_require__(69);

/**
 *   FMTextMarker 自定义文本标注对象，为自定义图层。
 *   @class
 *   @memberof fengmap
 *   @extends { fengmap.FMNode }
 *   @param {json} opts
 *          @param {number} opts.x  标注地图位置x值
 *          @param {number} opts.y 标注地图位置y值
 *          @param {number} opts.height 标注地图位置高度值
 *          @param {string} opts.name  标注值
 *          @param {int} opts.fontsize    文本标注字号
 *          @param {string} opts.anchor  锚点位置
 *          @param {string} opts.fillcolor    文本标注填充色，rgb类型字符串。如"255 0 0"
 *          @param {string} opts.strokecolor    文本标注填充色，rgb类型字符串。如'255,255,0'
 *          @param {number} opts.alpha    文本标注透明度，0 - 1之间取值
 *          @param {bool} opts.depth    文本渲染深度 【true】：开启深度；【false】：关闭深度
 */
var FMTextMarker =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMTextMarker, _FMNode);

  function FMTextMarker(param, model) {
    var _this;

    (0, _classCallCheck2.default)(this, FMTextMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMTextMarker).call(this, 0, _FMNodeType.default.TEXT_MARKER));
    _this._text = param.name;
    _this._param = param;
    _this.isInitSprite = false;
    _this._opx = param.x || 0;
    _this._opy = param.y || 0;
    _this._height = param.height || 0;
    _this._renderNode = null;
    _this._visible = true;
    _this._isRuning = false;
    _this._size = param.fontsize * 1.4;
    _this._callBack = param.callback;
    _this._fillcolor = param.fillcolor;
    _this._platecolor = param.platecolor;
    _this._platestrokecolor = param.platestrokecolor;
    _this._fontsize = param.fontsize;
    _this._strokecolor = param.strokecolor;
    _this._content = param.content;
    _this.needAvoid = false;

    if (!_this._content) {
      _this.needAvoid = true;

      var texts = _this._text.split("%rn%");

      var contents = [];

      for (var i = 0; i < texts.length; i++) {
        contents.push({
          text: texts[i],
          fontsize: _this._fontsize,
          fontcolor: _this._fillcolor,
          strokecolor: _this._strokecolor
        });
      }

      _this._content = contents;
    }

    _this._scale = param.scale;
    _this._target = model;
    _this._moveAnimater = null;
    _this.center = _this.getCenterByAnchor(param.anchor);
    _this.picLoading = false;
    return _this;
  }

  (0, _createClass2.default)(FMTextMarker, [{
    key: "getCenterByAnchor",
    value: function getCenterByAnchor(anchor) {
      var center = new fm.Vector2(0.5, 0.5);

      switch (anchor) {
        case _FMMarkerAnchor.default.LEFT:
          center.setX(0.0);
          break;

        case _FMMarkerAnchor.default.RIGHT:
          center.setX(1.0);
          break;

        case _FMMarkerAnchor.default.TOP:
          center.setY(1.0);
          break;

        case _FMMarkerAnchor.default.BOTTOM:
          center.setY(0.0);
          break;

        case _FMMarkerAnchor.default.LEFT_TOP:
          center.set(0.0, 1.0);
          break;

        case _FMMarkerAnchor.default.RIGHT_TOP:
          center.set(1.0, 1.0);
          break;

        case _FMMarkerAnchor.default.LEFT_BOTTOM:
          center.set(0.0, 0.0);
          break;

        case _FMMarkerAnchor.default.RIGHT_BOTTOM:
          center.set(1.0, 0.0);
          break;
      }

      return center;
    }
  }, {
    key: "initSprite",
    value: function initSprite() {
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;
      var material = nodeManager.materialManager.createTextMaterial(this._content, (0, _assign.default)({
        alpha: 1
      }, this._param), this._param.depth);
      this._size = material.size;
      material.userData.size = material.size;
      this._renderNode = new _Sprite.default(material);
      this._renderNode.mapNode = this;
      this._renderNode.frustumCulled = false;

      if (this._target) {
        this.setTsize();
      } else {
        nodeManager.map.renderer.setLabelSize(this._renderNode, material.size);
      }

      this._renderNode.center.set(this.center.x, this.center.y);

      this.isInitSprite = true;
      var center = this.parent.parent.parent.mapcenter;

      if (this._target) {
        var coord = this._target.mapCoord;
        this._x = coord.x;
        this._y = coord.y;
      } else {
        if (this._opx && this._opy) {
          this._x = this._opx;
          this._y = this._opy;
        } else {
          this._x = center.x;
          this._y = center.y;
        }
      }

      if (!this._height) {// this._height = this.parent.parent.height;
      }

      this.setPosition(this.x, this.y, 0, this._height);
      this._callBack && this._callBack();
      this._renderNode.visible = this.show;
      this._renderNode.name = "spirit";
      return true;
    }
  }, {
    key: "redraw",
    value: function redraw() {
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;

      if (this.renderNode) {
        var material = nodeManager.materialManager.createTextMaterial(this._content, (0, _assign.default)({
          alpha: 1
        }, this._param));
        this.renderNode.material.map.dispose();
        this.renderNode.material.dispose();
        this.renderNode.material = material;
      }
    }
  }, {
    key: "setTsize",
    value: function setTsize() {
      var model = this._target;
      var nearestDis = model.getNearestDis();

      if (this.renderNode) {
        this.setSize(nearestDis * this._scale);
        this.renderNode.material.sizeAttenuation = true;
      }
    }
  }, {
    key: "setSize",
    value: function setSize(scale) {
      var nodeManager = this.findParent(_NodeManager.default);
      this._size = scale;
      nodeManager.map.renderer.setLabelSize(this._renderNode, scale ? scale : this._size, scale ? true : false);
    }
    /**
     * 设置marker位置
     * @param {number} x 地图x坐标
     * @param {number} y 地图y坐标
     * @param {number} groupID 楼层id
     * @param {number} height 偏移高度
     */

  }, {
    key: "setPosition",
    value: function setPosition(x, y, groupID, height) {
      var scene = this.findParent(_FMScene.default);

      if (!scene) {
        console.error("Can't change position before map init Marker");
        return;
      }

      if (typeof groupID === "number" && groupID > 0) {
        this.moveToGroup(groupID);
      }

      var center = scene.mapcenter;
      this._height = height;
      this._x = x;
      this._y = y; // nodeManager.

      this._renderNode.position.set(this._x - center.x, this._height, -this._y + center.y);
    }
    /**
     * 获取marker的地图坐标
     * @returns {json} {x:, y:, z:, groupID:}
     */

  }, {
    key: "getPosition",
    value: function getPosition() {
      return {
        x: this._x,
        y: this._y,
        z: this._height,
        groupID: this.parent.parent.groupID
      };
    }
    /**
     * 动画移动marker到指定位置
     * @param {json} params 
     *      @param {number} params.x 地图x坐标
     *      @param {number} params.y 地图y坐标
     *      @param {number} params.time 移动到指定位置所用的时间（秒）
     *      @param {function} params.callback 移动到指定位置后的回调函数
     *      @param {function} params.update 动画执行过程中位置更新时的回调函数，返回更新后的位置信息。
     */

  }, {
    key: "moveTo",
    value: function moveTo(params) {
      var _this2 = this;

      if (this._isRuning) return;
      var nodeManager = this.findParent(_NodeManager.default);
      var destx = params.x;
      var desty = params.y;
      var animater = new _Animater.default({
        x: this.x,
        y: this.y
      }, {
        x: destx,
        y: desty
      }, params.time * 1000, function () {
        nodeManager.map.removeAnimater(animater);
        _this2._moveAnimater = null;
        _this2._isRuning = false;
        params.callback();
      }, function (coord) {
        _this2.setPosition(coord.x, coord.y, 0, 0);

        params.update(coord);
      }).start();
      this._isRuning = true;
      nodeManager.map.addAnimater(animater);
      this._moveAnimater = animater;
    }
    /**
     * 将marker移动到另一楼层
     * @param {number} groupID 楼层id
     */

  }, {
    key: "moveToGroup",
    value: function moveToGroup(groupID) {
      var nodeManager = this.findParent(_NodeManager.default);
      var currGid = this.parent.parent.groupID;

      if (currGid === groupID) {
        return;
      }

      if (!this.parent.parent.parent.groups["" + groupID]) {
        console.warn(_warnMessage.tileMessage.noGroup);
        return;
      }

      var toLayer = this.parent.parent.parent.groups["" + groupID].getOrCreateLayer("textMarker");
      this._groupId = groupID;
      this.parent.untiedMarker(this);
      this._renderNode.material.opacity = 0.9;
      toLayer.addMarker(this);
      nodeManager.map.renderer.setLabelSize(this._renderNode, this._renderNode.material.userData.size);
    }
    /**
     * 停止moveTo动画
     */

  }, {
    key: "stopMoveTo",
    value: function stopMoveTo() {
      var nodeManager = this.findParent(_NodeManager.default);
      this._moveAnimater && this._moveAnimater.stop();
      nodeManager.map.removeAnimater(this._moveAnimater);
    }
    /*
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode) {
        this._renderNode.material.texture && this._renderNode.material.texture.dispose();

        this._renderNode.material.dispose();

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }
    }
    /**
     * 文字内容
     * @property {string} name 文字内容
     */

  }, {
    key: "reDraw",
    value: function reDraw() {
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;
      var material = nodeManager.materialManager.createLabelMaterial(this._text, (0, _assign.default)({
        alpha: 1
      }, this._param));
      material.userData.size = this._size;

      this._renderNode.material.dispose();

      this._renderNode.material = undefined;
      this._renderNode.material = material;
      nodeManager.map.renderer.setLabelSize(this._renderNode, this._size);
    }
  }, {
    key: "name",
    set: function set(name) {
      this._text = name;
      this.reDraw();
    },
    get: function get() {
      return this._text;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    }
  }, {
    key: "visible",
    set: function set(bool) {
      if (bool) {
        if (this.parent.scene.children.indexOf(this._renderNode) < 0) {
          this._renderNode && this.parent.scene.add(this._renderNode);
        }
      } else {
        this._renderNode && this.parent.scene.remove(this._renderNode);
      }

      this._visible = bool;
    },
    get: function get() {
      return this._visible;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
    /**
     * 文字填充色
     * @property {string|number} fillcolor 文字填充色
     * @readonly
     */

  }, {
    key: "fillcolor",
    get: function get() {
      return this._fillcolor;
    },
    set: function set(v) {
      this._fillcolor = v;
      this._param.fillcolor = v;
      this.reDraw();
    }
    /**
     * 文字字号
     * @property {number} fontsize 文字字号
     * @readonly
     */

  }, {
    key: "fontsize",
    get: function get() {
      return this._fontsize;
    }
    /**
     * 文字边线颜色
     * @property {string|number} strokecolor 文字边线色
     * @readonly
     */

  }, {
    key: "strokecolor",
    get: function get() {
      return this._strokecolor;
    },
    set: function set(v) {
      this._strokecolor = v;
      this._param.strokecolor = v;
      this.reDraw();
    }
  }, {
    key: "content",
    set: function set(v) {
      this._content = v;
    }
  }, {
    key: "height",
    set: function set(height) {
      this._height = height;
      this._renderNode.position.y = this._height;
    }
  }]);
  return FMTextMarker;
}(_FMNode2.default);

var _default = FMTextMarker;
exports.default = _default;

/***/ }),
/* 425 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _LineGeometry = __webpack_require__(241);

var _LineMaterial = __webpack_require__(154);

var _Line = __webpack_require__(426);

/**
 * @author Mif / Made on May 19, 2020/
 */

/**
 * @class
 * @memberof fengmap
 */
var FMFlowLineMarker =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMFlowLineMarker, _FMNode);

  /**
   * FMFlowLineMarker 是一种具有流动颜色、可配和发光特效使用、可自定义线宽的线形标注
   * @param {Object} options 配置参数
   * @param {number} options.lineLength 流线流光的长度，以最小两顶点距离为单位长度
   * @param {Object} options.center 流线中心点坐标
   * @param {array} options.points 流线顶点坐标
   * @param {string} options.backgroundColor 流线背景颜色
   * @param {string} options.color 流线流光颜色
   * @param {number} options.opacity 流线透明度
   * @param {number} options.lineWidth 流线宽度（像素计）
   * @param {number} options.speed 流线流光速度，取值范围0-1
   */
  function FMFlowLineMarker(options) {
    var _this;

    (0, _classCallCheck2.default)(this, FMFlowLineMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMFlowLineMarker).call(this, options));
    _this._renderNode = null;
    _this._lineLength = typeof options.lineLength !== "undefined" ? options.lineLength : 5;
    _this._center = options.center;
    _this._minDistance = _this._getMinDistance(options.points);
    _this._points = _this._getPoints(options.points);
    _this._backgroundColor = options.backgroundColor;
    _this._color = options.color;
    _this._colors = _this._getColor();
    _this._opacity = options.opacity;
    _this._lineWidth = options.lineWidth;
    _this._speed = options.speed;
    _this._show = true;
    return _this;
  }

  (0, _createClass2.default)(FMFlowLineMarker, [{
    key: "initLine",
    value: function initLine() {
      var meshLine = new _LineGeometry.LineGeometry();
      meshLine.setPositions(this._points);
      meshLine.setColors(this._colors);
      var material = new _LineMaterial.LineMaterial({
        lineWidth: this._lineWidth,
        vertexColors: fm.VertexColors
      });
      material.uniforms["opacity"].value = this._opacity;
      material.resolution.set(this.parent.parent.parent.parent._map.renderer._w, this.parent.parent.parent.parent._map.renderer._h);
      this._renderNode = new _Line.Line2(meshLine, material);
      this._renderNode.mapNode = this;
      this._renderNode.name = "line";
      this._renderNode.userData.colors = this._colors;
      this._renderNode.userData.speed = this._speed;
      this._renderNode.userData.frustumUpdate = true;
      this._renderNode.userData.time = new Date().getTime();
      var center = this.parent.parent.parent.mapcenter;
      this._x = center.x;
      this._y = center.y;
    }
  }, {
    key: "_getMinDistance",
    value: function _getMinDistance(points) {
      var minDistance = 0;
      var distance = 0;

      for (var i = 0; i < points.length; i += 3) {
        var pos1 = new fm.Vector3(points[i], points[i + 2], -points[i + 1]);
        var pos2 = new fm.Vector3(points[i + 3], points[i + 5], -points[i + 4]);
        distance = pos1.distanceToSquared(pos2);

        if (i === 0) {
          minDistance = pos1.distanceToSquared(pos2);
        } else {
          if (distance < minDistance) minDistance = distance;
        }
      }

      return Math.sqrt(minDistance);
    }
  }, {
    key: "_getPoints",
    value: function _getPoints(points) {
      var pointArr = [];

      for (var i = 0; i < points.length - 3; i += 3) {
        var pos1 = new fm.Vector3(points[i] - this._center.x, points[i + 2], -points[i + 1] + this._center.y);
        var pos2 = new fm.Vector3(points[i + 3] - this._center.x, points[i + 5], -points[i + 4] + this._center.y);
        var line = new fm.LineCurve3(pos1, pos2);
        var distance = pos1.distanceTo(pos2);
        var segment = Math.ceil(distance / (this._minDistance * this._lineLength));
        var data = line.getPoints(segment);

        for (var a = 0; a < data.length; a++) {
          pointArr.push(data[a].x, data[a].y, data[a].z);
        }
      }

      return pointArr;
    }
  }, {
    key: "_getColor",
    value: function _getColor() {
      var colorArr = [];
      var colors = new fm.Color(this._color);
      var bgColors = new fm.Color(this._backgroundColor);

      for (var i = 0; i < this._points.length / 3; i++) {
        if (i * 3 < 3 * this._lineLength) {
          colorArr.push(colors.r, colors.g, colors.b);
        } else {
          colorArr.push(bgColors.r, bgColors.g, bgColors.b);
        }
      }

      return colorArr;
    }
    /**
     * 设置流光颜色
     * @param {string} color 流光颜色
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      this._color = color;
      this._colors = this._getColor();
      this._renderNode.userData.colors = this._colors;
    }
    /**
     * 设置流线背景色
     * @param {string} color 流线背景色
     */

  }, {
    key: "setBackgroundColor",
    value: function setBackgroundColor(color) {
      this._backgroundColor = color;
      this._colors = this._getColor();
      this._renderNode.userData.colors = this._colors;
    }
    /**
     * 设置流线透明度
     * @param {number} value 流线透明度，取值0-1
     */

  }, {
    key: "setOpacity",
    value: function setOpacity(value) {
      this._renderNode.material.uniforms["opacity"].vaule = value;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    }
  }, {
    key: "show",
    get: function get() {
      return this._show;
    }
    /**
     * 是否显示marker
     * @property {boolean} bool true,显示；false，隐藏
     */
    ,
    set: function set(bool) {
      this._renderNode.visible = bool;
      this._show = bool;
      this._renderNode.userData.frustumUpdate = true;
    }
  }]);
  return FMFlowLineMarker;
}(_FMNode2.default);

var _default = FMFlowLineMarker;
exports.default = _default;

/***/ }),
/* 426 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.Line2 = void 0;

var _create = _interopRequireDefault(__webpack_require__(31));

var _assign = _interopRequireDefault(__webpack_require__(11));

var _LineSegments = __webpack_require__(427);

var _LineGeometry = __webpack_require__(241);

var _LineMaterial = __webpack_require__(154);

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */
var Line2 = function Line2(geometry, material) {
  _LineSegments.LineSegments2.call(this);

  this.type = 'Line2';
  this.geometry = geometry !== undefined ? geometry : new _LineGeometry.LineGeometry();
  this.material = material !== undefined ? material : new _LineMaterial.LineMaterial({
    color: Math.random() * 0xffffff
  });
};

exports.Line2 = Line2;
Line2.prototype = (0, _assign.default)((0, _create.default)(_LineSegments.LineSegments2.prototype), {
  constructor: Line2,
  isLine2: true
});

/***/ }),
/* 427 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.LineSegments2 = void 0;

__webpack_require__(25);

var _create = _interopRequireDefault(__webpack_require__(31));

var _assign = _interopRequireDefault(__webpack_require__(11));

var _three = __webpack_require__(81);

var _LineSegmentsGeometry = __webpack_require__(242);

var _LineMaterial = __webpack_require__(154);

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */
var LineSegments2 = function LineSegments2(geometry, material) {
  _three.Mesh.call(this);

  this.type = 'LineSegments2';
  this.geometry = geometry !== undefined ? geometry : new _LineSegmentsGeometry.LineSegmentsGeometry();
  this.material = material !== undefined ? material : new _LineMaterial.LineMaterial({
    color: Math.random() * 0xffffff
  });
};

exports.LineSegments2 = LineSegments2;
LineSegments2.prototype = (0, _assign.default)((0, _create.default)(_three.Mesh.prototype), {
  constructor: LineSegments2,
  isLineSegments2: true,
  computeLineDistances: function () {
    // for backwards-compatability, but could be a method of LineSegmentsGeometry...
    var start = new _three.Vector3();
    var end = new _three.Vector3();
    return function computeLineDistances() {
      var geometry = this.geometry;
      var instanceStart = geometry.attributes.instanceStart;
      var instanceEnd = geometry.attributes.instanceEnd;
      var lineDistances = new Float32Array(2 * instanceStart.data.count);

      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {
        start.fromBufferAttribute(instanceStart, i);
        end.fromBufferAttribute(instanceEnd, i);
        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);
      }

      var instanceDistanceBuffer = new _three.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1

      geometry.setAttribute('instanceDistanceStart', new _three.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0

      geometry.setAttribute('instanceDistanceEnd', new _three.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1

      return this;
    };
  }(),
  raycast: function () {
    var start = new _three.Vector4();
    var end = new _three.Vector4();
    var ssOrigin = new _three.Vector4();
    var ssOrigin3 = new _three.Vector3();
    var mvMatrix = new _three.Matrix4();
    var line = new _three.Line3();
    var closestPoint = new _three.Vector3();
    return function raycast(raycaster, intersects) {
      if (raycaster.camera === null) {
        console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');
      }

      var ray = raycaster.ray;
      var camera = raycaster.camera;
      var projectionMatrix = camera.projectionMatrix;
      var geometry = this.geometry;
      var material = this.material;
      var resolution = material.resolution;
      var lineWidth = material.linewidth;
      var instanceStart = geometry.attributes.instanceStart;
      var instanceEnd = geometry.attributes.instanceEnd; // pick a point 1 unit out along the ray to avoid the ray origin
      // sitting at the camera origin which will cause "w" to be 0 when
      // applying the projection matrix.

      ray.at(1, ssOrigin); // ndc space [ - 1.0, 1.0 ]

      ssOrigin.w = 1;
      ssOrigin.applyMatrix4(camera.matrixWorldInverse);
      ssOrigin.applyMatrix4(projectionMatrix);
      ssOrigin.multiplyScalar(1 / ssOrigin.w); // screen space

      ssOrigin.x *= resolution.x / 2;
      ssOrigin.y *= resolution.y / 2;
      ssOrigin.z = 0;
      ssOrigin3.copy(ssOrigin);
      var matrixWorld = this.matrixWorld;
      mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);

      for (var i = 0, l = instanceStart.count; i < l; i++) {
        start.fromBufferAttribute(instanceStart, i);
        end.fromBufferAttribute(instanceEnd, i);
        start.w = 1;
        end.w = 1; // camera space

        start.applyMatrix4(mvMatrix);
        end.applyMatrix4(mvMatrix); // clip space

        start.applyMatrix4(projectionMatrix);
        end.applyMatrix4(projectionMatrix); // ndc space [ - 1.0, 1.0 ]

        start.multiplyScalar(1 / start.w);
        end.multiplyScalar(1 / end.w); // skip the segment if it's outside the camera near and far planes

        var isBehindCameraNear = start.z < -1 && end.z < -1;
        var isPastCameraFar = start.z > 1 && end.z > 1;

        if (isBehindCameraNear || isPastCameraFar) {
          continue;
        } // screen space


        start.x *= resolution.x / 2;
        start.y *= resolution.y / 2;
        end.x *= resolution.x / 2;
        end.y *= resolution.y / 2; // create 2d segment

        line.start.copy(start);
        line.start.z = 0;
        line.end.copy(end);
        line.end.z = 0; // get closest point on ray to segment

        var param = line.closestPointToPointParameter(ssOrigin3, true);
        line.at(param, closestPoint); // check if the intersection point is within clip space

        var zPos = _three.Math.lerp(start.z, end.z, param);

        var isInClipSpace = zPos >= -1 && zPos <= 1;
        var isInside = ssOrigin3.distanceTo(closestPoint) < lineWidth * 0.5;

        if (isInClipSpace && isInside) {
          line.start.fromBufferAttribute(instanceStart, i);
          line.end.fromBufferAttribute(instanceEnd, i);
          line.start.applyMatrix4(matrixWorld);
          line.end.applyMatrix4(matrixWorld);
          var pointOnLine = new _three.Vector3();
          var point = new _three.Vector3();
          ray.distanceSqToSegment(line.start, line.end, point, pointOnLine);
          intersects.push({
            point: point,
            pointOnLine: pointOnLine,
            distance: ray.origin.distanceTo(point),
            object: this,
            face: null,
            faceIndex: i,
            uv: null,
            uv2: null
          });
        }
      }
    };
  }()
});

/***/ }),
/* 428 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _LocationGeometry = _interopRequireDefault(__webpack_require__(429));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _Animater = _interopRequireDefault(__webpack_require__(58));

var _warnMessage = __webpack_require__(69);

/**
 * FMLocationMarker 自定义定位标注对象，为自定义图层。
 * @class
 * @memberof fengmap
 * @extends {fengmap.FMNode}
 * @param {json} opts
 *          @param {number} opts.x  图片地图位置x值
 *          @param {number} opts.y 图片地图位置y值
 *          @param {int} opts.groupID 楼层id,决定定位标注的高度
 *          @param {number} opts.size  图片尺寸，size= 长 = 宽
 *          @param {string} opts.url 图片地址
 *          @param {number} opts.height  标注高度
 */
var FMLocationMarker =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMLocationMarker, _FMNode);

  function FMLocationMarker(param) {
    var _this;

    (0, _classCallCheck2.default)(this, FMLocationMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMLocationMarker).call(this, 0, _FMNodeType.default.LOCATION_MARKER));
    _this._size = param.size || 20;
    _this._url = param.url;
    _this._groupId = param.groupID || 1;
    _this._x = param.x || _this._x;
    _this._y = param.y || _this._y;
    _this._dheight = param.height || 2.1;
    _this._gid = param.groupID || 1;
    _this._scene = null;
    _this._renderNode = null;
    _this._map = null;
    _this._callBack = param.callback;
    _this.rotateAnimater = null;
    return _this;
  }

  (0, _createClass2.default)(FMLocationMarker, [{
    key: "initSprite",
    value: function initSprite(nodeManager) {
      var _this2 = this;

      var geometry = new _LocationGeometry.default();
      var material = new fm.MeshBasicMaterial();
      var hidden = true;
      nodeManager.materialManager.loadTexture(this._url, function (texture) {
        // material.map = texture;
        texture.minFilter = fm.LinearFilter;
        texture.generateMipmaps = false;
        texture.flipY = false;
        material.map = texture;
        material.needsUpdate = true;

        if (_this2._renderNode) {
          _this2.picLoading = false;

          _this2._renderNode.layers.set(0);
        } else {
          hidden = false;
        }
      });
      material.side = 2; //double side

      material.transparent = true;
      this._renderNode = new fm.Mesh(geometry, material);
      this._renderNode.mapNode = this;

      if (hidden) {
        this.picLoading = true;

        this._renderNode.layers.set(2);
      }

      var center = this._scene.mapcenter;

      if (!this._x || !this._y) {
        this._x = center.x;
        this._y = center.y;
      }

      this._callBack && this._callBack(this);
      this.setPosition({
        x: this._x,
        y: this._y
      });
      return true;
    }
    /**
     * 设置Marker的位置。
     * @param {json} param
     *        @param {number} param.x 地图坐标x值
     *        @param {number} param.y 地图坐标y值
     *        @param {int} param.groupID 楼层id,决定定位标注的高度
     *        @param {number} param.height 标注高度
     */

  }, {
    key: "setPosition",
    value: function setPosition(param) {
      if (!this._scene) {
        console.error("Can't change position before map init Marker");
        return;
      }

      if (param.zOffset !== undefined) {
        this._dheight = param.zOffset;
      }

      ;

      if (param.height !== undefined) {
        this._dheight = param.height;
      }

      ;
      var group = this._scene.groups[this._gid];

      if (param.groupID && param.groupID !== this._gid) {
        var groupOld = group;
        var groupNew = this._scene.groups[param.groupID];

        if (!groupNew) {
          console.warn(_warnMessage.tileMessage.noGroup);
          return;
        }

        groupOld.removeLocation(this);
        groupNew.addLocation(this);
        group = groupNew;

        if (this.isAlwaysShow) {
          this.alwaysShow();
        }

        this._gid = param.groupID;
        this._groupId = this._gid;
      }

      var center = this._scene.mapcenter;
      this._x = param.x;
      this._y = param.y; // nodeManager.

      this._renderNode.position.set(this._x - center.x, this._dheight, -this._y + center.y);
    }
    /**
     * 将locationMarker水平旋转至特定角度，不带动画
     * @param {number} angle 角度
     */

  }, {
    key: "rotate",
    value: function rotate(angle) {
      this._renderNode.rotation.y = angle * fm.Math.DEG2RAD;
      ;
    }
    /**
     * 将locationMarker水平旋转至特定角度，带动画
        * @param {json} params 
        *      @param {number} params.to 角度
        *      @param {number} params.duration 动画持续时间
        *      @param {function} params.callback 移动到指定位置后的回调函数
        *      @param {function} params.update 动画执行过程中位置更新时的回调函数，返回更新后的位置信息。
     */

  }, {
    key: "rotateTo",
    value: function rotateTo(params) {
      var _this3 = this;

      var srcTheta = this.renderNode.rotation.y;
      var destTheta = params.to % 360 * fm.Math.DEG2RAD;
      var temp = destTheta;
      var dtheta = 0;

      if (destTheta - srcTheta != 0) {
        dtheta = Math.sin(destTheta - srcTheta) / Math.abs(Math.sin(destTheta - srcTheta)) * Math.acos(Math.cos(destTheta - srcTheta));
      }

      var dest = srcTheta + dtheta;
      var src = srcTheta;

      if (this.rotateAnimater) {
        this.rotateAnimater.stop();

        this._map.removeAnimater(this.rotateAnimater); // this._renderNode.rotation.y = temp;

      }

      var animater = new _Animater.default({
        angle: src
      }, {
        angle: dest
      }, params.duration ? params.duration * 1000 : 500, function () {
        _this3._map.removeAnimater(animater);

        _this3.rotateAnimater = null;
        _this3._renderNode.rotation.y = temp;
        params.callback && params.callback();
      }, function (cast) {
        _this3._renderNode.rotation.y = cast.angle;
        params.update && params.update();
      }).start();

      this._map.addAnimater(animater);

      this.rotateAnimater = animater;
    }
    /**
     * 动画移动marker到指定位置
     * @param {json} params 
     *      @param {number} params.x 地图x坐标
     *      @param {number} params.y 地图y坐标
     *      @param {number} params.time 移动到指定位置所用的时间（秒）
     *      @param {function} params.callback 移动到指定位置后的回调函数
     *      @param {function} params.update 动画执行过程中位置更新时的回调函数，返回更新后的位置信息。
     */

  }, {
    key: "moveTo",
    value: function moveTo(params) {
      var _this4 = this;

      if (this._isRuning) return;
      var destx = params.x;
      var desty = params.y;
      var animater = new _Animater.default({
        x: this._x,
        y: this._y
      }, {
        x: destx,
        y: desty
      }, params.time ? params.time * 1000 : 500, function () {
        _this4._map.removeAnimater(animater);

        _this4._isRuning = false;
        params.callback && params.callback();
      }, function (coord) {
        _this4.setPosition({
          x: coord.x,
          y: coord.y,
          groupID: 0,
          height: _this4._dheight
        });

        params.update && params.update(coord);
      }).start();
      this._isRuning = true;

      this._map.addAnimater(animater);
    }
  }, {
    key: "alwaysShow",
    value: function alwaysShow() {
      this._alwaysShow = true;
      var group;
      var parent = this.parent;

      while (parent) {
        if (parent.isGroup) {
          group = parent;
          break;
        }

        parent = parent.parent;
      }

      if (group) {
        if (this.renderNode) {
          this.renderNode.material.depthTest = false;
          group.alwaysShowMarkers.push(this.renderNode);
        }
      }
    }
    /*
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this.parent) {
        this.parent.removeLocation(this);
      }

      this.parent = null;

      if (this._renderNode) {
        this._renderNode.material.dispose();

        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }
    }
    /**
     * 方向
     * @property {number} direction 方向
     */

  }, {
    key: "direction",
    get: function get() {
      return this.renderNode.rotation.y;
    },
    set: function set(value) {
      this.renderNode.rotation.y = value * fm.Math.DEG2RAD;
    }
  }, {
    key: "scene",
    set: function set(s) {
      this._scene = s;
    }
  }, {
    key: "map",
    set: function set(map) {
      this._map = map;
    }
  }, {
    key: "size",
    get: function get() {
      return this._size;
    }
  }, {
    key: "renderNode",
    get: function get() {
      return this._renderNode;
    }
  }, {
    key: "groupID",
    get: function get() {
      return this._groupId;
    }
  }, {
    key: "height",
    get: function get() {
      return this._dheight;
    }
  }]);
  return FMLocationMarker;
}(_FMNode2.default);

var _default = FMLocationMarker;
exports.default = _default;

/***/ }),
/* 429 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(25);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var LocationGeometry =
/*#__PURE__*/
function (_fm$BufferGeometry) {
  (0, _inherits2.default)(LocationGeometry, _fm$BufferGeometry);

  function LocationGeometry() {
    var _this;

    (0, _classCallCheck2.default)(this, LocationGeometry);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LocationGeometry).call(this));
    var float32Array = new Float32Array([-0.5, 0, -0.5, 0, 0, 0.5, 0, -0.5, 1, 0, 0.5, 0, 0.5, 1, 1, -0.5, 0, 0.5, 0, 1]);
    var interleavedBuffer = new fm.InterleavedBuffer(float32Array, 5);

    _this.setIndex([0, 1, 2, 0, 2, 3]);

    _this.addAttribute('position', new fm.InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));

    _this.addAttribute('uv', new fm.InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));

    return _this;
  }

  return LocationGeometry;
}(fm.BufferGeometry);

var _default = LocationGeometry;
exports.default = _default;

/***/ }),
/* 430 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _LineSegments2 = _interopRequireDefault(__webpack_require__(431));

var _LineGeometry = _interopRequireDefault(__webpack_require__(245));

var _LineMaterial = _interopRequireDefault(__webpack_require__(244));

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */
var Line2 =
/*#__PURE__*/
function (_LineSegments) {
  (0, _inherits2.default)(Line2, _LineSegments);

  function Line2(geometry, material) {
    var _this;

    (0, _classCallCheck2.default)(this, Line2);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Line2).call(this, geometry, material));
    _this.type = 'Line2';
    _this.isLine2 = true;
    return _this;
  }

  (0, _createClass2.default)(Line2, [{
    key: "copy",
    value: function copy() {}
  }]);
  return Line2;
}(_LineSegments2.default);

;
var _default = Line2;
exports.default = _default;

/***/ }),
/* 431 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(25);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _LineSegmentsGeometry = _interopRequireDefault(__webpack_require__(246));

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 */
var LineSegments2 =
/*#__PURE__*/
function (_fm$Mesh) {
  (0, _inherits2.default)(LineSegments2, _fm$Mesh);

  function LineSegments2(geometry, material) {
    var _this;

    (0, _classCallCheck2.default)(this, LineSegments2);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(LineSegments2).call(this, geometry, material));
    _this.type = 'LineSegments2';
    _this.isLineSegments2 = true;
    return _this;
  }

  (0, _createClass2.default)(LineSegments2, [{
    key: "computeLineDistances",
    value: function computeLineDistances() {
      // for backwards-compatability, but could be a method of LineSegmentsGeometry...
      var start = new fm.Vector3();
      var end = new fm.Vector3();
      var geometry = this.geometry;
      var instanceStart = geometry.attributes.instanceStart;
      var instanceEnd = geometry.attributes.instanceEnd;
      var lineDistances = new Float32Array(2 * instanceStart.data.count);

      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {
        start.fromBufferAttribute(instanceStart, i);
        end.fromBufferAttribute(instanceEnd, i);
        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];
        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);
      }

      var instanceDistanceBuffer = new fm.InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1

      geometry.setAttribute('instanceDistanceStart', new fm.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0

      geometry.setAttribute('instanceDistanceEnd', new fm.InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1

      return this;
    }
  }, {
    key: "copy",
    value: function copy(source) {
      // todo
      return this;
    }
  }]);
  return LineSegments2;
}(fm.Mesh);

;
var _default = LineSegments2;
exports.default = _default;

/***/ }),
/* 432 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(25);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _FMLineMarker = _interopRequireDefault(__webpack_require__(155));

var _Graphics = _interopRequireDefault(__webpack_require__(49));

var _Centroid = _interopRequireDefault(__webpack_require__(248));

var _FMGeometryUtils = _interopRequireDefault(__webpack_require__(114));

var _FMMarker2 = _interopRequireDefault(__webpack_require__(249));

/**
 * @class FMPolygonMarker 自定义多边形标注对象，为自定义图层。
 * @memberof fengmap
 * @extends {fengmap.FMMarker}
 */
var FMPolygonMarker =
/*#__PURE__*/
function (_FMMarker) {
  (0, _inherits2.default)(FMPolygonMarker, _FMMarker);

  /**
   * @constructor
   * @param {json} param 参数
   * @param {number} param.alpha  多边形的透明度。0.0 - 1.0 之间取值, 默认为 1.0
   * @param {number} param.color  多边形的颜色
   * @param {number} param.height  多边形与楼层之间的高度, 默认为 1
   * @param {number} param.lineWidth  多边形边框线宽,默认为2
   * @param {number} param.lineColor  多边形边框线颜色。
   *
   * @param {array|json} param.points  1.array格式的为多边形的坐标点集数组。类似[{x: 12961583, y: 4861865, z: 56},{x: 12961644, y: 4861874, z: 56}]数组。2.json格式的为圆形或矩形的设置，具体参数如下：
   * @param {number} param.points[].x x坐标
   * @param {number} param.points[].y y坐标
   * @param {string} param.points.type  多边形图层类型。'circle'表示圆形；'rectangle' 表示矩形。
   * @param {json} param.points.center  圆形或矩形的中心点设置。
   * @param {number} param.points.radius  圆形的半径。
   * @param {number} param.points.segments  组成圆形的段数，默认40。值越大越接近圆。通常设置为近似圆的最小值，这样可以节省资源。
   * @param {json} param.points.startPoint  矩形的起始点设置，代表矩形的左上角。如存在center设置时，则优先使用stratPoint的值绘制矩形。
   * @param {number} param.points.width  矩形的宽度。
   * @param {number} param.points.height  矩形的高度。
   */
  function FMPolygonMarker(param) {
    var _this;

    (0, _classCallCheck2.default)(this, FMPolygonMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMPolygonMarker).call(this, 0, _FMNodeType.default.POLYGON_MARKER));
    _this._alpha = param.alpha !== undefined ? param.alpha : 1.0; // 透明度

    _this._color = param.color !== undefined ? param.color : "#FF0000"; // 颜色

    _this._dheight = param.height || 0;
    _this._lineColor = param.lineColor || param.color || "#FF0000";
    _this._lineWidth = typeof param.lineWidth === "number" ? param.lineWidth : 2;
    _this._points = param.points !== undefined ? param.points : [];

    if (param.points.type) {
      if (param.points.type === 'rectangle' && param.points.startPoint && param.points.startPoint.x && param.points.startPoint.y) {
        _this._x = param.points.startPoint.x + param.points.width / 2;
        _this._y = param.points.startPoint.y - param.points.height / 2;
      } else {
        _this._x = param.points.center.x;
        _this._y = param.points.center.y;
      }
    }

    _this._line = null;
    _this._linePoints = null; // 线的点 Float32Array

    return _this;
  }
  /***
   * 初始化
   * @returns {boolean}
   * @deprecated
   * @see this.init()
   */


  (0, _createClass2.default)(FMPolygonMarker, [{
    key: "initPolygon",
    value: function initPolygon() {
      return this.init();
    }
    /***
     * 初始化
     * @returns {boolean}
     */

  }, {
    key: "init",
    value: function init() {
      if (!this._points) return false;
      if (!this.parent) return false;
      if (!this.parent.parent) return false;
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;
      var style = {};
      style.resolution = new fm.Vector2(nodeManager.map.renderer.container.clientWidth, nodeManager.map.renderer.container.clientHeight);
      var camera = nodeManager.map.renderer.getCameraByViewMode(nodeManager.map._viewMode);
      style.near = camera.near;
      style.far = camera.far;
      style.color = this._lineColor;
      style.alpha = 1;
      style.lineWidth = this._lineWidth;
      var group = this.parent.parent;
      var material = new fm.MeshBasicMaterial();
      material.transparent = true;
      material.opacity = this._alpha;
      material.color = new fm.Color(this._color);
      material.side = 2;
      material.depthTest = false;
      var geometry,
          position,
          center = group.getCenterPosition(),
          sceneCenter = group.parent.mapcenter;
      var lineArray; // 存放一圈的点，起始点使用两次

      if (!this._x) {
        this._x = sceneCenter.x;
      }

      if (!this._y) {
        this._y = sceneCenter.y;
      }

      if (this._dheight) {
        this._height = this._dheight;
      } else {
        this._height = 0;
      } // 创建几何体


      switch (this._points.type) {
        case "circle":
          geometry = this.createCircleGeometry(this._points.radius, this._points.segments);
          lineArray = new Float32Array(geometry.attributes.position.array.length - 3);

          for (var i = 0; i < geometry.attributes.position.array.length; i++) {
            if (i > 2) {
              lineArray[i - 3] = geometry.attributes.position.array[i];
            }
          }

          break;

        case "rectangle":
          geometry = this.createReactGeometry(this._points.width, this._points.height);
          var lenr = geometry.attributes.position.array.length;
          var bufferArr = geometry.attributes.position.array;
          lineArray = new Float32Array(lenr + 3);

          for (var _i = 0; _i < lenr; _i++) {
            lineArray[_i] = geometry.attributes.position.array[_i];
          }

          lineArray[lenr - 6] = bufferArr[lenr - 3];
          lineArray[lenr - 5] = bufferArr[lenr - 2];
          lineArray[lenr - 4] = bufferArr[lenr - 1];
          lineArray[lenr - 3] = bufferArr[lenr - 6];
          lineArray[lenr - 2] = bufferArr[lenr - 5];
          lineArray[lenr - 1] = bufferArr[lenr - 4];
          lineArray[lenr] = bufferArr[0];
          lineArray[lenr + 1] = bufferArr[1];
          lineArray[lenr + 2] = bufferArr[2];
          break;

        default:
          geometry = _FMGeometryUtils.default.createShapeBufferGeometryByCenter(this._points, sceneCenter);
          var len = geometry.attributes.position.array.length;
          lineArray = new Float32Array(len + 3);

          for (var _i2 = 0; _i2 < len; _i2++) {
            lineArray[_i2] = geometry.attributes.position.array[_i2];
          }

          lineArray[len] = geometry.attributes.position.array[0];
          lineArray[len + 1] = geometry.attributes.position.array[1];
          lineArray[len + 2] = geometry.attributes.position.array[2];
          break;
      }

      this._linePoints = lineArray;
      var line = new _FMLineMarker.default();
      line.initLinePoints(lineArray, style);
      this._line = line;
      this._renderNode = new fm.Mesh(geometry, material);
      this._renderNode.mapNode = this;

      this._renderNode.add(line.renderNode);

      this._renderNode.rotation.set(Math.PI / 2, 0, 0, 'XYZ');

      this._renderNode.position.set(this._x - sceneCenter.x, this._height, -this._y + sceneCenter.y);

      return true;
    }
    /**
     * 检查多边形是否包含某一点
     * @param {json} point 坐标数据
     * @param {float} point.x 坐标x数据
     * @param {float} point.y 坐标y数据
     */

  }, {
    key: "contain",
    value: function contain(point) {
      if (!this._points) return false;
      if (!this.parent) return false;
      if (!this.parent.parent) return false;

      if (this._points.type === "circle") {
        var dis = Math.sqrt((point.x - this._x) * (point.x - this._x) + (point.y - this._y) * (point.y - this._y));
        if (dis < this._points.r) return true;
      } else if (this._points.type === "rectangle") {
        if (Math.abs(point.x - this._x) < this._points.width / 2 && Math.abs(point.y - this._y) < this._points.height / 2) {
          return true;
        }
      } else {
        return _Graphics.default.pointInPolygon2d(this._points, point, this._points.length);
      }

      return false;
    }
  }, {
    key: "createReactGeometry",
    value: function createReactGeometry(width, height) {
      return new fm.PlaneBufferGeometry(width, height);
    }
  }, {
    key: "createCircleGeometry",
    value: function createCircleGeometry(r, segments) {
      return new fm.CircleBufferGeometry(r, segments);
    }
    /***
     * 以给点给的中心点创建几何体
     * @param points {Array} 点数据
     * @param center {Vector2} 中心点
     * @deprecated
     * @see FMGeometryUtils.createShapeBufferGeometryByCenter
     * @returns {ShapeBufferGeometry|ShapeBufferGeometry}
     */

  }, {
    key: "createPolygonGeometry",
    value: function createPolygonGeometry(points, center) {
      var heartShape = new fm.Shape();

      for (var i = 0; i < points.length; i++) {
        if (i === 0) {
          heartShape.moveTo(points[i].x - center.x, -points[i].y + center.y);
        } else {
          heartShape.lineTo(points[i].x - center.x, -points[i].y + center.y);
        }
      }

      heartShape.lineTo(points[0].x - center.x, -points[0].y + center.y);
      return new fm.ShapeBufferGeometry(heartShape);
    }
    /**
     * 修改颜色
     * @param {string} color 如：'#ff0000'
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      this._renderNode.material.color = new fm.Color(color);
    }
    /**
     * 修改边线颜色
     * @param {string} color 如：'#ff0000'
     */

  }, {
    key: "setLineColor",
    value: function setLineColor(color) {
      this._line._renderNode.material.color = new fm.Color(color);
    }
    /**
     * 修改边线宽度
     * @param {number} val 线宽
     */

  }, {
    key: "setLineWidth",
    value: function setLineWidth(val) {
      this._renderNode.children[0].material.linewidth = val;
    }
    /**
     * 修改多边形面的透明度
     * @param {number} val 透明度
     */

  }, {
    key: "setAlpha",
    value: function setAlpha(val) {
      this._renderNode.material.opacity = val;
    }
    /**
     * 获取中心点坐标
     * @returns {{x: *, y: *, z: number}|{x: *, y: number, z: number}}
     */

  }, {
    key: "getPoints",

    /**
     * 获取顶点坐标数据
     * @returns {Array}
     */
    value: function getPoints() {
      if (this._points.type === "circle") {
        var geometry = null;
        var arr = [];
        geometry = this.createCircleGeometry(this._points.radius, this._points.segments);

        for (var i = 1; i < geometry.attributes.position.count; i++) {
          arr.push({
            x: geometry.attributes.position.array[i * 3] + this._x,
            y: geometry.attributes.position.array[i * 3 + 1] + this._y
          });
        }

        geometry.dispose();
        return arr;
      } else if (this._points.type === "rectangle") {
        var _geometry = null;
        var _arr = [];
        _geometry = this.createReactGeometry(this._points.width, this._points.height);

        _arr.push({
          x: _geometry.attributes.position.array[0] + this._x,
          y: _geometry.attributes.position.array[1] + this._y
        });

        _arr.push({
          x: _geometry.attributes.position.array[3] + this._x,
          y: _geometry.attributes.position.array[4] + this._y
        });

        _arr.push({
          x: _geometry.attributes.position.array[9] + this._x,
          y: _geometry.attributes.position.array[10] + this._y
        });

        _arr.push({
          x: _geometry.attributes.position.array[6] + this._x,
          y: _geometry.attributes.position.array[7] + this._y
        });

        _geometry.dispose();

        return _arr;
      } else {
        return this._points;
      }
    }
  }, {
    key: "center",
    get: function get() {
      var group = this.parent.parent;
      var sceneCenter = group.parent.mapcenter;
      var poly = [];

      for (var i = 0; i < this._linePoints.length; i += 3) {
        poly.push([this._linePoints[i], this._linePoints[i + 1]]);
      }

      var center = null;
      center = (0, _Centroid.default)([poly], 0.01);

      if (this._points.type != "circle" && this._points.type != "rectangle") {
        return {
          x: this._x + center[0],
          y: this._y - center[1],
          z: this._height
        };
      }

      return {
        x: this._x + center[0],
        y: this._y + center[1],
        z: this._height
      };
    }
    /***
     * @deprecated
     * @returns {boolean}
     */

  }, {
    key: "isInitPolygon",
    get: function get() {
      return this._isInit;
    }
  }]);
  return FMPolygonMarker;
}(_FMMarker2.default);

var _default = FMPolygonMarker;
exports.default = _default;

/***/ }),
/* 433 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var TinyQueue =
/*#__PURE__*/
function () {
  function TinyQueue() {
    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var compare = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultCompare;
    (0, _classCallCheck2.default)(this, TinyQueue);
    this.data = data;
    this.length = this.data.length;
    this.compare = compare;

    if (this.length > 0) {
      for (var i = (this.length >> 1) - 1; i >= 0; i--) {
        this._down(i);
      }
    }
  }

  (0, _createClass2.default)(TinyQueue, [{
    key: "push",
    value: function push(item) {
      this.data.push(item);
      this.length++;

      this._up(this.length - 1);
    }
  }, {
    key: "pop",
    value: function pop() {
      if (this.length === 0) return undefined;
      var top = this.data[0];
      var bottom = this.data.pop();
      this.length--;

      if (this.length > 0) {
        this.data[0] = bottom;

        this._down(0);
      }

      return top;
    }
  }, {
    key: "peek",
    value: function peek() {
      return this.data[0];
    }
  }, {
    key: "_up",
    value: function _up(pos) {
      var data = this.data,
          compare = this.compare;
      var item = data[pos];

      while (pos > 0) {
        var parent = pos - 1 >> 1;
        var current = data[parent];
        if (compare(item, current) >= 0) break;
        data[pos] = current;
        pos = parent;
      }

      data[pos] = item;
    }
  }, {
    key: "_down",
    value: function _down(pos) {
      var data = this.data,
          compare = this.compare;
      var halfLength = this.length >> 1;
      var item = data[pos];

      while (pos < halfLength) {
        var left = (pos << 1) + 1;
        var best = data[left];
        var right = left + 1;

        if (right < this.length && compare(data[right], best) < 0) {
          left = right;
          best = data[right];
        }

        if (compare(best, item) >= 0) break;
        data[pos] = best;
        pos = left;
      }

      data[pos] = item;
    }
  }]);
  return TinyQueue;
}();

function defaultCompare(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}

var _default = TinyQueue;
exports.default = _default;

/***/ }),
/* 434 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _FMGeometryUtils = _interopRequireDefault(__webpack_require__(114));

var _GradientVertShader = __webpack_require__(435);

var _GradientFragShader = __webpack_require__(436);

var _FMMapUtil = _interopRequireDefault(__webpack_require__(113));

var _FMBasePolygonMarker2 = _interopRequireDefault(__webpack_require__(250));

/**
 * @class FMGradientPolygonMarker 自定义渐变多边形标注对象，为自定义图层。
 * @memberof fengmap
 * @extends {fengmap.FMBasePolygonMarker}
 */
var FMGradientPolygonMarker =
/*#__PURE__*/
function (_FMBasePolygonMarker) {
  (0, _inherits2.default)(FMGradientPolygonMarker, _FMBasePolygonMarker);

  /**
   * @constructor
   * @param {json} param 参数
   * @param {number} param.alpha  多边形的透明度。0.0 - 1.0 之间取值, 默认为 1.0
   * @param {number} param.color  多边形的颜色
   * @param {number} param.height  多边形与楼层之间的高度, 默认为 1
   *
   * @param {array} param.points  多边形顶点
   * @param {number} param.points[].x x坐标
   * @param {number} param.points[].y y坐标
   *
   * @param {number} param.scale 缩放，默认为 1.0
   * @param {number} param.scaleValue 缩放值
   */
  function FMGradientPolygonMarker(param) {
    var _this;

    (0, _classCallCheck2.default)(this, FMGradientPolygonMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMGradientPolygonMarker).call(this, 0, _FMNodeType.default.GRADIENT_POLYGON_MARKER, param));
    _this._scale = param.scale !== undefined ? param.scale : 1.0;
    _this._scaleValue = param.scaleValue !== undefined ? param.scaleValue : 0.0;
    return _this;
  }
  /***
   * 初始化
   * @returns {boolean}
   */


  (0, _createClass2.default)(FMGradientPolygonMarker, [{
    key: "init",
    value: function init() {
      if (!this._points) return false;
      if (!this.parent) return false;
      if (!this.parent.parent) return false;
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;
      var group = this.parent.parent;
      var mapCenter = group.parent.mapcenter; // 创建几何体

      var geometry;

      switch (this._points.type) {
        case "circle":
          geometry = this.createCircleGeometry(this._points.radius, this._points.segments);
          break;

        case "rectangle":
          geometry = this.createReactGeometry(this._points.width, this._points.height);
          break;

        default:
          _FMMapUtil.default.convertPointsCoordsByCenter(this._points, mapCenter);

          var points = this._scalePoints();

          var center = new fm.Vector3();
          var Box3 = new fm.Box3();
          Box3.setFromPoints(points);
          Box3.getCenter(center);
          geometry = _FMGeometryUtils.default.createCenterBufferGeometry(points, center);
          break;
      }

      var material = new fm.ShaderMaterial({
        uniforms: {
          "color": {
            value: new fm.Color(this._color)
          },
          "alpha": {
            value: this._alpha
          }
        },
        vertexShader: _GradientVertShader.GradientVertShader,
        fragmentShader: _GradientFragShader.GradientFragShader,
        // blending: fm.AdditiveBlending,
        depthTest: true,
        depthWrite: false,
        transparent: true // wireframe: true

      }); // material.side = 2;

      this._renderNode = new fm.Mesh(geometry, material);
      this._renderNode.mapNode = this;

      this._renderNode.rotation.set(-Math.PI / 2, 0, 0, 'XYZ');

      this._renderNode.position.set(this.position.x, this._height, -this.position.y);

      return true;
    }
    /***
     * 放大基点
     * @private
     */

  }, {
    key: "_scalePoints",
    value: function _scalePoints() {
      if (this._scale === 1.0) {
        return this._points;
      }

      var center = new fm.Vector3();
      var Box3 = new fm.Box3();
      Box3.setFromPoints(this._points);
      Box3.getCenter(center);
      return _FMGeometryUtils.default.scalePoints(this._points, center, this._scale);
    }
    /***
     * 放大基点
     * @private
     */

  }, {
    key: "_scaleValuePoints",
    value: function _scaleValuePoints() {
      if (this._scaleValue === 0) {
        return this._points;
      }

      var center = new fm.Vector3();
      var Box3 = new fm.Box3();
      Box3.setFromPoints(this._points);
      Box3.getCenter(center);
      return _FMGeometryUtils.default.scaleValuePoints(this._points, center, this._scaleValue);
    }
  }, {
    key: "createReactGeometry",
    value: function createReactGeometry(width, height) {
      return new fm.PlaneBufferGeometry(width, height);
    }
  }, {
    key: "createCircleGeometry",
    value: function createCircleGeometry(r, segments) {
      return new fm.CircleBufferGeometry(r, segments);
    }
  }]);
  return FMGradientPolygonMarker;
}(_FMBasePolygonMarker2.default);

var _default = FMGradientPolygonMarker;
exports.default = _default;

/***/ }),
/* 435 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.GradientVertShader = void 0;

/**
 * @author Mif /  Made on September 25, 2020/
 */
var GradientVertShader = "\nattribute float gradientAlpha;\n\nvarying float v_gradientAlpha;\n\nvoid main() {\n  v_gradientAlpha = gradientAlpha;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n ";
exports.GradientVertShader = GradientVertShader;

/***/ }),
/* 436 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.GradientFragShader = void 0;

/**
 * @author Mif /  Made on September 25, 2020/
 */
var GradientFragShader = "\n\nuniform vec3 color;\nuniform float alpha;\n\nvarying float v_gradientAlpha;\n\nvoid main() {\n  gl_FragColor = vec4(color, alpha * v_gradientAlpha);\n}\n ";
exports.GradientFragShader = GradientFragShader;

/***/ }),
/* 437 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

/**
 * @class FMMathUtils是Math工具类 存放通用的一些计算工具函数
 */
var FMMathUtils =
/*#__PURE__*/
function () {
  function FMMathUtils() {
    (0, _classCallCheck2.default)(this, FMMathUtils);
  }
  /**
   * 计算多边形面积
   * @param points {Array<{x:0,y:0}>}
   * @param points[].x {number}
   * @param points[].y {number}
   * @returns {number}
   */


  (0, _createClass2.default)(FMMathUtils, null, [{
    key: "polygonArea",
    value: function polygonArea(points) {
      if (points.length < 3) return 0.0;
      var n = points.length;

      if (points[0].x === points[n - 1].x && points[0].y === points[n - 1].y) {
        n -= 1;
      }

      if (n < 3) return 0.0;
      var s = points[0].y * (points[n - 1].x - points[1].x);

      for (var i = 1; i < n - 1; ++i) {
        s += points[i].y * (points[i - 1].x - points[i + 1].x);
      }

      s = points[n - 1].y * (points[n - 2].x - points[0].x);
      return s * 0.5;
    }
  }]);
  return FMMathUtils;
}();

var _default = FMMathUtils;
exports.default = _default;

/***/ }),
/* 438 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(103));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _FMGeometryUtils = _interopRequireDefault(__webpack_require__(114));

var _FMMapUtil = _interopRequireDefault(__webpack_require__(113));

var _FMBasePolygonMarker2 = _interopRequireDefault(__webpack_require__(250));

var _EdgesLine = _interopRequireDefault(__webpack_require__(439));

var _FMEdgesLinesType = _interopRequireDefault(__webpack_require__(152));

/**
 * @class FMExtrudeMarker 自定义多边形拉伸几何体
 * @memberof fengmap
 * @extends {fengmap.FMBasePolygonMarker}
 */
var FMExtrudeMarker =
/*#__PURE__*/
function (_FMBasePolygonMarker) {
  (0, _inherits2.default)(FMExtrudeMarker, _FMBasePolygonMarker);

  /**
   * @constructor
   * @param {json} param 参数
   * @param {number} param.alpha  透明度。0.0 - 1.0 之间取值, 默认为 1.0
   * @param {number} param.color  颜色
   * @param {number} param.height  拉伸几何体与楼层之间的高度, 默认为 1
   * @param {number} param.extrudeHeight  高度
   * @param {number} param.lineType  类型
   * @param {number} param.lineColor  边框线颜色
   * @param {number} param.lineAlpha  边框线透明度
   *
   * @param {array} param.points  多边形顶点
   * @param {number} param.points[].x x坐标
   * @param {number} param.points[].y y坐标
   */
  function FMExtrudeMarker(param) {
    var _this;

    (0, _classCallCheck2.default)(this, FMExtrudeMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMExtrudeMarker).call(this, 0, _FMNodeType.default.EXTRUDE_MARKER, param));
    _this._extrudeHeight = param.extrudeHeight !== undefined ? param.extrudeHeight : 1; // 拉伸高度

    _this._edgesLine = new _EdgesLine.default((0, _assertThisInitialized2.default)(_this), param);
    return _this;
  }
  /***
   * 初始化
   * @returns {boolean}
   */


  (0, _createClass2.default)(FMExtrudeMarker, [{
    key: "init",
    value: function init() {
      if (!this._points) return false;
      if (!this.parent) return false;
      if (!this.parent.parent) return false;
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;
      var group = this.parent.parent;
      var mapCenter = group.parent.mapcenter; // 创建几何体

      var geometry;
      var extrudeSettings = {
        depth: this._extrudeHeight
      };

      switch (this._points.type) {
        case "circle":
          _FMMapUtil.default.convertPointCoordsByCenter(this.position, mapCenter);

          geometry = _FMGeometryUtils.default.createCircleExtrudeBufferGeometry(this._points.radius, this._points.segments, extrudeSettings);
          break;

        case "rectangle":
          _FMMapUtil.default.convertPointCoordsByCenter(this.position, mapCenter);

          geometry = _FMGeometryUtils.default.createReactExtrudeBufferGeometry(this._points.width, this._points.height, extrudeSettings);
          break;

        default:
          _FMMapUtil.default.convertPointsCoordsByCenter(this._points, mapCenter);

          geometry = _FMGeometryUtils.default.createPointsExtrudeBufferGeometry(this._points, extrudeSettings);
          break;
      }

      var material = nodeManager._materialManager.getExtrudeMaterial(this._color, this._alpha);

      this._renderNode = new fm.Mesh(geometry, material);
      this._renderNode.mapNode = this;

      this._renderNode.rotation.set(-Math.PI / 2, 0, 0, 'XYZ');

      this._renderNode.position.set(this.position.x, this._height, -this.position.y);

      if (this._edgesLine._lineType === _FMEdgesLinesType.default.TOP_LINES_TYPE) {
        this.initTopLine();
      } else {
        this.initLine(geometry);
      }

      return true;
    }
    /***
     * 初始化边线
     * @param geometry
     */

  }, {
    key: "initLine",
    value: function initLine(geometry) {
      this._edgesLine.createLine(geometry);

      this._renderNode.add(this._edgesLine._renderNode);
    }
    /***
     * 初始化顶线
     */

  }, {
    key: "initTopLine",
    value: function initTopLine() {
      var geometry = _FMGeometryUtils.default.createShapeBufferGeometry(this._points);

      this.initLine(geometry);

      this._edgesLine._renderNode.position.setZ(this._extrudeHeight);

      geometry.dispose();
    }
    /**
     * 修改颜色
     * @param {string} color 如：'#ff0000'
     */

  }, {
    key: "setColor",
    value: function setColor(color) {
      var nodeManager = this.findParent(_NodeManager.default);
      this._renderNode.material = nodeManager._materialManager.getExtrudeMaterial(color, this._alpha);
      this._color = color;
    }
    /**
     * 修改多边形面的透明度
     * @param {number} val 透明度
     */

  }, {
    key: "setAlpha",
    value: function setAlpha(val) {
      var nodeManager = this.findParent(_NodeManager.default);
      this._renderNode.material = nodeManager._materialManager.getExtrudeMaterial(this._color, val);
      this._alpha = val;
    }
    /**
     * 修改边线颜色
     * @param {string} color 如：'#ff0000'
     */

  }, {
    key: "setLineColor",
    value: function setLineColor(color) {
      if (this._edgesLine) {
        this._edgesLine.setLineColor(color);
      }
    }
    /**
     * 修改边线透明度
     * @param {number} val 透明度
     */

  }, {
    key: "setLineAlpha",
    value: function setLineAlpha(val) {
      if (this._edgesLine) {
        this._edgesLine.setLineAlpha(val);
      }
    }
    /**
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode) {
        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.geometry = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }

      if (this._edgesLine) {
        this._edgesLine.dispose();
      }
    }
  }]);
  return FMExtrudeMarker;
}(_FMBasePolygonMarker2.default);

var _default = FMExtrudeMarker;
exports.default = _default;

/***/ }),
/* 439 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _FMNodeType = _interopRequireDefault(__webpack_require__(21));

var _FMEdgesLinesType = _interopRequireDefault(__webpack_require__(152));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

/***
 * @class EdgesLine 边缘线
 */
var EdgesLine =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(EdgesLine, _FMNode);

  /***
   * @constructor
   * @param parent {FMNode} 父节点
   * @param {json} options 参数
   * @param {number} options.alpha  透明度。0.0 - 1.0 之间取值, 默认为 1.0
   * @param {number} options.color  颜色
   * @param {number} options.lineType  类型
   * @param {number} options.lineColor  线颜色
   * @param {number} options.lineAlpha  线透明度
   */
  function EdgesLine(parent, options) {
    var _this;

    (0, _classCallCheck2.default)(this, EdgesLine);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(EdgesLine).call(this, 0, _FMNodeType.default.EDGES_LINES_TYPE));
    options = options || {};
    _this._lineType = options.lineType !== undefined ? options.lineType : _FMEdgesLinesType.default.TOP_LINES_TYPE;
    _this._lineAlpha = options.lineAlpha !== undefined ? options.lineAlpha : options.alpha !== undefined ? options.alpha : 1.0; // 边线透明度

    _this._lineColor = options.lineColor !== undefined ? options.lineColor : options.color !== undefined ? options.color : "#FF0000";
    _this.parent = parent; // 渲染父节点

    _this._renderNode = null; // 渲染节点

    return _this;
  }
  /**
   * 创建边缘框
   * @param geometry
   */


  (0, _createClass2.default)(EdgesLine, [{
    key: "createLine",
    value: function createLine(geometry) {
      var edges = new fm.EdgesGeometry(geometry);
      var nodeManager = this.findParent(_NodeManager.default);

      var material = nodeManager._materialManager.getExtrudeMaterial(this._lineColor, this._lineAlpha);

      this._renderNode = new fm.LineSegments(edges, material);
    }
    /**
     * 修改边线颜色
     * @param {string} color 如：'#ff0000'
     */

  }, {
    key: "setLineColor",
    value: function setLineColor(color) {
      if (color) {
        var nodeManager = this.findParent(_NodeManager.default);
        this._renderNode.material = nodeManager._materialManager.getExtrudeMaterial(color, this._lineAlpha);
        this._lineColor = color;
      }
    }
    /**
     * 修改边线透明度
     * @param {number} val 透明度
     */

  }, {
    key: "setLineAlpha",
    value: function setLineAlpha(val) {
      if (val) {
        var nodeManager = this.findParent(_NodeManager.default);
        this._renderNode.material = nodeManager._materialManager.getExtrudeMaterial(this._lineColor, val);
        this._lineAlpha = val;
      }
    }
    /**
     * 释放
     */

  }, {
    key: "dispose",
    value: function dispose() {
      if (this._renderNode) {
        this._renderNode.geometry.dispose();

        this._renderNode.material = undefined;
        this._renderNode.mapNode = undefined;
        this._renderNode = undefined;
      }
    }
  }]);
  return EdgesLine;
}(_FMNode2.default);

var _default = EdgesLine;
exports.default = _default;

/***/ }),
/* 440 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

__webpack_require__(112);

__webpack_require__(68);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMNode2 = _interopRequireDefault(__webpack_require__(7));

var _NodeManager = _interopRequireDefault(__webpack_require__(20));

var _Animater = _interopRequireDefault(__webpack_require__(58));

/**
 * @author Mif / Made on November 19, 2019/
 */

/**
 *  FMDomMarker 自定义dom元素标注对象，为自定义图层。
 *   @class
 *   @memberof fengmap
 *   @extends { fengmap.FMNode }
 *   @param {json} opts
 *          @param {number} opts.x  标注地图位置x值
 *          @param {number} opts.y 标注地图位置y值
 *          @param {number} opts.height 标注地图位置高度值
 *          @param {string} opts.domContent  标注dom元素，也可直接填写文本。
 *          @param {number} opts.domWidth  标注dom元素的宽度。
 *          @param {number} opts.domHeight  标注dom元素的高度度。
 *          @param {string} opts.fontsize    文本标注字号
 *          @param {string} opts.anchor    标注锚点，默认为fm.FMMarkerAnchor.CENTER居中显示，其他可用常量请查看FMMarkerAnchor
 */
var FMDomMarker =
/*#__PURE__*/
function (_FMNode) {
  (0, _inherits2.default)(FMDomMarker, _FMNode);

  function FMDomMarker(param) {
    var _this;

    (0, _classCallCheck2.default)(this, FMDomMarker);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMDomMarker).call(this, param));
    _this._visible = true;
    _this.x = param.x;
    _this.y = param.y;
    _this.domContent = param.domContent;
    _this.fontSize = param.fontsize;
    _this._id = null;
    _this.anchor = param.anchor;
    _this.domWidth = param.domWidth;
    _this.domHeight = param.domHeight;
    _this.height = param.height;
    _this._param = param;
    _this.alpha = param.alpha;
    _this._left = null;
    _this._top = null;
    _this._isRuning = false;
    return _this;
  }

  (0, _createClass2.default)(FMDomMarker, [{
    key: "initDom",
    value: function initDom(marker) {
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return;
      var domMarkerDiv = document.createElement('div');
      var box = nodeManager._map.renderer.renderer.domElement.parentNode;
      box.style.position = 'absolute';
      box.appendChild(domMarkerDiv);
      var h = null;

      if (marker.height) {
        h = marker.height + this.parent.height;
      } else {
        h = this.parent.height;
      }

      var a = nodeManager._map.coordMapToScreen(marker.x, marker.y, h);

      domMarkerDiv.name = 'domMarker';
      domMarkerDiv.id = marker.id;
      domMarkerDiv.setAttribute("class", "domMarker");
      this._id = marker.id;
      this.domNode = domMarkerDiv;
      domMarkerDiv.style.fontSize = marker.fontSize;
      domMarkerDiv.innerHTML = marker.domContent;
      domMarkerDiv.style.width = marker.domWidth + "px";
      domMarkerDiv.style.height = marker.domHeight + "px";
      this._left = this._anchor(marker, a).left;
      this._top = this._anchor(marker, a).top;
      domMarkerDiv.style.left = this._left;
      domMarkerDiv.style.top = this._top; // domMarkerDiv.style.backgroundColor = '#ff0000';
      // domMarkerDiv.style.zIndex = nodeManager._map.renderer.renderer.domElement.style.zIndex+1;

      domMarkerDiv.style.position = 'absolute';
    }
  }, {
    key: "_anchor",
    value: function _anchor(marker, a) {
      var left = null;
      var top = null;

      switch (marker.anchor) {
        case 9:
          //'cMiddle'
          left = a.x - marker.domWidth / 2 + "px";
          top = a.y - marker.domHeight / 2 + "px";
          break;

        case 5:
          //'lTop'
          left = a.x + "px";
          top = a.y + "px";
          break;

        case 6:
          //'rTop'
          left = a.x - marker.domWidth + "px";
          top = a.y + "px";
          break;

        case 7:
          //'lDown'
          left = a.x + "px";
          top = a.y - marker.domHeight + "px";
          break;

        case 8:
          //'rDown'
          left = a.x - marker.domWidth + "px";
          top = a.y - marker.domHeight + "px";
          break;

        case 1:
          //'lMiddle'
          left = a.x + "px";
          top = a.y - marker.domHeight / 2 + "px";
          break;

        case 2:
          //'rMiddle'
          left = a.x - marker.domWidth + "px";
          top = a.y - marker.domHeight / 2 + "px";
          break;

        case 3:
          //'tCenter'
          left = a.x - marker.domWidth / 2 + "px";
          top = a.y + "px";
          break;

        case 4:
          //'dCenter'
          left = a.x - marker.domWidth / 2 + "px";
          top = a.y - marker.domHeight + "px";
          break;

        default:
          left = a.x - marker.domWidth / 2 + "px";
          top = a.y - marker.domHeight / 2 + "px";
          break;
      }

      return {
        'left': left,
        'top': top
      };
    }
    /**
     * 设置marker位置
     * @param {number} x 地图x坐标
     * @param {number} y 地图y坐标
     * @param {number} groupID 楼层id
     * @param {number} height 偏移高度
     */

  }, {
    key: "setPosition",
    value: function setPosition(x, y, groupID, height) {
      var nodeManager = this.findParent(_NodeManager.default);
      if (!nodeManager) return false;
      this.x = x;
      this.y = y;
      var h = null;
      if (groupID !== 0) this.gid = groupID;
      this.height = height;

      if (this.height) {
        h = this.height + nodeManager._map.groupSpace * groupID;
      } else {
        h = nodeManager._map.groupSpace * groupID;
      }

      var a = nodeManager._map.coordMapToScreen(this.x, this.y, h);

      this._left = a.left; //this._anchor(this, a).left;

      this._top = a.top; //this._anchor(this, a).top;

      this.domNode.style.left = this._left;
      this.domNode.style.top = this._top;
    }
  }, {
    key: "moveToGroup",
    value: function moveToGroup(groupID) {
      this.gid = groupID;
    }
    /**
     * 动画移动marker到指定位置
     * @param {object} params
     *      @param {number} params.x 地图x坐标
     *      @param {number} params.y 地图y坐标
     *      @param {number} params.time 移动到指定位置所用的时间（秒）
     *      @param {function} params.callback 移动到指定位置后的回调函数
     *      @param {function} params.update 动画执行过程中位置更新时的回调函数，返回更新后的位置信息。
     */

  }, {
    key: "moveTo",
    value: function moveTo(params) {
      var _this2 = this;

      if (this._isRuning) return;
      var nodeManager = this.findParent(_NodeManager.default);
      var destX = params.x;
      var destY = params.y;
      var animator = new _Animater.default({
        x: this.x,
        y: this.y
      }, {
        x: destX,
        y: destY
      }, params.time * 1000, function () {
        nodeManager.map.removeAnimater(animator);
        _this2._moveAnimater = null;
        _this2._isRuning = false;
        params.callback();
      }, function (coordinate) {
        _this2.setPosition(coordinate.x, coordinate.y, _this2.groupID, _this2.height);

        params.update(coordinate);
      }).start();
      this._isRuning = true;
      nodeManager.map.addAnimater(animator);
      this._moveAnimater = animator;
    }
    /**
       * 停止moveTo动画
       */

  }, {
    key: "stopMoveTo",
    value: function stopMoveTo() {
      var nodeManager = this.findParent(_NodeManager.default);
      this._moveAnimater && this._moveAnimater.stop();
      nodeManager.map.removeAnimater(this._moveAnimater);
      this._isRuning = false;
      this._moveAnimater = null;
    }
    /**
       * 地图元素的显示/隐藏
       * @property {bool} show 【true】: 显示，【false】: 隐藏
       */

  }, {
    key: "show",
    set: function set(show) {
      this._show = show;

      if (!show) {
        this.domNode.style.display = 'none';
      } else {
        this.domNode.style.display = 'block';
      }
    },
    get: function get() {
      return this._show;
    }
  }]);
  return FMDomMarker;
}(_FMNode2.default);

var _default = FMDomMarker;
exports.default = _default;

/***/ }),
/* 441 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

__webpack_require__(149);

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

var _parseInt2 = _interopRequireDefault(__webpack_require__(27));

//copy from fengmap2.2

/**
 * FMHeatMap 热力图, 用于地图热力展示使用。
 * @class
 * @hideconstructor true
 * @memberof fengmap
 */
function FMHeatMap(map, opts) {
  this.map_ = map;
  this.texture_ = null;
  this.config(opts);
}
/**
* 使用create方法创建热力图对象

* @param  {fengmap.FMMap} map map对象
* @param  {object} config 配置项
*             @param {object} config.radius  热点半径
*             @param {string} config.opacity 热力图透明度，范围0-1
*             @param {string} config.max  热力点value的最大值
*             @param {int} config.maxSize  热力图长宽的最大尺寸
*             @param {boolean} config.gradient  热力图的渐变颜色。默认为：{ 0.45: "rgb(0,0,255)", 0.55: "rgb(0,255,255)", 0.65: "rgb(0,255,0)", 0.95: "yellow", 1.0: "rgb(255,0,0)" }
* @static
* @return {fengmap.FMHeatMap}
*/


FMHeatMap.create = function (map, config) {
  return new FMHeatMap(map, config);
};

FMHeatMap.prototype = {
  //获取屏幕DPI
  getDeviceDPI: function getDeviceDPI() {
    var arrDPI = [];

    if (window.screen.deviceXDPI !== undefined) {
      arrDPI[0] = window.screen.deviceXDPI;
      arrDPI[1] = window.screen.deviceYDPI;
    } else {
      var tmpNode = document.createElement("DIV");
      tmpNode.style.cssText = "width:1in;height:1in;position:absolute;left:0px;top:0px;z-index:99;visibility:hidden";
      document.body.appendChild(tmpNode);
      arrDPI[0] = (0, _parseInt2.default)(tmpNode.offsetWidth);
      arrDPI[1] = (0, _parseInt2.default)(tmpNode.offsetHeight);
      tmpNode.parentNode.removeChild(tmpNode);
    }

    return arrDPI;
  },
  //获取地图范围的高宽。单位像素
  getDeviceWH: function getDeviceWH(opts) {
    opts = opts || {};
    var w = this.map_.maxX - this.map_.minX;
    var h = this.map_.maxY - this.map_.minY;
    var wh = {
      w: Math.round(w),
      h: Math.round(h)
    };
    var dpi = this.getDeviceDPI(); // wh.w = fm.Math.nextPowerOfTwo(wh.w * dpi[0] / 25.4); //取距离最近的2的幂，否则会输出警告
    // wh.h = fm.Math.nextPowerOfTwo(wh.h * dpi[1] / 25.4);
    // 使用 nearest 不使用上面的 next, 不浪费空间
    // wh.w = fm.Math.nearestPowerOfTwo(wh.w * dpi[0] / 25.4); //取距离最近的2的幂，否则会输出警告
    // wh.h = fm.Math.nearestPowerOfTwo(wh.h * dpi[1] / 25.4);
    // 使用 上面的方法得到的 2的幂的大小, 会使得最后的结果点不"圆"

    wh.w = (0, _parseInt2.default)(wh.w * dpi[0] / 25.4);
    wh.h = (0, _parseInt2.default)(wh.h * dpi[1] / 25.4); /////////////////////////////////
    // 20161201 clamp size to 2048 //
    /////////////////////////////////

    var rat = 1;
    var maxSize = opts.maxSize || 2048;

    if (wh.w >= maxSize || wh.h >= maxSize) {
      if (wh.w >= wh.h) {
        rat = wh.h / wh.w;
        wh.w = maxSize;
        wh.h = (0, _parseInt2.default)(maxSize * rat);
      } else {
        rat = wh.w / wh.h;
        wh.h = maxSize;
        wh.w = (0, _parseInt2.default)(maxSize * rat);
      }
    }

    return wh;
  },
  //转换地图坐标到像素坐标
  getPixXY: function getPixXY(x, y) {
    var aa = (x - this.map_.minX) / (this.map_.maxX - this.map_.minX);
    var bb = (this.map_.maxY - y) / (this.map_.maxY - this.map_.minY);
    var pnt = {
      x: aa,
      y: bb
    };
    pnt.x = pnt.x * this.options.width;
    pnt.y = pnt.y * this.options.height;
    return pnt;
  },
  // 初始化参数配置
  config: function config(opts) {
    var me = this;
    var wh = me.getDeviceWH(opts);
    var w = wh.w,
        h = wh.h;
    me.options = {
      width: w,
      height: h,
      // 热图画布透明度，取值范围 0-1
      opacity: opts.opacity ? opts.opacity * 255 : 100 * 255,
      // 点半径
      radius: opts.radius ? opts.radius : 30,
      // 边界模糊半径
      bshadow: opts.radius ? opts.radius / 20 : 30 / 20,
      maxSize: opts.mapSize || 2048,
      boundVal: 15000,
      shadowBlur: Math.ceil(opts.radius * 1),
      //0.3
      // 缓存画布中点数据，并且记录最大值, 当最大值发生变化的时候，热图画布需要重新根据缓存的点得数据绘制
      points: {
        max: opts.max ? opts.max : 100,
        data: []
      },
      // 调色板颜色取值范围
      gradient: opts.gradient ? opts.gradient : {
        0.45: "rgb(0,0,255)",
        0.55: "rgb(0,255,255)",
        0.65: "rgb(0,255,0)",
        0.95: "yellow",
        1.0: "rgb(255,0,0)"
      },
      isHeatPlan: opts.isHeatPlan,
      heatHeight: opts.heatHeight
    }; // 热图画布
    //let container = document.getElementById(id);

    var canvas = document.createElement("canvas");
    var ctx = canvas.getContext('2d');
    canvas.width = w;
    canvas.height = h;
    me.options.ctx = ctx;
    me.options.canvas = canvas; // console.log(w,h);
  },
  // 绘制圆阴影：可视区域只绘制了一个圆阴影效果，而圆本身的位置在可视区域之外
  renderShadow: function renderShadow(x, y, val, cache) {
    var me = this,
        ctx = me.options.ctx,
        radius = me.options.radius,
        bval = me.options.boundVal;
    var opacity = (0, _parseFloat2.default)(val / me.options.points.max, 10);
    ctx.save(); // ctx.globalAlpha = 0.1;

    ctx.shadowColor = 'rgba(0, 0, 0, ' + opacity + ')';
    ctx.shadowOffsetX = bval;
    ctx.shadowOffsetY = bval;
    ctx.shadowBlur = me.options.shadowBlur;
    ctx.beginPath();
    ctx.arc(x - bval, y - bval, me.options.radius, 0, Math.PI * 2, true);
    ctx.closePath();
    ctx.fill();
    ctx.restore();

    if (!cache) {
      me.cachePoint(x, y, val);
    }
  },
  // 绘制彩色热图根据调色板
  colorize: function colorize() {
    var me = this,
        w = me.options.width,
        h = me.options.height,
        ctx = me.options.ctx;
    var img = ctx.getImageData(0, 0, w, h);
    var imgData = img.data,
        len = imgData.length,
        palette = me.getPalette();
    var opacity = me.options.opacity;

    for (var i = 3; i < len; i += 4) {
      // [0] -> r, [1] -> g, [2] -> b, [3] -> alpha
      var alpha = imgData[i],
          // 是因为要取调色板中的颜色，而调色板数的颜色数据对应的步长是4
      offset = alpha * 4;

      if (!offset) {
        continue;
      }

      offset = Math.floor(offset);
      var finalAlpha = opacity < alpha ? opacity : alpha;

      if (finalAlpha < 0.8) {
        finalAlpha = 0.8;
      }

      imgData[i - 3] = palette[offset];
      imgData[i - 2] = palette[offset + 1];
      imgData[i - 1] = palette[offset + 2];
      imgData[i] = finalAlpha;
    }

    ctx.putImageData(img, 0, 0);
  },
  //地图上显示热力图
  renderToMap: function renderToMap(groupID) {
    var me = this;
    var canvas = me.options.canvas;
    var texture_ = new fm.Texture(canvas);
    this.setTexture(groupID, texture_);
  },
  //从地图上移除热力图
  disposeHeatMap: function disposeHeatMap(groupID) {
    if (!groupID) return;
    var me = this;
    var floor = this.map_.getFMGroup(groupID).getExtentMeshs()[0];

    if (!floor._hasHeatMap) {
      return;
    } // 加一个标签,记录当前的heapMap状态


    floor._hasHeatMap = false; //
    // release memory from gl
    //

    if (floor.material.map) {
      floor.material.map.dispose();
    }

    if (this.options.isHeatPlan) {
      floor.material.map = null;
      floor.material.mapMixColor = false;
      floor.material.transparent = true;
      floor.material.needsUpdate = true;

      this.map_.getFMGroup(groupID)._layers.model[0]._scene.getObjectByName("directionalLight").remove(this.map_.getFMGroup(groupID)._layers.model[0]._scene.getObjectByName("heatMap"));
    } else {
      var ms = this.map_.getFMGroup(groupID).getModelMeshs();

      this.map_.getFMGroup(groupID)._layers.model[0]._scene.traverse(function (mesh) {
        if (mesh.name === "heatmap") {
          mesh.parent.remove(mesh);
        }
      });

      ms.forEach(function (itm) {
        if (itm.material.type === "MultiMaterial") {
          // support multiMaterial index
          var matsLen = itm.material.materials.length;
          var matIndex = 0,
              step = 3;

          while (matIndex < matsLen) {
            var _mat = itm.material.materials[matIndex];
            _mat.map = null; // _mat.color.copy(_mat._color);

            _mat.mapMixColor = false;
            _mat.transparent = true;
            _mat.needsUpdate = true;
            step = matIndex === 0 ? 3 : 2;
            matIndex += step;
          }
        } else {
          //lazyCreateModel
          var _mat2 = itm.material;
          _mat2.map = null; // _mat.color.copy(_mat._color);

          _mat2.mapMixColor = false;
          _mat2.transparent = true;
          _mat2.needsUpdate = true;
        }
      });
    }
  },
  // 通过调色板来获取平滑的颜色值
  getPalette: function getPalette() {
    // 调色板画布
    var pcanvas = document.createElement("canvas"),
        pctx = pcanvas.getContext('2d');
    pcanvas.width = 1;
    pcanvas.height = 256;
    var me = this,
        gradient = me.options.gradient; //缓存调色板数据

    var grad = pctx.createLinearGradient(0, 0, 1, 256);

    for (var x in gradient) {
      grad.addColorStop(x, gradient[x]);
    }

    pctx.fillStyle = grad;
    pctx.fillRect(0, 0, 1, 256); // 这个有说明: http://www.w3school.com.cn/tags/canvas_getimagedata.asp
    // 返回的是一个一位数组，每一个像素的的颜色有四个值来表示
    // 前三个值表示 红绿蓝，第四个值表示alpha 通道
    // 也就是这个一位数组的长度是: 1 * 256 * 4;

    return pctx.getImageData(0, 0, 1, 256).data;
  }
}; // 缓存点数据

FMHeatMap.prototype.cachePoint = function (x, y, val) {
  var me = this,
      points = me.options.points,
      data = points.data;

  if (val > points.max) {// points.max = val;
  }

  data.push([x, y, val]);
};
/**
 * 清除热力图的所有热力点
 */


FMHeatMap.prototype.clearPoints = function () {
  this.options.points.data = [];
  this.clear();
};
/**
 * 增加一个热点
 *         @param {float} x  地图坐标x值。
 *         @param {float} y  地图坐标y值。
 *         @param {float} value 热点所占的比重值
 */
// 增加一个热点


FMHeatMap.prototype.addPoint = function (x, y, value) {
  if (!x || !y || !value) return;
  var newXY = this.getPixXY(x, y);
  if (!newXY) return;
  var me = this;
  me.clear();
  var data = me.options.points.data,
      len = data.length;

  for (var i = 0; i < len; i++) {
    me.renderShadow(data[i][0], data[i][1], data[i][2], true);
  }

  me.renderShadow(newXY.x, newXY.y, value, false);
  me.colorize();
}; //
// 根据给定的点
//


FMHeatMap.prototype.getTexture = function (points) {
  this.clearPoints();
  this.addPoints(points);
  var clone = this.options.canvas.cloneNode();
  clone.getContext('2d').drawImage(this.options.canvas, 0, 0);
  return new fm.CanvasTexture(clone);
};

FMHeatMap.prototype.setTexture = function (groupID, tex) {
  var me = this;
  var floor = this.map_.getFMGroup(groupID).getExtentMeshs()[0]; // 如果之前创建了FMHeatMap先将其移除

  if (floor._hasHeatMap) {
    this.disposeHeatMap(groupID);
  }

  var _color = floor.material.color;
  var _opcity = floor.material.opacity;

  if (this.options.isHeatPlan) {
    floor._hasHeatMap = true; // floor.material.mapMixColor = true;

    floor.material.map = tex; // floor.material.transparent = false;

    floor.material.map.needsUpdate = true;
    floor.material.needsUpdate = true;
    var heatMesh = floor.clone();
    heatMesh.name = "heatMap";
    heatMesh.material.transparent = true;
    heatMesh.material.opacity = 1;
    heatMesh.material.color = new fm.Color(0xffffff);
    heatMesh.material.depthTest = false;
    heatMesh.renderOrder = 12;
    heatMesh.material.needsUpdate = true;
    heatMesh.scale.z = 0.001;

    if (this.options.heatHeight) {
      heatMesh.position.y += this.options.heatHeight;
    } else {
      heatMesh.position.y += 4;
    }

    floor.material = new fm.MeshLambertMaterial({
      color: _color,
      opacity: _opcity,
      transparent: true
    });

    this.map_.getFMGroup(groupID)._layers.model[0]._scene.getObjectByName("directionalLight").add(heatMesh);
  } else {
    floor._hasHeatMap = true;
    floor.material.mapMixColor = true;
    floor.material.map = tex; // floor.material.transparent = false;

    floor.material.map.needsUpdate = true;
    floor.material.needsUpdate = true;
    var ms = this.map_.getFMGroup(groupID).getModelMeshs();

    this.map_.getFMGroup(groupID)._layers.model[0]._scene.traverse(function (mesh) {
      if (mesh instanceof fm.Mesh) {
        for (var i = 0; i < mesh.children.length; i++) {
          if (mesh.children[i].material.map !== null && typeof mesh.children[i].material.map !== "undefined") {
            // console.log("对了奥",mesh.children[i].material.map);
            var geo = mesh.geometry;
            var material1 = mesh.material;
            material1.opacity = 0.8;
            material1.needsUpdate = true; // console.log(material1);

            var material2 = new fm.MeshLambertMaterial({
              map: tex,
              transparent: true,
              blending: fm.CustomBlending,
              blendEquation: fm.AddEquation,
              blendSrc: fm.SrcAlphaFactor,
              blendDst: fm.OneMinusSrcAlphaFactor
            });
            material2.opacity = 0.9;
            var materials = [material1, material2];
            var group = new fm.Group();

            for (var _i = 0; _i < materials.length; _i++) {
              group.add(new fm.Mesh(geo, materials[_i]));
            } // mesh.add(group);


            var mesh1 = new fm.Mesh(geo, material2);
            mesh1.name = "heatmap";
            mesh1.renderOrder = 11;
            mesh1.material.depthTest = false;
            mesh1.material.depthWrite = false;
            mesh.add(mesh1); // mesh.children[i-1].material.opacity = 0;
            // mesh.remove(mesh.children[i]);
            // mesh.children[i] = null;
          }
        }
      }
    });

    ms.forEach(function (itm) {
      if (itm.material.type === "MultiMaterial") {
        // support multiMaterial index
        var matsLen = itm.material.materials.length;
        var matIndex = 0,
            step = 3;

        while (matIndex < matsLen) {
          itm.material.materials[matIndex].map = tex;
          itm.material.mapMixColor = true; // color to WHITE means DONT tints the map

          itm.material.materials[matIndex]._color = itm.material.materials[matIndex].color.clone();
          itm.material.materials[matIndex].color = new fm.Color(0xffffff); // itm.material.materials[matIndex].transparent = false;

          itm.material.materials[matIndex].map.needsUpdate = true;
          itm.material.materials[matIndex].needsUpdate = true;
          step = matIndex === 0 ? 3 : 2;
          matIndex += step;
        }
      } else {
        //lazyCreateModel
        itm.material.mapMixColor = true;
        itm.material.map = tex; // color to WHITE means DONT tints the map

        itm.material._color = itm.material.color.clone(); // itm.material.color = new fm.Color(0xffffff);

        if (itm.material.opacity === 1) {
          itm.material.transparent = false;
        } // itm.material.transparent = false;


        itm.material.map.needsUpdate = true;
        itm.material.needsUpdate = true;
      }
    });
  }
};

FMHeatMap.prototype.setModelMeshTexture = function (modelMesh) {
  if (!modelMesh || !texture_) {
    return;
  }

  if (modelMesh.material.type === "MultiMaterial") {
    // support multiMaterial index
    var matsLen = modelMesh.material.materials.length;
    var matIndex = 0,
        step = 3;

    while (matIndex < matsLen) {
      modelMesh.material.materials[matIndex].map = texture_; // color to WHITE means DONT tints the map

      modelMesh.material.materials[matIndex]._color = modelMesh.material.materials[matIndex].color.clone();
      modelMesh.material.materials[matIndex].color = new fm.Color(0xffffff);
      modelMesh.material.materials[matIndex].transparent = false;
      modelMesh.material.materials[matIndex].map.needsUpdate = true;
      modelMesh.material.materials[matIndex].needsUpdate = true;
      step = matIndex === 0 ? 3 : 2;
      matIndex += step;
    }
  } else {
    //lazyCreateModel
    modelMesh.material.map = texture_; // color to WHITE means DONT tints the map

    modelMesh.material._color = modelMesh.material.color.clone();
    modelMesh.material.color = new fm.Color(0xffffff);
    modelMesh.material.transparent = false;
    modelMesh.material.map.needsUpdate = true;
    modelMesh.material.needsUpdate = true;
  }
};

FMHeatMap.prototype.clear = function () {
  var ctx = this.options.ctx;
  ctx.clearRect(0, 0, this.options.width, this.options.height);
};
/**
 * 批量增加热点
 * @param  {array} datas datas数组的每一个值是{x,y,value}对象。
 */


FMHeatMap.prototype.addPoints = function (points) {
  var me = this; // me.options.ctx.clearRect(0, 0, me.options.width, me.options.height);

  me.clear();
  var data = me.options.points.data;
  var len = data.length;

  for (var i = 0; i < len; i++) {
    me.renderShadow(data[i][0], data[i][1], data[i][2], true);
  }

  var plen = points.length;

  for (var j = 0; j < plen; j++) {
    var newxy = this.getPixXY(points[j].x, points[j].y);
    if (!newxy) return true;
    me.renderShadow(newxy.x, newxy.y, points[j].value, false);
  }

  me.colorize();
}; // 随机画热点

/**
 * 随机增加热点
 * @param  {number} num 要随机生成的热力点的数量
 */


FMHeatMap.prototype.randomPoints = function (points) {
  var me = this;
  var w = me.options.width,
      h = me.options.height,
      max = me.options.points.max;
  me.clear();

  for (var i = 0; i < points; i++) {
    var x = Math.floor(Math.random() * w + 1);
    var y = Math.floor(Math.random() * h + 1);
    var value = Math.floor(Math.random() * max + 1);
    me.renderShadow(x, y, value);
  }

  me.colorize();
};

var _default = FMHeatMap;
exports.default = _default;

/***/ }),
/* 442 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _FMSearchRequest = _interopRequireDefault(__webpack_require__(251));

var _FMSingleAttrQuery = _interopRequireDefault(__webpack_require__(443));

var _FMMultiAttrQuery = _interopRequireDefault(__webpack_require__(444));

var _FMBufferQuery = _interopRequireDefault(__webpack_require__(445));

var _FMCircleQuery = _interopRequireDefault(__webpack_require__(448));

var _FMPolygonQuery = _interopRequireDefault(__webpack_require__(449));

/**
 * @author Mif /  Made on March 10, 2020/
 */

/**
 * FMSearchAnalyser 是可根据类型、ID、楼层ID、名称、关键字模糊查找模型、公共设施、文本标签、自定义图层或所有图层的分析类。
 * @class
 * @memberof fengmap
 * @param {json} map 地图对象
 */
var FMSearchAnalyser =
/*#__PURE__*/
function () {
  function FMSearchAnalyser(map, data) {
    (0, _classCallCheck2.default)(this, FMSearchAnalyser);
    this._data = data ? data : map.getCurrDecodeData();
    this._map = map;
    this.Graphics = fengmap.Graphics;
    this.DataManager = new fengmap.inner.DataManager();
    this.singleAttrQuery = new _FMSingleAttrQuery.default(this._data, this._map);
    this.bufferQuery = new _FMBufferQuery.default(this._data);
    this.multiAttrQuery = new _FMMultiAttrQuery.default(this._data, this._map);
    this.circleQuery = new _FMCircleQuery.default(this._data);
    this.polygonQuery = new _FMPolygonQuery.default(this._data);
  }

  (0, _createClass2.default)(FMSearchAnalyser, [{
    key: "query",
    value: function query(selector, back) {
      var result = null;

      if (!selector.queryTypes) {
        if (!selector.circle) {
          result = this.getQueryResult(selector, ["SINGLE"]);
        } else {
          result = this.getQueryResult(selector, ["SINGLE", "CIRCLE"]);
        }
      } else {
        result = this.getQueryResult(selector, selector.queryTypes);
      }

      back(result);
      return result;
    }
    /**
     * 获得搜索结果
     * @param {Object} selector 搜索请求体
     * @param {array} queryTypes 搜索类型数组，如["SINGLE"],["SINGLE","CIRCLE"],["SINGLE","POLYGON"]
     * @returns {array} 搜索结果
     */

  }, {
    key: "getQueryResult",
    value: function getQueryResult(selector, queryTypes) {
      var results = [];
      var result = null;

      for (var i = 0; i < queryTypes.length; i++) {
        switch (queryTypes[i]) {
          case "SINGLE":
            results.push(this.singleAttrQuery.query(selector));
            break;

          case "MULTI":
            results.push(this.multiAttrQuery.query(selector));
            break;

          case "BUFFER":
            results.push(this.bufferQuery.query(selector, this._map));
            break;

          case "CIRCLE":
            result = this.circleQuery.query(results, selector, this._map);
            results = [];
            results.push(result);
            break;

          case "POLYGON":
            result = this.polygonQuery.query(results, selector, this._map);
            results = [];
            results.push(result);
            break;

          default:
            results.push(this.singleAttrQuery.query(selector));
        }
      }

      return results[0];
    }
  }]);
  return FMSearchAnalyser;
}();

var _default = FMSearchAnalyser;
exports.default = _default;

/***/ }),
/* 443 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(8);

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(13);

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMAttributeQuery2 = _interopRequireDefault(__webpack_require__(252));

/**
 * @author Mif /  Made on March 11, 2020/
 */
var SingleAttrQuery =
/*#__PURE__*/
function (_FMAttributeQuery) {
  (0, _inherits2.default)(SingleAttrQuery, _FMAttributeQuery);

  function SingleAttrQuery(data, map) {
    var _this;

    (0, _classCallCheck2.default)(this, SingleAttrQuery);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(SingleAttrQuery).call(this, data));
    _this._map = map; // this._data = data;

    return _this;
  }

  (0, _createClass2.default)(SingleAttrQuery, [{
    key: "query",
    value: function query(selector) {
      var result = [];
      var groupID = selector.groupID;

      if (groupID) {
        if (typeof groupID === "number") {
          groupID = [groupID];
        } else if (groupID === "all") {// groupID = this._map ? this._map.groupIDs : 0;
        }
      } // console.log(this._data);


      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator2.default)(this._data.floors), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var group = _step.value;

          if (groupID) {
            if (groupID.indexOf(group.gid) > -1) {
              result.push.apply(result, (0, _toConsumableArray2.default)(this.queryGroup(group, selector)));
            }
          } else {
            result.push.apply(result, (0, _toConsumableArray2.default)(this.queryGroup(group, selector)));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return result;
    }
  }, {
    key: "queryGroup",
    value: function queryGroup(group, selector) {
      var _this2 = this;

      var file_ver = this._data.scene.file_ver;
      var nodetype = selector.nodeType ? selector.nodeType : fengmap.FMNodeType.ALL;

      if (nodetype == 'all') {
        nodetype = fengmap.FMNodeType.ALL;
      }

      var result = [];

      if (nodetype === fengmap.FMNodeType.EXTERNAL_MODEL || nodetype === fengmap.FMNodeType.ALL) {
        this.everyExternalModel(group, function (bdata, gdata, type, layer) {
          var pos = null;
          var x = 0.1;
          var y = 0.1;

          if (!bdata || !gdata || !type || !layer) {
            return;
          }

          if (file_ver === 1) {
            pos = layer.geo.substring(6, layer.geo.length - 1).split(' ');
            x = (0, _parseFloat2.default)(pos[0]);
            y = (0, _parseFloat2.default)(pos[1]);
          } else {
            pos = layer.pts;
            x = pos[0];
            y = pos[1];
          }

          var z = gdata.height;
          var res = {};
          console.log("group.gid", group.gid);

          if (_this2.check(bdata, gdata, selector, type, layer.geo, group.gid, res)) {
            console.log("886886");
            result.push({
              ID: bdata.eid,
              name: bdata.name,
              ename: bdata.ename,
              groupID: group.gid,
              FID: bdata.fid,
              typeID: bdata.type,
              nodeType: fengmap.FMNodeType.EXTERNAL_MODEL,
              gdata: gdata,
              target: res.target ? res.target : _this2._map.getFMGroup(group.gid).getNodeByLayerId("externalModel", bdata.eid),
              mapCoord: {
                x: x,
                y: y,
                z: z
              }
            });
          }
        });
      }

      if (nodetype === fengmap.FMNodeType.MODEL || nodetype === fengmap.FMNodeType.ALL) {
        this.everyModel(group, function (bdata, gdata, type, layer) {
          var pos = null;
          var x = 0;
          var y = 0;

          if (!bdata || !gdata || !type || !layer) {
            return;
          }

          if (file_ver === 1) {
            pos = layer.geo.substring(6, layer.geo.length - 1).split(' ');
            x = (0, _parseFloat2.default)(pos[0]);
            y = (0, _parseFloat2.default)(pos[1]);
          } else {
            pos = layer.pts;
            x = pos[0];
            y = pos[1];
          }

          var z = gdata.height;
          var res = {};

          if (_this2.check(bdata, gdata, selector, type, layer.geo, group.gid, res)) {
            result.push({
              ID: bdata.eid,
              name: bdata.name,
              ename: bdata.ename,
              groupID: group.gid,
              FID: bdata.fid,
              typeID: bdata.type,
              nodeType: fengmap.FMNodeType.MODEL,
              gdata: gdata,
              target: res.target ? res.target : _this2._map.getFMGroup(group.gid).getNodeByLayerId("model", bdata.eid),
              mapCoord: {
                x: x,
                y: y,
                z: z
              }
            });
          }
        });
      }

      if (nodetype === fengmap.FMNodeType.FACILITY || nodetype === fengmap.FMNodeType.ALL) {
        this.everyFacility(group, function (bdata, gdata, type) {
          var pos = null;
          var x = 0;
          var y = 0;

          if (!bdata || !gdata || !type) {
            return;
          }

          if (file_ver === 1) {
            pos = gdata.geo.substring(6, gdata.geo.length - 1).split(' ');
            x = (0, _parseFloat2.default)(pos[0]);
            y = (0, _parseFloat2.default)(pos[1]);
          } else {
            pos = gdata.pts;
            x = pos[0];
            y = pos[1];
          }

          var z = gdata.height;

          if (_this2.check(bdata, gdata, selector, type, null, group.gid)) {
            result.push({
              ID: bdata.eid,
              name: bdata.name,
              ename: bdata.ename,
              groupID: group.gid,
              FID: bdata.fid,
              typeID: bdata.type,
              nodeType: fengmap.FMNodeType.FACILITY,
              gdata: gdata,
              target: _this2._map.getFMGroup(group.gid).getNodeByLayerId("facility", bdata.eid),
              mapCoord: {
                x: x,
                y: y,
                z: z
              }
            });
          }
        });
      }

      if (nodetype === fengmap.FMNodeType.LABEL || nodetype === fengmap.FMNodeType.ALL) {
        this.everyLabel(group, function (bdata, gdata, type) {
          var pos = null;
          var x = 0;
          var y = 0;

          if (!bdata || !gdata || !type) {
            return;
          }

          if (file_ver === 1) {
            pos = gdata.geo.substring(6, gdata.geo.length - 1).split(' ');
            x = (0, _parseFloat2.default)(pos[0]);
            y = (0, _parseFloat2.default)(pos[1]);
          } else {
            pos = gdata.pts;
            x = pos[0];
            y = pos[1];
          }

          var z = gdata.height;

          if (_this2.check(bdata, gdata, selector, type, null, group.gid)) {
            result.push({
              ID: bdata.eid,
              name: bdata.name,
              ename: bdata.ename,
              groupID: group.gid,
              FID: bdata.fid,
              typeID: bdata.type,
              nodeType: fengmap.FMNodeType.LABEL,
              gdata: gdata,
              target: _this2._map.getFMGroup(group.gid).getNodeByLayerId("label", bdata.eid),
              mapCoord: {
                x: x,
                y: y,
                z: z
              }
            });
          }
        });
      }

      return result;
    }
  }]);
  return SingleAttrQuery;
}(_FMAttributeQuery2.default);

var _default = SingleAttrQuery;
exports.default = _default;

/***/ }),
/* 444 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(53);

__webpack_require__(8);

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(13);

var _toConsumableArray2 = _interopRequireDefault(__webpack_require__(41));

var _getIterator2 = _interopRequireDefault(__webpack_require__(12));

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMAttributeQuery2 = _interopRequireDefault(__webpack_require__(252));

/**
 * @author Mif /  Made on March 11, 2020/
 */
var FMMultiAttrQuery =
/*#__PURE__*/
function (_FMAttributeQuery) {
  (0, _inherits2.default)(FMMultiAttrQuery, _FMAttributeQuery);

  function FMMultiAttrQuery(data, map) {
    var _this;

    (0, _classCallCheck2.default)(this, FMMultiAttrQuery);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMMultiAttrQuery).call(this, data));
    _this._map = map;
    return _this;
  }

  (0, _createClass2.default)(FMMultiAttrQuery, [{
    key: "query",
    value: function query(selector, back) {
      console.log(868686857857);

      if (selector.pathPoints) {
        var result = this.distanceSorting(selector.groupID, selector.pathPoints, selector.startPoint, selector.bufferRadius); // back(result);

        return result;
      } else {
        var _result = [];
        var groupID = selector.groupID;

        if (groupID) {
          if (typeof groupID === "number") {
            groupID = [groupID];
          } else if (groupID === "all") {// groupID = this._map ? this._map.groupIDs : 0;
          }
        }

        console.log(this._data);
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _getIterator2.default)(this._data.floors), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var group = _step.value;

            if (groupID) {
              if (groupID.indexOf(group.gid) > -1) {
                _result.push.apply(_result, (0, _toConsumableArray2.default)(this.queryGroup(group, selector)));
              }
            } else {
              _result.push.apply(_result, (0, _toConsumableArray2.default)(this.queryGroup(group, selector)));
            }
          } // back(result);

        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return _result;
      }
    }
  }, {
    key: "queryGroup",
    value: function queryGroup(group, selector) {
      var _this2 = this;

      var file_ver = this._data.scene.file_ver;
      var nodetype = selector.nodeType ? selector.nodeType : fengmap.FMNodeType.ALL;

      if (nodetype == 'all') {
        nodetype = fengmap.FMNodeType.ALL;
      }

      var result = [];

      if (nodetype === fengmap.FMNodeType.EXTERNAL_MODEL || nodetype === fengmap.FMNodeType.ALL) {
        this.everyExternalModel(group, function (bdata, gdata, type, layer) {
          var pos = null;
          var x = 0.1;
          var y = 0.1;

          if (file_ver === 1) {
            pos = layer.geo.substring(6, layer.geo.length - 1).split(' ');
            x = (0, _parseFloat2.default)(pos[0]);
            y = (0, _parseFloat2.default)(pos[1]);
          } else {
            pos = layer.pts;
            x = pos[0];
            y = pos[1];
          }

          var z = gdata.height;
          var res = {};

          if (_this2.check(bdata, gdata, selector, type, layer.geo, group.gid, res)) {
            result.push({
              ID: bdata.eid,
              name: bdata.name,
              ename: bdata.ename,
              groupID: group.gid,
              FID: bdata.fid,
              typeID: bdata.type,
              nodeType: fengmap.FMNodeType.MODEL,
              distance: typeof res.distance == 'number' ? res.distance : null,
              target: res.target ? res.target : _this2._map.getFMGroup(group.gid).getNodeByLayerId("externalModel", bdata.eid),
              mapCoord: {
                x: x,
                y: y,
                z: z
              }
            });
          }
        });
      }

      if (nodetype === fengmap.FMNodeType.MODEL || nodetype === fengmap.FMNodeType.ALL) {
        this.everyModel(group, function (bdata, gdata, type, layer) {
          var pos = null;
          var x = 0;
          var y = 0;

          if (file_ver === 1) {
            pos = layer.geo.substring(6, layer.geo.length - 1).split(' ');
            x = (0, _parseFloat2.default)(pos[0]);
            y = (0, _parseFloat2.default)(pos[1]);
          } else {
            pos = layer.pts;
            x = pos[0];
            y = pos[1];
          }

          var z = gdata.height;
          var res = {};

          if (_this2.check(bdata, gdata, selector, type, layer.geo, group.gid, res)) {
            result.push({
              ID: bdata.eid,
              name: bdata.name,
              ename: bdata.ename,
              groupID: group.gid,
              FID: bdata.fid,
              typeID: bdata.type,
              nodeType: fengmap.FMNodeType.MODEL,
              distance: typeof res.distance == 'number' ? res.distance : null,
              target: res.target ? res.target : _this2._map.getFMGroup(group.gid).getNodeByLayerId("model", bdata.eid),
              mapCoord: {
                x: x,
                y: y,
                z: z
              }
            });
          }
        });
      }

      if (nodetype === fengmap.FMNodeType.FACILITY || nodetype === fengmap.FMNodeType.ALL) {
        this.everyFacility(group, function (bdata, gdata, type) {
          var pos = null;
          var x = 0;
          var y = 0;

          if (file_ver === 1) {
            pos = gdata.geo.substring(6, gdata.geo.length - 1).split(' ');
            x = (0, _parseFloat2.default)(pos[0]);
            y = (0, _parseFloat2.default)(pos[1]);
          } else {
            pos = gdata.pts;
            x = pos[0];
            y = pos[1];
          }

          var z = gdata.height;
          var res = {};

          if (_this2.check(bdata, gdata, selector, type, null, group.gid, res)) {
            result.push({
              ID: bdata.eid,
              name: bdata.name,
              ename: bdata.ename,
              groupID: group.gid,
              FID: bdata.fid,
              typeID: bdata.type,
              nodeType: fengmap.FMNodeType.FACILITY,
              distance: typeof res.distance == 'number' ? res.distance : null,
              target: _this2._map.getFMGroup(group.gid).getNodeByLayerId("facility", bdata.eid),
              mapCoord: {
                x: x,
                y: y,
                z: z
              }
            });
          }
        });
      }

      if (nodetype === fengmap.FMNodeType.LABEL || nodetype === fengmap.FMNodeType.ALL) {
        this.everyLabel(group, function (bdata, gdata, type) {
          var pos = null;
          var x = 0;
          var y = 0;

          if (file_ver === 1) {
            pos = gdata.geo.substring(6, gdata.geo.length - 1).split(' ');
            x = (0, _parseFloat2.default)(pos[0]);
            y = (0, _parseFloat2.default)(pos[1]);
          } else {
            pos = gdata.pts;
            x = pos[0];
            y = pos[1];
          }

          var z = gdata.height;
          var res = {};

          if (_this2.check(bdata, gdata, selector, type, null, group.gid, res)) {
            result.push({
              ID: bdata.eid,
              name: bdata.name,
              ename: bdata.ename,
              groupID: group.gid,
              FID: bdata.fid,
              typeID: bdata.type,
              nodeType: fengmap.FMNodeType.LABEL,
              distance: typeof res.distance == 'number' ? res.distance : null,
              target: _this2._map.getFMGroup(group.gid).getNodeByLayerId("label", bdata.eid),
              mapCoord: {
                x: x,
                y: y,
                z: z
              }
            });
          }
        });
      }

      if (selector.circle || selector.polygon) {
        result.sort(function (a, b) {
          if (typeof a.distance == 'number' && typeof b.distance == 'number') {
            return a.distance - b.distance;
          }

          return 0;
        });
      }

      return result;
    }
  }]);
  return FMMultiAttrQuery;
}(_FMAttributeQuery2.default);

var _default = FMMultiAttrQuery;
exports.default = _default;

/***/ }),
/* 445 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMRelationQuery2 = _interopRequireDefault(__webpack_require__(446));

var _geotool = __webpack_require__(447);

/**
 * @author Mif /  Made on March 11, 2020/
 */
var FMBufferQuery =
/*#__PURE__*/
function (_FMRelationQuery) {
  (0, _inherits2.default)(FMBufferQuery, _FMRelationQuery);

  function FMBufferQuery(data) {
    var _this;

    (0, _classCallCheck2.default)(this, FMBufferQuery);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMBufferQuery).call(this, data));
    _this._map = null;
    return _this;
  }

  (0, _createClass2.default)(FMBufferQuery, [{
    key: "query",
    value: function query(selector, map) {
      this._map = map;
      var result = this.distanceSorting(selector.groupID, selector.pathPoints, selector.startPoint, selector.bufferRadius);
      return result;
    }
  }, {
    key: "_calcBuffer",
    value: function _calcBuffer(points, bufferRadius) {
      for (var i = 0; i < points.length; i++) {
        var arr = [];
        arr.push(points[i].x);
        arr.push(points[i].y);
        points.splice(i, 1, arr);
      } // console.log(points);


      var points1 = (0, _geotool.straightenPoints)(points);
      var buffer = (0, _geotool.polylineSegBuffers)(points1, bufferRadius);
      return buffer;
    }
  }, {
    key: "_BMIntersect",
    value: function _BMIntersect(gpos, buffer, model) {
      for (var i = 0; i < model.length; i++) {
        var arr = [];
        arr.push(model[i].x + gpos.x);
        arr.push(model[i].y + gpos.y);
        model.splice(i, 1, arr);
      }

      var intersect = (0, _geotool.isSegBuffersIntersecots)(buffer, model);
      return intersect;
    }
  }, {
    key: "_BFIntersect",
    value: function _BFIntersect(gpos, buffer, facility) {
      var facility1 = [facility.x + gpos.x, facility.y + gpos.y];
      var arr = [facility1];
      var intersect = (0, _geotool.isSegBuffersIntersecots)(buffer, arr);
      return intersect;
    }
  }, {
    key: "distanceSorting",
    value: function distanceSorting(groupID, points, sp, bufferRadius) {
      var gpos = this._map.getFMGroup(groupID).mapCoord;

      var modelIntersects = [];
      var facilityIntersects = [];
      var newModel = [];
      var newFacility = [];
      var modelDistances = [];
      var facilityDistances = [];
      var allModel = this._map.nodeManager._scenes[this._map._currentSceneId].groups["" + groupID]._layers.model[0]._models;
      var allFacility = this._map.nodeManager._scenes[this._map._currentSceneId].groups["" + groupID]._layers.facility[0]._facility;

      var buffer = this._calcBuffer(points, bufferRadius);

      for (var i in allModel) {
        var model = allModel[i]._renderNode.children[0].geometry.vertices.concat();

        var intersect = this._BMIntersect(gpos, buffer, model);

        if (intersect) {
          newModel.push(allModel[i]);
          var box = {
            model: model,
            fid: allModel[i].FID,
            target: newModel[newModel.length - 1]
          };
          modelIntersects.push(box);
        }
      }

      for (var _i in allFacility) {
        var facility = allFacility[_i]._renderNode.position.clone();

        var _intersect = this._BFIntersect(gpos, buffer, facility);

        if (_intersect) {
          newFacility.push(allModel[_i]);
          var _box = {
            facility: facility,
            fid: allFacility[_i].FID,
            target: newFacility[newFacility.length - 1]
          };
          facilityIntersects.push(_box);
        }
      }

      for (var _i2 = 0; _i2 < modelIntersects.length; _i2++) {
        var _model = modelIntersects[_i2].model;
        var distance = (0, _geotool.distPointToPolygon)([sp.x, sp.y], _model);
        var _box2 = {
          distance: distance,
          fid: modelIntersects[_i2].fid,
          target: newModel[_i2]
        };
        modelDistances.push(_box2);
      }

      for (var _i3 = 0; _i3 < facilityIntersects.length; _i3++) {
        var _facility = facilityIntersects[_i3].facility;

        var _distance = Math.sqrt(Math.pow(sp.x - _facility.x, 2) + Math.pow(sp.y - _facility.y, 2));

        var _box3 = {
          distance: _distance,
          fid: facilityIntersects[_i3].fid,
          target: newFacility[_i3]
        };
        facilityDistances.push(_box3);
      }

      this._quickSort(modelDistances, 0, modelDistances.length - 1);

      this._quickSort(facilityDistances, 0, facilityDistances.length - 1);

      modelIntersects = null;
      facilityIntersects = null;
      newModel = null;
      newFacility = null;
      return {
        model: modelDistances,
        facility: facilityDistances
      };
    }
    /** 
     * 快速排序
     */

  }, {
    key: "_quickSort",
    value: function _quickSort(num, left, right) {
      var list = [[left, right]];

      while (list.length > 0) {
        var now = list.pop();

        if (now[0] >= now[1]) {
          continue;
        }

        var i = now[0],
            j = now[1],
            flag = now[0];

        while (i < j) {
          while (num[j].distance >= num[flag].distance && j > flag) {
            j--;
          }

          if (i >= j) {
            break;
          }

          while (num[i].distance <= num[flag].distance && i < j) {
            i++;
          }

          var temp = num[flag];
          num[flag] = num[j];
          num[j] = num[i];
          num[i] = temp;
          flag = i;
        }

        list.push([now[0], flag - 1]);
        list.push([flag + 1, now[1]]);
      }
    }
  }]);
  return FMBufferQuery;
}(_FMRelationQuery2.default);

var _default = FMBufferQuery;
exports.default = _default;

/***/ }),
/* 446 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _FMSpatialQuery2 = _interopRequireDefault(__webpack_require__(253));

/**
 * @author Mif /  Made on March 11, 2020/
 */
var FMRelationQuery =
/*#__PURE__*/
function (_FMSpatialQuery) {
  (0, _inherits2.default)(FMRelationQuery, _FMSpatialQuery);

  function FMRelationQuery(data) {
    (0, _classCallCheck2.default)(this, FMRelationQuery);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMRelationQuery).call(this, data));
  }

  return FMRelationQuery;
}(_FMSpatialQuery2.default);

var _default = FMRelationQuery;
exports.default = _default;

/***/ }),
/* 447 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _interopRequireDefault = __webpack_require__(1);

var _typeof2 = _interopRequireDefault(__webpack_require__(47));

(function (global, factory) {
  ( false ? undefined : (0, _typeof2.default)(exports)) === 'object' && typeof module !== 'undefined' ? factory(exports) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
})(void 0, function (exports) {
  'use strict';

  Array.prototype.merge = function (arr) {
    for (var i = 0; i < arr.length; i++) {
      this.push(arr[i]);
    }

    return this;
  };

  Array.prototype.print = function () {
    for (var i = 0; i < this.length; i++) {
      console.log(i, ',', this[i][0], ',', this[i][1]);
    }
  };

  var MAX_VALUE = 999999999999.0;
  var PI = 3.1415926;

  function getSegs(points) {
    var _segs = [];

    for (var i = 0; i < points.length; i++) {
      var _element1 = points[i];
      var _element2 = points[(i + 1) % points.length];

      _segs.push({
        x1: _element1[0],
        y1: _element1[1],
        x2: _element2[0],
        y2: _element2[1]
      });
    }

    return _segs;
  }

  function isPolygonsIntersects(polygon1Points, polygon2Points) {
    var _ifIntersect = false;
    _ifIntersect = fastExclude(polygon1Points, polygon2Points);

    if (_ifIntersect == false) {
      return _ifIntersect;
    }

    var _polygon1Segs = getSegs(polygon1Points);

    var _polygon2Segs = getSegs(polygon2Points);

    _ifIntersect = judgeSegsIntersect(_polygon1Segs, _polygon2Segs);

    if (_ifIntersect) {
      return true;
    } else {
      if (isPointInPolygon(polygon1Points[0], polygon2Points)) return true;
      if (isPointInPolygon(polygon2Points[0], polygon1Points)) return true;
      return false;
    }
  }

  function fastExclude(polygon1Points, polygon2Points) {
    var _polygon1MaxX;

    var _polygon1MaxY;

    var _polygon1MinX;

    var _polygon1MinY;

    var _polygon2MaxX;

    var _polygon2MaxY;

    var _polygon2MinX;

    var _polygon2MinY;

    for (var i = 0; i < polygon1Points.length; i++) {
      var _polygon1Point = polygon1Points[i];
      _polygon1MaxX = _polygon1MaxX > _polygon1Point.x ? _polygon1MaxX : _polygon1Point.x;
      _polygon1MinX = _polygon1MinX < _polygon1Point.x ? _polygon1MinX : _polygon1Point.x;
      _polygon1MaxY = _polygon1MaxY > _polygon1Point.y ? _polygon1MaxY : _polygon1Point.y;
      _polygon1MinY = _polygon1MinY < _polygon1Point.y ? _polygon1MinY : _polygon1Point.y;
    }

    for (var i = 0; i < polygon2Points.length; i++) {
      var _polygon2Point = polygon2Points[i];
      _polygon2MaxX = _polygon2MaxX > _polygon2Point.x ? _polygon2MaxX : _polygon2Point.x;
      _polygon2MinX = _polygon2MinX < _polygon2Point.x ? _polygon2MinX : _polygon2Point.x;
      _polygon2MaxY = _polygon2MaxY > _polygon2Point.y ? _polygon2MaxY : _polygon2Point.y;
      _polygon2MinY = _polygon2MinY < _polygon2Point.y ? _polygon2MinY : _polygon2Point.y;
    }

    if (_polygon1MaxX <= _polygon2MinX || _polygon2MaxX <= _polygon1MinX || _polygon1MinY >= _polygon2MaxY || _polygon2MinY >= _polygon1MaxY) {
      return false;
    } else {
      return true;
    }
  }

  function isSegsIntersect(seg1_x1, seg1_y1, seg1_x2, seg1_y2, seg2_x1, seg2_y1, seg2_x2, seg2_y2) {
    if (!(Math.min(seg1_x1, seg1_x2) <= Math.max(seg2_x1, seg2_x2) && Math.min(seg2_y1, seg2_y2) <= Math.max(seg1_y1, seg1_y2) && Math.min(seg2_x1, seg2_x2) <= Math.max(seg1_x1, seg1_x2) && Math.min(seg1_y1, seg1_y2) <= Math.max(seg2_y1, seg2_y2))) return false;
    var u, v, w, z;
    u = (seg2_x1 - seg1_x1) * (seg1_y2 - seg1_y1) - (seg1_x2 - seg1_x1) * (seg2_y1 - seg1_y1);
    v = (seg2_x2 - seg1_x1) * (seg1_y2 - seg1_y1) - (seg1_x2 - seg1_x1) * (seg2_y2 - seg1_y1);
    w = (seg1_x1 - seg2_x1) * (seg2_y2 - seg2_y1) - (seg2_x2 - seg2_x1) * (seg1_y1 - seg2_y1);
    z = (seg1_x2 - seg2_x1) * (seg2_y2 - seg2_y1) - (seg2_x2 - seg2_x1) * (seg1_y2 - seg2_y1);
    return u * v <= 0.00000001 && w * z <= 0.00000001;
  }

  function judgeSegsIntersect(polygon1Segs, polygon2Segs) {
    for (var i = 0; i < polygon1Segs.length; i++) {
      var seg1 = polygon1Segs[i];

      for (var j = 0; j < polygon2Segs.length; j++) {
        var seg2 = polygon2Segs[j];

        if (isSegsIntersect(seg1.x1, seg1.y1, seg1.x2, seg1.y2, seg2.x1, seg2.y1, seg2.x2, seg2.y2)) {
          return true;
        }
      }
    }

    return false;
  }

  function isPointInPolygon(point, vs) {
    var x = point[0],
        y = point[1];
    var inside = false;

    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
      var xi = vs[i][0],
          yi = vs[i][1];
      var xj = vs[j][0],
          yj = vs[j][1];
      var intersect = yi > y != yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
      if (intersect) inside = !inside;
    }

    return inside;
  }

  ;
  /**
   *  Vec2d的定义
   * @param x
   * @param y
   * @constructor
   */

  var Vec2d = function Vec2d() {
    if (arguments.length == 1) {
      this.x = arguments[0][0];
      this.y = arguments[0][1];
    }

    if (arguments.length == 2) {
      this.x = arguments[0];
      this.y = arguments[1];
    }
  };

  Vec2d.prototype.plus = function (other) {
    // this.x = this.x + other.x;
    // this.y = this.y + other.y;
    return new Vec2d(this.x + other.x, this.y + other.y);
  };

  Vec2d.prototype.minus = function (other) {
    // this.x = this.x - other.x;
    // this.y = this.y - other.y;
    return new Vec2d(this.x - other.x, this.y - other.y);
  };

  Vec2d.prototype.div = function (val) {
    return new Vec2d(this.x / val, this.y / val);
  };

  Vec2d.prototype.mul = function (other) {
    if ((0, _typeof2.default)(other) == 'object') {
      if (other instanceof Vec2d) {
        // this.x = this.x * other.x;
        // this.y = this.y * other.y;
        return this.x * other.x + this.y * other.y;
      }
    }

    if (typeof other == 'number') {
      // this.x = this.x * ohter;
      // this.y = this.y * ohter;
      return new Vec2d(this.x * other, this.y * other);
    }

    return this;
  };

  Vec2d.prototype.crossMul = function (other) {
    return this.x * other.y - other.x * this.y;
  };

  Vec2d.prototype.len = function () {
    var len2 = this.x * this.x + this.y * this.y;
    return Math.sqrt(len2);
  };

  Vec2d.prototype.toList = function () {
    return [this.x, this.y];
  };

  var Matrix2d = function Matrix2d(a1, a2, a3, a4) {
    this._row1 = new Vec2d(a1, a2);
    this._row2 = new Vec2d(a3, a4);
  };

  Matrix2d.prototype.mul = function (v2d) {
    if (v2d instanceof Vec2d) {
      return new Vec2d(this._row1.mul(v2d), this._row2.mul(v2d));
    }
  };

  var createRotateMatrix = function createRotateMatrix(angle) {
    var r = angle * PI / 180.0;
    return new Matrix2d(Math.cos(r), -Math.sin(r), Math.sin(r), Math.cos(r));
  };
  /**
   *                                     s_l           e_l
   *                                      \             \
   *                            pax1 --- pt1 --------> pt2 --- pax2
   *                                      \             \
   *                                     s_r           e_r
   * @param pt1
   * @param pt2
   * @param radius
   */


  var seg_circle_buffer = function seg_circle_buffer(pt1, pt2, radius) {
    var pt2 = new Vec2d(pt2);
    var pt1 = new Vec2d(pt1);
    var axis_v = pt2.minus(pt1);
    var axis_v = axis_v.div(axis_v.len());
    var axis_v = axis_v.mul(radius);
    var rot_mat = new Matrix2d(0, -1, 1, 0);
    var s_perp_v = rot_mat.mul(axis_v);
    var pax2 = pt2.plus(axis_v);
    var pax1 = pt1.minus(axis_v);
    var e_l = pt2.plus(s_perp_v);
    var e_r = pt2.minus(s_perp_v);
    var s_l = pt1.plus(s_perp_v);
    var s_r = pt1.minus(s_perp_v);
    var e_perp_v = s_perp_v.mul(-1.0);
    var s_cap_pts = [];
    var e_cap_pts = [];

    for (var i = 0; i <= 18; i++) {
      var rot_m = createRotateMatrix(i * 10.0);
      var s_rot_v = rot_m.mul(s_perp_v);
      var s_vetex = pt1.plus(s_rot_v);
      s_cap_pts.push(s_vetex.toList());
      var e_rot_v = rot_m.mul(e_perp_v);
      var e_vetex = pt2.plus(e_rot_v);
      e_cap_pts.push(e_vetex.toList());
    } //s_cap_pts.print();


    return s_cap_pts.merge(e_cap_pts);
  };

  var segs_buffer = function segs_buffer(segs, rad) {
    var seg_bufs = [];

    for (var i = 0; i < segs.length; i++) {
      var seg = segs[i];
      seg_bufs.push(seg_circle_buffer([seg.x1, seg.y1], [seg.x2, seg.y2], rad));
    }

    return seg_bufs;
  };

  var polylineSegBuffers = function polylineSegBuffers(pts, radius) {
    var segs = getSegs(pts);
    return segs_buffer(segs, radius);
  };

  var isSegBuffersIntersecots = function isSegBuffersIntersecots(segBuffers, pts) {
    for (var i = 0; i < segBuffers.length; i++) {
      var buffer = segBuffers[i];

      if (isPolygonsIntersects(buffer, pts)) {
        return true;
      }

      ;
    }

    return false;
  };

  function PointToSegDist(x, y, x1, y1, x2, y2) {
    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1); //|AB*AP|：矢量乘

    if (cross <= 0) return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1)); //是|AP|：矢量的大小

    var d2 = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1); //|AB|^2：矢量AB的大小的平方

    if (cross >= d2) return Math.sqrt((x - x2) * (x - x2) + (y - y2) * (y - y2)); //是|BP|：矢量的大小

    var r = cross / d2; //相似三角形原理求出c点的坐标

    var px = x1 + (x2 - x1) * r;
    var py = y1 + (y2 - y1) * r;
    return Math.sqrt((x - px) * (x - px) + (py - y) * (py - y));
  }

  var distPointToPolygon = function distPointToPolygon(pt, pts) {
    var minDist = MAX_VALUE;

    for (var i = 0; i < pts.length; i++) {
      var pt1 = pts[i];
      var pt2 = pts[(i + 1) % pts.length];
      var dist = PointToSegDist(pt[0], pt[1], pt1[0], pt1[1], pt2[0], pt2[1]);
      if (minDist > dist) minDist = dist;
    }

    return minDist;
  };

  var straightenPoints = function straightenPoints(pts) {
    if (pts.length < 3) return pts;
    var rectied_pts = [];
    rectied_pts.push(pts[0]);

    for (var i = 1; i < pts.length - 1; i++) {
      var last_v = new Vec2d(rectied_pts[rectied_pts.length - 1]);
      var v1 = new Vec2d(pts[i]).minus(last_v);
      var v2 = new Vec2d(pts[i + 1]).minus(new Vec2d(pts[i]));
      var prod = v1.crossMul(v2);

      if (Math.abs(prod) < 0.001) {} else {
        rectied_pts.push(pts[i]);
      }
    }

    rectied_pts.push(pts[pts.length - 1]);
    return rectied_pts;
  };

  exports.isPolygonIntersects = isPolygonsIntersects;
  exports.isPointInPolygon = isPointInPolygon;
  exports.polylineSegBuffers = polylineSegBuffers;
  exports.isSegBuffersIntersecots = isSegBuffersIntersecots;
  exports.distPointToPolygon = distPointToPolygon;
  exports.straightenPoints = straightenPoints;
});

/***/ }),
/* 448 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(13);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

var _FMLocationQuery2 = _interopRequireDefault(__webpack_require__(254));

/**
 * @author Mif /  Made on March 11, 2020/
 */
var FMCircleQuery =
/*#__PURE__*/
function (_FMLocationQuery) {
  (0, _inherits2.default)(FMCircleQuery, _FMLocationQuery);

  function FMCircleQuery(data) {
    (0, _classCallCheck2.default)(this, FMCircleQuery);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMCircleQuery).call(this, data));
  }

  (0, _createClass2.default)(FMCircleQuery, [{
    key: "query",
    value: function query(results, selector, map) {
      console.log(results);
      var circle = selector.circle;
      var result = [];
      var file_ver = this._data.scene.file_ver;

      onefor: for (var i = 0; i < results[0].length; i++) {
        // console.log(results[0][i]);
        var gdata = results[0][i].gdata;

        if (results[0][i].nodeType === 5) {// geo && (geopos = geo);
        }

        var pos = null;
        var x = 0;
        var y = 0;

        if (file_ver === 1) {
          var geopos = gdata.geo;
          pos = geopos.substring(6, geopos.length - 1).split(' ');
          x = (0, _parseFloat2.default)(pos[0]);
          y = (0, _parseFloat2.default)(pos[1]);
        } else {
          pos = gdata.pts;
          x = pos[0];
          y = pos[1];
        }

        var center = circle.center;
        var dis = Math.sqrt((x - center.x) * (x - center.x) + (y - center.y) * (y - center.y));

        if (dis < circle.radius) {
          results[0][i].distance = dis;
          result.push(results[0][i]);
          continue;
        } else {
          if (results[0][i].nodeType === 5) {
            var distance = 0;
            var vertices = null;
            var model = map.getFMGroup(results[0][i].groupID).getNodeByLayerId("model", results[0][i].ID);

            if (model && model._data) {
              vertices = model._data.vertices;
            }

            if (vertices == null) {
              if (file_ver === 1) {
                vertices = _DataManager.default.convertGeo2Geometry(gdata.geo).vertices;
              } else {
                vertices = _DataManager.default.convertArr2Geometry(gdata.idxs, gdata.pts).vertices;
              }
            }

            var len = vertices.length / 2;

            for (var j = 0; j < len - 1; j++) {
              var index = 2 * j;
              distance = this.Graphics.pointDistanceToLine(center, {
                'x': vertices[index],
                'y': vertices[index + 1]
              }, {
                'x': vertices[index + 2],
                'y': vertices[index + 3]
              }, {});

              if (distance < circle.radius) {
                results[0][i].distance = dis;
                result.push(results[0][i]);
                continue onefor;
              }
            }

            if (this.Graphics.pointInPolygonVector2d(vertices, center, vertices.length)) {
              results[0][i].distance = dis;
              result.push(results[0][i]);
              continue;
            }
          }
        }
      }

      return result;
    }
  }]);
  return FMCircleQuery;
}(_FMLocationQuery2.default);

var _default = FMCircleQuery;
exports.default = _default;

/***/ }),
/* 449 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _parseFloat2 = _interopRequireDefault(__webpack_require__(16));

__webpack_require__(13);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(4));

var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(5));

var _inherits2 = _interopRequireDefault(__webpack_require__(6));

var _DataManager = _interopRequireDefault(__webpack_require__(42));

var _SearchPolygon = _interopRequireDefault(__webpack_require__(450));

var _FMLocationQuery2 = _interopRequireDefault(__webpack_require__(254));

/**
 * @author Mif /  Made on March 11, 2020/
 */
var FMPolygonQuery =
/*#__PURE__*/
function (_FMLocationQuery) {
  (0, _inherits2.default)(FMPolygonQuery, _FMLocationQuery);

  function FMPolygonQuery(data) {
    (0, _classCallCheck2.default)(this, FMPolygonQuery);
    return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(FMPolygonQuery).call(this, data));
  }

  (0, _createClass2.default)(FMPolygonQuery, [{
    key: "query",
    value: function query(results, selector, map) {
      var file_ver = this._data.scene.file_ver;
      var searchPolygon = selector.polygon.length > 2 ? new _SearchPolygon.default(selector.polygon, true) : null;
      var result = [];

      for (var i = 0; i < results[0].length; i++) {
        var gdata = results[0][i].gdata;

        if (results[0][i].nodeType === 5) {// geo && (geopos = geo);
        }

        var pos = null;
        var center = null;

        if (file_ver === 1) {
          var geopos = gdata.geo;
          pos = geopos.substring(6, geopos.length - 1).split(' ');
          center = {
            'x': (0, _parseFloat2.default)(pos[0]),
            'y': (0, _parseFloat2.default)(pos[1])
          };
        } else {
          pos = gdata.pts;
          center = {
            'x': (0, _parseFloat2.default)(pos[0]),
            'y': (0, _parseFloat2.default)(pos[1])
          };
        }

        if (searchPolygon.contain(center)) {
          results[0][i].distance = searchPolygon.distanceToPoint(center);
          result.push(results[0][i]);
          continue;
        }

        if (results[0][i].nodeType === 5) {
          var vertices = null;
          var model = map.getFMGroup(results[0][i].groupID).getNodeByLayerId("model", results[0][i].ID);

          if (model && model._data) {
            vertices = model._data.vertices;
          }

          if (vertices == null) {
            if (file_ver === 1) {
              vertices = _DataManager.default.convertGeo2Geometry(gdata.geo).vertices;
            } else {
              vertices = _DataManager.default.convertArr2Geometry(gdata.idxs, gdata.pts).vertices;
            }
          }

          if (searchPolygon.containXYArray(vertices)) {
            results[0][i].distance = searchPolygon.distanceToPoint(center);
            result.push(results[0][i]);
            continue;
          }
        }
      }

      return result;
    }
  }]);
  return FMPolygonQuery;
}(_FMLocationQuery2.default);

var _default = FMPolygonQuery;
exports.default = _default;

/***/ }),
/* 450 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _SearchBoundingBox = _interopRequireDefault(__webpack_require__(451));

// import Graphics from "../math/Graphics.js";
var SearchPolygon =
/*#__PURE__*/
function () {
  function SearchPolygon(points) {
    (0, _classCallCheck2.default)(this, SearchPolygon);
    this._points = points;
    this._bb = new _SearchBoundingBox.default(points);
    var count = points.length;

    if (points[0].x == points[count - 1].x && points[0].y == points[count - 1].y) {
      count--;
    }

    this._count = count;
    this._center = fengmap.inner.Graphics.calcCenterOfGravityPoint(points, this._count);
  }

  (0, _createClass2.default)(SearchPolygon, [{
    key: "contain",
    value: function contain(point) {
      if (this._bb.contain(point)) {
        return fengmap.inner.Graphics.pointInPolygon2d(this._points, point, this._count);
      }

      return false;
    }
  }, {
    key: "containXYArray",
    value: function containXYArray(array) {
      var length = array.length / 2;
      var points = [];
      var isContain = false;

      for (var i = 0; i < length; i++) {
        var index = i * 2;
        var point = {
          'x': array[index],
          'y': array[index + 1]
        };

        if (this.contain(point)) {
          isContain = true;
          break;
        }

        points.push(point);
      }

      if (isContain) {
        return true;
      }

      var polygon = new SearchPolygon(points);

      if (fengmap.inner.Graphics.isRectCross(this._bb._min, this._bb._max, polygon._bb._min, polygon._bb._max)) {
        for (var j = 0; j < this._count; j++) {
          if (polygon.contain(this._points[j])) {
            isContain = true;
            break;
          }
        }
      }

      if (isContain) {
        return true;
      }

      return false;
    }
  }, {
    key: "distanceToPoint",
    value: function distanceToPoint(point) {
      return fengmap.inner.Graphics.distanceOfTwoPoints(this._center, point);
    }
  }]);
  return SearchPolygon;
}();

var _default = SearchPolygon;
exports.default = _default;

/***/ }),
/* 451 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(56);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var SearchBoundingBox =
/*#__PURE__*/
function () {
  function SearchBoundingBox(points) {
    (0, _classCallCheck2.default)(this, SearchBoundingBox);
    this._min = {
      'x': Number.MAX_VALUE,
      'y': Number.MAX_VALUE
    };
    this._max = {
      'x': -Number.MAX_VALUE,
      'y': -Number.MAX_VALUE
    };

    if (points) {
      var length = points.length;

      for (var i = 0; i < length; i++) {
        this.expandBy(points[i]);
      }
    }
  }

  (0, _createClass2.default)(SearchBoundingBox, [{
    key: "expandBy",
    value: function expandBy(point) {
      if (point.x < this._min.x) {
        this._min.x = point.x;
      }

      if (point.y < this._min.y) {
        this._min.y = point.y;
      }

      if (point.x > this._max.x) {
        this._max.x = point.x;
      }

      if (point.y > this._max.y) {
        this._max.y = point.y;
      }
    }
  }, {
    key: "contain",
    value: function contain(point) {
      if (point.x < this._min.x || point.x > this._max.x) {
        return false;
      }

      if (point.y < this._min.y || point.y > this._max.y) {
        return false;
      }

      return true;
    }
  }]);
  return SearchBoundingBox;
}();

var _default = SearchBoundingBox;
exports.default = _default;

/***/ }),
/* 452 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
*  FMNaviMode 导航中路径规划模式。
*   @class
*   @memberof fengmap
*   @hideconstructor true
*/

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var FMNaviMode = {
  /**
   * 最短路径标识
   * @property {number} MODULE_SHORTEST -1
   * @readOnly
   */
  MODULE_SHORTEST: 1,

  /**
   * 最优路径标识
   * @property {number} MODULE_BEST -2
   * @readOnly
   */
  MODULE_BEST: 2
};
var _default = FMNaviMode;
exports.default = _default;

/***/ }),
/* 453 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

/**
 *   FMTextAlign 对齐方式类型枚举
 *   @class
 *   @memberof fengmap
 *   @hideconstructor true
 */
var FMTextAlign = {
  /**
  * 左对齐
  * @property {number} 左对齐 -0
  * @final
  */
  "Left": 0,

  /**
   * 水平居中
   * @property {number} 水平居中 -1
   * @final
   */
  "Center": 1,

  /**
   * 右对齐
   * @property {number} 右对齐 -2
   * @final
   */
  "Right": 2
};
var _default = FMTextAlign;
exports.default = _default;

/***/ }),
/* 454 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * FMNaviPriority 导航中的路线规划梯类优先级
 *   @class
 *   @memberof fengmap
 *   @hideconstructor true
 */

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var FMNaviPriority = {
  /**
   * 默认模式
   * @property {number} PRIORITY_DEFAULT -1
   * @readOnly
   */
  PRIORITY_DEFAULT: 1,

  /**
   * 直梯优先, 直梯 > 扶梯 > 步行梯
   * @property {number} PRIORITY_LIFTFIRST -2
   * @readOnly
   */
  PRIORITY_LIFTFIRST: 2,

  /**
   * 扶梯优先, 扶梯 > 直梯 > 步行梯
   * @property {number} PRIORITY_ESCALATORFIRST -3
   * @readOnly
   */
  PRIORITY_ESCALATORFIRST: 3,

  /**
   * 步行梯优先, 步行梯 > 直梯 > 扶梯
   * @property {number} PRIORITY_STAIRFIRST -4
   * @readOnly
   */
  PRIORITY_STAIRFIRST: 4,

  /**
   * 只走直梯
   * @property {number} PRIORITY_LIFTONLY -5
   * @readOnly
   */
  PRIORITY_LIFTONLY: 5,

  /**
   * 只走扶梯
   * @property {number} PRIORITY_ESCALATORONLY -6
   * @readOnly
   */
  PRIORITY_ESCALATORONLY: 6,

  /**
   * 只走步行梯
   * @property {number} PRIORITY_STAIRONLY -7
   * @readOnly
   */
  PRIORITY_STAIRONLY: 7,

  /**
   * 只走无障碍电梯
   * @property {number} PRIORITY_ACCESSIBLEONLY -8
   * @readOnly
   */
  PRIORITY_ACCESSIBLEONLY: 8,

  /**
   * 直梯为主, 直梯 > 扶梯 > 步行梯
   * @property {number} PRIORITY_LIFTFIRST1 -2
   * @readOnly
   */
  PRIORITY_LIFTFIRST1: 9,

  /**
   * 扶梯为主, 扶梯 > 直梯 > 步行梯
   * @property {number} PRIORITY_ESCALATORFIRST1 -3
   * @readOnly
   */
  PRIORITY_ESCALATORFIRST1: 10,

  /**
   * 步行梯为主, 步行梯 > 直梯 > 扶梯
   * @property {number} PRIORITY_STAIRFIRST1 -4
   * @readOnly
   */
  PRIORITY_STAIRFIRST1: 11
};
var _default = FMNaviPriority;
exports.default = _default;

/***/ }),
/* 455 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var viewMode = {
  MODE_2D: "top",
  MODE_3D: "3d"
};
var _default = viewMode;
exports.default = _default;

/***/ }),
/* 456 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * FMRouteCalcuResult 路线计算返回值, 标识是否计算成功的枚举。
 *   @class
 *   @memberof fengmap
 *   @hideconstructor true
 */

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var FMRouteCalcuResult = {
  /**
   * 表示路线计算成功的标识
   * @property {number} ROUTE_SUCCESS -1
   * @readOnly
   */
  ROUTE_SUCCESS: 1,
  //路线计算成功

  /**
   * 表示失败，没有传入路径计算数据的标识
   * @property {number} ROUTE_FAILED_NO_FMDBDATA -2
   * @readOnly
   */
  ROUTE_FAILED_NO_FMDBDATA: 2,
  //失败，没有传入路径计算数据

  /**
   * 表示失败，起点与终点很近(绑定到同一个node上)的标识
   * @property {number} ROUTE_FAILED_TOO_CLOSE -3
   * @readOnly
   */
  ROUTE_FAILED_TOO_CLOSE: 3,
  //失败，起点与终点很近(绑定到同一个node上)

  /**
   * 表示失败，没有起点所在group的navi数据的标识
   * @property {number} ROUTE_FAILED_NO_DATA_START -4
   * @readOnly
   */
  ROUTE_FAILED_NO_DATA_START: 4,
  //失败，没有起点所在group的navi数据

  /**
   * 表示失败，没有终点所在group的navi数据的标识
   * @property {number} ROUTE_FAILED_NO_DATA_END -5
   * @readOnly
   */
  ROUTE_FAILED_NO_DATA_END: 5,
  //失败，没有终点所在group的navi数据

  /**
   * 表示失败，没有电梯(手扶梯)进行跨楼梯路线计算的标识
   * @property {number} ROUTE_FAILED_NO_STAIR -6
   * @readOnly
   */
  ROUTE_FAILED_NO_STAIR: 6,
  //失败，没有电梯(手扶梯)进行跨楼梯路线计算

  /**
   * 表示失败，不支持跨层路线计算的标识
   * @property {number} ROUTE_FAILED_NOTSUPPORT -7
   * @readOnly
   */
  ROUTE_FAILED_NOTSUPPORT: 7,
  //失败，不支持跨层路线计算

  /**
   * 表示失败，不能计算的标识
   * @property {number} ROUTE_FAILED_CANNOT_CALCULATE -8
   * @readOnly
   */
  ROUTE_FAILED_CANNOT_CALCULATE: 8,
  // 失败，不能计算

  /**
   * 表示失败，无法到达的标识
   * @property {number} ROUTE_FAILED_CANNOT_ARRIVE -9
   * @readOnly
   */
  ROUTE_FAILED_CANNOT_ARRIVE: 9,
  // 失败，无法到达

  /**
   * 表示失败，途经点计算错误
   * @property {number} ROUTE_FAILED_WAYPOINT_CALCULATE_ERROR -10
   * @readOnly
   */
  ROUTE_FAILED_WAYPOINT_CALCULATE_ERROR: 10,
  // 失败，途经点计算错误

  /**
   * 表示失败，起点不可达
   * @property {number} ROUTE_FAILED_NO_START_ARRIVAL -11
   * @readOnly
   */
  ROUTE_FAILED_NO_START_ARRIVAL: 11,
  // 失败，起点不可达

  /**
   * 表示失败，终点不可达
   * @property {number} ROUTE_FAILED_NO_END_ARRIVAL -12
   * @readOnly
   */
  ROUTE_FAILED_NO_END_ARRIVAL: 12,
  // 失败，终点不可达

  /**
   * 表示失败，引导线计算失败
   * @property {number} ROUTE_FAILED_OUTLINE -13
   * @readOnly
   */
  ROUTE_FAILED_OUTLINE: 13,
  // 引导线计算失败

  /**
   * 表示失败，起点附近没有出去的门点
   * @property {number} ROUTE_FAILED_NO_DOOR_START -14
   * @readOnly
   */
  ROUTE_FAILED_NO_DOOR_START: 14,
  // 起点附近没有出去的门点

  /**
   * 表示失败，终点附近没有进入的门点
   * @property {number} ROUTE_FAILED_NO_DOOR_END -15
   * @readOnly
   */
  ROUTE_FAILED_NO_DOOR_END: 15 // 终点附近没有进入的门点

};
var _default = FMRouteCalcuResult;
exports.default = _default;

/***/ }),
/* 457 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*
 * 地图坐标类
 * 包含x\y\z
 * @class
 * @memberof fengmap
 * @constructor
 */

var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var FMMapCoord =
/*#__PURE__*/
function () {
  function FMMapCoord() {
    (0, _classCallCheck2.default)(this, FMMapCoord);
    //共有属性 外部可直接访问 不加_不写set get方法减少单对象的内存大小

    /**
     * @property {number} x
     */
    this.x = undefined;
    /**
     * @property {number} y
     */

    this.y = undefined;
    /**
     * @property {number} z
     */

    this.z = undefined;
    this.gid = undefined;
  }

  (0, _createClass2.default)(FMMapCoord, [{
    key: "setGeoPoint",
    value: function setGeoPoint(other) {
      this.x = other.x;
      this.y = other.y;
    }
  }]);
  return FMMapCoord;
}();

var _default = FMMapCoord;
exports.default = _default;

/***/ }),
/* 458 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

/*
 * 屏幕坐标类 像素坐标
 * 包含x\y
 * @class
 * @memberof fengmap
 * @constructor
 */
var FMScreenCoord = function FMScreenCoord(x, y) {
  (0, _classCallCheck2.default)(this, FMScreenCoord);

  /**
   * @property {number} x 
   */
  this.x = x === undefined ? 0 : x;
  /**
   * @property {number} y
   */

  this.y = y === undefined ? 0 : y;
};

var _default = FMScreenCoord;
exports.default = _default;

/***/ }),
/* 459 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * FMMapCoordTransformer 是定位坐标转地图坐标转换器。
 * @class 
 * @memberof fengmap
 */

var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var FMMapCoordTransformer =
/*#__PURE__*/
function () {
  /**
  * @constructor
  * @param  {json} locOrigion {x:, y: } 定位坐标原点， 如： {x: 0, y: 0}
  * @param  {json} locRange   {x:, y: } 定位范围 如： {x: 100, y: 100}
  * @param  {array} mapParas   定位图上的四个角点对应的地图坐标数组,逆时针序列。[0]:定位原点地图坐标，[1]:X轴终点地图坐标，[2]:定位原点对角点地图坐标，[3]:Y轴终点地图坐标，如：[{x: 13502836.48, y: 3658566.56}, {x:, y:}, {x:, y:}, {x:, y:}]
  */
  function FMMapCoordTransformer(locOrigion, locRange, mapParas) {
    (0, _classCallCheck2.default)(this, FMMapCoordTransformer);
    this._locOrigion = null;
    this._locRange = null;
    this._mapOrigion = null;
    this._mapAxisX = null;
    this._mapAxisY = null;
    this._mapRange = null;

    if (locOrigion && locRange && mapParas) {
      this.init(locOrigion, locRange, mapParas);
    }
  }

  (0, _createClass2.default)(FMMapCoordTransformer, [{
    key: "init",
    value: function init(locOrigion, locRange, mapParas) {
      if (mapParas.length != 4) {
        return false;
      }

      this._locOrigion = locOrigion;
      this._locRange = locRange;
      this._mapOrigion = mapParas[0];
      this._mapAxisX = {
        'x': mapParas[1].x - mapParas[0].x,
        'y': mapParas[1].y - mapParas[0].y
      };
      this._mapAxisY = {
        'x': mapParas[3].x - mapParas[0].x,
        'y': mapParas[3].y - mapParas[0].y
      };
      this._mapRange = {
        'x': this._getVectorLen(this._mapAxisX),
        'y': this._getVectorLen(this._mapAxisY)
      }; //向量单位化

      this._mapAxisX.x /= this._mapRange.x;
      this._mapAxisX.y /= this._mapRange.x;
      this._mapAxisY.x /= this._mapRange.y;
      this._mapAxisY.y /= this._mapRange.y;
    }
  }, {
    key: "transform",

    /**
     * 定位坐标转换方法
     * @param  {json} loc {x:, y:}定位坐标点， 如{x: 45, y: 150}
     * @return {json} 返回对应的地图坐标{x:, y:}
     */
    value: function transform(loc) {
      var offstRatio = {
        'x': (loc.x - this._locOrigion.x) / this._locRange.x,
        'y': (loc.y - this._locOrigion.y) / this._locRange.y
      };
      var mapOffset = {
        'x': offstRatio.x * this._mapRange.x,
        'y': offstRatio.y * this._mapRange.y
      };
      var mapCoord = {
        'x': this._mapOrigion.x + this._mapAxisX.x * mapOffset.x + this._mapAxisY.x * mapOffset.y,
        'y': this._mapOrigion.y + this._mapAxisX.y * mapOffset.x + this._mapAxisY.y * mapOffset.y
      };
      return mapCoord;
    }
  }, {
    key: "_getVectorLen",
    value: function _getVectorLen(vector) {
      return Math.sqrt(vector.x * vector.x + vector.y * vector.y);
    }
  }]);
  return FMMapCoordTransformer;
}();

var _default = FMMapCoordTransformer;
exports.default = _default;

/***/ }),
/* 460 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;
var _default = {
  NaviNodeType_NULL: -1,
  NaviNodeType_COMMON: 0,
  // 普通节点
  NaviNodeType_SIDE: 1,
  // 端点
  NaviNodeType_FLOOR: 2,
  // 跨层节点(电梯类)
  NaviNodeType_EXTENT: 3,
  // 外部节点(连接室外路段或其它建筑路段)
  NaviLiftType_NULL: 0,
  // 无梯类
  NaviLiftType_Lift: 1,
  // 垂直电梯
  NaviLiftType_Stair: 2,
  // 步行梯
  NaviLiftType_Escalator: 3,
  // 手扶电梯
  NaviLiftType_Accessible: 4,
  // 无障碍电梯
  NaviLiftEntry_BOTH: 0,
  // 双向通行
  NaviLiftEntry_UP: 1,
  // 上行
  NaviLiftEntry_DOWN: 2,
  // 下行
  NaviLiftEntry_FORBID: 3,
  // 双向禁行
  NaviEntranceType_NULL: 0,
  NaviEntranceType_EXIT: 1,
  NaviEntranceType_ENTRANCE: 2,
  NaviEntranceType_ACCESS: 3,
  //need to verify
  NaviRoadRank_MAIN: 1,
  // 主要通道
  NaviRoadRank_MINOR: 2,
  // 次要通道
  NaviRoadRank_NARROW: 3,
  // 窄通道
  NaviRoadEntry_BOTH: 0,
  // 双向通行
  NaviRoadEntry_FORWARD: 1,
  // 正向通行
  NaviRoadEntry_BACK: 2,
  // 反向通行
  NaviRoadEntry_FORBID: 3,
  // 双向禁行
  NaviRoadPass_NULL: -1,
  NaviRoadPass_NOT_THROUGH: 0,
  NaviRoadPass_THROUGH: 1,
  NaviZoneType_NULL: -1,
  // 未知类型
  NaviZoneType_PASS_UNRESTRAINT: 0,
  // 可通行也可沿边界法向穿行
  NaviZoneType_PASS_THROUGH: 1,
  // 可通行也可穿行
  NaviZoneType_PASS_NOT_THROUGH: 2,
  // 可通行不可穿行
  NaviZoneType_NO_ENTRY: 3,
  // 不可通行
  NaviZoneType_CORRIDOR: 4,
  // 不在任何模型，在过道上
  // model的pass属性
  NaviModelPassType_PASS_THROUGH: 0,
  //默认值，可通行可穿行
  NaviModelPassType_PASS_NOT_THROUGH: 1,
  //可通行不可穿行
  NaviModelPassType_NOT_PASS: 2,
  //不可通行区域
  NaviModelPassType_DECORATE: 3,
  //装饰面
  NaviRoadHinderType_HINDER_GENERAL: 0,
  NaviRoadHinderType_HINDER_HIGH: 1,
  NaviObstructType_MODEL: 0,
  NaviObstructType_EXTENT: 1
};
exports.default = _default;

/***/ }),
/* 461 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 //包围盒子

var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

__webpack_require__(56);

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var BoundingBox =
/*#__PURE__*/
function () {
  function BoundingBox() {
    (0, _classCallCheck2.default)(this, BoundingBox);
    this.minX = Number.MAX_VALUE;
    this.minY = Number.MAX_VALUE;
    this.maxX = -Number.MAX_VALUE;
    this.maxY = -Number.MAX_VALUE;
  }

  (0, _createClass2.default)(BoundingBox, [{
    key: "init",
    value: function init() {
      this.minX = Number.MAX_VALUE;
      this.minY = Number.MAX_VALUE;
      this.maxX = -Number.MAX_VALUE;
      this.maxY = -Number.MAX_VALUE;
    }
  }, {
    key: "expandBy",
    value: function expandBy(point) {
      if (!point || !point.x || !point.y) {
        return;
      }

      if (this.minX > point.x) {
        this.minX = point.x;
      }

      if (this.maxX < point.x) {
        this.maxX = point.x;
      }

      if (this.minY > point.y) {
        this.minY = point.y;
      }

      if (this.maxY < point.y) {
        this.maxY = point.y;
      }
    }
  }, {
    key: "isSeparate",
    value: function isSeparate(bb) {
      if (this.minX > bb.maxX) {
        return true;
      }

      if (this.minY > bb.maxY) {
        return true;
      }

      if (this.maxX < bb.minX) {
        return true;
      }

      if (this.maxY < bb.minY) {
        return true;
      }

      return false;
    }
  }]);
  return BoundingBox;
}();

var _default = BoundingBox;
exports.default = _default;

/***/ }),
/* 462 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _interopRequireDefault = __webpack_require__(1);

var _Object$defineProperty = __webpack_require__(0);

_Object$defineProperty(exports, "__esModule", {
  value: true
});

exports.default = void 0;

var _classCallCheck2 = _interopRequireDefault(__webpack_require__(2));

var _createClass2 = _interopRequireDefault(__webpack_require__(3));

var _Graphics = _interopRequireDefault(__webpack_require__(49));

/**
 *	FMCalculator 基础的计算类
 * 	@class
 *  @memberof fengmap
 */
var FMCalculator =
/*#__PURE__*/
function () {
  function FMCalculator() {
    (0, _classCallCheck2.default)(this, FMCalculator);
  }

  (0, _createClass2.default)(FMCalculator, null, [{
    key: "MercatorToWGS84",

    /**
     * 墨卡托坐标转WGS84
     * @param {object} Mercator
     * @param {number} Mercator.x 指定点x坐标
     * @param {number} Mercator.y 指定点y坐标
     */
    value: function MercatorToWGS84(Mercator) {
      var XYtoBL = {};
      var dLong = Mercator.x / 20037508.34 * 180;
      var dLat = Mercator.y / 20037508.34 * 180;
      dLat = 180 / Math.PI * (2 * Math.atan(Math.exp(dLat * Math.PI / 180)) - Math.PI / 2);
      XYtoBL.dLong = dLong;
      XYtoBL.dLat = dLat;
      return XYtoBL;
    }
    /**
     * WGS84转墨卡托坐标
     * @param {object} lonLat
     * @param {number} lonLat.x 指定点经度坐标
     * @param {number} lonLat.y 指定点纬度坐标
     */

  }, {
    key: "WGS84ToWebMercator",
    value: function WGS84ToWebMercator(lonLat) {
      var mercator = {};
      var x = lonLat.x * 20037508.34 / 180;
      var y = Math.log(Math.tan((90 + lonLat.y) * Math.PI / 360)) / (Math.PI / 180);
      y = y * 20037508.34 / 180;
      mercator.x = x;
      mercator.y = y;
      return mercator;
    }
    /**
     * 判断点是否在多边形内
     * @param {object} polygon 多边形
     * @param {object} point 点坐标
     * @param {number} point.x 指定点x坐标
     * @param {number} point.y 指定点y坐标
     */

  }, {
    key: "Contain",
    value: function Contain(polygon, point) {
      var count = polygon.length;
      return _Graphics.default.pointInPolygon2d(polygon, point, count);
    }
    /**
     * 计算长度
     * @param {object} start 起点
     * @param {number} start.x 起点的x坐标
     * @param {number} start.y 起点的y坐标
     * @param {object} end 终点
     * @param {number} end.x 终点x坐标
     * @param {number} end.y 终点y坐标
     */

  }, {
    key: "GetLength",
    value: function GetLength(start, end) {
      var dx = start.x - end.x;
      var dy = start.y - end.y;
      return Math.sqrt(dx * dx + dy * dy);
    }
    /**
     * 计算面积
     * @param {object} polygon 多边形
     */

  }, {
    key: "GetArea",
    value: function GetArea(polygon) {
      return _Graphics.default.calcPolygonArea2d(polygon);
    }
  }, {
    key: "ScreenToWebMercator",
    value: function ScreenToWebMercator(x, y, z, isFloat, giveMeRaw) {}
  }, {
    key: "WebMercatorToScreen",
    value: function WebMercatorToScreen(coord) {}
  }, {
    key: "CoordTransform",
    value: function CoordTransform() {}
  }]);
  return FMCalculator;
}();

var _default = FMCalculator;
exports.default = _default;

/***/ })
/******/ ])["default"];
});